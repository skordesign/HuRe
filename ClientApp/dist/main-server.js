(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded chunks
/******/ 	// "0" means "already loaded"
/******/ 	var installedChunks = {
/******/ 		10: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] !== 0) {
/******/ 			var chunk = require("./" + chunkId + ".js");
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids;
/******/ 			for(var moduleId in moreModules) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 		}
/******/ 		return Promise.resolve();
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "dist/";
/******/
/******/ 	// uncatched error handler for webpack runtime
/******/ 	__webpack_require__.oe = function(err) {
/******/ 		process.nextTick(function() {
/******/ 			throw err; // catch this error by using System.import().catch()
/******/ 		});
/******/ 	};
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 135);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("./vendor");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(2);

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(1);

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(10);

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(19);

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(0);

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(5);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var AsyncAction_1 = __webpack_require__(69);
var AsyncScheduler_1 = __webpack_require__(70);
/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
//# sourceMappingURL=async.js.map

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(101);

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(32);

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NS = exports.NAMESPACES = {
    HTML: 'http://www.w3.org/1999/xhtml',
    MATHML: 'http://www.w3.org/1998/Math/MathML',
    SVG: 'http://www.w3.org/2000/svg',
    XLINK: 'http://www.w3.org/1999/xlink',
    XML: 'http://www.w3.org/XML/1998/namespace',
    XMLNS: 'http://www.w3.org/2000/xmlns/'
};

exports.ATTRS = {
    TYPE: 'type',
    ACTION: 'action',
    ENCODING: 'encoding',
    PROMPT: 'prompt',
    NAME: 'name',
    COLOR: 'color',
    FACE: 'face',
    SIZE: 'size'
};

exports.DOCUMENT_MODE = {
    NO_QUIRKS: 'no-quirks',
    QUIRKS: 'quirks',
    LIMITED_QUIRKS: 'limited-quirks'
};

var $ = exports.TAG_NAMES = {
    A: 'a',
    ADDRESS: 'address',
    ANNOTATION_XML: 'annotation-xml',
    APPLET: 'applet',
    AREA: 'area',
    ARTICLE: 'article',
    ASIDE: 'aside',

    B: 'b',
    BASE: 'base',
    BASEFONT: 'basefont',
    BGSOUND: 'bgsound',
    BIG: 'big',
    BLOCKQUOTE: 'blockquote',
    BODY: 'body',
    BR: 'br',
    BUTTON: 'button',

    CAPTION: 'caption',
    CENTER: 'center',
    CODE: 'code',
    COL: 'col',
    COLGROUP: 'colgroup',

    DD: 'dd',
    DESC: 'desc',
    DETAILS: 'details',
    DIALOG: 'dialog',
    DIR: 'dir',
    DIV: 'div',
    DL: 'dl',
    DT: 'dt',

    EM: 'em',
    EMBED: 'embed',

    FIELDSET: 'fieldset',
    FIGCAPTION: 'figcaption',
    FIGURE: 'figure',
    FONT: 'font',
    FOOTER: 'footer',
    FOREIGN_OBJECT: 'foreignObject',
    FORM: 'form',
    FRAME: 'frame',
    FRAMESET: 'frameset',

    H1: 'h1',
    H2: 'h2',
    H3: 'h3',
    H4: 'h4',
    H5: 'h5',
    H6: 'h6',
    HEAD: 'head',
    HEADER: 'header',
    HGROUP: 'hgroup',
    HR: 'hr',
    HTML: 'html',

    I: 'i',
    IMG: 'img',
    IMAGE: 'image',
    INPUT: 'input',
    IFRAME: 'iframe',

    KEYGEN: 'keygen',

    LABEL: 'label',
    LI: 'li',
    LINK: 'link',
    LISTING: 'listing',

    MAIN: 'main',
    MALIGNMARK: 'malignmark',
    MARQUEE: 'marquee',
    MATH: 'math',
    MENU: 'menu',
    MENUITEM: 'menuitem',
    META: 'meta',
    MGLYPH: 'mglyph',
    MI: 'mi',
    MO: 'mo',
    MN: 'mn',
    MS: 'ms',
    MTEXT: 'mtext',

    NAV: 'nav',
    NOBR: 'nobr',
    NOFRAMES: 'noframes',
    NOEMBED: 'noembed',
    NOSCRIPT: 'noscript',

    OBJECT: 'object',
    OL: 'ol',
    OPTGROUP: 'optgroup',
    OPTION: 'option',

    P: 'p',
    PARAM: 'param',
    PLAINTEXT: 'plaintext',
    PRE: 'pre',

    RB: 'rb',
    RP: 'rp',
    RT: 'rt',
    RTC: 'rtc',
    RUBY: 'ruby',

    S: 's',
    SCRIPT: 'script',
    SECTION: 'section',
    SELECT: 'select',
    SOURCE: 'source',
    SMALL: 'small',
    SPAN: 'span',
    STRIKE: 'strike',
    STRONG: 'strong',
    STYLE: 'style',
    SUB: 'sub',
    SUMMARY: 'summary',
    SUP: 'sup',

    TABLE: 'table',
    TBODY: 'tbody',
    TEMPLATE: 'template',
    TEXTAREA: 'textarea',
    TFOOT: 'tfoot',
    TD: 'td',
    TH: 'th',
    THEAD: 'thead',
    TITLE: 'title',
    TR: 'tr',
    TRACK: 'track',
    TT: 'tt',

    U: 'u',
    UL: 'ul',

    SVG: 'svg',

    VAR: 'var',

    WBR: 'wbr',

    XMP: 'xmp'
};

var SPECIAL_ELEMENTS = exports.SPECIAL_ELEMENTS = Object.create(null);

SPECIAL_ELEMENTS[NS.HTML] = Object.create(null);
SPECIAL_ELEMENTS[NS.HTML][$.ADDRESS] = true;
SPECIAL_ELEMENTS[NS.HTML][$.APPLET] = true;
SPECIAL_ELEMENTS[NS.HTML][$.AREA] = true;
SPECIAL_ELEMENTS[NS.HTML][$.ARTICLE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.ASIDE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.BASE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.BASEFONT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.BGSOUND] = true;
SPECIAL_ELEMENTS[NS.HTML][$.BLOCKQUOTE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.BODY] = true;
SPECIAL_ELEMENTS[NS.HTML][$.BR] = true;
SPECIAL_ELEMENTS[NS.HTML][$.BUTTON] = true;
SPECIAL_ELEMENTS[NS.HTML][$.CAPTION] = true;
SPECIAL_ELEMENTS[NS.HTML][$.CENTER] = true;
SPECIAL_ELEMENTS[NS.HTML][$.COL] = true;
SPECIAL_ELEMENTS[NS.HTML][$.COLGROUP] = true;
SPECIAL_ELEMENTS[NS.HTML][$.DD] = true;
SPECIAL_ELEMENTS[NS.HTML][$.DETAILS] = true;
SPECIAL_ELEMENTS[NS.HTML][$.DIR] = true;
SPECIAL_ELEMENTS[NS.HTML][$.DIV] = true;
SPECIAL_ELEMENTS[NS.HTML][$.DL] = true;
SPECIAL_ELEMENTS[NS.HTML][$.DT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.EMBED] = true;
SPECIAL_ELEMENTS[NS.HTML][$.FIELDSET] = true;
SPECIAL_ELEMENTS[NS.HTML][$.FIGCAPTION] = true;
SPECIAL_ELEMENTS[NS.HTML][$.FIGURE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.FOOTER] = true;
SPECIAL_ELEMENTS[NS.HTML][$.FORM] = true;
SPECIAL_ELEMENTS[NS.HTML][$.FRAME] = true;
SPECIAL_ELEMENTS[NS.HTML][$.FRAMESET] = true;
SPECIAL_ELEMENTS[NS.HTML][$.H1] = true;
SPECIAL_ELEMENTS[NS.HTML][$.H2] = true;
SPECIAL_ELEMENTS[NS.HTML][$.H3] = true;
SPECIAL_ELEMENTS[NS.HTML][$.H4] = true;
SPECIAL_ELEMENTS[NS.HTML][$.H5] = true;
SPECIAL_ELEMENTS[NS.HTML][$.H6] = true;
SPECIAL_ELEMENTS[NS.HTML][$.HEAD] = true;
SPECIAL_ELEMENTS[NS.HTML][$.HEADER] = true;
SPECIAL_ELEMENTS[NS.HTML][$.HGROUP] = true;
SPECIAL_ELEMENTS[NS.HTML][$.HR] = true;
SPECIAL_ELEMENTS[NS.HTML][$.HTML] = true;
SPECIAL_ELEMENTS[NS.HTML][$.IFRAME] = true;
SPECIAL_ELEMENTS[NS.HTML][$.IMG] = true;
SPECIAL_ELEMENTS[NS.HTML][$.INPUT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.LI] = true;
SPECIAL_ELEMENTS[NS.HTML][$.LINK] = true;
SPECIAL_ELEMENTS[NS.HTML][$.LISTING] = true;
SPECIAL_ELEMENTS[NS.HTML][$.MAIN] = true;
SPECIAL_ELEMENTS[NS.HTML][$.MARQUEE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.MENU] = true;
SPECIAL_ELEMENTS[NS.HTML][$.META] = true;
SPECIAL_ELEMENTS[NS.HTML][$.NAV] = true;
SPECIAL_ELEMENTS[NS.HTML][$.NOEMBED] = true;
SPECIAL_ELEMENTS[NS.HTML][$.NOFRAMES] = true;
SPECIAL_ELEMENTS[NS.HTML][$.NOSCRIPT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.OBJECT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.OL] = true;
SPECIAL_ELEMENTS[NS.HTML][$.P] = true;
SPECIAL_ELEMENTS[NS.HTML][$.PARAM] = true;
SPECIAL_ELEMENTS[NS.HTML][$.PLAINTEXT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.PRE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.SCRIPT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.SECTION] = true;
SPECIAL_ELEMENTS[NS.HTML][$.SELECT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.SOURCE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.STYLE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.SUMMARY] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TABLE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TBODY] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TD] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TEMPLATE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TEXTAREA] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TFOOT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TH] = true;
SPECIAL_ELEMENTS[NS.HTML][$.THEAD] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TITLE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TR] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TRACK] = true;
SPECIAL_ELEMENTS[NS.HTML][$.UL] = true;
SPECIAL_ELEMENTS[NS.HTML][$.WBR] = true;
SPECIAL_ELEMENTS[NS.HTML][$.XMP] = true;

SPECIAL_ELEMENTS[NS.MATHML] = Object.create(null);
SPECIAL_ELEMENTS[NS.MATHML][$.MI] = true;
SPECIAL_ELEMENTS[NS.MATHML][$.MO] = true;
SPECIAL_ELEMENTS[NS.MATHML][$.MN] = true;
SPECIAL_ELEMENTS[NS.MATHML][$.MS] = true;
SPECIAL_ELEMENTS[NS.MATHML][$.MTEXT] = true;
SPECIAL_ELEMENTS[NS.MATHML][$.ANNOTATION_XML] = true;

SPECIAL_ELEMENTS[NS.SVG] = Object.create(null);
SPECIAL_ELEMENTS[NS.SVG][$.TITLE] = true;
SPECIAL_ELEMENTS[NS.SVG][$.FOREIGN_OBJECT] = true;
SPECIAL_ELEMENTS[NS.SVG][$.DESC] = true;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(6);

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CommonHttpService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__frontend_loading_service__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__frontend_alert_service__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_http__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_http___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__angular_http__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_add_operator_map__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_add_operator_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_add_operator_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_add_operator_catch__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_add_operator_catch___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs_add_operator_catch__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







var CommonHttpService = (function () {
    function CommonHttpService(http, loadingSvc, alertSvc) {
        this.http = http;
        this.loadingSvc = loadingSvc;
        this.alertSvc = alertSvc;
    }
    CommonHttpService.prototype.extractdata = function (res) {
        var body = res.json();
        return body || {};
    };
    CommonHttpService.prototype.createHeader = function () {
        var headers = new __WEBPACK_IMPORTED_MODULE_4__angular_http__["Headers"]();
        headers.set("Content-Type", "application/json");
        return headers;
    };
    CommonHttpService.prototype.gets = function (url, headers) {
        try {
            this.loadingSvc.showLoading(true);
            return this.http.get(url, { headers: headers || this.createHeader() })
                .map(this.extractdata).catch(function (err) { return []; });
        }
        catch (err) {
            return new __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"](function (sub) { return sub.next(); });
        }
        finally {
            this.loadingSvc.showLoading(false);
        }
    };
    CommonHttpService.prototype.get = function (url, id, headers) {
        try {
            this.loadingSvc.showLoading(true);
            return this.http.get(url + ("/" + id.toString()) || "", { headers: headers || this.createHeader() })
                .map(this.extractdata).catch(function (err) { return new __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"](function (sub) { return sub.next(); }); });
        }
        catch (err) {
            return new __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"](function (sub) { return sub.next(); });
        }
        finally {
            this.loadingSvc.showLoading(false);
        }
    };
    CommonHttpService.prototype.post = function (url, body, headers) {
        return this.http.post(url, JSON.stringify(body), { headers: headers || this.createHeader() })
            .map(this.extractdata).catch(function (err) { return []; });
    };
    CommonHttpService.prototype.put = function (url, id, body, headers) {
        return this.http.put(url + id.toString(), JSON.stringify(body), { headers: headers || this.createHeader() })
            .map(this.extractdata).catch(function (err) { return []; });
    };
    CommonHttpService.prototype.delete = function (url, id, headers) {
        return this.http.delete(url + id.toString(), { headers: headers || this.createHeader() })
            .map(this.extractdata).catch(function (err) { return []; });
    };
    CommonHttpService = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__angular_http__["Http"], __WEBPACK_IMPORTED_MODULE_2__frontend_loading_service__["a" /* LoadingService */], __WEBPACK_IMPORTED_MODULE_3__frontend_alert_service__["a" /* AlertService */]])
    ], CommonHttpService);
    return CommonHttpService;
}());



/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(43);

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(7);

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return URL; });
var URL = {
    BASE_URL: "/api",
    JOB_URL: "/api/jobs",
    EVENT_URL: "/api/events",
    PROFILE_URL: "/api/profiles",
    JOB_GROUP_URL: "/api/job-groups",
    ROLE_URL: "/api/roles",
    WORKTYPE_URL: "/api/work-types",
    COMPANY_URL: "/api/companies"
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(39);

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(18);

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(41);

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var http_1 = __webpack_require__(18);
var core_1 = __webpack_require__(1);
var Observable_1 = __webpack_require__(5);
__webpack_require__(183);
__webpack_require__(182);
__webpack_require__(184);
var AuthConfigConsts = (function () {
    function AuthConfigConsts() {
    }
    return AuthConfigConsts;
}());
AuthConfigConsts.DEFAULT_TOKEN_NAME = 'token';
AuthConfigConsts.DEFAULT_HEADER_NAME = 'Authorization';
AuthConfigConsts.HEADER_PREFIX_BEARER = 'Bearer ';
exports.AuthConfigConsts = AuthConfigConsts;
var AuthConfigDefaults = {
    headerName: AuthConfigConsts.DEFAULT_HEADER_NAME,
    headerPrefix: null,
    tokenName: AuthConfigConsts.DEFAULT_TOKEN_NAME,
    tokenGetter: function () { return localStorage.getItem(AuthConfigDefaults.tokenName); },
    noJwtError: false,
    noClientCheck: false,
    globalHeaders: [],
    noTokenScheme: false
};
/**
 * Sets up the authentication configuration.
 */
var AuthConfig = (function () {
    function AuthConfig(config) {
        config = config || {};
        this._config = objectAssign({}, AuthConfigDefaults, config);
        if (this._config.headerPrefix) {
            this._config.headerPrefix += ' ';
        }
        else if (this._config.noTokenScheme) {
            this._config.headerPrefix = '';
        }
        else {
            this._config.headerPrefix = AuthConfigConsts.HEADER_PREFIX_BEARER;
        }
        if (config.tokenName && !config.tokenGetter) {
            this._config.tokenGetter = function () { return localStorage.getItem(config.tokenName); };
        }
    }
    AuthConfig.prototype.getConfig = function () {
        return this._config;
    };
    return AuthConfig;
}());
exports.AuthConfig = AuthConfig;
var AuthHttpError = (function (_super) {
    __extends(AuthHttpError, _super);
    function AuthHttpError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AuthHttpError;
}(Error));
exports.AuthHttpError = AuthHttpError;
/**
 * Allows for explicit authenticated HTTP requests.
 */
var AuthHttp = (function () {
    function AuthHttp(options, http, defOpts) {
        var _this = this;
        this.http = http;
        this.defOpts = defOpts;
        this.config = options.getConfig();
        this.tokenStream = new Observable_1.Observable(function (obs) {
            obs.next(_this.config.tokenGetter());
        });
    }
    AuthHttp.prototype.mergeOptions = function (providedOpts, defaultOpts) {
        var newOptions = defaultOpts || new http_1.RequestOptions();
        if (this.config.globalHeaders) {
            this.setGlobalHeaders(this.config.globalHeaders, providedOpts);
        }
        newOptions = newOptions.merge(new http_1.RequestOptions(providedOpts));
        return newOptions;
    };
    AuthHttp.prototype.requestHelper = function (requestArgs, additionalOptions) {
        var options = new http_1.RequestOptions(requestArgs);
        if (additionalOptions) {
            options = options.merge(additionalOptions);
        }
        return this.request(new http_1.Request(this.mergeOptions(options, this.defOpts)));
    };
    AuthHttp.prototype.requestWithToken = function (req, token) {
        if (!this.config.noClientCheck && !tokenNotExpired(undefined, token)) {
            if (!this.config.noJwtError) {
                return new Observable_1.Observable(function (obs) {
                    obs.error(new AuthHttpError('No JWT present or has expired'));
                });
            }
        }
        else {
            req.headers.set(this.config.headerName, this.config.headerPrefix + token);
        }
        return this.http.request(req);
    };
    AuthHttp.prototype.setGlobalHeaders = function (headers, request) {
        if (!request.headers) {
            request.headers = new http_1.Headers();
        }
        headers.forEach(function (header) {
            var key = Object.keys(header)[0];
            var headerValue = header[key];
            request.headers.set(key, headerValue);
        });
    };
    AuthHttp.prototype.request = function (url, options) {
        var _this = this;
        if (typeof url === 'string') {
            return this.get(url, options); // Recursion: transform url from String to Request
        }
        // else if ( ! url instanceof Request ) {
        //   throw new Error('First argument must be a url string or Request instance.');
        // }
        // from this point url is always an instance of Request;
        var req = url;
        // Create a cold observable and load the token just in time
        return Observable_1.Observable.defer(function () {
            var token = _this.config.tokenGetter();
            if (token instanceof Promise) {
                return Observable_1.Observable.fromPromise(token).mergeMap(function (jwtToken) { return _this.requestWithToken(req, jwtToken); });
            }
            else {
                return _this.requestWithToken(req, token);
            }
        });
    };
    AuthHttp.prototype.get = function (url, options) {
        return this.requestHelper({ body: '', method: http_1.RequestMethod.Get, url: url }, options);
    };
    AuthHttp.prototype.post = function (url, body, options) {
        return this.requestHelper({ body: body, method: http_1.RequestMethod.Post, url: url }, options);
    };
    AuthHttp.prototype.put = function (url, body, options) {
        return this.requestHelper({ body: body, method: http_1.RequestMethod.Put, url: url }, options);
    };
    AuthHttp.prototype.delete = function (url, options) {
        return this.requestHelper({ body: '', method: http_1.RequestMethod.Delete, url: url }, options);
    };
    AuthHttp.prototype.patch = function (url, body, options) {
        return this.requestHelper({ body: body, method: http_1.RequestMethod.Patch, url: url }, options);
    };
    AuthHttp.prototype.head = function (url, options) {
        return this.requestHelper({ body: '', method: http_1.RequestMethod.Head, url: url }, options);
    };
    AuthHttp.prototype.options = function (url, options) {
        return this.requestHelper({ body: '', method: http_1.RequestMethod.Options, url: url }, options);
    };
    return AuthHttp;
}());
AuthHttp = __decorate([
    core_1.Injectable(),
    __metadata("design:paramtypes", [AuthConfig, http_1.Http, http_1.RequestOptions])
], AuthHttp);
exports.AuthHttp = AuthHttp;
/**
 * Helper class to decode and find JWT expiration.
 */
var JwtHelper = (function () {
    function JwtHelper() {
    }
    JwtHelper.prototype.urlBase64Decode = function (str) {
        var output = str.replace(/-/g, '+').replace(/_/g, '/');
        switch (output.length % 4) {
            case 0: {
                break;
            }
            case 2: {
                output += '==';
                break;
            }
            case 3: {
                output += '=';
                break;
            }
            default: {
                throw 'Illegal base64url string!';
            }
        }
        return this.b64DecodeUnicode(output);
    };
    // credits for decoder goes to https://github.com/atk
    JwtHelper.prototype.b64decode = function (str) {
        var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        var output = '';
        str = String(str).replace(/=+$/, '');
        if (str.length % 4 == 1) {
            throw new Error("'atob' failed: The string to be decoded is not correctly encoded.");
        }
        for (
        // initialize result and counters
        var bc = 0, bs = void 0, buffer = void 0, idx = 0; 
        // get next character
        buffer = str.charAt(idx++); 
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
            // and if not first of each 4 characters,
            // convert the first 8 bits to one ascii character
            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
            // try to find character in table (0-63, not found => -1)
            buffer = chars.indexOf(buffer);
        }
        return output;
    };
    // https://developer.mozilla.org/en/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem
    JwtHelper.prototype.b64DecodeUnicode = function (str) {
        return decodeURIComponent(Array.prototype.map.call(this.b64decode(str), function (c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
    };
    JwtHelper.prototype.decodeToken = function (token) {
        var parts = token.split('.');
        if (parts.length !== 3) {
            throw new Error('JWT must have 3 parts');
        }
        var decoded = this.urlBase64Decode(parts[1]);
        if (!decoded) {
            throw new Error('Cannot decode the token');
        }
        return JSON.parse(decoded);
    };
    JwtHelper.prototype.getTokenExpirationDate = function (token) {
        var decoded;
        decoded = this.decodeToken(token);
        if (!decoded.hasOwnProperty('exp')) {
            return null;
        }
        var date = new Date(0); // The 0 here is the key, which sets the date to the epoch
        date.setUTCSeconds(decoded.exp);
        return date;
    };
    JwtHelper.prototype.isTokenExpired = function (token, offsetSeconds) {
        var date = this.getTokenExpirationDate(token);
        offsetSeconds = offsetSeconds || 0;
        if (date == null) {
            return false;
        }
        // Token expired?
        return !(date.valueOf() > (new Date().valueOf() + (offsetSeconds * 1000)));
    };
    return JwtHelper;
}());
exports.JwtHelper = JwtHelper;
/**
 * Checks for presence of token and that token hasn't expired.
 * For use with the @CanActivate router decorator and NgIf
 */
function tokenNotExpired(tokenName, jwt) {
    if (tokenName === void 0) { tokenName = AuthConfigConsts.DEFAULT_TOKEN_NAME; }
    var token = jwt || localStorage.getItem(tokenName);
    var jwtHelper = new JwtHelper();
    return token != null && !jwtHelper.isTokenExpired(token);
}
exports.tokenNotExpired = tokenNotExpired;
exports.AUTH_PROVIDERS = [
    {
        provide: AuthHttp,
        deps: [http_1.Http, http_1.RequestOptions],
        useFactory: function (http, options) {
            return new AuthHttp(new AuthConfig(), http, options);
        }
    }
];
function provideAuth(config) {
    return [
        {
            provide: AuthHttp,
            deps: [http_1.Http, http_1.RequestOptions],
            useFactory: function (http, options) {
                return new AuthHttp(new AuthConfig(config), http, options);
            }
        }
    ];
}
exports.provideAuth = provideAuth;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
    if (val === null || val === undefined) {
        throw new TypeError('Object.assign cannot be called with null or undefined');
    }
    return Object(val);
}
function objectAssign(target) {
    var source = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        source[_i - 1] = arguments[_i];
    }
    var from;
    var to = toObject(target);
    var symbols;
    for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
                to[key] = from[key];
            }
        }
        if (Object.getOwnPropertySymbols) {
            symbols = Object.getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
                if (propIsEnumerable.call(from, symbols[i])) {
                    to[symbols[i]] = from[symbols[i]];
                }
            }
        }
    }
    return to;
}
/**
 * Module for angular2-jwt
 * @experimental
 */
var AuthModule = AuthModule_1 = (function () {
    function AuthModule(parentModule) {
        if (parentModule) {
            throw new Error('AuthModule is already loaded. Import it in the AppModule only');
        }
    }
    AuthModule.forRoot = function (config) {
        return {
            ngModule: AuthModule_1,
            providers: [
                { provide: AuthConfig, useValue: config }
            ]
        };
    };
    return AuthModule;
}());
AuthModule = AuthModule_1 = __decorate([
    core_1.NgModule({
        imports: [http_1.HttpModule],
        providers: [AuthHttp, JwtHelper]
    }),
    __param(0, core_1.Optional()), __param(0, core_1.SkipSelf()),
    __metadata("design:paramtypes", [AuthModule])
], AuthModule);
exports.AuthModule = AuthModule;
var AuthModule_1;
//# sourceMappingURL=angular2-jwt.js.map

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.REPLACEMENT_CHARACTER = '\uFFFD';

exports.CODE_POINTS = {
    EOF: -1,
    NULL: 0x00,
    TABULATION: 0x09,
    CARRIAGE_RETURN: 0x0D,
    LINE_FEED: 0x0A,
    FORM_FEED: 0x0C,
    SPACE: 0x20,
    EXCLAMATION_MARK: 0x21,
    QUOTATION_MARK: 0x22,
    NUMBER_SIGN: 0x23,
    AMPERSAND: 0x26,
    APOSTROPHE: 0x27,
    HYPHEN_MINUS: 0x2D,
    SOLIDUS: 0x2F,
    DIGIT_0: 0x30,
    DIGIT_9: 0x39,
    SEMICOLON: 0x3B,
    LESS_THAN_SIGN: 0x3C,
    EQUALS_SIGN: 0x3D,
    GREATER_THAN_SIGN: 0x3E,
    QUESTION_MARK: 0x3F,
    LATIN_CAPITAL_A: 0x41,
    LATIN_CAPITAL_F: 0x46,
    LATIN_CAPITAL_X: 0x58,
    LATIN_CAPITAL_Z: 0x5A,
    GRAVE_ACCENT: 0x60,
    LATIN_SMALL_A: 0x61,
    LATIN_SMALL_F: 0x66,
    LATIN_SMALL_X: 0x78,
    LATIN_SMALL_Z: 0x7A,
    REPLACEMENT_CHARACTER: 0xFFFD
};

exports.CODE_POINT_SEQUENCES = {
    DASH_DASH_STRING: [0x2D, 0x2D], //--
    DOCTYPE_STRING: [0x44, 0x4F, 0x43, 0x54, 0x59, 0x50, 0x45], //DOCTYPE
    CDATA_START_STRING: [0x5B, 0x43, 0x44, 0x41, 0x54, 0x41, 0x5B], //[CDATA[
    CDATA_END_STRING: [0x5D, 0x5D, 0x3E], //]]>
    SCRIPT_STRING: [0x73, 0x63, 0x72, 0x69, 0x70, 0x74], //script
    PUBLIC_STRING: [0x50, 0x55, 0x42, 0x4C, 0x49, 0x43], //PUBLIC
    SYSTEM_STRING: [0x53, 0x59, 0x53, 0x54, 0x45, 0x4D] //SYSTEM
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Preprocessor = __webpack_require__(178),
    locationInfoMixin = __webpack_require__(170),
    UNICODE = __webpack_require__(20),
    neTree = __webpack_require__(177);

//Aliases
var $ = UNICODE.CODE_POINTS,
    $$ = UNICODE.CODE_POINT_SEQUENCES;

//Replacement code points for numeric entities
var NUMERIC_ENTITY_REPLACEMENTS = {
    0x00: 0xFFFD, 0x0D: 0x000D, 0x80: 0x20AC, 0x81: 0x0081, 0x82: 0x201A, 0x83: 0x0192, 0x84: 0x201E,
    0x85: 0x2026, 0x86: 0x2020, 0x87: 0x2021, 0x88: 0x02C6, 0x89: 0x2030, 0x8A: 0x0160, 0x8B: 0x2039,
    0x8C: 0x0152, 0x8D: 0x008D, 0x8E: 0x017D, 0x8F: 0x008F, 0x90: 0x0090, 0x91: 0x2018, 0x92: 0x2019,
    0x93: 0x201C, 0x94: 0x201D, 0x95: 0x2022, 0x96: 0x2013, 0x97: 0x2014, 0x98: 0x02DC, 0x99: 0x2122,
    0x9A: 0x0161, 0x9B: 0x203A, 0x9C: 0x0153, 0x9D: 0x009D, 0x9E: 0x017E, 0x9F: 0x0178
};

// Named entity tree flags
var HAS_DATA_FLAG = 1 << 0;
var DATA_DUPLET_FLAG = 1 << 1;
var HAS_BRANCHES_FLAG = 1 << 2;
var MAX_BRANCH_MARKER_VALUE = HAS_DATA_FLAG | DATA_DUPLET_FLAG | HAS_BRANCHES_FLAG;


//States
var DATA_STATE = 'DATA_STATE',
    CHARACTER_REFERENCE_IN_DATA_STATE = 'CHARACTER_REFERENCE_IN_DATA_STATE',
    RCDATA_STATE = 'RCDATA_STATE',
    CHARACTER_REFERENCE_IN_RCDATA_STATE = 'CHARACTER_REFERENCE_IN_RCDATA_STATE',
    RAWTEXT_STATE = 'RAWTEXT_STATE',
    SCRIPT_DATA_STATE = 'SCRIPT_DATA_STATE',
    PLAINTEXT_STATE = 'PLAINTEXT_STATE',
    TAG_OPEN_STATE = 'TAG_OPEN_STATE',
    END_TAG_OPEN_STATE = 'END_TAG_OPEN_STATE',
    TAG_NAME_STATE = 'TAG_NAME_STATE',
    RCDATA_LESS_THAN_SIGN_STATE = 'RCDATA_LESS_THAN_SIGN_STATE',
    RCDATA_END_TAG_OPEN_STATE = 'RCDATA_END_TAG_OPEN_STATE',
    RCDATA_END_TAG_NAME_STATE = 'RCDATA_END_TAG_NAME_STATE',
    RAWTEXT_LESS_THAN_SIGN_STATE = 'RAWTEXT_LESS_THAN_SIGN_STATE',
    RAWTEXT_END_TAG_OPEN_STATE = 'RAWTEXT_END_TAG_OPEN_STATE',
    RAWTEXT_END_TAG_NAME_STATE = 'RAWTEXT_END_TAG_NAME_STATE',
    SCRIPT_DATA_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_LESS_THAN_SIGN_STATE',
    SCRIPT_DATA_END_TAG_OPEN_STATE = 'SCRIPT_DATA_END_TAG_OPEN_STATE',
    SCRIPT_DATA_END_TAG_NAME_STATE = 'SCRIPT_DATA_END_TAG_NAME_STATE',
    SCRIPT_DATA_ESCAPE_START_STATE = 'SCRIPT_DATA_ESCAPE_START_STATE',
    SCRIPT_DATA_ESCAPE_START_DASH_STATE = 'SCRIPT_DATA_ESCAPE_START_DASH_STATE',
    SCRIPT_DATA_ESCAPED_STATE = 'SCRIPT_DATA_ESCAPED_STATE',
    SCRIPT_DATA_ESCAPED_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_STATE',
    SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_DASH_STATE',
    SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE',
    SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE',
    SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE',
    SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE',
    SCRIPT_DATA_DOUBLE_ESCAPED_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_STATE',
    SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE',
    SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE',
    SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE',
    SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE',
    BEFORE_ATTRIBUTE_NAME_STATE = 'BEFORE_ATTRIBUTE_NAME_STATE',
    ATTRIBUTE_NAME_STATE = 'ATTRIBUTE_NAME_STATE',
    AFTER_ATTRIBUTE_NAME_STATE = 'AFTER_ATTRIBUTE_NAME_STATE',
    BEFORE_ATTRIBUTE_VALUE_STATE = 'BEFORE_ATTRIBUTE_VALUE_STATE',
    ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE',
    ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE',
    ATTRIBUTE_VALUE_UNQUOTED_STATE = 'ATTRIBUTE_VALUE_UNQUOTED_STATE',
    CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE = 'CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE',
    AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = 'AFTER_ATTRIBUTE_VALUE_QUOTED_STATE',
    SELF_CLOSING_START_TAG_STATE = 'SELF_CLOSING_START_TAG_STATE',
    BOGUS_COMMENT_STATE = 'BOGUS_COMMENT_STATE',
    BOGUS_COMMENT_STATE_CONTINUATION = 'BOGUS_COMMENT_STATE_CONTINUATION',
    MARKUP_DECLARATION_OPEN_STATE = 'MARKUP_DECLARATION_OPEN_STATE',
    COMMENT_START_STATE = 'COMMENT_START_STATE',
    COMMENT_START_DASH_STATE = 'COMMENT_START_DASH_STATE',
    COMMENT_STATE = 'COMMENT_STATE',
    COMMENT_END_DASH_STATE = 'COMMENT_END_DASH_STATE',
    COMMENT_END_STATE = 'COMMENT_END_STATE',
    COMMENT_END_BANG_STATE = 'COMMENT_END_BANG_STATE',
    DOCTYPE_STATE = 'DOCTYPE_STATE',
    DOCTYPE_NAME_STATE = 'DOCTYPE_NAME_STATE',
    AFTER_DOCTYPE_NAME_STATE = 'AFTER_DOCTYPE_NAME_STATE',
    BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE',
    DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE',
    DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE',
    BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE = 'BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE',
    BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE',
    DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE',
    DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE',
    AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE',
    BOGUS_DOCTYPE_STATE = 'BOGUS_DOCTYPE_STATE',
    CDATA_SECTION_STATE = 'CDATA_SECTION_STATE';

//Utils

//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline
//this functions if they will be situated in another module due to context switch.
//Always perform inlining check before modifying this functions ('node --trace-inlining').
function isWhitespace(cp) {
    return cp === $.SPACE || cp === $.LINE_FEED || cp === $.TABULATION || cp === $.FORM_FEED;
}

function isAsciiDigit(cp) {
    return cp >= $.DIGIT_0 && cp <= $.DIGIT_9;
}

function isAsciiUpper(cp) {
    return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_Z;
}

function isAsciiLower(cp) {
    return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_Z;
}

function isAsciiLetter(cp) {
    return isAsciiLower(cp) || isAsciiUpper(cp);
}

function isAsciiAlphaNumeric(cp) {
    return isAsciiLetter(cp) || isAsciiDigit(cp);
}

function isDigit(cp, isHex) {
    return isAsciiDigit(cp) || isHex && (cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_F ||
                                         cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_F);
}

function isReservedCodePoint(cp) {
    return cp >= 0xD800 && cp <= 0xDFFF || cp > 0x10FFFF;
}

function toAsciiLowerCodePoint(cp) {
    return cp + 0x0020;
}

//NOTE: String.fromCharCode() function can handle only characters from BMP subset.
//So, we need to workaround this manually.
//(see: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/fromCharCode#Getting_it_to_work_with_higher_values)
function toChar(cp) {
    if (cp <= 0xFFFF)
        return String.fromCharCode(cp);

    cp -= 0x10000;
    return String.fromCharCode(cp >>> 10 & 0x3FF | 0xD800) + String.fromCharCode(0xDC00 | cp & 0x3FF);
}

function toAsciiLowerChar(cp) {
    return String.fromCharCode(toAsciiLowerCodePoint(cp));
}

function findNamedEntityTreeBranch(nodeIx, cp) {
    var branchCount = neTree[++nodeIx],
        lo = ++nodeIx,
        hi = lo + branchCount - 1;

    while (lo <= hi) {
        var mid = lo + hi >>> 1,
            midCp = neTree[mid];

        if (midCp < cp)
            lo = mid + 1;

        else if (midCp > cp)
            hi = mid - 1;

        else
            return neTree[mid + branchCount];
    }

    return -1;
}


//Tokenizer
var Tokenizer = module.exports = function (options) {
    this.preprocessor = new Preprocessor();

    this.tokenQueue = [];

    this.allowCDATA = false;

    this.state = DATA_STATE;
    this.returnState = '';

    this.tempBuff = [];
    this.additionalAllowedCp = void 0;
    this.lastStartTagName = '';

    this.consumedAfterSnapshot = -1;
    this.active = false;

    this.currentCharacterToken = null;
    this.currentToken = null;
    this.currentAttr = null;

    if (options && options.locationInfo)
        locationInfoMixin.assign(this);
};

//Token types
Tokenizer.CHARACTER_TOKEN = 'CHARACTER_TOKEN';
Tokenizer.NULL_CHARACTER_TOKEN = 'NULL_CHARACTER_TOKEN';
Tokenizer.WHITESPACE_CHARACTER_TOKEN = 'WHITESPACE_CHARACTER_TOKEN';
Tokenizer.START_TAG_TOKEN = 'START_TAG_TOKEN';
Tokenizer.END_TAG_TOKEN = 'END_TAG_TOKEN';
Tokenizer.COMMENT_TOKEN = 'COMMENT_TOKEN';
Tokenizer.DOCTYPE_TOKEN = 'DOCTYPE_TOKEN';
Tokenizer.EOF_TOKEN = 'EOF_TOKEN';
Tokenizer.HIBERNATION_TOKEN = 'HIBERNATION_TOKEN';

//Tokenizer initial states for different modes
Tokenizer.MODE = Tokenizer.prototype.MODE = {
    DATA: DATA_STATE,
    RCDATA: RCDATA_STATE,
    RAWTEXT: RAWTEXT_STATE,
    SCRIPT_DATA: SCRIPT_DATA_STATE,
    PLAINTEXT: PLAINTEXT_STATE
};

//Static
Tokenizer.getTokenAttr = function (token, attrName) {
    for (var i = token.attrs.length - 1; i >= 0; i--) {
        if (token.attrs[i].name === attrName)
            return token.attrs[i].value;
    }

    return null;
};

//API
Tokenizer.prototype.getNextToken = function () {
    while (!this.tokenQueue.length && this.active) {
        this._hibernationSnapshot();

        var cp = this._consume();

        if (!this._ensureHibernation())
            this[this.state](cp);
    }

    return this.tokenQueue.shift();
};

Tokenizer.prototype.write = function (chunk, isLastChunk) {
    this.active = true;
    this.preprocessor.write(chunk, isLastChunk);
};

Tokenizer.prototype.insertHtmlAtCurrentPos = function (chunk) {
    this.active = true;
    this.preprocessor.insertHtmlAtCurrentPos(chunk);
};

//Hibernation
Tokenizer.prototype._hibernationSnapshot = function () {
    this.consumedAfterSnapshot = 0;
};

Tokenizer.prototype._ensureHibernation = function () {
    if (this.preprocessor.endOfChunkHit) {
        for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--)
            this.preprocessor.retreat();

        this.active = false;
        this.tokenQueue.push({type: Tokenizer.HIBERNATION_TOKEN});

        return true;
    }

    return false;
};


//Consumption
Tokenizer.prototype._consume = function () {
    this.consumedAfterSnapshot++;
    return this.preprocessor.advance();
};

Tokenizer.prototype._unconsume = function () {
    this.consumedAfterSnapshot--;
    this.preprocessor.retreat();
};

Tokenizer.prototype._unconsumeSeveral = function (count) {
    while (count--)
        this._unconsume();
};

Tokenizer.prototype._reconsumeInState = function (state) {
    this.state = state;
    this._unconsume();
};

Tokenizer.prototype._consumeSubsequentIfMatch = function (pattern, startCp, caseSensitive) {
    var consumedCount = 0,
        isMatch = true,
        patternLength = pattern.length,
        patternPos = 0,
        cp = startCp,
        patternCp = void 0;

    for (; patternPos < patternLength; patternPos++) {
        if (patternPos > 0) {
            cp = this._consume();
            consumedCount++;
        }

        if (cp === $.EOF) {
            isMatch = false;
            break;
        }

        patternCp = pattern[patternPos];

        if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {
            isMatch = false;
            break;
        }
    }

    if (!isMatch)
        this._unconsumeSeveral(consumedCount);

    return isMatch;
};

//Lookahead
Tokenizer.prototype._lookahead = function () {
    var cp = this._consume();

    this._unconsume();

    return cp;
};

//Temp buffer
Tokenizer.prototype.isTempBufferEqualToScriptString = function () {
    if (this.tempBuff.length !== $$.SCRIPT_STRING.length)
        return false;

    for (var i = 0; i < this.tempBuff.length; i++) {
        if (this.tempBuff[i] !== $$.SCRIPT_STRING[i])
            return false;
    }

    return true;
};

//Token creation
Tokenizer.prototype._createStartTagToken = function () {
    this.currentToken = {
        type: Tokenizer.START_TAG_TOKEN,
        tagName: '',
        selfClosing: false,
        attrs: []
    };
};

Tokenizer.prototype._createEndTagToken = function () {
    this.currentToken = {
        type: Tokenizer.END_TAG_TOKEN,
        tagName: '',
        attrs: []
    };
};

Tokenizer.prototype._createCommentToken = function () {
    this.currentToken = {
        type: Tokenizer.COMMENT_TOKEN,
        data: ''
    };
};

Tokenizer.prototype._createDoctypeToken = function (initialName) {
    this.currentToken = {
        type: Tokenizer.DOCTYPE_TOKEN,
        name: initialName,
        forceQuirks: false,
        publicId: null,
        systemId: null
    };
};

Tokenizer.prototype._createCharacterToken = function (type, ch) {
    this.currentCharacterToken = {
        type: type,
        chars: ch
    };
};

//Tag attributes
Tokenizer.prototype._createAttr = function (attrNameFirstCh) {
    this.currentAttr = {
        name: attrNameFirstCh,
        value: ''
    };
};

Tokenizer.prototype._isDuplicateAttr = function () {
    return Tokenizer.getTokenAttr(this.currentToken, this.currentAttr.name) !== null;
};

Tokenizer.prototype._leaveAttrName = function (toState) {
    this.state = toState;

    if (!this._isDuplicateAttr())
        this.currentToken.attrs.push(this.currentAttr);
};

Tokenizer.prototype._leaveAttrValue = function (toState) {
    this.state = toState;
};

//Appropriate end tag token
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#appropriate-end-tag-token)
Tokenizer.prototype._isAppropriateEndTagToken = function () {
    return this.lastStartTagName === this.currentToken.tagName;
};

//Token emission
Tokenizer.prototype._emitCurrentToken = function () {
    this._emitCurrentCharacterToken();

    //NOTE: store emited start tag's tagName to determine is the following end tag token is appropriate.
    if (this.currentToken.type === Tokenizer.START_TAG_TOKEN)
        this.lastStartTagName = this.currentToken.tagName;

    this.tokenQueue.push(this.currentToken);
    this.currentToken = null;
};

Tokenizer.prototype._emitCurrentCharacterToken = function () {
    if (this.currentCharacterToken) {
        this.tokenQueue.push(this.currentCharacterToken);
        this.currentCharacterToken = null;
    }
};

Tokenizer.prototype._emitEOFToken = function () {
    this._emitCurrentCharacterToken();
    this.tokenQueue.push({type: Tokenizer.EOF_TOKEN});
};

//Characters emission

//OPTIMIZATION: specification uses only one type of character tokens (one token per character).
//This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
//If we have a sequence of characters that belong to the same group, parser can process it
//as a single solid character token.
//So, there are 3 types of character tokens in parse5:
//1)NULL_CHARACTER_TOKEN - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
//2)WHITESPACE_CHARACTER_TOKEN - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
//3)CHARACTER_TOKEN - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
Tokenizer.prototype._appendCharToCurrentCharacterToken = function (type, ch) {
    if (this.currentCharacterToken && this.currentCharacterToken.type !== type)
        this._emitCurrentCharacterToken();

    if (this.currentCharacterToken)
        this.currentCharacterToken.chars += ch;

    else
        this._createCharacterToken(type, ch);
};

Tokenizer.prototype._emitCodePoint = function (cp) {
    var type = Tokenizer.CHARACTER_TOKEN;

    if (isWhitespace(cp))
        type = Tokenizer.WHITESPACE_CHARACTER_TOKEN;

    else if (cp === $.NULL)
        type = Tokenizer.NULL_CHARACTER_TOKEN;

    this._appendCharToCurrentCharacterToken(type, toChar(cp));
};

Tokenizer.prototype._emitSeveralCodePoints = function (codePoints) {
    for (var i = 0; i < codePoints.length; i++)
        this._emitCodePoint(codePoints[i]);
};

//NOTE: used then we emit character explicitly. This is always a non-whitespace and a non-null character.
//So we can avoid additional checks here.
Tokenizer.prototype._emitChar = function (ch) {
    this._appendCharToCurrentCharacterToken(Tokenizer.CHARACTER_TOKEN, ch);
};

//Character reference tokenization
Tokenizer.prototype._consumeNumericEntity = function (isHex) {
    var digits = '',
        nextCp = void 0;

    do {
        digits += toChar(this._consume());
        nextCp = this._lookahead();
    } while (nextCp !== $.EOF && isDigit(nextCp, isHex));

    if (this._lookahead() === $.SEMICOLON)
        this._consume();

    var referencedCp = parseInt(digits, isHex ? 16 : 10),
        replacement = NUMERIC_ENTITY_REPLACEMENTS[referencedCp];

    if (replacement)
        return replacement;

    if (isReservedCodePoint(referencedCp))
        return $.REPLACEMENT_CHARACTER;

    return referencedCp;
};

// NOTE: for the details on this algorithm see
// https://github.com/inikulin/parse5/tree/master/scripts/generate_named_entity_data/README.md
Tokenizer.prototype._consumeNamedEntity = function (inAttr) {
    var referencedCodePoints = null,
        referenceSize = 0,
        cp = null,
        consumedCount = 0,
        semicolonTerminated = false;

    for (var i = 0; i > -1;) {
        var current = neTree[i],
            inNode = current < MAX_BRANCH_MARKER_VALUE,
            nodeWithData = inNode && current & HAS_DATA_FLAG;

        if (nodeWithData) {
            referencedCodePoints = current & DATA_DUPLET_FLAG ? [neTree[++i], neTree[++i]] : [neTree[++i]];
            referenceSize = consumedCount;

            if (cp === $.SEMICOLON) {
                semicolonTerminated = true;
                break;
            }
        }

        cp = this._consume();
        consumedCount++;

        if (cp === $.EOF)
            break;

        if (inNode)
            i = current & HAS_BRANCHES_FLAG ? findNamedEntityTreeBranch(i, cp) : -1;

        else
            i = cp === current ? ++i : -1;
    }


    if (referencedCodePoints) {
        if (!semicolonTerminated) {
            //NOTE: unconsume excess (e.g. 'it' in '&notit')
            this._unconsumeSeveral(consumedCount - referenceSize);

            //NOTE: If the character reference is being consumed as part of an attribute and the next character
            //is either a U+003D EQUALS SIGN character (=) or an alphanumeric ASCII character, then, for historical
            //reasons, all the characters that were matched after the U+0026 AMPERSAND character (&) must be
            //unconsumed, and nothing is returned.
            //However, if this next character is in fact a U+003D EQUALS SIGN character (=), then this is a
            //parse error, because some legacy user agents will misinterpret the markup in those cases.
            //(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#tokenizing-character-references)
            if (inAttr) {
                var nextCp = this._lookahead();

                if (nextCp === $.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp)) {
                    this._unconsumeSeveral(referenceSize);
                    return null;
                }
            }
        }

        return referencedCodePoints;
    }

    this._unconsumeSeveral(consumedCount);

    return null;
};

Tokenizer.prototype._consumeCharacterReference = function (startCp, inAttr) {
    if (isWhitespace(startCp) || startCp === $.GREATER_THAN_SIGN ||
        startCp === $.AMPERSAND || startCp === this.additionalAllowedCp || startCp === $.EOF) {
        //NOTE: not a character reference. No characters are consumed, and nothing is returned.
        this._unconsume();
        return null;
    }

    if (startCp === $.NUMBER_SIGN) {
        //NOTE: we have a numeric entity candidate, now we should determine if it's hex or decimal
        var isHex = false,
            nextCp = this._lookahead();

        if (nextCp === $.LATIN_SMALL_X || nextCp === $.LATIN_CAPITAL_X) {
            this._consume();
            isHex = true;
        }

        nextCp = this._lookahead();

        //NOTE: if we have at least one digit this is a numeric entity for sure, so we consume it
        if (nextCp !== $.EOF && isDigit(nextCp, isHex))
            return [this._consumeNumericEntity(isHex)];

        //NOTE: otherwise this is a bogus number entity and a parse error. Unconsume the number sign
        //and the 'x'-character if appropriate.
        this._unconsumeSeveral(isHex ? 2 : 1);
        return null;
    }

    this._unconsume();

    return this._consumeNamedEntity(inAttr);
};

//State machine
var _ = Tokenizer.prototype;

//12.2.4.1 Data state
//------------------------------------------------------------------
_[DATA_STATE] = function dataState(cp) {
    this.preprocessor.dropParsedChunk();

    if (cp === $.AMPERSAND)
        this.state = CHARACTER_REFERENCE_IN_DATA_STATE;

    else if (cp === $.LESS_THAN_SIGN)
        this.state = TAG_OPEN_STATE;

    else if (cp === $.NULL)
        this._emitCodePoint(cp);

    else if (cp === $.EOF)
        this._emitEOFToken();

    else
        this._emitCodePoint(cp);
};


//12.2.4.2 Character reference in data state
//------------------------------------------------------------------
_[CHARACTER_REFERENCE_IN_DATA_STATE] = function characterReferenceInDataState(cp) {
    this.additionalAllowedCp = void 0;

    var referencedCodePoints = this._consumeCharacterReference(cp, false);

    if (!this._ensureHibernation()) {
        if (referencedCodePoints)
            this._emitSeveralCodePoints(referencedCodePoints);

        else
            this._emitChar('&');

        this.state = DATA_STATE;
    }
};


//12.2.4.3 RCDATA state
//------------------------------------------------------------------
_[RCDATA_STATE] = function rcdataState(cp) {
    this.preprocessor.dropParsedChunk();

    if (cp === $.AMPERSAND)
        this.state = CHARACTER_REFERENCE_IN_RCDATA_STATE;

    else if (cp === $.LESS_THAN_SIGN)
        this.state = RCDATA_LESS_THAN_SIGN_STATE;

    else if (cp === $.NULL)
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);

    else if (cp === $.EOF)
        this._emitEOFToken();

    else
        this._emitCodePoint(cp);
};


//12.2.4.4 Character reference in RCDATA state
//------------------------------------------------------------------
_[CHARACTER_REFERENCE_IN_RCDATA_STATE] = function characterReferenceInRcdataState(cp) {
    this.additionalAllowedCp = void 0;

    var referencedCodePoints = this._consumeCharacterReference(cp, false);

    if (!this._ensureHibernation()) {
        if (referencedCodePoints)
            this._emitSeveralCodePoints(referencedCodePoints);

        else
            this._emitChar('&');

        this.state = RCDATA_STATE;
    }
};


//12.2.4.5 RAWTEXT state
//------------------------------------------------------------------
_[RAWTEXT_STATE] = function rawtextState(cp) {
    this.preprocessor.dropParsedChunk();

    if (cp === $.LESS_THAN_SIGN)
        this.state = RAWTEXT_LESS_THAN_SIGN_STATE;

    else if (cp === $.NULL)
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);

    else if (cp === $.EOF)
        this._emitEOFToken();

    else
        this._emitCodePoint(cp);
};


//12.2.4.6 Script data state
//------------------------------------------------------------------
_[SCRIPT_DATA_STATE] = function scriptDataState(cp) {
    this.preprocessor.dropParsedChunk();

    if (cp === $.LESS_THAN_SIGN)
        this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;

    else if (cp === $.NULL)
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);

    else if (cp === $.EOF)
        this._emitEOFToken();

    else
        this._emitCodePoint(cp);
};


//12.2.4.7 PLAINTEXT state
//------------------------------------------------------------------
_[PLAINTEXT_STATE] = function plaintextState(cp) {
    this.preprocessor.dropParsedChunk();

    if (cp === $.NULL)
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);

    else if (cp === $.EOF)
        this._emitEOFToken();

    else
        this._emitCodePoint(cp);
};


//12.2.4.8 Tag open state
//------------------------------------------------------------------
_[TAG_OPEN_STATE] = function tagOpenState(cp) {
    if (cp === $.EXCLAMATION_MARK)
        this.state = MARKUP_DECLARATION_OPEN_STATE;

    else if (cp === $.SOLIDUS)
        this.state = END_TAG_OPEN_STATE;

    else if (isAsciiLetter(cp)) {
        this._createStartTagToken();
        this._reconsumeInState(TAG_NAME_STATE);
    }

    else if (cp === $.QUESTION_MARK)
        this._reconsumeInState(BOGUS_COMMENT_STATE);

    else {
        this._emitChar('<');
        this._reconsumeInState(DATA_STATE);
    }
};


//12.2.4.9 End tag open state
//------------------------------------------------------------------
_[END_TAG_OPEN_STATE] = function endTagOpenState(cp) {
    if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this._reconsumeInState(TAG_NAME_STATE);
    }

    else if (cp === $.GREATER_THAN_SIGN)
        this.state = DATA_STATE;

    else if (cp === $.EOF) {
        this._reconsumeInState(DATA_STATE);
        this._emitChar('<');
        this._emitChar('/');
    }

    else
        this._reconsumeInState(BOGUS_COMMENT_STATE);
};


//12.2.4.10 Tag name state
//------------------------------------------------------------------
_[TAG_NAME_STATE] = function tagNameState(cp) {
    if (isWhitespace(cp))
        this.state = BEFORE_ATTRIBUTE_NAME_STATE;

    else if (cp === $.SOLIDUS)
        this.state = SELF_CLOSING_START_TAG_STATE;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (isAsciiUpper(cp))
        this.currentToken.tagName += toAsciiLowerChar(cp);

    else if (cp === $.NULL)
        this.currentToken.tagName += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this.currentToken.tagName += toChar(cp);
};


//12.2.4.11 RCDATA less-than sign state
//------------------------------------------------------------------
_[RCDATA_LESS_THAN_SIGN_STATE] = function rcdataLessThanSignState(cp) {
    if (cp === $.SOLIDUS) {
        this.tempBuff = [];
        this.state = RCDATA_END_TAG_OPEN_STATE;
    }

    else {
        this._emitChar('<');
        this._reconsumeInState(RCDATA_STATE);
    }
};


//12.2.4.12 RCDATA end tag open state
//------------------------------------------------------------------
_[RCDATA_END_TAG_OPEN_STATE] = function rcdataEndTagOpenState(cp) {
    if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this._reconsumeInState(RCDATA_END_TAG_NAME_STATE);
    }

    else {
        this._emitChar('<');
        this._emitChar('/');
        this._reconsumeInState(RCDATA_STATE);
    }
};


//12.2.4.13 RCDATA end tag name state
//------------------------------------------------------------------
_[RCDATA_END_TAG_NAME_STATE] = function rcdataEndTagNameState(cp) {
    if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
    }

    else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
    }

    else {
        if (this._isAppropriateEndTagToken()) {
            if (isWhitespace(cp)) {
                this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                return;
            }

            if (cp === $.SOLIDUS) {
                this.state = SELF_CLOSING_START_TAG_STATE;
                return;
            }

            if (cp === $.GREATER_THAN_SIGN) {
                this.state = DATA_STATE;
                this._emitCurrentToken();
                return;
            }
        }

        this._emitChar('<');
        this._emitChar('/');
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(RCDATA_STATE);
    }
};


//12.2.4.14 RAWTEXT less-than sign state
//------------------------------------------------------------------
_[RAWTEXT_LESS_THAN_SIGN_STATE] = function rawtextLessThanSignState(cp) {
    if (cp === $.SOLIDUS) {
        this.tempBuff = [];
        this.state = RAWTEXT_END_TAG_OPEN_STATE;
    }

    else {
        this._emitChar('<');
        this._reconsumeInState(RAWTEXT_STATE);
    }
};


//12.2.4.15 RAWTEXT end tag open state
//------------------------------------------------------------------
_[RAWTEXT_END_TAG_OPEN_STATE] = function rawtextEndTagOpenState(cp) {
    if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this._reconsumeInState(RAWTEXT_END_TAG_NAME_STATE);
    }

    else {
        this._emitChar('<');
        this._emitChar('/');
        this._reconsumeInState(RAWTEXT_STATE);
    }
};


//12.2.4.16 RAWTEXT end tag name state
//------------------------------------------------------------------
_[RAWTEXT_END_TAG_NAME_STATE] = function rawtextEndTagNameState(cp) {
    if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
    }

    else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
    }

    else {
        if (this._isAppropriateEndTagToken()) {
            if (isWhitespace(cp)) {
                this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                return;
            }

            if (cp === $.SOLIDUS) {
                this.state = SELF_CLOSING_START_TAG_STATE;
                return;
            }

            if (cp === $.GREATER_THAN_SIGN) {
                this._emitCurrentToken();
                this.state = DATA_STATE;
                return;
            }
        }

        this._emitChar('<');
        this._emitChar('/');
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(RAWTEXT_STATE);
    }
};


//12.2.4.17 Script data less-than sign state
//------------------------------------------------------------------
_[SCRIPT_DATA_LESS_THAN_SIGN_STATE] = function scriptDataLessThanSignState(cp) {
    if (cp === $.SOLIDUS) {
        this.tempBuff = [];
        this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;
    }

    else if (cp === $.EXCLAMATION_MARK) {
        this.state = SCRIPT_DATA_ESCAPE_START_STATE;
        this._emitChar('<');
        this._emitChar('!');
    }

    else {
        this._emitChar('<');
        this._reconsumeInState(SCRIPT_DATA_STATE);
    }
};


//12.2.4.18 Script data end tag open state
//------------------------------------------------------------------
_[SCRIPT_DATA_END_TAG_OPEN_STATE] = function scriptDataEndTagOpenState(cp) {
    if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this._reconsumeInState(SCRIPT_DATA_END_TAG_NAME_STATE);
    }

    else {
        this._emitChar('<');
        this._emitChar('/');
        this._reconsumeInState(SCRIPT_DATA_STATE);
    }
};


//12.2.4.19 Script data end tag name state
//------------------------------------------------------------------
_[SCRIPT_DATA_END_TAG_NAME_STATE] = function scriptDataEndTagNameState(cp) {
    if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
    }

    else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
    }

    else {
        if (this._isAppropriateEndTagToken()) {
            if (isWhitespace(cp)) {
                this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                return;
            }

            else if (cp === $.SOLIDUS) {
                this.state = SELF_CLOSING_START_TAG_STATE;
                return;
            }

            else if (cp === $.GREATER_THAN_SIGN) {
                this._emitCurrentToken();
                this.state = DATA_STATE;
                return;
            }
        }

        this._emitChar('<');
        this._emitChar('/');
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(SCRIPT_DATA_STATE);
    }
};


//12.2.4.20 Script data escape start state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPE_START_STATE] = function scriptDataEscapeStartState(cp) {
    if (cp === $.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;
        this._emitChar('-');
    }

    else
        this._reconsumeInState(SCRIPT_DATA_STATE);
};


//12.2.4.21 Script data escape start dash state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPE_START_DASH_STATE] = function scriptDataEscapeStartDashState(cp) {
    if (cp === $.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
        this._emitChar('-');
    }

    else
        this._reconsumeInState(SCRIPT_DATA_STATE);
};


//12.2.4.22 Script data escaped state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPED_STATE] = function scriptDataEscapedState(cp) {
    if (cp === $.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;
        this._emitChar('-');
    }

    else if (cp === $.LESS_THAN_SIGN)
        this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;

    else if (cp === $.NULL)
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this._emitCodePoint(cp);
};


//12.2.4.23 Script data escaped dash state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPED_DASH_STATE] = function scriptDataEscapedDashState(cp) {
    if (cp === $.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
        this._emitChar('-');
    }

    else if (cp === $.LESS_THAN_SIGN)
        this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;

    else if (cp === $.NULL) {
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else {
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitCodePoint(cp);
    }
};


//12.2.4.24 Script data escaped dash dash state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPED_DASH_DASH_STATE] = function scriptDataEscapedDashDashState(cp) {
    if (cp === $.HYPHEN_MINUS)
        this._emitChar('-');

    else if (cp === $.LESS_THAN_SIGN)
        this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = SCRIPT_DATA_STATE;
        this._emitChar('>');
    }

    else if (cp === $.NULL) {
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else {
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitCodePoint(cp);
    }
};


//12.2.4.25 Script data escaped less-than sign state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE] = function scriptDataEscapedLessThanSignState(cp) {
    if (cp === $.SOLIDUS) {
        this.tempBuff = [];
        this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
    }

    else if (isAsciiLetter(cp)) {
        this.tempBuff = [];
        this._emitChar('<');
        this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE);
    }

    else {
        this._emitChar('<');
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
    }
};


//12.2.4.26 Script data escaped end tag open state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE] = function scriptDataEscapedEndTagOpenState(cp) {
    if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE);
    }

    else {
        this._emitChar('<');
        this._emitChar('/');
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
    }
};


//12.2.4.27 Script data escaped end tag name state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE] = function scriptDataEscapedEndTagNameState(cp) {
    if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
    }

    else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
    }

    else {
        if (this._isAppropriateEndTagToken()) {
            if (isWhitespace(cp)) {
                this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                return;
            }

            if (cp === $.SOLIDUS) {
                this.state = SELF_CLOSING_START_TAG_STATE;
                return;
            }

            if (cp === $.GREATER_THAN_SIGN) {
                this._emitCurrentToken();
                this.state = DATA_STATE;
                return;
            }
        }

        this._emitChar('<');
        this._emitChar('/');
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
    }
};


//12.2.4.28 Script data double escape start state
//------------------------------------------------------------------
_[SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE] = function scriptDataDoubleEscapeStartState(cp) {
    if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {
        this.state = this.isTempBufferEqualToScriptString() ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE : SCRIPT_DATA_ESCAPED_STATE;
        this._emitCodePoint(cp);
    }

    else if (isAsciiUpper(cp)) {
        this.tempBuff.push(toAsciiLowerCodePoint(cp));
        this._emitCodePoint(cp);
    }

    else if (isAsciiLower(cp)) {
        this.tempBuff.push(cp);
        this._emitCodePoint(cp);
    }

    else
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
};


//12.2.4.29 Script data double escaped state
//------------------------------------------------------------------
_[SCRIPT_DATA_DOUBLE_ESCAPED_STATE] = function scriptDataDoubleEscapedState(cp) {
    if (cp === $.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
        this._emitChar('-');
    }

    else if (cp === $.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
        this._emitChar('<');
    }

    else if (cp === $.NULL)
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this._emitCodePoint(cp);
};


//12.2.4.30 Script data double escaped dash state
//------------------------------------------------------------------
_[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE] = function scriptDataDoubleEscapedDashState(cp) {
    if (cp === $.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;
        this._emitChar('-');
    }

    else if (cp === $.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
        this._emitChar('<');
    }

    else if (cp === $.NULL) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitCodePoint(cp);
    }
};


//12.2.4.31 Script data double escaped dash dash state
//------------------------------------------------------------------
_[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE] = function scriptDataDoubleEscapedDashDashState(cp) {
    if (cp === $.HYPHEN_MINUS)
        this._emitChar('-');

    else if (cp === $.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
        this._emitChar('<');
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = SCRIPT_DATA_STATE;
        this._emitChar('>');
    }

    else if (cp === $.NULL) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitCodePoint(cp);
    }
};


//12.2.4.32 Script data double escaped less-than sign state
//------------------------------------------------------------------
_[SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE] = function scriptDataDoubleEscapedLessThanSignState(cp) {
    if (cp === $.SOLIDUS) {
        this.tempBuff = [];
        this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
        this._emitChar('/');
    }

    else
        this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
};


//12.2.4.33 Script data double escape end state
//------------------------------------------------------------------
_[SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE] = function scriptDataDoubleEscapeEndState(cp) {
    if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {
        this.state = this.isTempBufferEqualToScriptString() ? SCRIPT_DATA_ESCAPED_STATE : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

        this._emitCodePoint(cp);
    }

    else if (isAsciiUpper(cp)) {
        this.tempBuff.push(toAsciiLowerCodePoint(cp));
        this._emitCodePoint(cp);
    }

    else if (isAsciiLower(cp)) {
        this.tempBuff.push(cp);
        this._emitCodePoint(cp);
    }

    else
        this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
};


//12.2.4.34 Before attribute name state
//------------------------------------------------------------------
_[BEFORE_ATTRIBUTE_NAME_STATE] = function beforeAttributeNameState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF)
        this._reconsumeInState(AFTER_ATTRIBUTE_NAME_STATE);

    else if (cp === $.EQUALS_SIGN) {
        this._createAttr('=');
        this.state = ATTRIBUTE_NAME_STATE;
    }

    else {
        this._createAttr('');
        this._reconsumeInState(ATTRIBUTE_NAME_STATE);
    }
};


//12.2.4.35 Attribute name state
//------------------------------------------------------------------
_[ATTRIBUTE_NAME_STATE] = function attributeNameState(cp) {
    if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF) {
        this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);
        this._unconsume();
    }

    else if (cp === $.EQUALS_SIGN)
        this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);

    else if (isAsciiUpper(cp))
        this.currentAttr.name += toAsciiLowerChar(cp);

    else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN)
        this.currentAttr.name += toChar(cp);

    else if (cp === $.NULL)
        this.currentAttr.name += UNICODE.REPLACEMENT_CHARACTER;

    else
        this.currentAttr.name += toChar(cp);
};


//12.2.4.36 After attribute name state
//------------------------------------------------------------------
_[AFTER_ATTRIBUTE_NAME_STATE] = function afterAttributeNameState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.SOLIDUS)
        this.state = SELF_CLOSING_START_TAG_STATE;

    else if (cp === $.EQUALS_SIGN)
        this.state = BEFORE_ATTRIBUTE_VALUE_STATE;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else {
        this._createAttr('');
        this._reconsumeInState(ATTRIBUTE_NAME_STATE);
    }
};


//12.2.4.37 Before attribute value state
//------------------------------------------------------------------
_[BEFORE_ATTRIBUTE_VALUE_STATE] = function beforeAttributeValueState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.QUOTATION_MARK)
        this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;

    else if (cp === $.APOSTROPHE)
        this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;

    else
        this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);
};


//12.2.4.38 Attribute value (double-quoted) state
//------------------------------------------------------------------
_[ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE] = function attributeValueDoubleQuotedState(cp) {
    if (cp === $.QUOTATION_MARK)
        this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;

    else if (cp === $.AMPERSAND) {
        this.additionalAllowedCp = $.QUOTATION_MARK;
        this.returnState = this.state;
        this.state = CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE;
    }

    else if (cp === $.NULL)
        this.currentAttr.value += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this.currentAttr.value += toChar(cp);
};


//12.2.4.39 Attribute value (single-quoted) state
//------------------------------------------------------------------
_[ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE] = function attributeValueSingleQuotedState(cp) {
    if (cp === $.APOSTROPHE)
        this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;

    else if (cp === $.AMPERSAND) {
        this.additionalAllowedCp = $.APOSTROPHE;
        this.returnState = this.state;
        this.state = CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE;
    }

    else if (cp === $.NULL)
        this.currentAttr.value += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this.currentAttr.value += toChar(cp);
};


//12.2.4.40 Attribute value (unquoted) state
//------------------------------------------------------------------
_[ATTRIBUTE_VALUE_UNQUOTED_STATE] = function attributeValueUnquotedState(cp) {
    if (isWhitespace(cp))
        this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);

    else if (cp === $.AMPERSAND) {
        this.additionalAllowedCp = $.GREATER_THAN_SIGN;
        this.returnState = this.state;
        this.state = CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE;
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this._leaveAttrValue(DATA_STATE);
        this._emitCurrentToken();
    }

    else if (cp === $.NULL)
        this.currentAttr.value += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN ||
             cp === $.EQUALS_SIGN || cp === $.GRAVE_ACCENT)
        this.currentAttr.value += toChar(cp);

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this.currentAttr.value += toChar(cp);
};


//12.2.4.41 Character reference in attribute value state
//------------------------------------------------------------------
_[CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE] = function characterReferenceInAttributeValueState(cp) {
    var referencedCodePoints = this._consumeCharacterReference(cp, true);

    if (!this._ensureHibernation()) {
        if (referencedCodePoints) {
            for (var i = 0; i < referencedCodePoints.length; i++)
                this.currentAttr.value += toChar(referencedCodePoints[i]);
        }
        else
            this.currentAttr.value += '&';

        this.state = this.returnState;
    }
};


//12.2.4.42 After attribute value (quoted) state
//------------------------------------------------------------------
_[AFTER_ATTRIBUTE_VALUE_QUOTED_STATE] = function afterAttributeValueQuotedState(cp) {
    if (isWhitespace(cp))
        this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);

    else if (cp === $.SOLIDUS)
        this._leaveAttrValue(SELF_CLOSING_START_TAG_STATE);

    else if (cp === $.GREATER_THAN_SIGN) {
        this._leaveAttrValue(DATA_STATE);
        this._emitCurrentToken();
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
};


//12.2.4.43 Self-closing start tag state
//------------------------------------------------------------------
_[SELF_CLOSING_START_TAG_STATE] = function selfClosingStartTagState(cp) {
    if (cp === $.GREATER_THAN_SIGN) {
        this.currentToken.selfClosing = true;
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
};


//12.2.4.44 Bogus comment state
//------------------------------------------------------------------
_[BOGUS_COMMENT_STATE] = function bogusCommentState() {
    this._createCommentToken();
    this._reconsumeInState(BOGUS_COMMENT_STATE_CONTINUATION);
};

//HACK: to support streaming and make BOGUS_COMMENT_STATE reentrant we've
//introduced BOGUS_COMMENT_STATE_CONTINUATION state which will not produce
//comment token on each call.
_[BOGUS_COMMENT_STATE_CONTINUATION] = function bogusCommentStateContinuation(cp) {
    while (true) {
        if (cp === $.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            break;
        }

        else if (cp === $.EOF) {
            this._reconsumeInState(DATA_STATE);
            break;
        }

        else {
            this.currentToken.data += cp === $.NULL ? UNICODE.REPLACEMENT_CHARACTER : toChar(cp);

            this._hibernationSnapshot();
            cp = this._consume();

            if (this._ensureHibernation())
                return;
        }
    }

    this._emitCurrentToken();
};

//12.2.4.45 Markup declaration open state
//------------------------------------------------------------------
_[MARKUP_DECLARATION_OPEN_STATE] = function markupDeclarationOpenState(cp) {
    var dashDashMatch = this._consumeSubsequentIfMatch($$.DASH_DASH_STRING, cp, true),
        doctypeMatch = !dashDashMatch && this._consumeSubsequentIfMatch($$.DOCTYPE_STRING, cp, false),
        cdataMatch = !dashDashMatch && !doctypeMatch &&
                     this.allowCDATA &&
                     this._consumeSubsequentIfMatch($$.CDATA_START_STRING, cp, true);

    if (!this._ensureHibernation()) {
        if (dashDashMatch) {
            this._createCommentToken();
            this.state = COMMENT_START_STATE;
        }

        else if (doctypeMatch)
            this.state = DOCTYPE_STATE;

        else if (cdataMatch)
            this.state = CDATA_SECTION_STATE;

        else
            this._reconsumeInState(BOGUS_COMMENT_STATE);
    }
};


//12.2.4.46 Comment start state
//------------------------------------------------------------------
_[COMMENT_START_STATE] = function commentStartState(cp) {
    if (cp === $.HYPHEN_MINUS)
        this.state = COMMENT_START_DASH_STATE;

    else if (cp === $.NULL) {
        this.currentToken.data += UNICODE.REPLACEMENT_CHARACTER;
        this.state = COMMENT_STATE;
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (cp === $.EOF) {
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else {
        this.currentToken.data += toChar(cp);
        this.state = COMMENT_STATE;
    }
};


//12.2.4.47 Comment start dash state
//------------------------------------------------------------------
_[COMMENT_START_DASH_STATE] = function commentStartDashState(cp) {
    if (cp === $.HYPHEN_MINUS)
        this.state = COMMENT_END_STATE;

    else if (cp === $.NULL) {
        this.currentToken.data += '-';
        this.currentToken.data += UNICODE.REPLACEMENT_CHARACTER;
        this.state = COMMENT_STATE;
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (cp === $.EOF) {
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else {
        this.currentToken.data += '-';
        this.currentToken.data += toChar(cp);
        this.state = COMMENT_STATE;
    }
};


//12.2.4.48 Comment state
//------------------------------------------------------------------
_[COMMENT_STATE] = function commentState(cp) {
    if (cp === $.HYPHEN_MINUS)
        this.state = COMMENT_END_DASH_STATE;

    else if (cp === $.NULL)
        this.currentToken.data += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.EOF) {
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else
        this.currentToken.data += toChar(cp);
};


//12.2.4.49 Comment end dash state
//------------------------------------------------------------------
_[COMMENT_END_DASH_STATE] = function commentEndDashState(cp) {
    if (cp === $.HYPHEN_MINUS)
        this.state = COMMENT_END_STATE;

    else if (cp === $.NULL) {
        this.currentToken.data += '-';
        this.currentToken.data += UNICODE.REPLACEMENT_CHARACTER;
        this.state = COMMENT_STATE;
    }

    else if (cp === $.EOF) {
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else {
        this.currentToken.data += '-';
        this.currentToken.data += toChar(cp);
        this.state = COMMENT_STATE;
    }
};


//12.2.4.50 Comment end state
//------------------------------------------------------------------
_[COMMENT_END_STATE] = function commentEndState(cp) {
    if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (cp === $.EXCLAMATION_MARK)
        this.state = COMMENT_END_BANG_STATE;

    else if (cp === $.HYPHEN_MINUS)
        this.currentToken.data += '-';

    else if (cp === $.NULL) {
        this.currentToken.data += '--';
        this.currentToken.data += UNICODE.REPLACEMENT_CHARACTER;
        this.state = COMMENT_STATE;
    }

    else if (cp === $.EOF) {
        this._reconsumeInState(DATA_STATE);
        this._emitCurrentToken();
    }

    else {
        this.currentToken.data += '--';
        this.currentToken.data += toChar(cp);
        this.state = COMMENT_STATE;
    }
};


//12.2.4.51 Comment end bang state
//------------------------------------------------------------------
_[COMMENT_END_BANG_STATE] = function commentEndBangState(cp) {
    if (cp === $.HYPHEN_MINUS) {
        this.currentToken.data += '--!';
        this.state = COMMENT_END_DASH_STATE;
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (cp === $.NULL) {
        this.currentToken.data += '--!';
        this.currentToken.data += UNICODE.REPLACEMENT_CHARACTER;
        this.state = COMMENT_STATE;
    }

    else if (cp === $.EOF) {
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else {
        this.currentToken.data += '--!';
        this.currentToken.data += toChar(cp);
        this.state = COMMENT_STATE;
    }
};


//12.2.4.52 DOCTYPE state
//------------------------------------------------------------------
_[DOCTYPE_STATE] = function doctypeState(cp) {
    if (isWhitespace(cp))
        return;

    else if (cp === $.GREATER_THAN_SIGN) {
        this._createDoctypeToken(null);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.EOF) {
        this._createDoctypeToken(null);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }
    else {
        this._createDoctypeToken('');
        this._reconsumeInState(DOCTYPE_NAME_STATE);
    }
};


//12.2.4.54 DOCTYPE name state
//------------------------------------------------------------------
_[DOCTYPE_NAME_STATE] = function doctypeNameState(cp) {
    if (isWhitespace(cp) || cp === $.GREATER_THAN_SIGN || cp === $.EOF)
        this._reconsumeInState(AFTER_DOCTYPE_NAME_STATE);

    else if (isAsciiUpper(cp))
        this.currentToken.name += toAsciiLowerChar(cp);

    else if (cp === $.NULL)
        this.currentToken.name += UNICODE.REPLACEMENT_CHARACTER;

    else
        this.currentToken.name += toChar(cp);
};


//12.2.4.55 After DOCTYPE name state
//------------------------------------------------------------------
_[AFTER_DOCTYPE_NAME_STATE] = function afterDoctypeNameState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else {
        var publicMatch = this._consumeSubsequentIfMatch($$.PUBLIC_STRING, cp, false),
            systemMatch = !publicMatch && this._consumeSubsequentIfMatch($$.SYSTEM_STRING, cp, false);

        if (!this._ensureHibernation()) {
            if (publicMatch)
                this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;

            else if (systemMatch)
                this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;

            else {
                this.currentToken.forceQuirks = true;
                this.state = BOGUS_DOCTYPE_STATE;
            }
        }
    }
};


//12.2.4.57 Before DOCTYPE public identifier state
//------------------------------------------------------------------
_[BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE] = function beforeDoctypePublicIdentifierState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.QUOTATION_MARK) {
        this.currentToken.publicId = '';
        this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
    }

    else if (cp === $.APOSTROPHE) {
        this.currentToken.publicId = '';
        this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
    }

    else {
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
    }
};


//12.2.4.58 DOCTYPE public identifier (double-quoted) state
//------------------------------------------------------------------
_[DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE] = function doctypePublicIdentifierDoubleQuotedState(cp) {
    if (cp === $.QUOTATION_MARK)
        this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;

    else if (cp === $.NULL)
        this.currentToken.publicId += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else
        this.currentToken.publicId += toChar(cp);
};


//12.2.4.59 DOCTYPE public identifier (single-quoted) state
//------------------------------------------------------------------
_[DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE] = function doctypePublicIdentifierSingleQuotedState(cp) {
    if (cp === $.APOSTROPHE)
        this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;

    else if (cp === $.NULL)
        this.currentToken.publicId += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else
        this.currentToken.publicId += toChar(cp);
};


//12.2.4.61 Between DOCTYPE public and system identifiers state
//------------------------------------------------------------------
_[BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE] = function betweenDoctypePublicAndSystemIdentifiersState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.QUOTATION_MARK) {
        this.currentToken.systemId = '';
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
    }


    else if (cp === $.APOSTROPHE) {
        this.currentToken.systemId = '';
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
    }

    else {
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
    }
};


//12.2.4.63 Before DOCTYPE system identifier state
//------------------------------------------------------------------
_[BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE] = function beforeDoctypeSystemIdentifierState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.QUOTATION_MARK) {
        this.currentToken.systemId = '';
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
    }

    else if (cp === $.APOSTROPHE) {
        this.currentToken.systemId = '';
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
    }

    else {
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
    }
};


//12.2.4.64 DOCTYPE system identifier (double-quoted) state
//------------------------------------------------------------------
_[DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE] = function doctypeSystemIdentifierDoubleQuotedState(cp) {
    if (cp === $.QUOTATION_MARK)
        this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.NULL)
        this.currentToken.systemId += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else
        this.currentToken.systemId += toChar(cp);
};


//12.2.4.65 DOCTYPE system identifier (single-quoted) state
//------------------------------------------------------------------
_[DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE] = function doctypeSystemIdentifierSingleQuotedState(cp) {
    if (cp === $.APOSTROPHE)
        this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.NULL)
        this.currentToken.systemId += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else
        this.currentToken.systemId += toChar(cp);
};


//12.2.4.66 After DOCTYPE system identifier state
//------------------------------------------------------------------
_[AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE] = function afterDoctypeSystemIdentifierState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else
        this.state = BOGUS_DOCTYPE_STATE;
};


//12.2.4.67 Bogus DOCTYPE state
//------------------------------------------------------------------
_[BOGUS_DOCTYPE_STATE] = function bogusDoctypeState(cp) {
    if (cp === $.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.EOF) {
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }
};


//12.2.4.68 CDATA section state
//------------------------------------------------------------------
_[CDATA_SECTION_STATE] = function cdataSectionState(cp) {
    while (true) {
        if (cp === $.EOF) {
            this._reconsumeInState(DATA_STATE);
            break;
        }

        else {
            var cdataEndMatch = this._consumeSubsequentIfMatch($$.CDATA_END_STRING, cp, true);

            if (this._ensureHibernation())
                break;

            if (cdataEndMatch) {
                this.state = DATA_STATE;
                break;
            }

            this._emitCodePoint(cp);

            this._hibernationSnapshot();
            cp = this._consume();

            if (this._ensureHibernation())
                break;
        }
    }
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(37);

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(90);

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;
//# sourceMappingURL=isDate.js.map

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(11);

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(92);

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AlertService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var AlertService = (function () {
    function AlertService() {
        var _this = this;
        this.alertChanged = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["EventEmitter"]();
        this.showAlert = function (title, message, action) {
            if (action === void 0) { action = function () { }; }
            return _this.alertChanged.emit({ action: action, message: message, title: title });
        };
    }
    AlertService.prototype.show = function (title, message, action) {
        if (action === void 0) { action = function () { }; }
        this.showAlert(title, message, action);
    };
    AlertService = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])()
    ], AlertService);
    return AlertService;
}());



/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DOCUMENT_MODE = __webpack_require__(10).DOCUMENT_MODE;

//Const
var VALID_DOCTYPE_NAME = 'html',
    QUIRKS_MODE_SYSTEM_ID = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd',
    QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
        '+//silmaril//dtd html pro v0r11 19970101//en',
        '-//advasoft ltd//dtd html 3.0 aswedit + extensions//en',
        '-//as//dtd html 3.0 aswedit + extensions//en',
        '-//ietf//dtd html 2.0 level 1//en',
        '-//ietf//dtd html 2.0 level 2//en',
        '-//ietf//dtd html 2.0 strict level 1//en',
        '-//ietf//dtd html 2.0 strict level 2//en',
        '-//ietf//dtd html 2.0 strict//en',
        '-//ietf//dtd html 2.0//en',
        '-//ietf//dtd html 2.1e//en',
        '-//ietf//dtd html 3.0//en',
        '-//ietf//dtd html 3.0//en//',
        '-//ietf//dtd html 3.2 final//en',
        '-//ietf//dtd html 3.2//en',
        '-//ietf//dtd html 3//en',
        '-//ietf//dtd html level 0//en',
        '-//ietf//dtd html level 0//en//2.0',
        '-//ietf//dtd html level 1//en',
        '-//ietf//dtd html level 1//en//2.0',
        '-//ietf//dtd html level 2//en',
        '-//ietf//dtd html level 2//en//2.0',
        '-//ietf//dtd html level 3//en',
        '-//ietf//dtd html level 3//en//3.0',
        '-//ietf//dtd html strict level 0//en',
        '-//ietf//dtd html strict level 0//en//2.0',
        '-//ietf//dtd html strict level 1//en',
        '-//ietf//dtd html strict level 1//en//2.0',
        '-//ietf//dtd html strict level 2//en',
        '-//ietf//dtd html strict level 2//en//2.0',
        '-//ietf//dtd html strict level 3//en',
        '-//ietf//dtd html strict level 3//en//3.0',
        '-//ietf//dtd html strict//en',
        '-//ietf//dtd html strict//en//2.0',
        '-//ietf//dtd html strict//en//3.0',
        '-//ietf//dtd html//en',
        '-//ietf//dtd html//en//2.0',
        '-//ietf//dtd html//en//3.0',
        '-//metrius//dtd metrius presentational//en',
        '-//microsoft//dtd internet explorer 2.0 html strict//en',
        '-//microsoft//dtd internet explorer 2.0 html//en',
        '-//microsoft//dtd internet explorer 2.0 tables//en',
        '-//microsoft//dtd internet explorer 3.0 html strict//en',
        '-//microsoft//dtd internet explorer 3.0 html//en',
        '-//microsoft//dtd internet explorer 3.0 tables//en',
        '-//netscape comm. corp.//dtd html//en',
        '-//netscape comm. corp.//dtd strict html//en',
        '-//o\'reilly and associates//dtd html 2.0//en',
        '-//o\'reilly and associates//dtd html extended 1.0//en',
        '-//spyglass//dtd html 2.0 extended//en',
        '-//sq//dtd html 2.0 hotmetal + extensions//en',
        '-//sun microsystems corp.//dtd hotjava html//en',
        '-//sun microsystems corp.//dtd hotjava strict html//en',
        '-//w3c//dtd html 3 1995-03-24//en',
        '-//w3c//dtd html 3.2 draft//en',
        '-//w3c//dtd html 3.2 final//en',
        '-//w3c//dtd html 3.2//en',
        '-//w3c//dtd html 3.2s draft//en',
        '-//w3c//dtd html 4.0 frameset//en',
        '-//w3c//dtd html 4.0 transitional//en',
        '-//w3c//dtd html experimental 19960712//en',
        '-//w3c//dtd html experimental 970421//en',
        '-//w3c//dtd w3 html//en',
        '-//w3o//dtd w3 html 3.0//en',
        '-//w3o//dtd w3 html 3.0//en//',
        '-//webtechs//dtd mozilla html 2.0//en',
        '-//webtechs//dtd mozilla html//en'
    ],
    QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = QUIRKS_MODE_PUBLIC_ID_PREFIXES.concat([
        '-//w3c//dtd html 4.01 frameset//',
        '-//w3c//dtd html 4.01 transitional//'
    ]),
    QUIRKS_MODE_PUBLIC_IDS = [
        '-//w3o//dtd w3 html strict 3.0//en//',
        '-/w3c/dtd html 4.0 transitional/en',
        'html'
    ],
    LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = [
        '-//W3C//DTD XHTML 1.0 Frameset//',
        '-//W3C//DTD XHTML 1.0 Transitional//'
    ],
    LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = LIMITED_QUIRKS_PUBLIC_ID_PREFIXES.concat([
        '-//W3C//DTD HTML 4.01 Frameset//',
        '-//W3C//DTD HTML 4.01 Transitional//'
    ]);


//Utils
function enquoteDoctypeId(id) {
    var quote = id.indexOf('"') !== -1 ? '\'' : '"';

    return quote + id + quote;
}

function hasPrefix(publicId, prefixes) {
    for (var i = 0; i < prefixes.length; i++) {
        if (publicId.indexOf(prefixes[i]) === 0)
            return true;
    }

    return false;
}


//API
exports.getDocumentMode = function (name, publicId, systemId) {
    if (name !== VALID_DOCTYPE_NAME)
        return DOCUMENT_MODE.QUIRKS;

    if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID)
        return DOCUMENT_MODE.QUIRKS;

    if (publicId !== null) {
        publicId = publicId.toLowerCase();

        if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1)
            return DOCUMENT_MODE.QUIRKS;

        var prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;

        if (hasPrefix(publicId, prefixes))
            return DOCUMENT_MODE.QUIRKS;

        prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;

        if (hasPrefix(publicId, prefixes))
            return DOCUMENT_MODE.LIMITED_QUIRKS;
    }

    return DOCUMENT_MODE.NO_QUIRKS;
};

exports.serializeContent = function (name, publicId, systemId) {
    var str = '!DOCTYPE ';

    if (name)
        str += name;

    if (publicId !== null)
        str += ' PUBLIC ' + enquoteDoctypeId(publicId);

    else if (systemId !== null)
        str += ' SYSTEM';

    if (systemId !== null)
        str += ' ' + enquoteDoctypeId(systemId);

    return str;
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function mergeOptions(defaults, options) {
    options = options || Object.create(null);

    return [defaults, options].reduce(function (merged, optObj) {
        Object.keys(optObj).forEach(function (key) {
            merged[key] = optObj[key];
        });

        return merged;
    }, Object.create(null));
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Parser = __webpack_require__(54),
    Serializer = __webpack_require__(57);


// Shorthands
exports.parse = function parse(html, options) {
    var parser = new Parser(options);

    return parser.parse(html);
};

exports.parseFragment = function parseFragment(fragmentContext, html, options) {
    if (typeof fragmentContext === 'string') {
        options = html;
        html = fragmentContext;
        fragmentContext = null;
    }

    var parser = new Parser(options);

    return parser.parseFragment(html, fragmentContext);
};

exports.serialize = function (node, options) {
    var serializer = new Serializer(node, options);

    return serializer.serialize();
};


// Tree adapters
exports.treeAdapters = {
    default: __webpack_require__(33),
    htmlparser2: __webpack_require__(179)
};


// Streaming
exports.ParserStream = __webpack_require__(56);
exports.PlainTextConversionStream = __webpack_require__(172);
exports.SerializerStream = __webpack_require__(176);
exports.SAXParser = __webpack_require__(174);


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DOCUMENT_MODE = __webpack_require__(10).DOCUMENT_MODE;

//Node construction
exports.createDocument = function () {
    return {
        nodeName: '#document',
        mode: DOCUMENT_MODE.NO_QUIRKS,
        childNodes: []
    };
};

exports.createDocumentFragment = function () {
    return {
        nodeName: '#document-fragment',
        childNodes: []
    };
};

exports.createElement = function (tagName, namespaceURI, attrs) {
    return {
        nodeName: tagName,
        tagName: tagName,
        attrs: attrs,
        namespaceURI: namespaceURI,
        childNodes: [],
        parentNode: null
    };
};

exports.createCommentNode = function (data) {
    return {
        nodeName: '#comment',
        data: data,
        parentNode: null
    };
};

var createTextNode = function (value) {
    return {
        nodeName: '#text',
        value: value,
        parentNode: null
    };
};


//Tree mutation
var appendChild = exports.appendChild = function (parentNode, newNode) {
    parentNode.childNodes.push(newNode);
    newNode.parentNode = parentNode;
};

var insertBefore = exports.insertBefore = function (parentNode, newNode, referenceNode) {
    var insertionIdx = parentNode.childNodes.indexOf(referenceNode);

    parentNode.childNodes.splice(insertionIdx, 0, newNode);
    newNode.parentNode = parentNode;
};

exports.setTemplateContent = function (templateElement, contentElement) {
    templateElement.content = contentElement;
};

exports.getTemplateContent = function (templateElement) {
    return templateElement.content;
};

exports.setDocumentType = function (document, name, publicId, systemId) {
    var doctypeNode = null;

    for (var i = 0; i < document.childNodes.length; i++) {
        if (document.childNodes[i].nodeName === '#documentType') {
            doctypeNode = document.childNodes[i];
            break;
        }
    }

    if (doctypeNode) {
        doctypeNode.name = name;
        doctypeNode.publicId = publicId;
        doctypeNode.systemId = systemId;
    }

    else {
        appendChild(document, {
            nodeName: '#documentType',
            name: name,
            publicId: publicId,
            systemId: systemId
        });
    }
};

exports.setDocumentMode = function (document, mode) {
    document.mode = mode;
};

exports.getDocumentMode = function (document) {
    return document.mode;
};

exports.detachNode = function (node) {
    if (node.parentNode) {
        var idx = node.parentNode.childNodes.indexOf(node);

        node.parentNode.childNodes.splice(idx, 1);
        node.parentNode = null;
    }
};

exports.insertText = function (parentNode, text) {
    if (parentNode.childNodes.length) {
        var prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];

        if (prevNode.nodeName === '#text') {
            prevNode.value += text;
            return;
        }
    }

    appendChild(parentNode, createTextNode(text));
};

exports.insertTextBefore = function (parentNode, text, referenceNode) {
    var prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];

    if (prevNode && prevNode.nodeName === '#text')
        prevNode.value += text;
    else
        insertBefore(parentNode, createTextNode(text), referenceNode);
};

exports.adoptAttributes = function (recipient, attrs) {
    var recipientAttrsMap = [];

    for (var i = 0; i < recipient.attrs.length; i++)
        recipientAttrsMap.push(recipient.attrs[i].name);

    for (var j = 0; j < attrs.length; j++) {
        if (recipientAttrsMap.indexOf(attrs[j].name) === -1)
            recipient.attrs.push(attrs[j]);
    }
};


//Tree traversing
exports.getFirstChild = function (node) {
    return node.childNodes[0];
};

exports.getChildNodes = function (node) {
    return node.childNodes;
};

exports.getParentNode = function (node) {
    return node.parentNode;
};

exports.getAttrList = function (element) {
    return element.attrs;
};

//Node data
exports.getTagName = function (element) {
    return element.tagName;
};

exports.getNamespaceURI = function (element) {
    return element.namespaceURI;
};

exports.getTextNodeContent = function (textNode) {
    return textNode.value;
};

exports.getCommentNodeContent = function (commentNode) {
    return commentNode.data;
};

exports.getDocumentTypeNodeName = function (doctypeNode) {
    return doctypeNode.name;
};

exports.getDocumentTypeNodePublicId = function (doctypeNode) {
    return doctypeNode.publicId;
};

exports.getDocumentTypeNodeSystemId = function (doctypeNode) {
    return doctypeNode.systemId;
};

//Node types
exports.isTextNode = function (node) {
    return node.nodeName === '#text';
};

exports.isCommentNode = function (node) {
    return node.nodeName === '#comment';
};

exports.isDocumentTypeNode = function (node) {
    return node.nodeName === '#documentType';
};

exports.isElementNode = function (node) {
    return !!node.tagName;
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isScheduler_1 = __webpack_require__(22);
var of_1 = __webpack_require__(77);
var from_1 = __webpack_require__(300);
var concatAll_1 = __webpack_require__(79);
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from given
 * Observable and then moves on to the next.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * `concat` joins multiple Observables together, by subscribing to them one at a time and
 * merging their results into the output Observable. You can pass either an array of
 * Observables, or put them directly as arguments. Passing an empty array will result
 * in Observable that completes immediately.
 *
 * `concat` will subscribe to first input Observable and emit all its values, without
 * changing or affecting them in any way. When that Observable completes, it will
 * subscribe to then next Observable passed and, again, emit its values. This will be
 * repeated, until the operator runs out of Observables. When last input Observable completes,
 * `concat` will complete as well. At any given moment only one Observable passed to operator
 * emits values. If you would like to emit values from passed Observables concurrently, check out
 * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
 * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
 *
 * Note that if some input Observable never completes, `concat` will also never complete
 * and Observables following the one that did not complete will never be subscribed. On the other
 * hand, if some Observable simply completes immediately after it is subscribed, it will be
 * invisible for `concat`, which will just move on to the next Observable.
 *
 * If any Observable in chain errors, instead of passing control to the next Observable,
 * `concat` will error immediately as well. Observables that would be subscribed after
 * the one that emitted error, never will.
 *
 * If you pass to `concat` the same Observable many times, its stream of values
 * will be "replayed" on every subscription, which means you can repeat given Observable
 * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
 * you can always use {@link repeat}.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = Rx.Observable.concat(timer, sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 *
 * @example <caption>Concatenate an array of 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 *
 * @example <caption>Concatenate the same Observable to repeat it</caption>
 * const timer = Rx.Observable.interval(1000).take(2);
 *
 * Rx.Observable.concat(timer, timer) // concating the same Observable!
 * .subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('...and it is done!')
 * );
 *
 * // Logs:
 * // 0 after 1s
 * // 1 after 2s
 * // 0 after 3s
 * // 1 after 4s
 * // "...and it is done!" also after 4s
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} input1 An input Observable to concatenate with others.
 * @param {ObservableInput} input2 An input Observable to concatenate with others.
 * More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @static true
 * @name concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {
        return from_1.from(observables[0]);
    }
    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
}
exports.concat = concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(3);

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(8);

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(89);

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(96);

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v4.3.6
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports, __webpack_require__(1), __webpack_require__(74), __webpack_require__(43), __webpack_require__(11), __webpack_require__(44), __webpack_require__(293), __webpack_require__(18), __webpack_require__(107), __webpack_require__(5), __webpack_require__(6), __webpack_require__(83), __webpack_require__(42), __webpack_require__(78), __webpack_require__(190)) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/platform-browser', '@angular/animations/browser', '@angular/common', '@angular/common/http', '@angular/compiler', '@angular/http', '@angular/platform-browser/animations', 'rxjs/Observable', 'rxjs/Subject', 'url', 'rxjs/operator/filter', 'rxjs/operator/first', 'rxjs/operator/toPromise'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.platformServer = global.ng.platformServer || {}),global.ng.core,global.ng.platformBrowser,global._angular_animations_browser,global.ng.common,global._angular_common_http,global.ng.compiler,global._angular_http,global._angular_platformBrowser_animations,global.Rx,global.Rx,global.url,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype));
}(this, (function (exports,_angular_core,_angular_platformBrowser,_angular_animations_browser,_angular_common,_angular_common_http,_angular_compiler,_angular_http,_angular_platformBrowser_animations,rxjs_Observable,rxjs_Subject,url,rxjs_operator_filter,rxjs_operator_first,rxjs_operator_toPromise) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * @license Angular v4.3.6
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var parse5 = __webpack_require__(32);
/**
 * Representation of the current platform state.
 *
 * \@experimental
 */
var PlatformState = (function () {
    /**
     * @param {?} _doc
     */
    function PlatformState(_doc) {
        this._doc = _doc;
    }
    /**
     * Renders the current state of the platform to string.
     * @return {?}
     */
    PlatformState.prototype.renderToString = function () { return _angular_platformBrowser.getDOM().getInnerHTML(this._doc); };
    /**
     * Returns the current DOM state.
     * @return {?}
     */
    PlatformState.prototype.getDocument = function () { return this._doc; };
    return PlatformState;
}());
PlatformState.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
PlatformState.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var xhr2 = __webpack_require__(289);
var isAbsoluteUrl = /^[a-zA-Z\-\+.]+:\/\//;
/**
 * @param {?} url
 * @return {?}
 */
function validateRequestUrl(url$$1) {
    if (!isAbsoluteUrl.test(url$$1)) {
        throw new Error("URLs requested via Http on the server must be absolute. URL: " + url$$1);
    }
}
var ServerXhr = (function () {
    function ServerXhr() {
    }
    /**
     * @return {?}
     */
    ServerXhr.prototype.build = function () { return new xhr2.XMLHttpRequest(); };
    return ServerXhr;
}());
ServerXhr.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
ServerXhr.ctorParameters = function () { return []; };
var ServerXsrfStrategy = (function () {
    function ServerXsrfStrategy() {
    }
    /**
     * @param {?} req
     * @return {?}
     */
    ServerXsrfStrategy.prototype.configureRequest = function (req) { };
    return ServerXsrfStrategy;
}());
ServerXsrfStrategy.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
ServerXsrfStrategy.ctorParameters = function () { return []; };
/**
 * @abstract
 */
var ZoneMacroTaskWrapper = (function () {
    function ZoneMacroTaskWrapper() {
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneMacroTaskWrapper.prototype.wrap = function (request) {
        var _this = this;
        return new rxjs_Observable.Observable(function (observer) {
            var /** @type {?} */ task = ((null));
            var /** @type {?} */ scheduled = false;
            var /** @type {?} */ sub = null;
            var /** @type {?} */ savedResult = null;
            var /** @type {?} */ savedError = null;
            var /** @type {?} */ scheduleTask = function (_task) {
                task = _task;
                scheduled = true;
                var /** @type {?} */ delegate = _this.delegate(request);
                sub = delegate.subscribe(function (res) { return savedResult = res; }, function (err) {
                    if (!scheduled) {
                        throw new Error('An http observable was completed twice. This shouldn\'t happen, please file a bug.');
                    }
                    savedError = err;
                    scheduled = false;
                    task.invoke();
                }, function () {
                    if (!scheduled) {
                        throw new Error('An http observable was completed twice. This shouldn\'t happen, please file a bug.');
                    }
                    scheduled = false;
                    task.invoke();
                });
            };
            var /** @type {?} */ cancelTask = function (_task) {
                if (!scheduled) {
                    return;
                }
                scheduled = false;
                if (sub) {
                    sub.unsubscribe();
                    sub = null;
                }
            };
            var /** @type {?} */ onComplete = function () {
                if (savedError !== null) {
                    observer.error(savedError);
                }
                else {
                    observer.next(savedResult);
                    observer.complete();
                }
            };
            // MockBackend for Http is synchronous, which means that if scheduleTask is by
            // scheduleMacroTask, the request will hit MockBackend and the response will be
            // sent, causing task.invoke() to be called.
            var /** @type {?} */ _task = Zone.current.scheduleMacroTask('ZoneMacroTaskWrapper.subscribe', onComplete, {}, function () { return null; }, cancelTask);
            scheduleTask(_task);
            return function () {
                if (scheduled && task) {
                    task.zone.cancelTask(task);
                    scheduled = false;
                }
                if (sub) {
                    sub.unsubscribe();
                    sub = null;
                }
            };
        });
    };
    /**
     * @abstract
     * @param {?} request
     * @return {?}
     */
    ZoneMacroTaskWrapper.prototype.delegate = function (request) { };
    return ZoneMacroTaskWrapper;
}());
var ZoneMacroTaskConnection = (function (_super) {
    __extends(ZoneMacroTaskConnection, _super);
    /**
     * @param {?} request
     * @param {?} backend
     */
    function ZoneMacroTaskConnection(request, backend) {
        var _this = _super.call(this) || this;
        _this.request = request;
        _this.backend = backend;
        validateRequestUrl(request.url);
        _this.response = _this.wrap(request);
        return _this;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneMacroTaskConnection.prototype.delegate = function (request) {
        this.lastConnection = this.backend.createConnection(request);
        return (this.lastConnection.response);
    };
    Object.defineProperty(ZoneMacroTaskConnection.prototype, "readyState", {
        /**
         * @return {?}
         */
        get: function () {
            return !!this.lastConnection ? this.lastConnection.readyState : _angular_http.ReadyState.Unsent;
        },
        enumerable: true,
        configurable: true
    });
    return ZoneMacroTaskConnection;
}(ZoneMacroTaskWrapper));
var ZoneMacroTaskBackend = (function () {
    /**
     * @param {?} backend
     */
    function ZoneMacroTaskBackend(backend) {
        this.backend = backend;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneMacroTaskBackend.prototype.createConnection = function (request) {
        return new ZoneMacroTaskConnection(request, this.backend);
    };
    return ZoneMacroTaskBackend;
}());
var ZoneClientBackend = (function (_super) {
    __extends(ZoneClientBackend, _super);
    /**
     * @param {?} backend
     */
    function ZoneClientBackend(backend) {
        var _this = _super.call(this) || this;
        _this.backend = backend;
        return _this;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneClientBackend.prototype.handle = function (request) { return this.wrap(request); };
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneClientBackend.prototype.delegate = function (request) {
        return this.backend.handle(request);
    };
    return ZoneClientBackend;
}(ZoneMacroTaskWrapper));
/**
 * @param {?} xhrBackend
 * @param {?} options
 * @return {?}
 */
function httpFactory(xhrBackend, options) {
    var /** @type {?} */ macroBackend = new ZoneMacroTaskBackend(xhrBackend);
    return new _angular_http.Http(macroBackend, options);
}
/**
 * @param {?} backend
 * @param {?} interceptors
 * @return {?}
 */
function zoneWrappedInterceptingHandler(backend, interceptors) {
    var /** @type {?} */ realBackend = _angular_common_http.interceptingHandler(backend, interceptors);
    return new ZoneClientBackend(realBackend);
}
var SERVER_HTTP_PROVIDERS = [
    { provide: _angular_http.Http, useFactory: httpFactory, deps: [_angular_http.XHRBackend, _angular_http.RequestOptions] },
    { provide: _angular_http.BrowserXhr, useClass: ServerXhr }, { provide: _angular_http.XSRFStrategy, useClass: ServerXsrfStrategy },
    { provide: _angular_common_http.XhrFactory, useClass: ServerXhr }, {
        provide: _angular_common_http.HttpHandler,
        useFactory: zoneWrappedInterceptingHandler,
        deps: [_angular_common_http.HttpBackend, [new _angular_core.Optional(), _angular_common_http.HTTP_INTERCEPTORS]]
    }
];
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * The DI token for setting the initial config for the platform.
 *
 * \@experimental
 */
var INITIAL_CONFIG = new _angular_core.InjectionToken('Server.INITIAL_CONFIG');
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} urlStr
 * @return {?}
 */
function parseUrl(urlStr) {
    var /** @type {?} */ parsedUrl = url.parse(urlStr);
    return {
        pathname: parsedUrl.pathname || '',
        search: parsedUrl.search || '',
        hash: parsedUrl.hash || '',
    };
}
/**
 * Server-side implementation of URL state. Implements `pathname`, `search`, and `hash`
 * but not the state stack.
 */
var ServerPlatformLocation = (function () {
    /**
     * @param {?} _doc
     * @param {?} _config
     */
    function ServerPlatformLocation(_doc, _config) {
        this._doc = _doc;
        this._path = '/';
        this._search = '';
        this._hash = '';
        this._hashUpdate = new rxjs_Subject.Subject();
        var config = _config;
        if (!!config && !!config.url) {
            var parsedUrl = parseUrl(config.url);
            this._path = parsedUrl.pathname;
            this._search = parsedUrl.search;
            this._hash = parsedUrl.hash;
        }
    }
    /**
     * @return {?}
     */
    ServerPlatformLocation.prototype.getBaseHrefFromDOM = function () { return ((_angular_platformBrowser.getDOM().getBaseHref(this._doc))); };
    /**
     * @param {?} fn
     * @return {?}
     */
    ServerPlatformLocation.prototype.onPopState = function (fn) {
        // No-op: a state stack is not implemented, so
        // no events will ever come.
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ServerPlatformLocation.prototype.onHashChange = function (fn) { this._hashUpdate.subscribe(fn); };
    Object.defineProperty(ServerPlatformLocation.prototype, "pathname", {
        /**
         * @return {?}
         */
        get: function () { return this._path; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServerPlatformLocation.prototype, "search", {
        /**
         * @return {?}
         */
        get: function () { return this._search; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServerPlatformLocation.prototype, "hash", {
        /**
         * @return {?}
         */
        get: function () { return this._hash; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServerPlatformLocation.prototype, "url", {
        /**
         * @return {?}
         */
        get: function () { return "" + this.pathname + this.search + this.hash; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @param {?} oldUrl
     * @return {?}
     */
    ServerPlatformLocation.prototype.setHash = function (value, oldUrl) {
        var _this = this;
        if (this._hash === value) {
            // Don't fire events if the hash has not changed.
            return;
        }
        this._hash = value;
        var /** @type {?} */ newUrl = this.url;
        scheduleMicroTask(function () { return _this._hashUpdate.next(/** @type {?} */ ({ type: 'hashchange', oldUrl: oldUrl, newUrl: newUrl })); });
    };
    /**
     * @param {?} state
     * @param {?} title
     * @param {?} newUrl
     * @return {?}
     */
    ServerPlatformLocation.prototype.replaceState = function (state, title, newUrl) {
        var /** @type {?} */ oldUrl = this.url;
        var /** @type {?} */ parsedUrl = parseUrl(newUrl);
        this._path = parsedUrl.pathname;
        this._search = parsedUrl.search;
        this.setHash(parsedUrl.hash, oldUrl);
    };
    /**
     * @param {?} state
     * @param {?} title
     * @param {?} newUrl
     * @return {?}
     */
    ServerPlatformLocation.prototype.pushState = function (state, title, newUrl) {
        this.replaceState(state, title, newUrl);
    };
    /**
     * @return {?}
     */
    ServerPlatformLocation.prototype.forward = function () { throw new Error('Not implemented'); };
    /**
     * @return {?}
     */
    ServerPlatformLocation.prototype.back = function () { throw new Error('Not implemented'); };
    return ServerPlatformLocation;
}());
ServerPlatformLocation.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
ServerPlatformLocation.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
    { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [INITIAL_CONFIG,] },] },
]; };
/**
 * @param {?} fn
 * @return {?}
 */
function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var parse5$1 = __webpack_require__(32);
var treeAdapter;
var _attrToPropMap = {
    'class': 'className',
    'innerHtml': 'innerHTML',
    'readonly': 'readOnly',
    'tabindex': 'tabIndex',
};
var mapProps = ['attribs', 'x-attribsNamespace', 'x-attribsPrefix'];
/**
 * @param {?} methodName
 * @return {?}
 */
function _notImplemented(methodName) {
    return new Error('This method is not implemented in Parse5DomAdapter: ' + methodName);
}
/**
 * @param {?} el
 * @param {?} name
 * @return {?}
 */
function _getElement(el, name) {
    for (var /** @type {?} */ i = 0; i < el.childNodes.length; i++) {
        var /** @type {?} */ node = el.childNodes[i];
        if (node.name === name) {
            return node;
        }
    }
    return null;
}
/**
 * Parses a document string to a Document object.
 * @param {?} html
 * @return {?}
 */
function parseDocument(html) {
    var /** @type {?} */ doc = parse5$1.parse(html, { treeAdapter: parse5$1.treeAdapters.htmlparser2 });
    var /** @type {?} */ docElement = _getElement(doc, 'html');
    doc['head'] = _getElement(docElement, 'head');
    doc['body'] = _getElement(docElement, 'body');
    doc['_window'] = {};
    return doc;
}
/**
 * A `DomAdapter` powered by the `parse5` NodeJS module.
 *
 * \@security Tread carefully! Interacting with the DOM directly is dangerous and
 * can introduce XSS risks.
 */
var Parse5DomAdapter = (function (_super) {
    __extends(Parse5DomAdapter, _super);
    function Parse5DomAdapter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @return {?}
     */
    Parse5DomAdapter.makeCurrent = function () {
        treeAdapter = parse5$1.treeAdapters.htmlparser2;
        _angular_platformBrowser.setRootDomAdapter(new Parse5DomAdapter());
    };
    /**
     * @param {?} nodeA
     * @param {?} nodeB
     * @return {?}
     */
    Parse5DomAdapter.prototype.contains = function (nodeA, nodeB) {
        var /** @type {?} */ inner = nodeB;
        while (inner) {
            if (inner === nodeA)
                return true;
            inner = inner.parent;
        }
        return false;
    };
    /**
     * @param {?} element
     * @param {?} name
     * @return {?}
     */
    Parse5DomAdapter.prototype.hasProperty = function (element, name) {
        return _HTMLElementPropertyList.indexOf(name) > -1;
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    Parse5DomAdapter.prototype.setProperty = function (el, name, value) {
        if (name === 'innerHTML') {
            this.setInnerHTML(el, value);
        }
        else if (name === 'innerText') {
            this.setText(el, value);
        }
        else if (name === 'className') {
            el.attribs['class'] = el.className = value;
        }
        else {
            // Store the property in a separate property bag so that it doesn't clobber
            // actual parse5 properties on the Element.
            el.properties = el.properties || {};
            el.properties[name] = value;
        }
    };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    Parse5DomAdapter.prototype.getProperty = function (el, name) {
        return el.properties ? el.properties[name] : undefined;
    };
    /**
     * @param {?} error
     * @return {?}
     */
    Parse5DomAdapter.prototype.logError = function (error) { console.error(error); };
    /**
     * @param {?} error
     * @return {?}
     */
    Parse5DomAdapter.prototype.log = function (error) { console.log(error); };
    /**
     * @param {?} error
     * @return {?}
     */
    Parse5DomAdapter.prototype.logGroup = function (error) { console.error(error); };
    /**
     * @return {?}
     */
    Parse5DomAdapter.prototype.logGroupEnd = function () { };
    Object.defineProperty(Parse5DomAdapter.prototype, "attrToPropMap", {
        /**
         * @return {?}
         */
        get: function () { return _attrToPropMap; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} el
     * @param {?} selector
     * @return {?}
     */
    Parse5DomAdapter.prototype.querySelector = function (el, selector) {
        return this.querySelectorAll(el, selector)[0] || null;
    };
    /**
     * @param {?} el
     * @param {?} selector
     * @return {?}
     */
    Parse5DomAdapter.prototype.querySelectorAll = function (el, selector) {
        var _this = this;
        var /** @type {?} */ res = [];
        var /** @type {?} */ _recursive = function (result, node, selector, matcher) {
            var /** @type {?} */ cNodes = node.childNodes;
            if (cNodes && cNodes.length > 0) {
                for (var /** @type {?} */ i = 0; i < cNodes.length; i++) {
                    var /** @type {?} */ childNode = cNodes[i];
                    if (_this.elementMatches(childNode, selector, matcher)) {
                        result.push(childNode);
                    }
                    _recursive(result, childNode, selector, matcher);
                }
            }
        };
        var /** @type {?} */ matcher = new _angular_compiler.SelectorMatcher();
        matcher.addSelectables(_angular_compiler.CssSelector.parse(selector));
        _recursive(res, el, selector, matcher);
        return res;
    };
    /**
     * @param {?} node
     * @param {?} selector
     * @param {?=} matcher
     * @return {?}
     */
    Parse5DomAdapter.prototype.elementMatches = function (node, selector, matcher) {
        if (matcher === void 0) { matcher = null; }
        if (this.isElementNode(node) && selector === '*') {
            return true;
        }
        var /** @type {?} */ result = false;
        if (selector && selector.charAt(0) == '#') {
            result = this.getAttribute(node, 'id') == selector.substring(1);
        }
        else if (selector) {
            if (!matcher) {
                matcher = new _angular_compiler.SelectorMatcher();
                matcher.addSelectables(_angular_compiler.CssSelector.parse(selector));
            }
            var /** @type {?} */ cssSelector = new _angular_compiler.CssSelector();
            cssSelector.setElement(this.tagName(node));
            if (node.attribs) {
                for (var /** @type {?} */ attrName in node.attribs) {
                    cssSelector.addAttribute(attrName, node.attribs[attrName]);
                }
            }
            var /** @type {?} */ classList = this.classList(node);
            for (var /** @type {?} */ i = 0; i < classList.length; i++) {
                cssSelector.addClassName(classList[i]);
            }
            matcher.match(cssSelector, function (selector, cb) { result = true; });
        }
        return result;
    };
    /**
     * @param {?} el
     * @param {?} evt
     * @param {?} listener
     * @return {?}
     */
    Parse5DomAdapter.prototype.on = function (el, evt, listener) {
        var /** @type {?} */ listenersMap = el._eventListenersMap;
        if (!listenersMap) {
            listenersMap = {};
            el._eventListenersMap = listenersMap;
        }
        var /** @type {?} */ listeners = listenersMap[evt] || [];
        listenersMap[evt] = listeners.concat([listener]);
    };
    /**
     * @param {?} el
     * @param {?} evt
     * @param {?} listener
     * @return {?}
     */
    Parse5DomAdapter.prototype.onAndCancel = function (el, evt, listener) {
        this.on(el, evt, listener);
        return function () { remove(/** @type {?} */ ((el._eventListenersMap[evt])), listener); };
    };
    /**
     * @param {?} el
     * @param {?} evt
     * @return {?}
     */
    Parse5DomAdapter.prototype.dispatchEvent = function (el, evt) {
        if (!evt.target) {
            evt.target = el;
        }
        if (el._eventListenersMap) {
            var /** @type {?} */ listeners = el._eventListenersMap[evt.type];
            if (listeners) {
                for (var /** @type {?} */ i = 0; i < listeners.length; i++) {
                    listeners[i](evt);
                }
            }
        }
        if (el.parent) {
            this.dispatchEvent(el.parent, evt);
        }
        if (el._window) {
            this.dispatchEvent(el._window, evt);
        }
    };
    /**
     * @param {?} eventType
     * @return {?}
     */
    Parse5DomAdapter.prototype.createMouseEvent = function (eventType) { return this.createEvent(eventType); };
    /**
     * @param {?} eventType
     * @return {?}
     */
    Parse5DomAdapter.prototype.createEvent = function (eventType) {
        var /** @type {?} */ event = ({
            type: eventType,
            defaultPrevented: false,
            preventDefault: function () { ((event)).defaultPrevented = true; }
        });
        return event;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    Parse5DomAdapter.prototype.preventDefault = function (event) { event.returnValue = false; };
    /**
     * @param {?} event
     * @return {?}
     */
    Parse5DomAdapter.prototype.isPrevented = function (event) { return event.returnValue != null && !event.returnValue; };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.getInnerHTML = function (el) {
        return parse5$1.serialize(this.templateAwareRoot(el), { treeAdapter: treeAdapter });
    };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.getTemplateContent = function (el) { return null; };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.getOuterHTML = function (el) {
        var /** @type {?} */ fragment = treeAdapter.createDocumentFragment();
        this.appendChild(fragment, el);
        return parse5$1.serialize(fragment, { treeAdapter: treeAdapter });
    };
    /**
     * @param {?} node
     * @return {?}
     */
    Parse5DomAdapter.prototype.nodeName = function (node) { return node.tagName; };
    /**
     * @param {?} node
     * @return {?}
     */
    Parse5DomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };
    /**
     * @param {?} node
     * @return {?}
     */
    Parse5DomAdapter.prototype.type = function (node) { throw _notImplemented('type'); };
    /**
     * @param {?} node
     * @return {?}
     */
    Parse5DomAdapter.prototype.content = function (node) { return node.childNodes[0]; };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.firstChild = function (el) { return el.firstChild; };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.nextSibling = function (el) { return el.nextSibling; };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.parentElement = function (el) { return el.parent; };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.childNodes = function (el) { return el.childNodes; };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.childNodesAsList = function (el) {
        var /** @type {?} */ childNodes = el.childNodes;
        var /** @type {?} */ res = new Array(childNodes.length);
        for (var /** @type {?} */ i = 0; i < childNodes.length; i++) {
            res[i] = childNodes[i];
        }
        return res;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.clearNodes = function (el) {
        while (el.childNodes.length > 0) {
            this.remove(el.childNodes[0]);
        }
    };
    /**
     * @param {?} el
     * @param {?} node
     * @return {?}
     */
    Parse5DomAdapter.prototype.appendChild = function (el, node) {
        this.remove(node);
        treeAdapter.appendChild(this.templateAwareRoot(el), node);
    };
    /**
     * @param {?} el
     * @param {?} node
     * @return {?}
     */
    Parse5DomAdapter.prototype.removeChild = function (el, node) {
        if (el.childNodes.indexOf(node) > -1) {
            this.remove(node);
        }
    };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.remove = function (el) {
        var /** @type {?} */ parent = el.parent;
        if (parent) {
            var /** @type {?} */ index = parent.childNodes.indexOf(el);
            parent.childNodes.splice(index, 1);
        }
        var /** @type {?} */ prev = el.previousSibling;
        var /** @type {?} */ next = el.nextSibling;
        if (prev) {
            prev.next = next;
        }
        if (next) {
            next.prev = prev;
        }
        el.prev = null;
        el.next = null;
        el.parent = null;
        return el;
    };
    /**
     * @param {?} parent
     * @param {?} ref
     * @param {?} newNode
     * @return {?}
     */
    Parse5DomAdapter.prototype.insertBefore = function (parent, ref, newNode) {
        this.remove(newNode);
        if (ref) {
            treeAdapter.insertBefore(parent, newNode, ref);
        }
        else {
            this.appendChild(parent, newNode);
        }
    };
    /**
     * @param {?} parent
     * @param {?} ref
     * @param {?} nodes
     * @return {?}
     */
    Parse5DomAdapter.prototype.insertAllBefore = function (parent, ref, nodes) {
        var _this = this;
        nodes.forEach(function (n) { return _this.insertBefore(parent, ref, n); });
    };
    /**
     * @param {?} parent
     * @param {?} ref
     * @param {?} node
     * @return {?}
     */
    Parse5DomAdapter.prototype.insertAfter = function (parent, ref, node) {
        if (ref.nextSibling) {
            this.insertBefore(parent, ref.nextSibling, node);
        }
        else {
            this.appendChild(parent, node);
        }
    };
    /**
     * @param {?} el
     * @param {?} value
     * @return {?}
     */
    Parse5DomAdapter.prototype.setInnerHTML = function (el, value) {
        this.clearNodes(el);
        var /** @type {?} */ content = parse5$1.parseFragment(value, { treeAdapter: treeAdapter });
        for (var /** @type {?} */ i = 0; i < content.childNodes.length; i++) {
            treeAdapter.appendChild(el, content.childNodes[i]);
        }
    };
    /**
     * @param {?} el
     * @param {?=} isRecursive
     * @return {?}
     */
    Parse5DomAdapter.prototype.getText = function (el, isRecursive) {
        if (this.isTextNode(el)) {
            return el.data;
        }
        if (this.isCommentNode(el)) {
            // In the DOM, comments within an element return an empty string for textContent
            // However, comment node instances return the comment content for textContent getter
            return isRecursive ? '' : el.data;
        }
        if (!el.childNodes || el.childNodes.length == 0) {
            return '';
        }
        var /** @type {?} */ textContent = '';
        for (var /** @type {?} */ i = 0; i < el.childNodes.length; i++) {
            textContent += this.getText(el.childNodes[i], true);
        }
        return textContent;
    };
    /**
     * @param {?} el
     * @param {?} value
     * @return {?}
     */
    Parse5DomAdapter.prototype.setText = function (el, value) {
        if (this.isTextNode(el) || this.isCommentNode(el)) {
            el.data = value;
        }
        else {
            this.clearNodes(el);
            if (value !== '')
                treeAdapter.insertText(el, value);
        }
    };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.getValue = function (el) { return el.value; };
    /**
     * @param {?} el
     * @param {?} value
     * @return {?}
     */
    Parse5DomAdapter.prototype.setValue = function (el, value) { el.value = value; };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.getChecked = function (el) { return el.checked; };
    /**
     * @param {?} el
     * @param {?} value
     * @return {?}
     */
    Parse5DomAdapter.prototype.setChecked = function (el, value) { el.checked = value; };
    /**
     * @param {?} text
     * @return {?}
     */
    Parse5DomAdapter.prototype.createComment = function (text) { return treeAdapter.createCommentNode(text); };
    /**
     * @param {?} html
     * @return {?}
     */
    Parse5DomAdapter.prototype.createTemplate = function (html) {
        var /** @type {?} */ template = treeAdapter.createElement('template', 'http://www.w3.org/1999/xhtml', []);
        var /** @type {?} */ content = parse5$1.parseFragment(html, { treeAdapter: treeAdapter });
        treeAdapter.setTemplateContent(template, content);
        return template;
    };
    /**
     * @param {?} tagName
     * @return {?}
     */
    Parse5DomAdapter.prototype.createElement = function (tagName) {
        return treeAdapter.createElement(tagName, 'http://www.w3.org/1999/xhtml', []);
    };
    /**
     * @param {?} ns
     * @param {?} tagName
     * @return {?}
     */
    Parse5DomAdapter.prototype.createElementNS = function (ns, tagName) {
        return treeAdapter.createElement(tagName, ns, []);
    };
    /**
     * @param {?} text
     * @return {?}
     */
    Parse5DomAdapter.prototype.createTextNode = function (text) {
        var /** @type {?} */ t = (this.createComment(text));
        t.type = 'text';
        return t;
    };
    /**
     * @param {?} attrName
     * @param {?} attrValue
     * @return {?}
     */
    Parse5DomAdapter.prototype.createScriptTag = function (attrName, attrValue) {
        return treeAdapter.createElement('script', 'http://www.w3.org/1999/xhtml', [{ name: attrName, value: attrValue }]);
    };
    /**
     * @param {?} css
     * @return {?}
     */
    Parse5DomAdapter.prototype.createStyleElement = function (css) {
        var /** @type {?} */ style = this.createElement('style');
        this.setText(style, css);
        return (style);
    };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.createShadowRoot = function (el) {
        el.shadowRoot = treeAdapter.createDocumentFragment();
        el.shadowRoot.parent = el;
        return el.shadowRoot;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.getShadowRoot = function (el) { return el.shadowRoot; };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.getHost = function (el) { return el.host; };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.getDistributedNodes = function (el) { throw _notImplemented('getDistributedNodes'); };
    /**
     * @param {?} node
     * @return {?}
     */
    Parse5DomAdapter.prototype.clone = function (node) {
        var /** @type {?} */ _recursive = function (node) {
            var /** @type {?} */ nodeClone = Object.create(Object.getPrototypeOf(node));
            for (var /** @type {?} */ prop in node) {
                var /** @type {?} */ desc = Object.getOwnPropertyDescriptor(node, prop);
                if (desc && 'value' in desc && typeof desc.value !== 'object') {
                    nodeClone[prop] = node[prop];
                }
            }
            nodeClone.parent = null;
            nodeClone.prev = null;
            nodeClone.next = null;
            nodeClone.children = null;
            mapProps.forEach(function (mapName) {
                if (node[mapName] != null) {
                    nodeClone[mapName] = {};
                    for (var /** @type {?} */ prop in node[mapName]) {
                        nodeClone[mapName][prop] = node[mapName][prop];
                    }
                }
            });
            var /** @type {?} */ cNodes = node.children;
            if (cNodes) {
                var /** @type {?} */ cNodesClone = new Array(cNodes.length);
                for (var /** @type {?} */ i = 0; i < cNodes.length; i++) {
                    var /** @type {?} */ childNode = cNodes[i];
                    var /** @type {?} */ childNodeClone = _recursive(childNode);
                    cNodesClone[i] = childNodeClone;
                    if (i > 0) {
                        childNodeClone.prev = cNodesClone[i - 1];
                        cNodesClone[i - 1].next = childNodeClone;
                    }
                    childNodeClone.parent = nodeClone;
                }
                nodeClone.children = cNodesClone;
            }
            return nodeClone;
        };
        return _recursive(node);
    };
    /**
     * @param {?} element
     * @param {?} name
     * @return {?}
     */
    Parse5DomAdapter.prototype.getElementsByClassName = function (element, name) {
        return this.querySelectorAll(element, '.' + name);
    };
    /**
     * @param {?} element
     * @param {?} name
     * @return {?}
     */
    Parse5DomAdapter.prototype.getElementsByTagName = function (element, name) {
        return this.querySelectorAll(element, name);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    Parse5DomAdapter.prototype.classList = function (element) {
        var /** @type {?} */ classAttrValue = null;
        var /** @type {?} */ attributes = element.attribs;
        if (attributes && attributes['class'] != null) {
            classAttrValue = attributes['class'];
        }
        return classAttrValue ? classAttrValue.trim().split(/\s+/g) : [];
    };
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    Parse5DomAdapter.prototype.addClass = function (element, className) {
        var /** @type {?} */ classList = this.classList(element);
        var /** @type {?} */ index = classList.indexOf(className);
        if (index == -1) {
            classList.push(className);
            element.attribs['class'] = element.className = classList.join(' ');
        }
    };
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    Parse5DomAdapter.prototype.removeClass = function (element, className) {
        var /** @type {?} */ classList = this.classList(element);
        var /** @type {?} */ index = classList.indexOf(className);
        if (index > -1) {
            classList.splice(index, 1);
            element.attribs['class'] = element.className = classList.join(' ');
        }
    };
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    Parse5DomAdapter.prototype.hasClass = function (element, className) {
        return this.classList(element).indexOf(className) > -1;
    };
    /**
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    Parse5DomAdapter.prototype.hasStyle = function (element, styleName, styleValue) {
        var /** @type {?} */ value = this.getStyle(element, styleName) || '';
        return styleValue ? value == styleValue : value.length > 0;
    };
    /**
     * \@internal
     * @param {?} element
     * @return {?}
     */
    Parse5DomAdapter.prototype._readStyleAttribute = function (element) {
        var /** @type {?} */ styleMap = {};
        var /** @type {?} */ attributes = element.attribs;
        if (attributes && attributes['style'] != null) {
            var /** @type {?} */ styleAttrValue = attributes['style'];
            var /** @type {?} */ styleList = styleAttrValue.split(/;+/g);
            for (var /** @type {?} */ i = 0; i < styleList.length; i++) {
                if (styleList[i].length > 0) {
                    var /** @type {?} */ style = (styleList[i]);
                    var /** @type {?} */ colon = style.indexOf(':');
                    if (colon === -1) {
                        throw new Error("Invalid CSS style: " + style);
                    }
                    ((styleMap))[style.substr(0, colon).trim()] = style.substr(colon + 1).trim();
                }
            }
        }
        return styleMap;
    };
    /**
     * \@internal
     * @param {?} element
     * @param {?} styleMap
     * @return {?}
     */
    Parse5DomAdapter.prototype._writeStyleAttribute = function (element, styleMap) {
        var /** @type {?} */ styleAttrValue = '';
        for (var /** @type {?} */ key in styleMap) {
            var /** @type {?} */ newValue = styleMap[key];
            if (newValue) {
                styleAttrValue += key + ':' + styleMap[key] + ';';
            }
        }
        element.attribs['style'] = styleAttrValue;
    };
    /**
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    Parse5DomAdapter.prototype.setStyle = function (element, styleName, styleValue) {
        var /** @type {?} */ styleMap = this._readStyleAttribute(element);
        ((styleMap))[styleName] = styleValue;
        this._writeStyleAttribute(element, styleMap);
    };
    /**
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    Parse5DomAdapter.prototype.removeStyle = function (element, styleName) { this.setStyle(element, styleName, null); };
    /**
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    Parse5DomAdapter.prototype.getStyle = function (element, styleName) {
        var /** @type {?} */ styleMap = this._readStyleAttribute(element);
        return styleMap.hasOwnProperty(styleName) ? ((styleMap))[styleName] : '';
    };
    /**
     * @param {?} element
     * @return {?}
     */
    Parse5DomAdapter.prototype.tagName = function (element) { return element.tagName == 'style' ? 'STYLE' : element.tagName; };
    /**
     * @param {?} element
     * @return {?}
     */
    Parse5DomAdapter.prototype.attributeMap = function (element) {
        var /** @type {?} */ res = new Map();
        var /** @type {?} */ elAttrs = treeAdapter.getAttrList(element);
        for (var /** @type {?} */ i = 0; i < elAttrs.length; i++) {
            var /** @type {?} */ attrib = elAttrs[i];
            res.set(attrib.name, attrib.value);
        }
        return res;
    };
    /**
     * @param {?} element
     * @param {?} attribute
     * @return {?}
     */
    Parse5DomAdapter.prototype.hasAttribute = function (element, attribute) {
        return element.attribs && element.attribs[attribute] != null;
    };
    /**
     * @param {?} element
     * @param {?} ns
     * @param {?} attribute
     * @return {?}
     */
    Parse5DomAdapter.prototype.hasAttributeNS = function (element, ns, attribute) {
        return this.hasAttribute(element, attribute);
    };
    /**
     * @param {?} element
     * @param {?} attribute
     * @return {?}
     */
    Parse5DomAdapter.prototype.getAttribute = function (element, attribute) {
        return this.hasAttribute(element, attribute) ? element.attribs[attribute] : null;
    };
    /**
     * @param {?} element
     * @param {?} ns
     * @param {?} attribute
     * @return {?}
     */
    Parse5DomAdapter.prototype.getAttributeNS = function (element, ns, attribute) {
        return this.getAttribute(element, attribute);
    };
    /**
     * @param {?} element
     * @param {?} attribute
     * @param {?} value
     * @return {?}
     */
    Parse5DomAdapter.prototype.setAttribute = function (element, attribute, value) {
        if (attribute) {
            element.attribs[attribute] = value;
            if (attribute === 'class') {
                element.className = value;
            }
        }
    };
    /**
     * @param {?} element
     * @param {?} ns
     * @param {?} attribute
     * @param {?} value
     * @return {?}
     */
    Parse5DomAdapter.prototype.setAttributeNS = function (element, ns, attribute, value) {
        this.setAttribute(element, attribute, value);
    };
    /**
     * @param {?} element
     * @param {?} attribute
     * @return {?}
     */
    Parse5DomAdapter.prototype.removeAttribute = function (element, attribute) {
        if (attribute) {
            delete element.attribs[attribute];
        }
    };
    /**
     * @param {?} element
     * @param {?} ns
     * @param {?} name
     * @return {?}
     */
    Parse5DomAdapter.prototype.removeAttributeNS = function (element, ns, name) { throw 'not implemented'; };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.templateAwareRoot = function (el) {
        return this.isTemplateElement(el) ? treeAdapter.getTemplateContent(el) : el;
    };
    /**
     * @return {?}
     */
    Parse5DomAdapter.prototype.createHtmlDocument = function () {
        var /** @type {?} */ newDoc = treeAdapter.createDocument();
        newDoc.title = 'fakeTitle';
        var /** @type {?} */ head = treeAdapter.createElement('head', null, []);
        var /** @type {?} */ body = treeAdapter.createElement('body', 'http://www.w3.org/1999/xhtml', []);
        this.appendChild(newDoc, head);
        this.appendChild(newDoc, body);
        newDoc['head'] = head;
        newDoc['body'] = body;
        newDoc['_window'] = {};
        return newDoc;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.getBoundingClientRect = function (el) { return { left: 0, top: 0, width: 0, height: 0 }; };
    /**
     * @param {?} doc
     * @return {?}
     */
    Parse5DomAdapter.prototype.getTitle = function (doc) { return this.getText(this.getTitleNode(doc)) || ''; };
    /**
     * @param {?} doc
     * @param {?} newTitle
     * @return {?}
     */
    Parse5DomAdapter.prototype.setTitle = function (doc, newTitle) {
        this.setText(this.getTitleNode(doc), newTitle || '');
    };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.isTemplateElement = function (el) {
        return this.isElementNode(el) && this.tagName(el) === 'template';
    };
    /**
     * @param {?} node
     * @return {?}
     */
    Parse5DomAdapter.prototype.isTextNode = function (node) { return treeAdapter.isTextNode(node); };
    /**
     * @param {?} node
     * @return {?}
     */
    Parse5DomAdapter.prototype.isCommentNode = function (node) { return treeAdapter.isCommentNode(node); };
    /**
     * @param {?} node
     * @return {?}
     */
    Parse5DomAdapter.prototype.isElementNode = function (node) { return node ? treeAdapter.isElementNode(node) : false; };
    /**
     * @param {?} node
     * @return {?}
     */
    Parse5DomAdapter.prototype.hasShadowRoot = function (node) { return node.shadowRoot != null; };
    /**
     * @param {?} node
     * @return {?}
     */
    Parse5DomAdapter.prototype.isShadowRoot = function (node) { return this.getShadowRoot(node) == node; };
    /**
     * @param {?} node
     * @return {?}
     */
    Parse5DomAdapter.prototype.importIntoDoc = function (node) { return this.clone(node); };
    /**
     * @param {?} node
     * @return {?}
     */
    Parse5DomAdapter.prototype.adoptNode = function (node) { return node; };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.getHref = function (el) { return this.getAttribute(el, 'href'); };
    /**
     * @param {?} el
     * @param {?} baseUrl
     * @param {?} href
     * @return {?}
     */
    Parse5DomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {
        if (href == null) {
            el.href = baseUrl;
        }
        else {
            el.href = baseUrl + '/../' + href;
        }
    };
    /**
     * \@internal
     * @param {?} parsedRules
     * @param {?=} css
     * @return {?}
     */
    Parse5DomAdapter.prototype._buildRules = function (parsedRules, css) {
        var /** @type {?} */ rules = [];
        for (var /** @type {?} */ i = 0; i < parsedRules.length; i++) {
            var /** @type {?} */ parsedRule = parsedRules[i];
            var /** @type {?} */ rule = {};
            rule['cssText'] = css;
            rule['style'] = { content: '', cssText: '' };
            if (parsedRule.type == 'rule') {
                rule['type'] = 1;
                rule['selectorText'] =
                    parsedRule.selectors.join(', '.replace(/\s{2,}/g, ' ')
                        .replace(/\s*~\s*/g, ' ~ ')
                        .replace(/\s*\+\s*/g, ' + ')
                        .replace(/\s*>\s*/g, ' > ')
                        .replace(/\[(\w+)=(\w+)\]/g, '[$1="$2"]'));
                if (parsedRule.declarations == null) {
                    continue;
                }
                for (var /** @type {?} */ j = 0; j < parsedRule.declarations.length; j++) {
                    var /** @type {?} */ declaration = parsedRule.declarations[j];
                    rule['style'] = declaration.property[declaration.value];
                    rule['style'].cssText += declaration.property + ': ' + declaration.value + ';';
                }
            }
            else if (parsedRule.type == 'media') {
                rule['type'] = 4;
                rule['media'] = { mediaText: parsedRule.media };
                if (parsedRule.rules) {
                    rule['cssRules'] = this._buildRules(parsedRule.rules);
                }
            }
            rules.push(rule);
        }
        return rules;
    };
    /**
     * @return {?}
     */
    Parse5DomAdapter.prototype.supportsDOMEvents = function () { return false; };
    /**
     * @return {?}
     */
    Parse5DomAdapter.prototype.supportsNativeShadowDOM = function () { return false; };
    /**
     * @param {?} doc
     * @param {?} target
     * @return {?}
     */
    Parse5DomAdapter.prototype.getGlobalEventTarget = function (doc, target) {
        if (target == 'window') {
            return ((doc))._window;
        }
        else if (target == 'document') {
            return doc;
        }
        else if (target == 'body') {
            return doc.body;
        }
    };
    /**
     * @param {?} doc
     * @return {?}
     */
    Parse5DomAdapter.prototype.getBaseHref = function (doc) {
        var /** @type {?} */ base = this.querySelector(doc, 'base');
        var /** @type {?} */ href = '';
        if (base) {
            href = this.getHref(base);
        }
        // TODO(alxhub): Need relative path logic from BrowserDomAdapter here?
        return href == null ? null : href;
    };
    /**
     * @return {?}
     */
    Parse5DomAdapter.prototype.resetBaseElement = function () { throw 'not implemented'; };
    /**
     * @return {?}
     */
    Parse5DomAdapter.prototype.getHistory = function () { throw 'not implemented'; };
    /**
     * @return {?}
     */
    Parse5DomAdapter.prototype.getLocation = function () { throw 'not implemented'; };
    /**
     * @return {?}
     */
    Parse5DomAdapter.prototype.getUserAgent = function () { return 'Fake user agent'; };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    Parse5DomAdapter.prototype.getData = function (el, name) { return this.getAttribute(el, 'data-' + name); };
    /**
     * @param {?} el
     * @return {?}
     */
    Parse5DomAdapter.prototype.getComputedStyle = function (el) { throw 'not implemented'; };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    Parse5DomAdapter.prototype.setData = function (el, name, value) { this.setAttribute(el, 'data-' + name, value); };
    /**
     * @return {?}
     */
    Parse5DomAdapter.prototype.supportsWebAnimation = function () { return false; };
    /**
     * @return {?}
     */
    Parse5DomAdapter.prototype.performanceNow = function () { return Date.now(); };
    /**
     * @return {?}
     */
    Parse5DomAdapter.prototype.getAnimationPrefix = function () { return ''; };
    /**
     * @return {?}
     */
    Parse5DomAdapter.prototype.getTransitionEnd = function () { return 'transitionend'; };
    /**
     * @return {?}
     */
    Parse5DomAdapter.prototype.supportsAnimation = function () { return true; };
    /**
     * @param {?} el
     * @param {?} newNode
     * @param {?} oldNode
     * @return {?}
     */
    Parse5DomAdapter.prototype.replaceChild = function (el, newNode, oldNode) { throw new Error('not implemented'); };
    /**
     * @param {?} templateHtml
     * @return {?}
     */
    Parse5DomAdapter.prototype.parse = function (templateHtml) { throw new Error('not implemented'); };
    /**
     * @param {?} el
     * @param {?} methodName
     * @param {?} args
     * @return {?}
     */
    Parse5DomAdapter.prototype.invoke = function (el, methodName, args) { throw new Error('not implemented'); };
    /**
     * @param {?} event
     * @return {?}
     */
    Parse5DomAdapter.prototype.getEventKey = function (event) { throw new Error('not implemented'); };
    /**
     * @return {?}
     */
    Parse5DomAdapter.prototype.supportsCookies = function () { return false; };
    /**
     * @param {?} name
     * @return {?}
     */
    Parse5DomAdapter.prototype.getCookie = function (name) { throw new Error('not implemented'); };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    Parse5DomAdapter.prototype.setCookie = function (name, value) { throw new Error('not implemented'); };
    /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} options
     * @return {?}
     */
    Parse5DomAdapter.prototype.animate = function (element, keyframes, options) { throw new Error('not implemented'); };
    /**
     * @param {?} doc
     * @return {?}
     */
    Parse5DomAdapter.prototype.getTitleNode = function (doc) {
        var /** @type {?} */ title = this.querySelector(doc, 'title');
        if (!title) {
            title = (this.createElement('title'));
            this.appendChild(this.querySelector(doc, 'head'), title);
        }
        return title;
    };
    return Parse5DomAdapter;
}(_angular_platformBrowser.DomAdapter));
// TODO: build a proper list, this one is all the keys of a HTMLInputElement
var _HTMLElementPropertyList = [
    'webkitEntries',
    'incremental',
    'webkitdirectory',
    'selectionDirection',
    'selectionEnd',
    'selectionStart',
    'labels',
    'validationMessage',
    'validity',
    'willValidate',
    'width',
    'valueAsNumber',
    'valueAsDate',
    'value',
    'useMap',
    'defaultValue',
    'type',
    'step',
    'src',
    'size',
    'required',
    'readOnly',
    'placeholder',
    'pattern',
    'name',
    'multiple',
    'min',
    'minLength',
    'maxLength',
    'max',
    'list',
    'indeterminate',
    'height',
    'formTarget',
    'formNoValidate',
    'formMethod',
    'formEnctype',
    'formAction',
    'files',
    'form',
    'disabled',
    'dirName',
    'checked',
    'defaultChecked',
    'autofocus',
    'autocomplete',
    'alt',
    'align',
    'accept',
    'onautocompleteerror',
    'onautocomplete',
    'onwaiting',
    'onvolumechange',
    'ontoggle',
    'ontimeupdate',
    'onsuspend',
    'onsubmit',
    'onstalled',
    'onshow',
    'onselect',
    'onseeking',
    'onseeked',
    'onscroll',
    'onresize',
    'onreset',
    'onratechange',
    'onprogress',
    'onplaying',
    'onplay',
    'onpause',
    'onmousewheel',
    'onmouseup',
    'onmouseover',
    'onmouseout',
    'onmousemove',
    'onmouseleave',
    'onmouseenter',
    'onmousedown',
    'onloadstart',
    'onloadedmetadata',
    'onloadeddata',
    'onload',
    'onkeyup',
    'onkeypress',
    'onkeydown',
    'oninvalid',
    'oninput',
    'onfocus',
    'onerror',
    'onended',
    'onemptied',
    'ondurationchange',
    'ondrop',
    'ondragstart',
    'ondragover',
    'ondragleave',
    'ondragenter',
    'ondragend',
    'ondrag',
    'ondblclick',
    'oncuechange',
    'oncontextmenu',
    'onclose',
    'onclick',
    'onchange',
    'oncanplaythrough',
    'oncanplay',
    'oncancel',
    'onblur',
    'onabort',
    'spellcheck',
    'isContentEditable',
    'contentEditable',
    'outerText',
    'innerText',
    'accessKey',
    'hidden',
    'webkitdropzone',
    'draggable',
    'tabIndex',
    'dir',
    'translate',
    'lang',
    'title',
    'childElementCount',
    'lastElementChild',
    'firstElementChild',
    'children',
    'onwebkitfullscreenerror',
    'onwebkitfullscreenchange',
    'nextElementSibling',
    'previousElementSibling',
    'onwheel',
    'onselectstart',
    'onsearch',
    'onpaste',
    'oncut',
    'oncopy',
    'onbeforepaste',
    'onbeforecut',
    'onbeforecopy',
    'shadowRoot',
    'dataset',
    'classList',
    'className',
    'outerHTML',
    'innerHTML',
    'scrollHeight',
    'scrollWidth',
    'scrollTop',
    'scrollLeft',
    'clientHeight',
    'clientWidth',
    'clientTop',
    'clientLeft',
    'offsetParent',
    'offsetHeight',
    'offsetWidth',
    'offsetTop',
    'offsetLeft',
    'localName',
    'prefix',
    'namespaceURI',
    'id',
    'style',
    'attributes',
    'tagName',
    'parentElement',
    'textContent',
    'baseURI',
    'ownerDocument',
    'nextSibling',
    'previousSibling',
    'lastChild',
    'firstChild',
    'childNodes',
    'parentNode',
    'nodeType',
    'nodeValue',
    'nodeName',
    'closure_lm_714617',
    '__jsaction',
];
/**
 * @template T
 * @param {?} list
 * @param {?} el
 * @return {?}
 */
function remove(list, el) {
    var /** @type {?} */ index = list.indexOf(el);
    if (index > -1) {
        list.splice(index, 1);
    }
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var EMPTY_ARRAY = [];
var ServerRendererFactory2 = (function () {
    /**
     * @param {?} ngZone
     * @param {?} document
     * @param {?} sharedStylesHost
     */
    function ServerRendererFactory2(ngZone, document, sharedStylesHost) {
        this.ngZone = ngZone;
        this.document = document;
        this.sharedStylesHost = sharedStylesHost;
        this.rendererByCompId = new Map();
        this.schema = new _angular_compiler.DomElementSchemaRegistry();
        this.defaultRenderer = new DefaultServerRenderer2(document, ngZone, this.schema);
    }
    
    /**
     * @param {?} element
     * @param {?} type
     * @return {?}
     */
    ServerRendererFactory2.prototype.createRenderer = function (element, type) {
        if (!element || !type) {
            return this.defaultRenderer;
        }
        switch (type.encapsulation) {
            case _angular_core.ViewEncapsulation.Native:
            case _angular_core.ViewEncapsulation.Emulated: {
                var /** @type {?} */ renderer = this.rendererByCompId.get(type.id);
                if (!renderer) {
                    renderer = new EmulatedEncapsulationServerRenderer2(this.document, this.ngZone, this.sharedStylesHost, this.schema, type);
                    this.rendererByCompId.set(type.id, renderer);
                }
                ((renderer)).applyToHost(element);
                return renderer;
            }
            case _angular_core.ViewEncapsulation.Native:
                throw new Error('Native encapsulation is not supported on the server!');
            default: {
                if (!this.rendererByCompId.has(type.id)) {
                    var /** @type {?} */ styles = _angular_platformBrowser.flattenStyles(type.id, type.styles, []);
                    this.sharedStylesHost.addStyles(styles);
                    this.rendererByCompId.set(type.id, this.defaultRenderer);
                }
                return this.defaultRenderer;
            }
        }
    };
    /**
     * @return {?}
     */
    ServerRendererFactory2.prototype.begin = function () { };
    /**
     * @return {?}
     */
    ServerRendererFactory2.prototype.end = function () { };
    return ServerRendererFactory2;
}());
ServerRendererFactory2.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
ServerRendererFactory2.ctorParameters = function () { return [
    { type: _angular_core.NgZone, },
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
    { type: _angular_platformBrowser.SharedStylesHost, },
]; };
var DefaultServerRenderer2 = (function () {
    /**
     * @param {?} document
     * @param {?} ngZone
     * @param {?} schema
     */
    function DefaultServerRenderer2(document, ngZone, schema) {
        this.document = document;
        this.ngZone = ngZone;
        this.schema = schema;
        this.data = Object.create(null);
    }
    /**
     * @return {?}
     */
    DefaultServerRenderer2.prototype.destroy = function () { };
    /**
     * @param {?} name
     * @param {?=} namespace
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.createElement = function (name, namespace, debugInfo) {
        if (namespace) {
            return _angular_platformBrowser.getDOM().createElementNS(_angular_platformBrowser.NAMESPACE_URIS[namespace], name);
        }
        return _angular_platformBrowser.getDOM().createElement(name);
    };
    /**
     * @param {?} value
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.createComment = function (value, debugInfo) { return _angular_platformBrowser.getDOM().createComment(value); };
    /**
     * @param {?} value
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.createText = function (value, debugInfo) { return _angular_platformBrowser.getDOM().createTextNode(value); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    DefaultServerRenderer2.prototype.appendChild = function (parent, newChild) { _angular_platformBrowser.getDOM().appendChild(parent, newChild); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    DefaultServerRenderer2.prototype.insertBefore = function (parent, newChild, refChild) {
        if (parent) {
            _angular_platformBrowser.getDOM().insertBefore(parent, refChild, newChild);
        }
    };
    /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeChild = function (parent, oldChild) {
        if (parent) {
            _angular_platformBrowser.getDOM().removeChild(parent, oldChild);
        }
    };
    /**
     * @param {?} selectorOrNode
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
        var /** @type {?} */ el;
        if (typeof selectorOrNode === 'string') {
            el = _angular_platformBrowser.getDOM().querySelector(this.document, selectorOrNode);
            if (!el) {
                throw new Error("The selector \"" + selectorOrNode + "\" did not match any elements");
            }
        }
        else {
            el = selectorOrNode;
        }
        _angular_platformBrowser.getDOM().clearNodes(el);
        return el;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    DefaultServerRenderer2.prototype.parentNode = function (node) { return _angular_platformBrowser.getDOM().parentElement(node); };
    /**
     * @param {?} node
     * @return {?}
     */
    DefaultServerRenderer2.prototype.nextSibling = function (node) { return _angular_platformBrowser.getDOM().nextSibling(node); };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setAttribute = function (el, name, value, namespace) {
        if (namespace) {
            _angular_platformBrowser.getDOM().setAttributeNS(el, _angular_platformBrowser.NAMESPACE_URIS[namespace], namespace + ':' + name, value);
        }
        else {
            _angular_platformBrowser.getDOM().setAttribute(el, name, value);
        }
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeAttribute = function (el, name, namespace) {
        if (namespace) {
            _angular_platformBrowser.getDOM().removeAttributeNS(el, _angular_platformBrowser.NAMESPACE_URIS[namespace], name);
        }
        else {
            _angular_platformBrowser.getDOM().removeAttribute(el, name);
        }
    };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    DefaultServerRenderer2.prototype.addClass = function (el, name) { _angular_platformBrowser.getDOM().addClass(el, name); };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeClass = function (el, name) { _angular_platformBrowser.getDOM().removeClass(el, name); };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?} flags
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setStyle = function (el, style, value, flags) {
        _angular_platformBrowser.getDOM().setStyle(el, style, value);
    };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} flags
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeStyle = function (el, style, flags) {
        _angular_platformBrowser.getDOM().removeStyle(el, style);
    };
    /**
     * @param {?} tagName
     * @param {?} propertyName
     * @return {?}
     */
    DefaultServerRenderer2.prototype._isSafeToReflectProperty = function (tagName, propertyName) {
        return this.schema.securityContext(tagName, propertyName, true) ===
            this.schema.securityContext(tagName, propertyName, false);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setProperty = function (el, name, value) {
        checkNoSyntheticProp(name, 'property');
        _angular_platformBrowser.getDOM().setProperty(el, name, value);
        // Mirror property values for known HTML element properties in the attributes.
        var /** @type {?} */ tagName = ((el.tagName)).toLowerCase();
        if (value != null && (typeof value === 'number' || typeof value == 'string') &&
            this.schema.hasElement(tagName, EMPTY_ARRAY) &&
            this.schema.hasProperty(tagName, name, EMPTY_ARRAY) &&
            this._isSafeToReflectProperty(tagName, name)) {
            this.setAttribute(el, name, value.toString());
        }
    };
    /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setValue = function (node, value) { _angular_platformBrowser.getDOM().setText(node, value); };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    DefaultServerRenderer2.prototype.listen = function (target, eventName, callback) {
        var _this = this;
        // Note: We are not using the EventsPlugin here as this is not needed
        // to run our tests.
        checkNoSyntheticProp(eventName, 'listener');
        var /** @type {?} */ el = typeof target === 'string' ? _angular_platformBrowser.getDOM().getGlobalEventTarget(this.document, target) : target;
        var /** @type {?} */ outsideHandler = function (event) { return _this.ngZone.runGuarded(function () { return callback(event); }); };
        return this.ngZone.runOutsideAngular(function () { return _angular_platformBrowser.getDOM().onAndCancel(el, eventName, outsideHandler); });
    };
    return DefaultServerRenderer2;
}());
var AT_CHARCODE = '@'.charCodeAt(0);
/**
 * @param {?} name
 * @param {?} nameKind
 * @return {?}
 */
function checkNoSyntheticProp(name, nameKind) {
    if (name.charCodeAt(0) === AT_CHARCODE) {
        throw new Error("Found the synthetic " + nameKind + " " + name + ". Please include either \"BrowserAnimationsModule\" or \"NoopAnimationsModule\" in your application.");
    }
}
var EmulatedEncapsulationServerRenderer2 = (function (_super) {
    __extends(EmulatedEncapsulationServerRenderer2, _super);
    /**
     * @param {?} document
     * @param {?} ngZone
     * @param {?} sharedStylesHost
     * @param {?} schema
     * @param {?} component
     */
    function EmulatedEncapsulationServerRenderer2(document, ngZone, sharedStylesHost, schema, component) {
        var _this = _super.call(this, document, ngZone, schema) || this;
        _this.component = component;
        var styles = _angular_platformBrowser.flattenStyles(component.id, component.styles, []);
        sharedStylesHost.addStyles(styles);
        _this.contentAttr = _angular_platformBrowser.shimContentAttribute(component.id);
        _this.hostAttr = _angular_platformBrowser.shimHostAttribute(component.id);
        return _this;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    EmulatedEncapsulationServerRenderer2.prototype.applyToHost = function (element) { _super.prototype.setAttribute.call(this, element, this.hostAttr, ''); };
    /**
     * @param {?} parent
     * @param {?} name
     * @return {?}
     */
    EmulatedEncapsulationServerRenderer2.prototype.createElement = function (parent, name) {
        var /** @type {?} */ el = _super.prototype.createElement.call(this, parent, name);
        _super.prototype.setAttribute.call(this, el, this.contentAttr, '');
        return el;
    };
    return EmulatedEncapsulationServerRenderer2;
}(DefaultServerRenderer2));
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ServerStylesHost = (function (_super) {
    __extends(ServerStylesHost, _super);
    /**
     * @param {?} doc
     * @param {?} transitionId
     */
    function ServerStylesHost(doc, transitionId) {
        var _this = _super.call(this) || this;
        _this.doc = doc;
        _this.transitionId = transitionId;
        _this.head = null;
        _this.head = _angular_platformBrowser.getDOM().getElementsByTagName(doc, 'head')[0];
        return _this;
    }
    /**
     * @param {?} style
     * @return {?}
     */
    ServerStylesHost.prototype._addStyle = function (style) {
        var /** @type {?} */ adapter = (_angular_platformBrowser.getDOM());
        var /** @type {?} */ el = adapter.createElement('style');
        adapter.setText(el, style);
        if (!!this.transitionId) {
            adapter.setAttribute(el, 'ng-transition', this.transitionId);
        }
        adapter.appendChild(this.head, el);
    };
    /**
     * @param {?} additions
     * @return {?}
     */
    ServerStylesHost.prototype.onStylesAdded = function (additions) {
        var _this = this;
        additions.forEach(function (style) { return _this._addStyle(style); });
    };
    return ServerStylesHost;
}(_angular_platformBrowser.SharedStylesHost));
ServerStylesHost.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
ServerStylesHost.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
    { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [_angular_platformBrowser.TRANSITION_ID,] },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var INTERNAL_SERVER_PLATFORM_PROVIDERS = [
    { provide: _angular_platformBrowser.DOCUMENT, useFactory: _document, deps: [_angular_core.Injector] },
    { provide: _angular_core.PLATFORM_ID, useValue: _angular_common.PLATFORM_SERVER_ID },
    { provide: _angular_core.PLATFORM_INITIALIZER, useFactory: initParse5Adapter, multi: true, deps: [_angular_core.Injector] },
    { provide: _angular_common.PlatformLocation, useClass: ServerPlatformLocation }, PlatformState,
    // Add special provider that allows multiple instances of platformServer* to be created.
    { provide: _angular_core.ALLOW_MULTIPLE_PLATFORMS, useValue: true }
];
/**
 * @param {?} injector
 * @return {?}
 */
function initParse5Adapter(injector) {
    return function () { Parse5DomAdapter.makeCurrent(); };
}
/**
 * @param {?} renderer
 * @param {?} engine
 * @param {?} zone
 * @return {?}
 */
function instantiateServerRendererFactory(renderer, engine, zone) {
    return new _angular_platformBrowser_animations.AnimationRendererFactory(renderer, engine, zone);
}
var SERVER_RENDER_PROVIDERS = [
    ServerRendererFactory2,
    {
        provide: _angular_core.RendererFactory2,
        useFactory: instantiateServerRendererFactory,
        deps: [ServerRendererFactory2, _angular_animations_browser.AnimationEngine, _angular_core.NgZone]
    },
    ServerStylesHost,
    { provide: _angular_platformBrowser.SharedStylesHost, useExisting: ServerStylesHost },
];
/**
 * The ng module for the server.
 *
 * \@experimental
 */
var ServerModule = (function () {
    function ServerModule() {
    }
    return ServerModule;
}());
ServerModule.decorators = [
    { type: _angular_core.NgModule, args: [{
                exports: [_angular_platformBrowser.BrowserModule],
                imports: [_angular_http.HttpModule, _angular_common_http.HttpClientModule, _angular_platformBrowser_animations.NoopAnimationsModule],
                providers: [
                    SERVER_RENDER_PROVIDERS,
                    SERVER_HTTP_PROVIDERS,
                    { provide: _angular_core.Testability, useValue: null },
                ],
            },] },
];
/**
 * @nocollapse
 */
ServerModule.ctorParameters = function () { return []; };
/**
 * @param {?} injector
 * @return {?}
 */
function _document(injector) {
    var /** @type {?} */ config = injector.get(INITIAL_CONFIG, null);
    if (config && config.document) {
        return parseDocument(config.document);
    }
    else {
        return _angular_platformBrowser.getDOM().createHtmlDocument();
    }
}
/**
 * \@experimental
 */
var platformServer = _angular_core.createPlatformFactory(_angular_core.platformCore, 'server', INTERNAL_SERVER_PLATFORM_PROVIDERS);
/**
 * The server platform that supports the runtime compiler.
 *
 * \@experimental
 */
var platformDynamicServer = _angular_core.createPlatformFactory(_angular_compiler.platformCoreDynamic, 'serverDynamic', INTERNAL_SERVER_PLATFORM_PROVIDERS);
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var parse5$2 = __webpack_require__(32);
/**
 * @param {?} platformFactory
 * @param {?} options
 * @return {?}
 */
function _getPlatform(platformFactory, options) {
    var /** @type {?} */ extraProviders = options.extraProviders ? options.extraProviders : [];
    return platformFactory([
        { provide: INITIAL_CONFIG, useValue: { document: options.document, url: options.url } },
        extraProviders
    ]);
}
/**
 * @template T
 * @param {?} platform
 * @param {?} moduleRefPromise
 * @return {?}
 */
function _render(platform, moduleRefPromise) {
    return moduleRefPromise.then(function (moduleRef) {
        var /** @type {?} */ transitionId = moduleRef.injector.get(_angular_platformBrowser.TRANSITION_ID, null);
        if (!transitionId) {
            throw new Error("renderModule[Factory]() requires the use of BrowserModule.withServerTransition() to ensure\nthe server-rendered app can be properly bootstrapped into a client app.");
        }
        var /** @type {?} */ applicationRef = moduleRef.injector.get(_angular_core.ApplicationRef);
        return rxjs_operator_toPromise.toPromise
            .call(rxjs_operator_first.first.call(rxjs_operator_filter.filter.call(applicationRef.isStable, function (isStable) { return isStable; })))
            .then(function () {
            var /** @type {?} */ output = platform.injector.get(PlatformState).renderToString();
            platform.destroy();
            return output;
        });
    });
}
/**
 * Renders a Module to string.
 *
 * `document` is the full document HTML of the page to render, as a string.
 * `url` is the URL for the current render request.
 * `extraProviders` are the platform level providers for the current render request.
 *
 * Do not use this in a production server environment. Use pre-compiled {\@link NgModuleFactory} with
 * {\@link renderModuleFactory} instead.
 *
 * \@experimental
 * @template T
 * @param {?} module
 * @param {?} options
 * @return {?}
 */
function renderModule(module, options) {
    var /** @type {?} */ platform = _getPlatform(platformDynamicServer, options);
    return _render(platform, platform.bootstrapModule(module));
}
/**
 * Renders a {\@link NgModuleFactory} to string.
 *
 * `document` is the full document HTML of the page to render, as a string.
 * `url` is the URL for the current render request.
 * `extraProviders` are the platform level providers for the current render request.
 *
 * \@experimental
 * @template T
 * @param {?} moduleFactory
 * @param {?} options
 * @return {?}
 */
function renderModuleFactory(moduleFactory, options) {
    var /** @type {?} */ platform = _getPlatform(platformServer, options);
    return _render(platform, platform.bootstrapModuleFactory(moduleFactory));
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the common package.
 */
/**
 * \@stable
 */
var VERSION = new _angular_core.Version('4.3.6');

exports.PlatformState = PlatformState;
exports.ServerModule = ServerModule;
exports.platformDynamicServer = platformDynamicServer;
exports.platformServer = platformServer;
exports.INITIAL_CONFIG = INITIAL_CONFIG;
exports.renderModule = renderModule;
exports.renderModuleFactory = renderModuleFactory;
exports.VERSION = VERSION;
exports.INTERNAL_SERVER_PLATFORM_PROVIDERS = INTERNAL_SERVER_PLATFORM_PROVIDERS;
exports.SERVER_RENDER_PROVIDERS = SERVER_RENDER_PROVIDERS;
exports.ServerRendererFactory2 = ServerRendererFactory2;
exports.g = SERVER_HTTP_PROVIDERS;
exports.c = ServerXhr;
exports.d = ServerXsrfStrategy;
exports.e = httpFactory;
exports.f = zoneWrappedInterceptingHandler;
exports.a = instantiateServerRendererFactory;
exports.b = ServerStylesHost;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=platform-server.umd.js.map


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LoadingService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var LoadingService = (function () {
    function LoadingService() {
        var _this = this;
        this.loadingChanged = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["EventEmitter"]();
        this.showLoading = function (isLoading) {
            return _this.loadingChanged.emit(isLoading);
        };
    }
    LoadingService = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])()
    ], LoadingService);
    return LoadingService;
}());



/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return function switchMapOperatorFunction(source) {
        return source.lift(new SwitchMapOperator(project, resultSelector));
    };
}
exports.switchMap = switchMap;
var SwitchMapOperator = (function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(74);

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v4.3.6
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports, __webpack_require__(16)) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/animations'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.animations = global.ng.animations || {}, global.ng.animations.browser = global.ng.animations.browser || {}),global.ng.animations));
}(this, (function (exports,_angular_animations) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * @license Angular v4.3.6
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function optimizeGroupPlayer(players) {
    switch (players.length) {
        case 0:
            return new _angular_animations.NoopAnimationPlayer();
        case 1:
            return players[0];
        default:
            return new _angular_animations.AnimationGroupPlayer(players);
    }
}
function normalizeKeyframes(driver, normalizer, element, keyframes, preStyles, postStyles) {
    if (preStyles === void 0) { preStyles = {}; }
    if (postStyles === void 0) { postStyles = {}; }
    var errors = [];
    var normalizedKeyframes = [];
    var previousOffset = -1;
    var previousKeyframe = null;
    keyframes.forEach(function (kf) {
        var offset = kf['offset'];
        var isSameOffset = offset == previousOffset;
        var normalizedKeyframe = (isSameOffset && previousKeyframe) || {};
        Object.keys(kf).forEach(function (prop) {
            var normalizedProp = prop;
            var normalizedValue = kf[prop];
            if (prop !== 'offset') {
                normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);
                switch (normalizedValue) {
                    case _angular_animations.PRE_STYLE:
                        normalizedValue = preStyles[prop];
                        break;
                    case _angular_animations.AUTO_STYLE:
                        normalizedValue = postStyles[prop];
                        break;
                    default:
                        normalizedValue =
                            normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);
                        break;
                }
            }
            normalizedKeyframe[normalizedProp] = normalizedValue;
        });
        if (!isSameOffset) {
            normalizedKeyframes.push(normalizedKeyframe);
        }
        previousKeyframe = normalizedKeyframe;
        previousOffset = offset;
    });
    if (errors.length) {
        var LINE_START = '\n - ';
        throw new Error("Unable to animate due to the following errors:" + LINE_START + errors.join(LINE_START));
    }
    return normalizedKeyframes;
}
function listenOnPlayer(player, eventName, event, callback) {
    switch (eventName) {
        case 'start':
            player.onStart(function () { return callback(event && copyAnimationEvent(event, 'start', player.totalTime)); });
            break;
        case 'done':
            player.onDone(function () { return callback(event && copyAnimationEvent(event, 'done', player.totalTime)); });
            break;
        case 'destroy':
            player.onDestroy(function () { return callback(event && copyAnimationEvent(event, 'destroy', player.totalTime)); });
            break;
    }
}
function copyAnimationEvent(e, phaseName, totalTime) {
    var event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, totalTime == undefined ? e.totalTime : totalTime);
    var data = e['_data'];
    if (data != null) {
        event['_data'] = data;
    }
    return event;
}
function makeAnimationEvent(element, triggerName, fromState, toState, phaseName, totalTime) {
    if (phaseName === void 0) { phaseName = ''; }
    if (totalTime === void 0) { totalTime = 0; }
    return { element: element, triggerName: triggerName, fromState: fromState, toState: toState, phaseName: phaseName, totalTime: totalTime };
}
function getOrSetAsInMap(map, key, defaultValue) {
    var value;
    if (map instanceof Map) {
        value = map.get(key);
        if (!value) {
            map.set(key, value = defaultValue);
        }
    }
    else {
        value = map[key];
        if (!value) {
            value = map[key] = defaultValue;
        }
    }
    return value;
}
function parseTimelineCommand(command) {
    var separatorPos = command.indexOf(':');
    var id = command.substring(1, separatorPos);
    var action = command.substr(separatorPos + 1);
    return [id, action];
}
var _contains = function (elm1, elm2) { return false; };
var _matches = function (element, selector) { return false; };
var _query = function (element, selector, multi) {
    return [];
};
if (typeof Element != 'undefined') {
    // this is well supported in all browsers
    _contains = function (elm1, elm2) { return elm1.contains(elm2); };
    if (Element.prototype.matches) {
        _matches = function (element, selector) { return element.matches(selector); };
    }
    else {
        var proto = Element.prototype;
        var fn_1 = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector ||
            proto.oMatchesSelector || proto.webkitMatchesSelector;
        if (fn_1) {
            _matches = function (element, selector) { return fn_1.apply(element, [selector]); };
        }
    }
    _query = function (element, selector, multi) {
        var results = [];
        if (multi) {
            results.push.apply(results, element.querySelectorAll(selector));
        }
        else {
            var elm = element.querySelector(selector);
            if (elm) {
                results.push(elm);
            }
        }
        return results;
    };
}
var matchesElement = _matches;
var containsElement = _contains;
var invokeQuery = _query;
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @experimental
 */
var NoopAnimationDriver = (function () {
    function NoopAnimationDriver() {
    }
    NoopAnimationDriver.prototype.matchesElement = function (element, selector) {
        return matchesElement(element, selector);
    };
    NoopAnimationDriver.prototype.containsElement = function (elm1, elm2) { return containsElement(elm1, elm2); };
    NoopAnimationDriver.prototype.query = function (element, selector, multi) {
        return invokeQuery(element, selector, multi);
    };
    NoopAnimationDriver.prototype.computeStyle = function (element, prop, defaultValue) {
        return defaultValue || '';
    };
    NoopAnimationDriver.prototype.animate = function (element, keyframes, duration, delay, easing, previousPlayers) {
        if (previousPlayers === void 0) { previousPlayers = []; }
        return new _angular_animations.NoopAnimationPlayer();
    };
    return NoopAnimationDriver;
}());
/**
 * @experimental
 */
var AnimationDriver = (function () {
    function AnimationDriver() {
    }
    return AnimationDriver;
}());
AnimationDriver.NOOP = new NoopAnimationDriver();
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ONE_SECOND = 1000;
var SUBSTITUTION_EXPR_START = '{{';
var SUBSTITUTION_EXPR_END = '}}';
var ENTER_CLASSNAME = 'ng-enter';
var LEAVE_CLASSNAME = 'ng-leave';
var ENTER_SELECTOR = '.ng-enter';
var LEAVE_SELECTOR = '.ng-leave';
var NG_TRIGGER_CLASSNAME = 'ng-trigger';
var NG_TRIGGER_SELECTOR = '.ng-trigger';
var NG_ANIMATING_CLASSNAME = 'ng-animating';
var NG_ANIMATING_SELECTOR = '.ng-animating';
function resolveTimingValue(value) {
    if (typeof value == 'number')
        return value;
    var matches = value.match(/^(-?[\.\d]+)(m?s)/);
    if (!matches || matches.length < 2)
        return 0;
    return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
}
function _convertTimeValueToMS(value, unit) {
    switch (unit) {
        case 's':
            return value * ONE_SECOND;
        default:
            return value;
    }
}
function resolveTiming(timings, errors, allowNegativeValues) {
    return timings.hasOwnProperty('duration') ?
        timings :
        parseTimeExpression(timings, errors, allowNegativeValues);
}
function parseTimeExpression(exp, errors, allowNegativeValues) {
    var regex = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i;
    var duration;
    var delay = 0;
    var easing = '';
    if (typeof exp === 'string') {
        var matches = exp.match(regex);
        if (matches === null) {
            errors.push("The provided timing value \"" + exp + "\" is invalid.");
            return { duration: 0, delay: 0, easing: '' };
        }
        duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
        var delayMatch = matches[3];
        if (delayMatch != null) {
            delay = _convertTimeValueToMS(Math.floor(parseFloat(delayMatch)), matches[4]);
        }
        var easingVal = matches[5];
        if (easingVal) {
            easing = easingVal;
        }
    }
    else {
        duration = exp;
    }
    if (!allowNegativeValues) {
        var containsErrors = false;
        var startIndex = errors.length;
        if (duration < 0) {
            errors.push("Duration values below 0 are not allowed for this animation step.");
            containsErrors = true;
        }
        if (delay < 0) {
            errors.push("Delay values below 0 are not allowed for this animation step.");
            containsErrors = true;
        }
        if (containsErrors) {
            errors.splice(startIndex, 0, "The provided timing value \"" + exp + "\" is invalid.");
        }
    }
    return { duration: duration, delay: delay, easing: easing };
}
function copyObj(obj, destination) {
    if (destination === void 0) { destination = {}; }
    Object.keys(obj).forEach(function (prop) { destination[prop] = obj[prop]; });
    return destination;
}
function normalizeStyles(styles) {
    var normalizedStyles = {};
    if (Array.isArray(styles)) {
        styles.forEach(function (data) { return copyStyles(data, false, normalizedStyles); });
    }
    else {
        copyStyles(styles, false, normalizedStyles);
    }
    return normalizedStyles;
}
function copyStyles(styles, readPrototype, destination) {
    if (destination === void 0) { destination = {}; }
    if (readPrototype) {
        // we make use of a for-in loop so that the
        // prototypically inherited properties are
        // revealed from the backFill map
        for (var prop in styles) {
            destination[prop] = styles[prop];
        }
    }
    else {
        copyObj(styles, destination);
    }
    return destination;
}
function setStyles(element, styles) {
    if (element['style']) {
        Object.keys(styles).forEach(function (prop) {
            var camelProp = dashCaseToCamelCase(prop);
            element.style[camelProp] = styles[prop];
        });
    }
}
function eraseStyles(element, styles) {
    if (element['style']) {
        Object.keys(styles).forEach(function (prop) {
            var camelProp = dashCaseToCamelCase(prop);
            element.style[camelProp] = '';
        });
    }
}
function normalizeAnimationEntry(steps) {
    if (Array.isArray(steps)) {
        if (steps.length == 1)
            return steps[0];
        return _angular_animations.sequence(steps);
    }
    return steps;
}
function validateStyleParams(value, options, errors) {
    var params = options.params || {};
    var matches = extractStyleParams(value);
    if (matches.length) {
        matches.forEach(function (varName) {
            if (!params.hasOwnProperty(varName)) {
                errors.push("Unable to resolve the local animation param " + varName + " in the given list of values");
            }
        });
    }
}
var PARAM_REGEX = new RegExp(SUBSTITUTION_EXPR_START + "\\s*(.+?)\\s*" + SUBSTITUTION_EXPR_END, 'g');
function extractStyleParams(value) {
    var params = [];
    if (typeof value === 'string') {
        var val = value.toString();
        var match = void 0;
        while (match = PARAM_REGEX.exec(val)) {
            params.push(match[1]);
        }
        PARAM_REGEX.lastIndex = 0;
    }
    return params;
}
function interpolateParams(value, params, errors) {
    var original = value.toString();
    var str = original.replace(PARAM_REGEX, function (_, varName) {
        var localVal = params[varName];
        // this means that the value was never overidden by the data passed in by the user
        if (!params.hasOwnProperty(varName)) {
            errors.push("Please provide a value for the animation param " + varName);
            localVal = '';
        }
        return localVal.toString();
    });
    // we do this to assert that numeric values stay as they are
    return str == original ? value : str;
}
function iteratorToArray(iterator) {
    var arr = [];
    var item = iterator.next();
    while (!item.done) {
        arr.push(item.value);
        item = iterator.next();
    }
    return arr;
}
var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
function dashCaseToCamelCase(input) {
    return input.replace(DASH_CASE_REGEXP, function () {
        var m = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            m[_i] = arguments[_i];
        }
        return m[1].toUpperCase();
    });
}
function allowPreviousPlayerStylesMerge(duration, delay) {
    return duration === 0 || delay === 0;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var EMPTY_ANIMATION_OPTIONS = {};
/**
 * @abstract
 */
var Ast = (function () {
    function Ast() {
        this.options = EMPTY_ANIMATION_OPTIONS;
    }
    /**
     * @abstract
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    Ast.prototype.visit = function (ast, context) { };
    Object.defineProperty(Ast.prototype, "params", {
        /**
         * @return {?}
         */
        get: function () { return this.options['params'] || null; },
        enumerable: true,
        configurable: true
    });
    return Ast;
}());
var TriggerAst = (function (_super) {
    __extends(TriggerAst, _super);
    /**
     * @param {?} name
     * @param {?} states
     * @param {?} transitions
     */
    function TriggerAst(name, states, transitions) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.states = states;
        _this.transitions = transitions;
        _this.queryCount = 0;
        _this.depCount = 0;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    TriggerAst.prototype.visit = function (visitor, context) { return visitor.visitTrigger(this, context); };
    return TriggerAst;
}(Ast));
var StateAst = (function (_super) {
    __extends(StateAst, _super);
    /**
     * @param {?} name
     * @param {?} style
     */
    function StateAst(name, style$$1) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.style = style$$1;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    StateAst.prototype.visit = function (visitor, context) { return visitor.visitState(this, context); };
    return StateAst;
}(Ast));
var TransitionAst = (function (_super) {
    __extends(TransitionAst, _super);
    /**
     * @param {?} matchers
     * @param {?} animation
     */
    function TransitionAst(matchers, animation) {
        var _this = _super.call(this) || this;
        _this.matchers = matchers;
        _this.animation = animation;
        _this.queryCount = 0;
        _this.depCount = 0;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    TransitionAst.prototype.visit = function (visitor, context) { return visitor.visitTransition(this, context); };
    return TransitionAst;
}(Ast));
var SequenceAst = (function (_super) {
    __extends(SequenceAst, _super);
    /**
     * @param {?} steps
     */
    function SequenceAst(steps) {
        var _this = _super.call(this) || this;
        _this.steps = steps;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    SequenceAst.prototype.visit = function (visitor, context) { return visitor.visitSequence(this, context); };
    return SequenceAst;
}(Ast));
var GroupAst = (function (_super) {
    __extends(GroupAst, _super);
    /**
     * @param {?} steps
     */
    function GroupAst(steps) {
        var _this = _super.call(this) || this;
        _this.steps = steps;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    GroupAst.prototype.visit = function (visitor, context) { return visitor.visitGroup(this, context); };
    return GroupAst;
}(Ast));
var AnimateAst = (function (_super) {
    __extends(AnimateAst, _super);
    /**
     * @param {?} timings
     * @param {?} style
     */
    function AnimateAst(timings, style$$1) {
        var _this = _super.call(this) || this;
        _this.timings = timings;
        _this.style = style$$1;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    AnimateAst.prototype.visit = function (visitor, context) { return visitor.visitAnimate(this, context); };
    return AnimateAst;
}(Ast));
var StyleAst = (function (_super) {
    __extends(StyleAst, _super);
    /**
     * @param {?} styles
     * @param {?} easing
     * @param {?} offset
     */
    function StyleAst(styles, easing, offset) {
        var _this = _super.call(this) || this;
        _this.styles = styles;
        _this.easing = easing;
        _this.offset = offset;
        _this.isEmptyStep = false;
        _this.containsDynamicStyles = false;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    StyleAst.prototype.visit = function (visitor, context) { return visitor.visitStyle(this, context); };
    return StyleAst;
}(Ast));
var KeyframesAst = (function (_super) {
    __extends(KeyframesAst, _super);
    /**
     * @param {?} styles
     */
    function KeyframesAst(styles) {
        var _this = _super.call(this) || this;
        _this.styles = styles;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    KeyframesAst.prototype.visit = function (visitor, context) { return visitor.visitKeyframes(this, context); };
    return KeyframesAst;
}(Ast));
var ReferenceAst = (function (_super) {
    __extends(ReferenceAst, _super);
    /**
     * @param {?} animation
     */
    function ReferenceAst(animation) {
        var _this = _super.call(this) || this;
        _this.animation = animation;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    ReferenceAst.prototype.visit = function (visitor, context) { return visitor.visitReference(this, context); };
    return ReferenceAst;
}(Ast));
var AnimateChildAst = (function (_super) {
    __extends(AnimateChildAst, _super);
    function AnimateChildAst() {
        return _super.call(this) || this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    AnimateChildAst.prototype.visit = function (visitor, context) { return visitor.visitAnimateChild(this, context); };
    return AnimateChildAst;
}(Ast));
var AnimateRefAst = (function (_super) {
    __extends(AnimateRefAst, _super);
    /**
     * @param {?} animation
     */
    function AnimateRefAst(animation) {
        var _this = _super.call(this) || this;
        _this.animation = animation;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    AnimateRefAst.prototype.visit = function (visitor, context) { return visitor.visitAnimateRef(this, context); };
    return AnimateRefAst;
}(Ast));
var QueryAst = (function (_super) {
    __extends(QueryAst, _super);
    /**
     * @param {?} selector
     * @param {?} limit
     * @param {?} optional
     * @param {?} includeSelf
     * @param {?} animation
     */
    function QueryAst(selector, limit, optional, includeSelf, animation) {
        var _this = _super.call(this) || this;
        _this.selector = selector;
        _this.limit = limit;
        _this.optional = optional;
        _this.includeSelf = includeSelf;
        _this.animation = animation;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    QueryAst.prototype.visit = function (visitor, context) { return visitor.visitQuery(this, context); };
    return QueryAst;
}(Ast));
var StaggerAst = (function (_super) {
    __extends(StaggerAst, _super);
    /**
     * @param {?} timings
     * @param {?} animation
     */
    function StaggerAst(timings, animation) {
        var _this = _super.call(this) || this;
        _this.timings = timings;
        _this.animation = animation;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    StaggerAst.prototype.visit = function (visitor, context) { return visitor.visitStagger(this, context); };
    return StaggerAst;
}(Ast));
var TimingAst = (function (_super) {
    __extends(TimingAst, _super);
    /**
     * @param {?} duration
     * @param {?=} delay
     * @param {?=} easing
     */
    function TimingAst(duration, delay, easing) {
        if (delay === void 0) { delay = 0; }
        if (easing === void 0) { easing = null; }
        var _this = _super.call(this) || this;
        _this.duration = duration;
        _this.delay = delay;
        _this.easing = easing;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    TimingAst.prototype.visit = function (visitor, context) { return visitor.visitTiming(this, context); };
    return TimingAst;
}(Ast));
var DynamicTimingAst = (function (_super) {
    __extends(DynamicTimingAst, _super);
    /**
     * @param {?} value
     */
    function DynamicTimingAst(value) {
        var _this = _super.call(this, 0, 0, '') || this;
        _this.value = value;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    DynamicTimingAst.prototype.visit = function (visitor, context) { return visitor.visitTiming(this, context); };
    return DynamicTimingAst;
}(TimingAst));
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} visitor
 * @param {?} node
 * @param {?} context
 * @return {?}
 */
function visitAnimationNode(visitor, node, context) {
    switch (node.type) {
        case 7 /* Trigger */:
            return visitor.visitTrigger(/** @type {?} */ (node), context);
        case 0 /* State */:
            return visitor.visitState(/** @type {?} */ (node), context);
        case 1 /* Transition */:
            return visitor.visitTransition(/** @type {?} */ (node), context);
        case 2 /* Sequence */:
            return visitor.visitSequence(/** @type {?} */ (node), context);
        case 3 /* Group */:
            return visitor.visitGroup(/** @type {?} */ (node), context);
        case 4 /* Animate */:
            return visitor.visitAnimate(/** @type {?} */ (node), context);
        case 5 /* Keyframes */:
            return visitor.visitKeyframes(/** @type {?} */ (node), context);
        case 6 /* Style */:
            return visitor.visitStyle(/** @type {?} */ (node), context);
        case 8 /* Reference */:
            return visitor.visitReference(/** @type {?} */ (node), context);
        case 9 /* AnimateChild */:
            return visitor.visitAnimateChild(/** @type {?} */ (node), context);
        case 10 /* AnimateRef */:
            return visitor.visitAnimateRef(/** @type {?} */ (node), context);
        case 11 /* Query */:
            return visitor.visitQuery(/** @type {?} */ (node), context);
        case 12 /* Stagger */:
            return visitor.visitStagger(/** @type {?} */ (node), context);
        default:
            throw new Error("Unable to resolve animation metadata node #" + node.type);
    }
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ANY_STATE = '*';
/**
 * @param {?} transitionValue
 * @param {?} errors
 * @return {?}
 */
function parseTransitionExpr(transitionValue, errors) {
    var /** @type {?} */ expressions = [];
    if (typeof transitionValue == 'string') {
        ((transitionValue))
            .split(/\s*,\s*/)
            .forEach(function (str) { return parseInnerTransitionStr(str, expressions, errors); });
    }
    else {
        expressions.push(/** @type {?} */ (transitionValue));
    }
    return expressions;
}
/**
 * @param {?} eventStr
 * @param {?} expressions
 * @param {?} errors
 * @return {?}
 */
function parseInnerTransitionStr(eventStr, expressions, errors) {
    if (eventStr[0] == ':') {
        eventStr = parseAnimationAlias(eventStr, errors);
    }
    var /** @type {?} */ match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
    if (match == null || match.length < 4) {
        errors.push("The provided transition expression \"" + eventStr + "\" is not supported");
        return expressions;
    }
    var /** @type {?} */ fromState = match[1];
    var /** @type {?} */ separator = match[2];
    var /** @type {?} */ toState = match[3];
    expressions.push(makeLambdaFromStates(fromState, toState));
    var /** @type {?} */ isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;
    if (separator[0] == '<' && !isFullAnyStateExpr) {
        expressions.push(makeLambdaFromStates(toState, fromState));
    }
}
/**
 * @param {?} alias
 * @param {?} errors
 * @return {?}
 */
function parseAnimationAlias(alias, errors) {
    switch (alias) {
        case ':enter':
            return 'void => *';
        case ':leave':
            return '* => void';
        default:
            errors.push("The transition alias value \"" + alias + "\" is not supported");
            return '* => *';
    }
}
/**
 * @param {?} lhs
 * @param {?} rhs
 * @return {?}
 */
function makeLambdaFromStates(lhs, rhs) {
    return function (fromState, toState) {
        var /** @type {?} */ lhsMatch = lhs == ANY_STATE || lhs == fromState;
        var /** @type {?} */ rhsMatch = rhs == ANY_STATE || rhs == toState;
        if (!lhsMatch && typeof fromState === 'boolean') {
            lhsMatch = fromState ? lhs === 'true' : lhs === 'false';
        }
        if (!rhsMatch && typeof toState === 'boolean') {
            rhsMatch = toState ? rhs === 'true' : rhs === 'false';
        }
        return lhsMatch && rhsMatch;
    };
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var SELF_TOKEN = ':self';
var SELF_TOKEN_REGEX = new RegExp("s*" + SELF_TOKEN + "s*,?", 'g');
/**
 * @param {?} metadata
 * @param {?} errors
 * @return {?}
 */
function buildAnimationAst(metadata, errors) {
    return new AnimationAstBuilderVisitor().build(metadata, errors);
}
var LEAVE_TOKEN = ':leave';
var LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, 'g');
var ENTER_TOKEN = ':enter';
var ENTER_TOKEN_REGEX = new RegExp(ENTER_TOKEN, 'g');
var ROOT_SELECTOR = '';
var AnimationAstBuilderVisitor = (function () {
    function AnimationAstBuilderVisitor() {
    }
    /**
     * @param {?} metadata
     * @param {?} errors
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.build = function (metadata, errors) {
        var /** @type {?} */ context = new AnimationAstBuilderContext(errors);
        this._resetContextStyleTimingState(context);
        return (visitAnimationNode(this, normalizeAnimationEntry(metadata), context));
    };
    /**
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype._resetContextStyleTimingState = function (context) {
        context.currentQuerySelector = ROOT_SELECTOR;
        context.collectedStyles = {};
        context.collectedStyles[ROOT_SELECTOR] = {};
        context.currentTime = 0;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitTrigger = function (metadata, context) {
        var _this = this;
        var /** @type {?} */ queryCount = context.queryCount = 0;
        var /** @type {?} */ depCount = context.depCount = 0;
        var /** @type {?} */ states = [];
        var /** @type {?} */ transitions = [];
        metadata.definitions.forEach(function (def) {
            _this._resetContextStyleTimingState(context);
            if (def.type == 0 /* State */) {
                var /** @type {?} */ stateDef_1 = (def);
                var /** @type {?} */ name = stateDef_1.name;
                name.split(/\s*,\s*/).forEach(function (n) {
                    stateDef_1.name = n;
                    states.push(_this.visitState(stateDef_1, context));
                });
                stateDef_1.name = name;
            }
            else if (def.type == 1 /* Transition */) {
                var /** @type {?} */ transition = _this.visitTransition(/** @type {?} */ (def), context);
                queryCount += transition.queryCount;
                depCount += transition.depCount;
                transitions.push(transition);
            }
            else {
                context.errors.push('only state() and transition() definitions can sit inside of a trigger()');
            }
        });
        var /** @type {?} */ ast = new TriggerAst(metadata.name, states, transitions);
        ast.options = normalizeAnimationOptions(metadata.options);
        ast.queryCount = queryCount;
        ast.depCount = depCount;
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitState = function (metadata, context) {
        var /** @type {?} */ styleAst = this.visitStyle(metadata.styles, context);
        var /** @type {?} */ astParams = (metadata.options && metadata.options.params) || null;
        if (styleAst.containsDynamicStyles) {
            var /** @type {?} */ missingSubs_1 = new Set();
            var /** @type {?} */ params_1 = astParams || {};
            styleAst.styles.forEach(function (value) {
                if (isObject(value)) {
                    var /** @type {?} */ stylesObj_1 = (value);
                    Object.keys(stylesObj_1).forEach(function (prop) {
                        extractStyleParams(stylesObj_1[prop]).forEach(function (sub) {
                            if (!params_1.hasOwnProperty(sub)) {
                                missingSubs_1.add(sub);
                            }
                        });
                    });
                }
            });
            if (missingSubs_1.size) {
                var /** @type {?} */ missingSubsArr = iteratorToArray(missingSubs_1.values());
                context.errors.push("state(\"" + metadata.name + "\", ...) must define default values for all the following style substitutions: " + missingSubsArr.join(', '));
            }
        }
        var /** @type {?} */ stateAst = new StateAst(metadata.name, styleAst);
        if (astParams) {
            stateAst.options = { params: astParams };
        }
        return stateAst;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitTransition = function (metadata, context) {
        context.queryCount = 0;
        context.depCount = 0;
        var /** @type {?} */ entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);
        var /** @type {?} */ matchers = parseTransitionExpr(metadata.expr, context.errors);
        var /** @type {?} */ ast = new TransitionAst(matchers, entry);
        ast.options = normalizeAnimationOptions(metadata.options);
        ast.queryCount = context.queryCount;
        ast.depCount = context.depCount;
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitSequence = function (metadata, context) {
        var _this = this;
        var /** @type {?} */ ast = new SequenceAst(metadata.steps.map(function (s) { return visitAnimationNode(_this, s, context); }));
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitGroup = function (metadata, context) {
        var _this = this;
        var /** @type {?} */ currentTime = context.currentTime;
        var /** @type {?} */ furthestTime = 0;
        var /** @type {?} */ steps = metadata.steps.map(function (step) {
            context.currentTime = currentTime;
            var /** @type {?} */ innerAst = visitAnimationNode(_this, step, context);
            furthestTime = Math.max(furthestTime, context.currentTime);
            return innerAst;
        });
        context.currentTime = furthestTime;
        var /** @type {?} */ ast = new GroupAst(steps);
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitAnimate = function (metadata, context) {
        var /** @type {?} */ timingAst = constructTimingAst(metadata.timings, context.errors);
        context.currentAnimateTimings = timingAst;
        var /** @type {?} */ styles;
        var /** @type {?} */ styleMetadata = metadata.styles ? metadata.styles : _angular_animations.style({});
        if (styleMetadata.type == 5 /* Keyframes */) {
            styles = this.visitKeyframes(/** @type {?} */ (styleMetadata), context);
        }
        else {
            var /** @type {?} */ styleMetadata_1 = (metadata.styles);
            var /** @type {?} */ isEmpty = false;
            if (!styleMetadata_1) {
                isEmpty = true;
                var /** @type {?} */ newStyleData = {};
                if (timingAst.easing) {
                    newStyleData['easing'] = timingAst.easing;
                }
                styleMetadata_1 = _angular_animations.style(newStyleData);
            }
            context.currentTime += timingAst.duration + timingAst.delay;
            var /** @type {?} */ styleAst = this.visitStyle(styleMetadata_1, context);
            styleAst.isEmptyStep = isEmpty;
            styles = styleAst;
        }
        context.currentAnimateTimings = null;
        return new AnimateAst(timingAst, styles);
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitStyle = function (metadata, context) {
        var /** @type {?} */ ast = this._makeStyleAst(metadata, context);
        this._validateStyleAst(ast, context);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype._makeStyleAst = function (metadata, context) {
        var /** @type {?} */ styles = [];
        if (Array.isArray(metadata.styles)) {
            ((metadata.styles)).forEach(function (styleTuple) {
                if (typeof styleTuple == 'string') {
                    if (styleTuple == _angular_animations.AUTO_STYLE) {
                        styles.push(/** @type {?} */ (styleTuple));
                    }
                    else {
                        context.errors.push("The provided style string value " + styleTuple + " is not allowed.");
                    }
                }
                else {
                    styles.push(/** @type {?} */ (styleTuple));
                }
            });
        }
        else {
            styles.push(metadata.styles);
        }
        var /** @type {?} */ containsDynamicStyles = false;
        var /** @type {?} */ collectedEasing = null;
        styles.forEach(function (styleData) {
            if (isObject(styleData)) {
                var /** @type {?} */ styleMap = (styleData);
                var /** @type {?} */ easing = styleMap['easing'];
                if (easing) {
                    collectedEasing = (easing);
                    delete styleMap['easing'];
                }
                if (!containsDynamicStyles) {
                    for (var /** @type {?} */ prop in styleMap) {
                        var /** @type {?} */ value = styleMap[prop];
                        if (value.toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {
                            containsDynamicStyles = true;
                            break;
                        }
                    }
                }
            }
        });
        var /** @type {?} */ ast = new StyleAst(styles, collectedEasing, metadata.offset);
        ast.containsDynamicStyles = containsDynamicStyles;
        return ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype._validateStyleAst = function (ast, context) {
        var /** @type {?} */ timings = context.currentAnimateTimings;
        var /** @type {?} */ endTime = context.currentTime;
        var /** @type {?} */ startTime = context.currentTime;
        if (timings && startTime > 0) {
            startTime -= timings.duration + timings.delay;
        }
        ast.styles.forEach(function (tuple) {
            if (typeof tuple == 'string')
                return;
            Object.keys(tuple).forEach(function (prop) {
                var /** @type {?} */ collectedStyles = context.collectedStyles[((context.currentQuerySelector))];
                var /** @type {?} */ collectedEntry = collectedStyles[prop];
                var /** @type {?} */ updateCollectedStyle = true;
                if (collectedEntry) {
                    if (startTime != endTime && startTime >= collectedEntry.startTime &&
                        endTime <= collectedEntry.endTime) {
                        context.errors.push("The CSS property \"" + prop + "\" that exists between the times of \"" + collectedEntry.startTime + "ms\" and \"" + collectedEntry.endTime + "ms\" is also being animated in a parallel animation between the times of \"" + startTime + "ms\" and \"" + endTime + "ms\"");
                        updateCollectedStyle = false;
                    }
                    // we always choose the smaller start time value since we
                    // want to have a record of the entire animation window where
                    // the style property is being animated in between
                    startTime = collectedEntry.startTime;
                }
                if (updateCollectedStyle) {
                    collectedStyles[prop] = { startTime: startTime, endTime: endTime };
                }
                if (context.options) {
                    validateStyleParams(tuple[prop], context.options, context.errors);
                }
            });
        });
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitKeyframes = function (metadata, context) {
        var _this = this;
        if (!context.currentAnimateTimings) {
            context.errors.push("keyframes() must be placed inside of a call to animate()");
            return new KeyframesAst([]);
        }
        var /** @type {?} */ MAX_KEYFRAME_OFFSET = 1;
        var /** @type {?} */ totalKeyframesWithOffsets = 0;
        var /** @type {?} */ offsets = [];
        var /** @type {?} */ offsetsOutOfOrder = false;
        var /** @type {?} */ keyframesOutOfRange = false;
        var /** @type {?} */ previousOffset = 0;
        var /** @type {?} */ keyframes = metadata.steps.map(function (styles) {
            var /** @type {?} */ style$$1 = _this._makeStyleAst(styles, context);
            var /** @type {?} */ offsetVal = style$$1.offset != null ? style$$1.offset : consumeOffset(style$$1.styles);
            var /** @type {?} */ offset = 0;
            if (offsetVal != null) {
                totalKeyframesWithOffsets++;
                offset = style$$1.offset = offsetVal;
            }
            keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;
            offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;
            previousOffset = offset;
            offsets.push(offset);
            return style$$1;
        });
        if (keyframesOutOfRange) {
            context.errors.push("Please ensure that all keyframe offsets are between 0 and 1");
        }
        if (offsetsOutOfOrder) {
            context.errors.push("Please ensure that all keyframe offsets are in order");
        }
        var /** @type {?} */ length = metadata.steps.length;
        var /** @type {?} */ generatedOffset = 0;
        if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {
            context.errors.push("Not all style() steps within the declared keyframes() contain offsets");
        }
        else if (totalKeyframesWithOffsets == 0) {
            generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);
        }
        var /** @type {?} */ limit = length - 1;
        var /** @type {?} */ currentTime = context.currentTime;
        var /** @type {?} */ currentAnimateTimings = ((context.currentAnimateTimings));
        var /** @type {?} */ animateDuration = currentAnimateTimings.duration;
        keyframes.forEach(function (kf, i) {
            var /** @type {?} */ offset = generatedOffset > 0 ? (i == limit ? 1 : (generatedOffset * i)) : offsets[i];
            var /** @type {?} */ durationUpToThisFrame = offset * animateDuration;
            context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;
            currentAnimateTimings.duration = durationUpToThisFrame;
            _this._validateStyleAst(kf, context);
            kf.offset = offset;
        });
        return new KeyframesAst(keyframes);
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitReference = function (metadata, context) {
        var /** @type {?} */ entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);
        var /** @type {?} */ ast = new ReferenceAst(entry);
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitAnimateChild = function (metadata, context) {
        context.depCount++;
        var /** @type {?} */ ast = new AnimateChildAst();
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitAnimateRef = function (metadata, context) {
        var /** @type {?} */ animation = this.visitReference(metadata.animation, context);
        var /** @type {?} */ ast = new AnimateRefAst(animation);
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitQuery = function (metadata, context) {
        var /** @type {?} */ parentSelector = ((context.currentQuerySelector));
        var /** @type {?} */ options = ((metadata.options || {}));
        context.queryCount++;
        context.currentQuery = metadata;
        var _a = normalizeSelector(metadata.selector), selector = _a[0], includeSelf = _a[1];
        context.currentQuerySelector =
            parentSelector.length ? (parentSelector + ' ' + selector) : selector;
        getOrSetAsInMap(context.collectedStyles, context.currentQuerySelector, {});
        var /** @type {?} */ entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);
        context.currentQuery = null;
        context.currentQuerySelector = parentSelector;
        var /** @type {?} */ ast = new QueryAst(selector, options.limit || 0, !!options.optional, includeSelf, entry);
        ast.originalSelector = metadata.selector;
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitStagger = function (metadata, context) {
        if (!context.currentQuery) {
            context.errors.push("stagger() can only be used inside of query()");
        }
        var /** @type {?} */ timings = metadata.timings === 'full' ?
            { duration: 0, delay: 0, easing: 'full' } :
            resolveTiming(metadata.timings, context.errors, true);
        var /** @type {?} */ animation = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);
        return new StaggerAst(timings, animation);
    };
    return AnimationAstBuilderVisitor;
}());
/**
 * @param {?} selector
 * @return {?}
 */
function normalizeSelector(selector) {
    var /** @type {?} */ hasAmpersand = selector.split(/\s*,\s*/).find(function (token) { return token == SELF_TOKEN; }) ? true : false;
    if (hasAmpersand) {
        selector = selector.replace(SELF_TOKEN_REGEX, '');
    }
    selector = selector.replace(ENTER_TOKEN_REGEX, ENTER_SELECTOR)
        .replace(LEAVE_TOKEN_REGEX, LEAVE_SELECTOR)
        .replace(/@\*/g, NG_TRIGGER_SELECTOR)
        .replace(/@\w+/g, function (match) { return NG_TRIGGER_SELECTOR + '-' + match.substr(1); })
        .replace(/:animating/g, NG_ANIMATING_SELECTOR);
    return [selector, hasAmpersand];
}
/**
 * @param {?} obj
 * @return {?}
 */
function normalizeParams(obj) {
    return obj ? copyObj(obj) : null;
}
var AnimationAstBuilderContext = (function () {
    /**
     * @param {?} errors
     */
    function AnimationAstBuilderContext(errors) {
        this.errors = errors;
        this.queryCount = 0;
        this.depCount = 0;
        this.currentTransition = null;
        this.currentQuery = null;
        this.currentQuerySelector = null;
        this.currentAnimateTimings = null;
        this.currentTime = 0;
        this.collectedStyles = {};
        this.options = null;
    }
    return AnimationAstBuilderContext;
}());
/**
 * @param {?} styles
 * @return {?}
 */
function consumeOffset(styles) {
    if (typeof styles == 'string')
        return null;
    var /** @type {?} */ offset = null;
    if (Array.isArray(styles)) {
        styles.forEach(function (styleTuple) {
            if (isObject(styleTuple) && styleTuple.hasOwnProperty('offset')) {
                var /** @type {?} */ obj = (styleTuple);
                offset = parseFloat(/** @type {?} */ (obj['offset']));
                delete obj['offset'];
            }
        });
    }
    else if (isObject(styles) && styles.hasOwnProperty('offset')) {
        var /** @type {?} */ obj = (styles);
        offset = parseFloat(/** @type {?} */ (obj['offset']));
        delete obj['offset'];
    }
    return offset;
}
/**
 * @param {?} value
 * @return {?}
 */
function isObject(value) {
    return !Array.isArray(value) && typeof value == 'object';
}
/**
 * @param {?} value
 * @param {?} errors
 * @return {?}
 */
function constructTimingAst(value, errors) {
    var /** @type {?} */ timings = null;
    if (value.hasOwnProperty('duration')) {
        timings = (value);
    }
    else if (typeof value == 'number') {
        var /** @type {?} */ duration = resolveTiming(/** @type {?} */ (value), errors).duration;
        return new TimingAst(/** @type {?} */ (value), 0, '');
    }
    var /** @type {?} */ strValue = (value);
    var /** @type {?} */ isDynamic = strValue.split(/\s+/).some(function (v) { return v.charAt(0) == '{' && v.charAt(1) == '{'; });
    if (isDynamic) {
        return new DynamicTimingAst(strValue);
    }
    timings = timings || resolveTiming(strValue, errors);
    return new TimingAst(timings.duration, timings.delay, timings.easing);
}
/**
 * @param {?} options
 * @return {?}
 */
function normalizeAnimationOptions(options) {
    if (options) {
        options = copyObj(options);
        if (options['params']) {
            options['params'] = ((normalizeParams(options['params'])));
        }
    }
    else {
        options = {};
    }
    return options;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} element
 * @param {?} keyframes
 * @param {?} preStyleProps
 * @param {?} postStyleProps
 * @param {?} duration
 * @param {?} delay
 * @param {?=} easing
 * @param {?=} subTimeline
 * @return {?}
 */
function createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay, easing, subTimeline) {
    if (easing === void 0) { easing = null; }
    if (subTimeline === void 0) { subTimeline = false; }
    return {
        type: 1 /* TimelineAnimation */,
        element: element,
        keyframes: keyframes,
        preStyleProps: preStyleProps,
        postStyleProps: postStyleProps,
        duration: duration,
        delay: delay,
        totalTime: duration + delay, easing: easing, subTimeline: subTimeline
    };
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ElementInstructionMap = (function () {
    function ElementInstructionMap() {
        this._map = new Map();
    }
    /**
     * @param {?} element
     * @return {?}
     */
    ElementInstructionMap.prototype.consume = function (element) {
        var /** @type {?} */ instructions = this._map.get(element);
        if (instructions) {
            this._map.delete(element);
        }
        else {
            instructions = [];
        }
        return instructions;
    };
    /**
     * @param {?} element
     * @param {?} instructions
     * @return {?}
     */
    ElementInstructionMap.prototype.append = function (element, instructions) {
        var /** @type {?} */ existingInstructions = this._map.get(element);
        if (!existingInstructions) {
            this._map.set(element, existingInstructions = []);
        }
        existingInstructions.push.apply(existingInstructions, instructions);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    ElementInstructionMap.prototype.has = function (element) { return this._map.has(element); };
    /**
     * @return {?}
     */
    ElementInstructionMap.prototype.clear = function () { this._map.clear(); };
    return ElementInstructionMap;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ONE_FRAME_IN_MILLISECONDS = 1;
/**
 * @param {?} driver
 * @param {?} rootElement
 * @param {?} ast
 * @param {?=} startingStyles
 * @param {?=} finalStyles
 * @param {?=} options
 * @param {?=} subInstructions
 * @param {?=} errors
 * @return {?}
 */
function buildAnimationTimelines(driver, rootElement, ast, startingStyles, finalStyles, options, subInstructions, errors) {
    if (startingStyles === void 0) { startingStyles = {}; }
    if (finalStyles === void 0) { finalStyles = {}; }
    if (errors === void 0) { errors = []; }
    return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, startingStyles, finalStyles, options, subInstructions, errors);
}
var AnimationTimelineBuilderVisitor = (function () {
    function AnimationTimelineBuilderVisitor() {
    }
    /**
     * @param {?} driver
     * @param {?} rootElement
     * @param {?} ast
     * @param {?} startingStyles
     * @param {?} finalStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @param {?=} errors
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.buildKeyframes = function (driver, rootElement, ast, startingStyles, finalStyles, options, subInstructions, errors) {
        if (errors === void 0) { errors = []; }
        subInstructions = subInstructions || new ElementInstructionMap();
        var /** @type {?} */ context = new AnimationTimelineContext(driver, rootElement, subInstructions, errors, []);
        context.options = options;
        context.currentTimeline.setStyles([startingStyles], null, context.errors, options);
        ast.visit(this, context);
        // this checks to see if an actual animation happened
        var /** @type {?} */ timelines = context.timelines.filter(function (timeline) { return timeline.containsAnimation(); });
        if (timelines.length && Object.keys(finalStyles).length) {
            var /** @type {?} */ tl = timelines[timelines.length - 1];
            if (!tl.allowOnlyTimelineStyles()) {
                tl.setStyles([finalStyles], null, context.errors, options);
            }
        }
        return timelines.length ? timelines.map(function (timeline) { return timeline.buildKeyframes(); }) :
            [createTimelineInstruction(rootElement, [], [], [], 0, 0, '', false)];
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitTrigger = function (ast, context) {
        // these values are not visited in this AST
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitState = function (ast, context) {
        // these values are not visited in this AST
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitTransition = function (ast, context) {
        // these values are not visited in this AST
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitAnimateChild = function (ast, context) {
        var /** @type {?} */ elementInstructions = context.subInstructions.consume(context.element);
        if (elementInstructions) {
            var /** @type {?} */ innerContext = context.createSubContext(ast.options);
            var /** @type {?} */ startTime = context.currentTimeline.currentTime;
            var /** @type {?} */ endTime = this._visitSubInstructions(elementInstructions, innerContext, /** @type {?} */ (innerContext.options));
            if (startTime != endTime) {
                // we do this on the upper context because we created a sub context for
                // the sub child animations
                context.transformIntoNewTimeline(endTime);
            }
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitAnimateRef = function (ast, context) {
        var /** @type {?} */ innerContext = context.createSubContext(ast.options);
        innerContext.transformIntoNewTimeline();
        this.visitReference(ast.animation, innerContext);
        context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);
        context.previousNode = ast;
    };
    /**
     * @param {?} instructions
     * @param {?} context
     * @param {?} options
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype._visitSubInstructions = function (instructions, context, options) {
        var /** @type {?} */ startTime = context.currentTimeline.currentTime;
        var /** @type {?} */ furthestTime = startTime;
        // this is a special-case for when a user wants to skip a sub
        // animation from being fired entirely.
        var /** @type {?} */ duration = options.duration != null ? resolveTimingValue(options.duration) : null;
        var /** @type {?} */ delay = options.delay != null ? resolveTimingValue(options.delay) : null;
        if (duration !== 0) {
            instructions.forEach(function (instruction) {
                var /** @type {?} */ instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay);
                furthestTime =
                    Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);
            });
        }
        return furthestTime;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitReference = function (ast, context) {
        context.updateOptions(ast.options, true);
        ast.animation.visit(this, context);
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitSequence = function (ast, context) {
        var _this = this;
        var /** @type {?} */ subContextCount = context.subContextCount;
        var /** @type {?} */ ctx = context;
        var /** @type {?} */ options = ast.options;
        if (options && (options.params || options.delay)) {
            ctx = context.createSubContext(options);
            ctx.transformIntoNewTimeline();
            if (options.delay != null) {
                if (ctx.previousNode instanceof StyleAst) {
                    ctx.currentTimeline.snapshotCurrentStyles();
                    ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
                }
                var /** @type {?} */ delay = resolveTimingValue(options.delay);
                ctx.delayNextStep(delay);
            }
        }
        if (ast.steps.length) {
            ast.steps.forEach(function (s) { return s.visit(_this, ctx); });
            // this is here just incase the inner steps only contain or end with a style() call
            ctx.currentTimeline.applyStylesToKeyframe();
            // this means that some animation function within the sequence
            // ended up creating a sub timeline (which means the current
            // timeline cannot overlap with the contents of the sequence)
            if (ctx.subContextCount > subContextCount) {
                ctx.transformIntoNewTimeline();
            }
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitGroup = function (ast, context) {
        var _this = this;
        var /** @type {?} */ innerTimelines = [];
        var /** @type {?} */ furthestTime = context.currentTimeline.currentTime;
        var /** @type {?} */ delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;
        ast.steps.forEach(function (s) {
            var /** @type {?} */ innerContext = context.createSubContext(ast.options);
            if (delay) {
                innerContext.delayNextStep(delay);
            }
            s.visit(_this, innerContext);
            furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);
            innerTimelines.push(innerContext.currentTimeline);
        });
        // this operation is run after the AST loop because otherwise
        // if the parent timeline's collected styles were updated then
        // it would pass in invalid data into the new-to-be forked items
        innerTimelines.forEach(function (timeline) { return context.currentTimeline.mergeTimelineCollectedStyles(timeline); });
        context.transformIntoNewTimeline(furthestTime);
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitTiming = function (ast, context) {
        if (ast instanceof DynamicTimingAst) {
            var /** @type {?} */ strValue = context.params ?
                interpolateParams(ast.value, context.params, context.errors) :
                ast.value.toString();
            return resolveTiming(strValue, context.errors);
        }
        else {
            return { duration: ast.duration, delay: ast.delay, easing: ast.easing };
        }
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitAnimate = function (ast, context) {
        var /** @type {?} */ timings = context.currentAnimateTimings = this.visitTiming(ast.timings, context);
        var /** @type {?} */ timeline = context.currentTimeline;
        if (timings.delay) {
            context.incrementTime(timings.delay);
            timeline.snapshotCurrentStyles();
        }
        var /** @type {?} */ style$$1 = ast.style;
        if (style$$1 instanceof KeyframesAst) {
            this.visitKeyframes(style$$1, context);
        }
        else {
            context.incrementTime(timings.duration);
            this.visitStyle(/** @type {?} */ (style$$1), context);
            timeline.applyStylesToKeyframe();
        }
        context.currentAnimateTimings = null;
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitStyle = function (ast, context) {
        var /** @type {?} */ timeline = context.currentTimeline;
        var /** @type {?} */ timings = ((context.currentAnimateTimings));
        // this is a special case for when a style() call
        // directly follows  an animate() call (but not inside of an animate() call)
        if (!timings && timeline.getCurrentStyleProperties().length) {
            timeline.forwardFrame();
        }
        var /** @type {?} */ easing = (timings && timings.easing) || ast.easing;
        if (ast.isEmptyStep) {
            timeline.applyEmptyStep(easing);
        }
        else {
            timeline.setStyles(ast.styles, easing, context.errors, context.options);
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitKeyframes = function (ast, context) {
        var /** @type {?} */ currentAnimateTimings = ((context.currentAnimateTimings));
        var /** @type {?} */ startTime = (((context.currentTimeline))).duration;
        var /** @type {?} */ duration = currentAnimateTimings.duration;
        var /** @type {?} */ innerContext = context.createSubContext();
        var /** @type {?} */ innerTimeline = innerContext.currentTimeline;
        innerTimeline.easing = currentAnimateTimings.easing;
        ast.styles.forEach(function (step) {
            var /** @type {?} */ offset = step.offset || 0;
            innerTimeline.forwardTime(offset * duration);
            innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);
            innerTimeline.applyStylesToKeyframe();
        });
        // this will ensure that the parent timeline gets all the styles from
        // the child even if the new timeline below is not used
        context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);
        // we do this because the window between this timeline and the sub timeline
        // should ensure that the styles within are exactly the same as they were before
        context.transformIntoNewTimeline(startTime + duration);
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitQuery = function (ast, context) {
        var _this = this;
        // in the event that the first step before this is a style step we need
        // to ensure the styles are applied before the children are animated
        var /** @type {?} */ startTime = context.currentTimeline.currentTime;
        var /** @type {?} */ options = ((ast.options || {}));
        var /** @type {?} */ delay = options.delay ? resolveTimingValue(options.delay) : 0;
        if (delay && (context.previousNode instanceof StyleAst ||
            (startTime == 0 && context.currentTimeline.getCurrentStyleProperties().length))) {
            context.currentTimeline.snapshotCurrentStyles();
            context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        }
        var /** @type {?} */ furthestTime = startTime;
        var /** @type {?} */ elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context.errors);
        context.currentQueryTotal = elms.length;
        var /** @type {?} */ sameElementTimeline = null;
        elms.forEach(function (element, i) {
            context.currentQueryIndex = i;
            var /** @type {?} */ innerContext = context.createSubContext(ast.options, element);
            if (delay) {
                innerContext.delayNextStep(delay);
            }
            if (element === context.element) {
                sameElementTimeline = innerContext.currentTimeline;
            }
            ast.animation.visit(_this, innerContext);
            // this is here just incase the inner steps only contain or end
            // with a style() call (which is here to signal that this is a preparatory
            // call to style an element before it is animated again)
            innerContext.currentTimeline.applyStylesToKeyframe();
            var /** @type {?} */ endTime = innerContext.currentTimeline.currentTime;
            furthestTime = Math.max(furthestTime, endTime);
        });
        context.currentQueryIndex = 0;
        context.currentQueryTotal = 0;
        context.transformIntoNewTimeline(furthestTime);
        if (sameElementTimeline) {
            context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);
            context.currentTimeline.snapshotCurrentStyles();
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitStagger = function (ast, context) {
        var /** @type {?} */ parentContext = ((context.parentContext));
        var /** @type {?} */ tl = context.currentTimeline;
        var /** @type {?} */ timings = ast.timings;
        var /** @type {?} */ duration = Math.abs(timings.duration);
        var /** @type {?} */ maxTime = duration * (context.currentQueryTotal - 1);
        var /** @type {?} */ delay = duration * context.currentQueryIndex;
        var /** @type {?} */ staggerTransformer = timings.duration < 0 ? 'reverse' : timings.easing;
        switch (staggerTransformer) {
            case 'reverse':
                delay = maxTime - delay;
                break;
            case 'full':
                delay = parentContext.currentStaggerTime;
                break;
        }
        var /** @type {?} */ timeline = context.currentTimeline;
        if (delay) {
            timeline.delayNextStep(delay);
        }
        var /** @type {?} */ startingTime = timeline.currentTime;
        ast.animation.visit(this, context);
        context.previousNode = ast;
        // time = duration + delay
        // the reason why this computation is so complex is because
        // the inner timeline may either have a delay value or a stretched
        // keyframe depending on if a subtimeline is not used or is used.
        parentContext.currentStaggerTime =
            (tl.currentTime - startingTime) + (tl.startTime - parentContext.currentTimeline.startTime);
    };
    return AnimationTimelineBuilderVisitor;
}());
var DEFAULT_NOOP_PREVIOUS_NODE = ({});
var AnimationTimelineContext = (function () {
    /**
     * @param {?} _driver
     * @param {?} element
     * @param {?} subInstructions
     * @param {?} errors
     * @param {?} timelines
     * @param {?=} initialTimeline
     */
    function AnimationTimelineContext(_driver, element, subInstructions, errors, timelines, initialTimeline) {
        this._driver = _driver;
        this.element = element;
        this.subInstructions = subInstructions;
        this.errors = errors;
        this.timelines = timelines;
        this.parentContext = null;
        this.currentAnimateTimings = null;
        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        this.subContextCount = 0;
        this.options = {};
        this.currentQueryIndex = 0;
        this.currentQueryTotal = 0;
        this.currentStaggerTime = 0;
        this.currentTimeline = initialTimeline || new TimelineBuilder(element, 0);
        timelines.push(this.currentTimeline);
    }
    Object.defineProperty(AnimationTimelineContext.prototype, "params", {
        /**
         * @return {?}
         */
        get: function () { return this.options.params; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} options
     * @param {?=} skipIfExists
     * @return {?}
     */
    AnimationTimelineContext.prototype.updateOptions = function (options, skipIfExists) {
        var _this = this;
        if (!options)
            return;
        var /** @type {?} */ newOptions = (options);
        var /** @type {?} */ optionsToUpdate = this.options;
        // NOTE: this will get patched up when other animation methods support duration overrides
        if (newOptions.duration != null) {
            ((optionsToUpdate)).duration = resolveTimingValue(newOptions.duration);
        }
        if (newOptions.delay != null) {
            optionsToUpdate.delay = resolveTimingValue(newOptions.delay);
        }
        var /** @type {?} */ newParams = newOptions.params;
        if (newParams) {
            var /** @type {?} */ paramsToUpdate_1 = ((optionsToUpdate.params));
            if (!paramsToUpdate_1) {
                paramsToUpdate_1 = this.options.params = {};
            }
            Object.keys(newParams).forEach(function (name) {
                if (!skipIfExists || !paramsToUpdate_1.hasOwnProperty(name)) {
                    paramsToUpdate_1[name] = interpolateParams(newParams[name], paramsToUpdate_1, _this.errors);
                }
            });
        }
    };
    /**
     * @return {?}
     */
    AnimationTimelineContext.prototype._copyOptions = function () {
        var /** @type {?} */ options = {};
        if (this.options) {
            var /** @type {?} */ oldParams_1 = this.options.params;
            if (oldParams_1) {
                var /** @type {?} */ params_2 = options['params'] = {};
                Object.keys(this.options.params).forEach(function (name) { params_2[name] = oldParams_1[name]; });
            }
        }
        return options;
    };
    /**
     * @param {?=} options
     * @param {?=} element
     * @param {?=} newTime
     * @return {?}
     */
    AnimationTimelineContext.prototype.createSubContext = function (options, element, newTime) {
        if (options === void 0) { options = null; }
        var /** @type {?} */ target = element || this.element;
        var /** @type {?} */ context = new AnimationTimelineContext(this._driver, target, this.subInstructions, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));
        context.previousNode = this.previousNode;
        context.currentAnimateTimings = this.currentAnimateTimings;
        context.options = this._copyOptions();
        context.updateOptions(options);
        context.currentQueryIndex = this.currentQueryIndex;
        context.currentQueryTotal = this.currentQueryTotal;
        context.parentContext = this;
        this.subContextCount++;
        return context;
    };
    /**
     * @param {?=} newTime
     * @return {?}
     */
    AnimationTimelineContext.prototype.transformIntoNewTimeline = function (newTime) {
        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        this.currentTimeline = this.currentTimeline.fork(this.element, newTime);
        this.timelines.push(this.currentTimeline);
        return this.currentTimeline;
    };
    /**
     * @param {?} instruction
     * @param {?} duration
     * @param {?} delay
     * @return {?}
     */
    AnimationTimelineContext.prototype.appendInstructionToTimeline = function (instruction, duration, delay) {
        var /** @type {?} */ updatedTimings = {
            duration: duration != null ? duration : instruction.duration,
            delay: this.currentTimeline.currentTime + (delay != null ? delay : 0) + instruction.delay,
            easing: ''
        };
        var /** @type {?} */ builder = new SubTimelineBuilder(instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);
        this.timelines.push(builder);
        return updatedTimings;
    };
    /**
     * @param {?} time
     * @return {?}
     */
    AnimationTimelineContext.prototype.incrementTime = function (time) {
        this.currentTimeline.forwardTime(this.currentTimeline.duration + time);
    };
    /**
     * @param {?} delay
     * @return {?}
     */
    AnimationTimelineContext.prototype.delayNextStep = function (delay) {
        // negative delays are not yet supported
        if (delay > 0) {
            this.currentTimeline.delayNextStep(delay);
        }
    };
    /**
     * @param {?} selector
     * @param {?} originalSelector
     * @param {?} limit
     * @param {?} includeSelf
     * @param {?} optional
     * @param {?} errors
     * @return {?}
     */
    AnimationTimelineContext.prototype.invokeQuery = function (selector, originalSelector, limit, includeSelf, optional, errors) {
        var /** @type {?} */ results = [];
        if (includeSelf) {
            results.push(this.element);
        }
        if (selector.length > 0) {
            var /** @type {?} */ multi = limit != 1;
            results.push.apply(results, this._driver.query(this.element, selector, multi));
        }
        if (!optional && results.length == 0) {
            errors.push("`query(\"" + originalSelector + "\")` returned zero elements. (Use `query(\"" + originalSelector + "\", { optional: true })` if you wish to allow this.)");
        }
        return results;
    };
    return AnimationTimelineContext;
}());
var TimelineBuilder = (function () {
    /**
     * @param {?} element
     * @param {?} startTime
     * @param {?=} _elementTimelineStylesLookup
     */
    function TimelineBuilder(element, startTime, _elementTimelineStylesLookup) {
        this.element = element;
        this.startTime = startTime;
        this._elementTimelineStylesLookup = _elementTimelineStylesLookup;
        this.duration = 0;
        this._previousKeyframe = {};
        this._currentKeyframe = {};
        this._keyframes = new Map();
        this._styleSummary = {};
        this._pendingStyles = {};
        this._backFill = {};
        this._currentEmptyStepKeyframe = null;
        if (!this._elementTimelineStylesLookup) {
            this._elementTimelineStylesLookup = new Map();
        }
        this._localTimelineStyles = Object.create(this._backFill, {});
        this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element);
        if (!this._globalTimelineStyles) {
            this._globalTimelineStyles = this._localTimelineStyles;
            this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);
        }
        this._loadKeyframe();
    }
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.containsAnimation = function () {
        switch (this._keyframes.size) {
            case 0:
                return false;
            case 1:
                return this.getCurrentStyleProperties().length > 0;
            default:
                return true;
        }
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.getCurrentStyleProperties = function () { return Object.keys(this._currentKeyframe); };
    Object.defineProperty(TimelineBuilder.prototype, "currentTime", {
        /**
         * @return {?}
         */
        get: function () { return this.startTime + this.duration; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} delay
     * @return {?}
     */
    TimelineBuilder.prototype.delayNextStep = function (delay) {
        // in the event that a style() step is placed right before a stagger()
        // and that style() step is the very first style() value in the animation
        // then we need to make a copy of the keyframe [0, copy, 1] so that the delay
        // properly applies the style() values to work with the stagger...
        var /** @type {?} */ hasPreStyleStep = this._keyframes.size == 1 && Object.keys(this._pendingStyles).length;
        if (this.duration || hasPreStyleStep) {
            this.forwardTime(this.currentTime + delay);
            if (hasPreStyleStep) {
                this.snapshotCurrentStyles();
            }
        }
        else {
            this.startTime += delay;
        }
    };
    /**
     * @param {?} element
     * @param {?=} currentTime
     * @return {?}
     */
    TimelineBuilder.prototype.fork = function (element, currentTime) {
        this.applyStylesToKeyframe();
        return new TimelineBuilder(element, currentTime || this.currentTime, this._elementTimelineStylesLookup);
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype._loadKeyframe = function () {
        if (this._currentKeyframe) {
            this._previousKeyframe = this._currentKeyframe;
        }
        this._currentKeyframe = ((this._keyframes.get(this.duration)));
        if (!this._currentKeyframe) {
            this._currentKeyframe = Object.create(this._backFill, {});
            this._keyframes.set(this.duration, this._currentKeyframe);
        }
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.forwardFrame = function () {
        this.duration += ONE_FRAME_IN_MILLISECONDS;
        this._loadKeyframe();
    };
    /**
     * @param {?} time
     * @return {?}
     */
    TimelineBuilder.prototype.forwardTime = function (time) {
        this.applyStylesToKeyframe();
        this.duration = time;
        this._loadKeyframe();
    };
    /**
     * @param {?} prop
     * @param {?} value
     * @return {?}
     */
    TimelineBuilder.prototype._updateStyle = function (prop, value) {
        this._localTimelineStyles[prop] = value;
        this._globalTimelineStyles[prop] = value;
        this._styleSummary[prop] = { time: this.currentTime, value: value };
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.allowOnlyTimelineStyles = function () { return this._currentEmptyStepKeyframe !== this._currentKeyframe; };
    /**
     * @param {?} easing
     * @return {?}
     */
    TimelineBuilder.prototype.applyEmptyStep = function (easing) {
        var _this = this;
        if (easing) {
            this._previousKeyframe['easing'] = easing;
        }
        // special case for animate(duration):
        // all missing styles are filled with a `*` value then
        // if any destination styles are filled in later on the same
        // keyframe then they will override the overridden styles
        // We use `_globalTimelineStyles` here because there may be
        // styles in previous keyframes that are not present in this timeline
        Object.keys(this._globalTimelineStyles).forEach(function (prop) {
            _this._backFill[prop] = _this._globalTimelineStyles[prop] || _angular_animations.AUTO_STYLE;
            _this._currentKeyframe[prop] = _angular_animations.AUTO_STYLE;
        });
        this._currentEmptyStepKeyframe = this._currentKeyframe;
    };
    /**
     * @param {?} input
     * @param {?} easing
     * @param {?} errors
     * @param {?=} options
     * @return {?}
     */
    TimelineBuilder.prototype.setStyles = function (input, easing, errors, options) {
        var _this = this;
        if (easing) {
            this._previousKeyframe['easing'] = easing;
        }
        var /** @type {?} */ params = (options && options.params) || {};
        var /** @type {?} */ styles = flattenStyles(input, this._globalTimelineStyles);
        Object.keys(styles).forEach(function (prop) {
            var /** @type {?} */ val = interpolateParams(styles[prop], params, errors);
            _this._pendingStyles[prop] = val;
            if (!_this._localTimelineStyles.hasOwnProperty(prop)) {
                _this._backFill[prop] = _this._globalTimelineStyles.hasOwnProperty(prop) ?
                    _this._globalTimelineStyles[prop] :
                    _angular_animations.AUTO_STYLE;
            }
            _this._updateStyle(prop, val);
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.applyStylesToKeyframe = function () {
        var _this = this;
        var /** @type {?} */ styles = this._pendingStyles;
        var /** @type {?} */ props = Object.keys(styles);
        if (props.length == 0)
            return;
        this._pendingStyles = {};
        props.forEach(function (prop) {
            var /** @type {?} */ val = styles[prop];
            _this._currentKeyframe[prop] = val;
        });
        Object.keys(this._localTimelineStyles).forEach(function (prop) {
            if (!_this._currentKeyframe.hasOwnProperty(prop)) {
                _this._currentKeyframe[prop] = _this._localTimelineStyles[prop];
            }
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.snapshotCurrentStyles = function () {
        var _this = this;
        Object.keys(this._localTimelineStyles).forEach(function (prop) {
            var /** @type {?} */ val = _this._localTimelineStyles[prop];
            _this._pendingStyles[prop] = val;
            _this._updateStyle(prop, val);
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.getFinalKeyframe = function () { return this._keyframes.get(this.duration); };
    Object.defineProperty(TimelineBuilder.prototype, "properties", {
        /**
         * @return {?}
         */
        get: function () {
            var /** @type {?} */ properties = [];
            for (var /** @type {?} */ prop in this._currentKeyframe) {
                properties.push(prop);
            }
            return properties;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} timeline
     * @return {?}
     */
    TimelineBuilder.prototype.mergeTimelineCollectedStyles = function (timeline) {
        var _this = this;
        Object.keys(timeline._styleSummary).forEach(function (prop) {
            var /** @type {?} */ details0 = _this._styleSummary[prop];
            var /** @type {?} */ details1 = timeline._styleSummary[prop];
            if (!details0 || details1.time > details0.time) {
                _this._updateStyle(prop, details1.value);
            }
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.buildKeyframes = function () {
        var _this = this;
        this.applyStylesToKeyframe();
        var /** @type {?} */ preStyleProps = new Set();
        var /** @type {?} */ postStyleProps = new Set();
        var /** @type {?} */ isEmpty = this._keyframes.size === 1 && this.duration === 0;
        var /** @type {?} */ finalKeyframes = [];
        this._keyframes.forEach(function (keyframe, time) {
            var /** @type {?} */ finalKeyframe = copyStyles(keyframe, true);
            Object.keys(finalKeyframe).forEach(function (prop) {
                var /** @type {?} */ value = finalKeyframe[prop];
                if (value == _angular_animations.PRE_STYLE) {
                    preStyleProps.add(prop);
                }
                else if (value == _angular_animations.AUTO_STYLE) {
                    postStyleProps.add(prop);
                }
            });
            if (!isEmpty) {
                finalKeyframe['offset'] = time / _this.duration;
            }
            finalKeyframes.push(finalKeyframe);
        });
        var /** @type {?} */ preProps = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [];
        var /** @type {?} */ postProps = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : [];
        // special case for a 0-second animation (which is designed just to place styles onscreen)
        if (isEmpty) {
            var /** @type {?} */ kf0 = finalKeyframes[0];
            var /** @type {?} */ kf1 = copyObj(kf0);
            kf0['offset'] = 0;
            kf1['offset'] = 1;
            finalKeyframes = [kf0, kf1];
        }
        return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);
    };
    return TimelineBuilder;
}());
var SubTimelineBuilder = (function (_super) {
    __extends(SubTimelineBuilder, _super);
    /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} preStyleProps
     * @param {?} postStyleProps
     * @param {?} timings
     * @param {?=} _stretchStartingKeyframe
     */
    function SubTimelineBuilder(element, keyframes, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe) {
        if (_stretchStartingKeyframe === void 0) { _stretchStartingKeyframe = false; }
        var _this = _super.call(this, element, timings.delay) || this;
        _this.element = element;
        _this.keyframes = keyframes;
        _this.preStyleProps = preStyleProps;
        _this.postStyleProps = postStyleProps;
        _this._stretchStartingKeyframe = _stretchStartingKeyframe;
        _this.timings = { duration: timings.duration, delay: timings.delay, easing: timings.easing };
        return _this;
    }
    /**
     * @return {?}
     */
    SubTimelineBuilder.prototype.containsAnimation = function () { return this.keyframes.length > 1; };
    /**
     * @return {?}
     */
    SubTimelineBuilder.prototype.buildKeyframes = function () {
        var /** @type {?} */ keyframes = this.keyframes;
        var _a = this.timings, delay = _a.delay, duration = _a.duration, easing = _a.easing;
        if (this._stretchStartingKeyframe && delay) {
            var /** @type {?} */ newKeyframes = [];
            var /** @type {?} */ totalTime = duration + delay;
            var /** @type {?} */ startingGap = delay / totalTime;
            // the original starting keyframe now starts once the delay is done
            var /** @type {?} */ newFirstKeyframe = copyStyles(keyframes[0], false);
            newFirstKeyframe['offset'] = 0;
            newKeyframes.push(newFirstKeyframe);
            var /** @type {?} */ oldFirstKeyframe = copyStyles(keyframes[0], false);
            oldFirstKeyframe['offset'] = roundOffset(startingGap);
            newKeyframes.push(oldFirstKeyframe);
            /*
              When the keyframe is stretched then it means that the delay before the animation
              starts is gone. Instead the first keyframe is placed at the start of the animation
              and it is then copied to where it starts when the original delay is over. This basically
              means nothing animates during that delay, but the styles are still renderered. For this
              to work the original offset values that exist in the original keyframes must be "warped"
              so that they can take the new keyframe + delay into account.
      
              delay=1000, duration=1000, keyframes = 0 .5 1
      
              turns into
      
              delay=0, duration=2000, keyframes = 0 .33 .66 1
             */
            // offsets between 1 ... n -1 are all warped by the keyframe stretch
            var /** @type {?} */ limit = keyframes.length - 1;
            for (var /** @type {?} */ i = 1; i <= limit; i++) {
                var /** @type {?} */ kf = copyStyles(keyframes[i], false);
                var /** @type {?} */ oldOffset = (kf['offset']);
                var /** @type {?} */ timeAtKeyframe = delay + oldOffset * duration;
                kf['offset'] = roundOffset(timeAtKeyframe / totalTime);
                newKeyframes.push(kf);
            }
            // the new starting keyframe should be added at the start
            duration = totalTime;
            delay = 0;
            easing = '';
            keyframes = newKeyframes;
        }
        return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, true);
    };
    return SubTimelineBuilder;
}(TimelineBuilder));
/**
 * @param {?} offset
 * @param {?=} decimalPoints
 * @return {?}
 */
function roundOffset(offset, decimalPoints) {
    if (decimalPoints === void 0) { decimalPoints = 3; }
    var /** @type {?} */ mult = Math.pow(10, decimalPoints - 1);
    return Math.round(offset * mult) / mult;
}
/**
 * @param {?} input
 * @param {?} allStyles
 * @return {?}
 */
function flattenStyles(input, allStyles) {
    var /** @type {?} */ styles = {};
    var /** @type {?} */ allProperties;
    input.forEach(function (token) {
        if (token === '*') {
            allProperties = allProperties || Object.keys(allStyles);
            allProperties.forEach(function (prop) { styles[prop] = _angular_animations.AUTO_STYLE; });
        }
        else {
            copyStyles(/** @type {?} */ (token), false, styles);
        }
    });
    return styles;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var Animation = (function () {
    /**
     * @param {?} _driver
     * @param {?} input
     */
    function Animation(_driver, input) {
        this._driver = _driver;
        var errors = [];
        var ast = buildAnimationAst(input, errors);
        if (errors.length) {
            var errorMessage = "animation validation failed:\n" + errors.join("\n");
            throw new Error(errorMessage);
        }
        this._animationAst = ast;
    }
    /**
     * @param {?} element
     * @param {?} startingStyles
     * @param {?} destinationStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @return {?}
     */
    Animation.prototype.buildTimelines = function (element, startingStyles, destinationStyles, options, subInstructions) {
        var /** @type {?} */ start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) : (startingStyles);
        var /** @type {?} */ dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) : (destinationStyles);
        var /** @type {?} */ errors = [];
        subInstructions = subInstructions || new ElementInstructionMap();
        var /** @type {?} */ result = buildAnimationTimelines(this._driver, element, this._animationAst, start, dest, options, subInstructions, errors);
        if (errors.length) {
            var /** @type {?} */ errorMessage = "animation building failed:\n" + errors.join("\n");
            throw new Error(errorMessage);
        }
        return result;
    };
    return Animation;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @experimental Animation support is experimental.
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */ var AnimationStyleNormalizer = (function () {
    function AnimationStyleNormalizer() {
    }
    return AnimationStyleNormalizer;
}());
/**
 * @experimental Animation support is experimental.
 */
var NoopAnimationStyleNormalizer = (function () {
    function NoopAnimationStyleNormalizer() {
    }
    NoopAnimationStyleNormalizer.prototype.normalizePropertyName = function (propertyName, errors) { return propertyName; };
    NoopAnimationStyleNormalizer.prototype.normalizeStyleValue = function (userProvidedProperty, normalizedProperty, value, errors) {
        return value;
    };
    return NoopAnimationStyleNormalizer;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var WebAnimationsStyleNormalizer = (function (_super) {
    __extends(WebAnimationsStyleNormalizer, _super);
    function WebAnimationsStyleNormalizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} propertyName
     * @param {?} errors
     * @return {?}
     */
    WebAnimationsStyleNormalizer.prototype.normalizePropertyName = function (propertyName, errors) {
        return dashCaseToCamelCase(propertyName);
    };
    /**
     * @param {?} userProvidedProperty
     * @param {?} normalizedProperty
     * @param {?} value
     * @param {?} errors
     * @return {?}
     */
    WebAnimationsStyleNormalizer.prototype.normalizeStyleValue = function (userProvidedProperty, normalizedProperty, value, errors) {
        var /** @type {?} */ unit = '';
        var /** @type {?} */ strVal = value.toString().trim();
        if (DIMENSIONAL_PROP_MAP[normalizedProperty] && value !== 0 && value !== '0') {
            if (typeof value === 'number') {
                unit = 'px';
            }
            else {
                var /** @type {?} */ valAndSuffixMatch = value.match(/^[+-]?[\d\.]+([a-z]*)$/);
                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
                    errors.push("Please provide a CSS unit value for " + userProvidedProperty + ":" + value);
                }
            }
        }
        return strVal + unit;
    };
    return WebAnimationsStyleNormalizer;
}(AnimationStyleNormalizer));
var DIMENSIONAL_PROP_MAP = makeBooleanMap('width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective'
    .split(','));
/**
 * @param {?} keys
 * @return {?}
 */
function makeBooleanMap(keys) {
    var /** @type {?} */ map = {};
    keys.forEach(function (key) { return map[key] = true; });
    return map;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} element
 * @param {?} triggerName
 * @param {?} fromState
 * @param {?} toState
 * @param {?} isRemovalTransition
 * @param {?} fromStyles
 * @param {?} toStyles
 * @param {?} timelines
 * @param {?} queriedElements
 * @param {?} preStyleProps
 * @param {?} postStyleProps
 * @param {?=} errors
 * @return {?}
 */
function createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, errors) {
    return {
        type: 0 /* TransitionAnimation */,
        element: element,
        triggerName: triggerName,
        isRemovalTransition: isRemovalTransition,
        fromState: fromState,
        fromStyles: fromStyles,
        toState: toState,
        toStyles: toStyles,
        timelines: timelines,
        queriedElements: queriedElements,
        preStyleProps: preStyleProps,
        postStyleProps: postStyleProps,
        errors: errors
    };
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var EMPTY_OBJECT = {};
var AnimationTransitionFactory = (function () {
    /**
     * @param {?} _triggerName
     * @param {?} ast
     * @param {?} _stateStyles
     */
    function AnimationTransitionFactory(_triggerName, ast, _stateStyles) {
        this._triggerName = _triggerName;
        this.ast = ast;
        this._stateStyles = _stateStyles;
    }
    /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    AnimationTransitionFactory.prototype.match = function (currentState, nextState) {
        return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState);
    };
    /**
     * @param {?} stateName
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    AnimationTransitionFactory.prototype.buildStyles = function (stateName, params, errors) {
        var /** @type {?} */ backupStateStyler = this._stateStyles['*'];
        var /** @type {?} */ stateStyler = this._stateStyles[stateName];
        var /** @type {?} */ backupStyles = backupStateStyler ? backupStateStyler.buildStyles(params, errors) : {};
        return stateStyler ? stateStyler.buildStyles(params, errors) : backupStyles;
    };
    /**
     * @param {?} driver
     * @param {?} element
     * @param {?} currentState
     * @param {?} nextState
     * @param {?=} currentOptions
     * @param {?=} nextOptions
     * @param {?=} subInstructions
     * @return {?}
     */
    AnimationTransitionFactory.prototype.build = function (driver, element, currentState, nextState, currentOptions, nextOptions, subInstructions) {
        var /** @type {?} */ errors = [];
        var /** @type {?} */ transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT;
        var /** @type {?} */ currentAnimationParams = currentOptions && currentOptions.params || EMPTY_OBJECT;
        var /** @type {?} */ currentStateStyles = this.buildStyles(currentState, currentAnimationParams, errors);
        var /** @type {?} */ nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT;
        var /** @type {?} */ nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors);
        var /** @type {?} */ queriedElements = new Set();
        var /** @type {?} */ preStyleMap = new Map();
        var /** @type {?} */ postStyleMap = new Map();
        var /** @type {?} */ isRemoval = nextState === 'void';
        var /** @type {?} */ animationOptions = { params: Object.assign({}, transitionAnimationParams, nextAnimationParams) };
        var /** @type {?} */ timelines = buildAnimationTimelines(driver, element, this.ast.animation, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);
        if (errors.length) {
            return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, errors);
        }
        timelines.forEach(function (tl) {
            var /** @type {?} */ elm = tl.element;
            var /** @type {?} */ preProps = getOrSetAsInMap(preStyleMap, elm, {});
            tl.preStyleProps.forEach(function (prop) { return preProps[prop] = true; });
            var /** @type {?} */ postProps = getOrSetAsInMap(postStyleMap, elm, {});
            tl.postStyleProps.forEach(function (prop) { return postProps[prop] = true; });
            if (elm !== element) {
                queriedElements.add(elm);
            }
        });
        var /** @type {?} */ queriedElementsList = iteratorToArray(queriedElements.values());
        return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, queriedElementsList, preStyleMap, postStyleMap);
    };
    return AnimationTransitionFactory;
}());
/**
 * @param {?} matchFns
 * @param {?} currentState
 * @param {?} nextState
 * @return {?}
 */
function oneOrMoreTransitionsMatch(matchFns, currentState, nextState) {
    return matchFns.some(function (fn) { return fn(currentState, nextState); });
}
var AnimationStateStyles = (function () {
    /**
     * @param {?} styles
     * @param {?} defaultParams
     */
    function AnimationStateStyles(styles, defaultParams) {
        this.styles = styles;
        this.defaultParams = defaultParams;
    }
    /**
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    AnimationStateStyles.prototype.buildStyles = function (params, errors) {
        var /** @type {?} */ finalStyles = {};
        var /** @type {?} */ combinedParams = copyObj(this.defaultParams);
        Object.keys(params).forEach(function (key) {
            var /** @type {?} */ value = params[key];
            if (value != null) {
                combinedParams[key] = value;
            }
        });
        this.styles.styles.forEach(function (value) {
            if (typeof value !== 'string') {
                var /** @type {?} */ styleObj_1 = (value);
                Object.keys(styleObj_1).forEach(function (prop) {
                    var /** @type {?} */ val = styleObj_1[prop];
                    if (val.length > 1) {
                        val = interpolateParams(val, combinedParams, errors);
                    }
                    finalStyles[prop] = val;
                });
            }
        });
        return finalStyles;
    };
    return AnimationStateStyles;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@experimental Animation support is experimental.
 * @param {?} name
 * @param {?} ast
 * @return {?}
 */
function buildTrigger(name, ast) {
    return new AnimationTrigger(name, ast);
}
/**
 * \@experimental Animation support is experimental.
 */
var AnimationTrigger = (function () {
    /**
     * @param {?} name
     * @param {?} ast
     */
    function AnimationTrigger(name, ast) {
        var _this = this;
        this.name = name;
        this.ast = ast;
        this.transitionFactories = [];
        this.states = {};
        ast.states.forEach(function (ast) {
            var defaultParams = (ast.options && ast.options.params) || {};
            _this.states[ast.name] = new AnimationStateStyles(ast.style, defaultParams);
        });
        balanceProperties(this.states, 'true', '1');
        balanceProperties(this.states, 'false', '0');
        ast.transitions.forEach(function (ast) {
            _this.transitionFactories.push(new AnimationTransitionFactory(name, ast, _this.states));
        });
        this.fallbackTransition = createFallbackTransition(name, this.states);
    }
    Object.defineProperty(AnimationTrigger.prototype, "containsQueries", {
        /**
         * @return {?}
         */
        get: function () { return this.ast.queryCount > 0; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    AnimationTrigger.prototype.matchTransition = function (currentState, nextState) {
        var /** @type {?} */ entry = this.transitionFactories.find(function (f) { return f.match(currentState, nextState); });
        return entry || null;
    };
    /**
     * @param {?} currentState
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    AnimationTrigger.prototype.matchStyles = function (currentState, params, errors) {
        return this.fallbackTransition.buildStyles(currentState, params, errors);
    };
    return AnimationTrigger;
}());
/**
 * @param {?} triggerName
 * @param {?} states
 * @return {?}
 */
function createFallbackTransition(triggerName, states) {
    var /** @type {?} */ matchers = [function (fromState, toState) { return true; }];
    var /** @type {?} */ animation = new SequenceAst([]);
    var /** @type {?} */ transition = new TransitionAst(matchers, animation);
    return new AnimationTransitionFactory(triggerName, transition, states);
}
/**
 * @param {?} obj
 * @param {?} key1
 * @param {?} key2
 * @return {?}
 */
function balanceProperties(obj, key1, key2) {
    if (obj.hasOwnProperty(key1)) {
        if (!obj.hasOwnProperty(key2)) {
            obj[key2] = obj[key1];
        }
    }
    else if (obj.hasOwnProperty(key2)) {
        obj[key1] = obj[key2];
    }
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var EMPTY_INSTRUCTION_MAP = new ElementInstructionMap();
var TimelineAnimationEngine = (function () {
    /**
     * @param {?} _driver
     * @param {?} _normalizer
     */
    function TimelineAnimationEngine(_driver, _normalizer) {
        this._driver = _driver;
        this._normalizer = _normalizer;
        this._animations = {};
        this._playersById = {};
        this.players = [];
    }
    /**
     * @param {?} id
     * @param {?} metadata
     * @return {?}
     */
    TimelineAnimationEngine.prototype.register = function (id, metadata) {
        var /** @type {?} */ errors = [];
        var /** @type {?} */ ast = buildAnimationAst(metadata, errors);
        if (errors.length) {
            throw new Error("Unable to build the animation due to the following errors: " + errors.join("\n"));
        }
        else {
            this._animations[id] = ast;
        }
    };
    /**
     * @param {?} i
     * @param {?} preStyles
     * @param {?=} postStyles
     * @return {?}
     */
    TimelineAnimationEngine.prototype._buildPlayer = function (i, preStyles, postStyles) {
        var /** @type {?} */ element = i.element;
        var /** @type {?} */ keyframes = normalizeKeyframes(this._driver, this._normalizer, element, i.keyframes, preStyles, postStyles);
        return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, []);
    };
    /**
     * @param {?} id
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    TimelineAnimationEngine.prototype.create = function (id, element, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var /** @type {?} */ errors = [];
        var /** @type {?} */ ast = this._animations[id];
        var /** @type {?} */ instructions;
        var /** @type {?} */ autoStylesMap = new Map();
        if (ast) {
            instructions = buildAnimationTimelines(this._driver, element, ast, {}, {}, options, EMPTY_INSTRUCTION_MAP, errors);
            instructions.forEach(function (inst) {
                var /** @type {?} */ styles = getOrSetAsInMap(autoStylesMap, inst.element, {});
                inst.postStyleProps.forEach(function (prop) { return styles[prop] = null; });
            });
        }
        else {
            errors.push('The requested animation doesn\'t exist or has already been destroyed');
            instructions = [];
        }
        if (errors.length) {
            throw new Error("Unable to create the animation due to the following errors: " + errors.join("\n"));
        }
        autoStylesMap.forEach(function (styles, element) {
            Object.keys(styles).forEach(function (prop) { styles[prop] = _this._driver.computeStyle(element, prop, _angular_animations.AUTO_STYLE); });
        });
        var /** @type {?} */ players = instructions.map(function (i) {
            var /** @type {?} */ styles = autoStylesMap.get(i.element);
            return _this._buildPlayer(i, {}, styles);
        });
        var /** @type {?} */ player = optimizeGroupPlayer(players);
        this._playersById[id] = player;
        player.onDestroy(function () { return _this.destroy(id); });
        this.players.push(player);
        return player;
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TimelineAnimationEngine.prototype.destroy = function (id) {
        var /** @type {?} */ player = this._getPlayer(id);
        player.destroy();
        delete this._playersById[id];
        var /** @type {?} */ index = this.players.indexOf(player);
        if (index >= 0) {
            this.players.splice(index, 1);
        }
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TimelineAnimationEngine.prototype._getPlayer = function (id) {
        var /** @type {?} */ player = this._playersById[id];
        if (!player) {
            throw new Error("Unable to find the timeline player referenced by " + id);
        }
        return player;
    };
    /**
     * @param {?} id
     * @param {?} element
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    TimelineAnimationEngine.prototype.listen = function (id, element, eventName, callback) {
        // triggerName, fromState, toState are all ignored for timeline animations
        var /** @type {?} */ baseEvent = makeAnimationEvent(element, '', '', '');
        listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);
        return function () { };
    };
    /**
     * @param {?} id
     * @param {?} element
     * @param {?} command
     * @param {?} args
     * @return {?}
     */
    TimelineAnimationEngine.prototype.command = function (id, element, command, args) {
        if (command == 'register') {
            this.register(id, /** @type {?} */ (args[0]));
            return;
        }
        if (command == 'create') {
            var /** @type {?} */ options = ((args[0] || {}));
            this.create(id, element, options);
            return;
        }
        var /** @type {?} */ player = this._getPlayer(id);
        switch (command) {
            case 'play':
                player.play();
                break;
            case 'pause':
                player.pause();
                break;
            case 'reset':
                player.reset();
                break;
            case 'restart':
                player.restart();
                break;
            case 'finish':
                player.finish();
                break;
            case 'init':
                player.init();
                break;
            case 'setPosition':
                player.setPosition(parseFloat(/** @type {?} */ (args[0])));
                break;
            case 'destroy':
                this.destroy(id);
                break;
        }
    };
    return TimelineAnimationEngine;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var QUEUED_CLASSNAME = 'ng-animate-queued';
var QUEUED_SELECTOR = '.ng-animate-queued';
var DISABLED_CLASSNAME = 'ng-animate-disabled';
var DISABLED_SELECTOR = '.ng-animate-disabled';
var EMPTY_PLAYER_ARRAY = [];
var NULL_REMOVAL_STATE = {
    namespaceId: '',
    setForRemoval: null,
    hasAnimation: false,
    removedBeforeQueried: false
};
var NULL_REMOVED_QUERIED_STATE = {
    namespaceId: '',
    setForRemoval: null,
    hasAnimation: false,
    removedBeforeQueried: true
};
var REMOVAL_FLAG = '__ng_removed';
var StateValue = (function () {
    /**
     * @param {?} input
     */
    function StateValue(input) {
        var isObj = input && input.hasOwnProperty('value');
        var value = isObj ? input['value'] : input;
        this.value = normalizeTriggerValue(value);
        if (isObj) {
            var options = copyObj(input);
            delete options['value'];
            this.options = options;
        }
        else {
            this.options = {};
        }
        if (!this.options.params) {
            this.options.params = {};
        }
    }
    Object.defineProperty(StateValue.prototype, "params", {
        /**
         * @return {?}
         */
        get: function () { return (this.options.params); },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} options
     * @return {?}
     */
    StateValue.prototype.absorbOptions = function (options) {
        var /** @type {?} */ newParams = options.params;
        if (newParams) {
            var /** @type {?} */ oldParams_2 = ((this.options.params));
            Object.keys(newParams).forEach(function (prop) {
                if (oldParams_2[prop] == null) {
                    oldParams_2[prop] = newParams[prop];
                }
            });
        }
    };
    return StateValue;
}());
var VOID_VALUE = 'void';
var DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);
var DELETED_STATE_VALUE = new StateValue('DELETED');
var AnimationTransitionNamespace = (function () {
    /**
     * @param {?} id
     * @param {?} hostElement
     * @param {?} _engine
     */
    function AnimationTransitionNamespace(id, hostElement, _engine) {
        this.id = id;
        this.hostElement = hostElement;
        this._engine = _engine;
        this.players = [];
        this._triggers = {};
        this._queue = [];
        this._elementListeners = new Map();
        this._hostClassName = 'ng-tns-' + id;
        addClass(hostElement, this._hostClassName);
    }
    /**
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.listen = function (element, name, phase, callback) {
        var _this = this;
        if (!this._triggers.hasOwnProperty(name)) {
            throw new Error("Unable to listen on the animation trigger event \"" + phase + "\" because the animation trigger \"" + name + "\" doesn't exist!");
        }
        if (phase == null || phase.length == 0) {
            throw new Error("Unable to listen on the animation trigger \"" + name + "\" because the provided event is undefined!");
        }
        if (!isTriggerEventValid(phase)) {
            throw new Error("The provided animation trigger event \"" + phase + "\" for the animation trigger \"" + name + "\" is not supported!");
        }
        var /** @type {?} */ listeners = getOrSetAsInMap(this._elementListeners, element, []);
        var /** @type {?} */ data = { name: name, phase: phase, callback: callback };
        listeners.push(data);
        var /** @type {?} */ triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});
        if (!triggersWithStates.hasOwnProperty(name)) {
            addClass(element, NG_TRIGGER_CLASSNAME);
            addClass(element, NG_TRIGGER_CLASSNAME + '-' + name);
            triggersWithStates[name] = null;
        }
        return function () {
            // the event listener is removed AFTER the flush has occurred such
            // that leave animations callbacks can fire (otherwise if the node
            // is removed in between then the listeners would be deregistered)
            _this._engine.afterFlush(function () {
                var /** @type {?} */ index = listeners.indexOf(data);
                if (index >= 0) {
                    listeners.splice(index, 1);
                }
                if (!_this._triggers[name]) {
                    delete triggersWithStates[name];
                }
            });
        };
    };
    /**
     * @param {?} name
     * @param {?} ast
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.register = function (name, ast) {
        if (this._triggers[name]) {
            // throw
            return false;
        }
        else {
            this._triggers[name] = ast;
            return true;
        }
    };
    /**
     * @param {?} name
     * @return {?}
     */
    AnimationTransitionNamespace.prototype._getTrigger = function (name) {
        var /** @type {?} */ trigger = this._triggers[name];
        if (!trigger) {
            throw new Error("The provided animation trigger \"" + name + "\" has not been registered!");
        }
        return trigger;
    };
    /**
     * @param {?} element
     * @param {?} triggerName
     * @param {?} value
     * @param {?=} defaultToFallback
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.trigger = function (element, triggerName, value, defaultToFallback) {
        var _this = this;
        if (defaultToFallback === void 0) { defaultToFallback = true; }
        var /** @type {?} */ trigger = this._getTrigger(triggerName);
        var /** @type {?} */ player = new TransitionAnimationPlayer(this.id, triggerName, element);
        var /** @type {?} */ triggersWithStates = this._engine.statesByElement.get(element);
        if (!triggersWithStates) {
            addClass(element, NG_TRIGGER_CLASSNAME);
            addClass(element, NG_TRIGGER_CLASSNAME + '-' + triggerName);
            this._engine.statesByElement.set(element, triggersWithStates = {});
        }
        var /** @type {?} */ fromState = triggersWithStates[triggerName];
        var /** @type {?} */ toState = new StateValue(value);
        var /** @type {?} */ isObj = value && value.hasOwnProperty('value');
        if (!isObj && fromState) {
            toState.absorbOptions(fromState.options);
        }
        triggersWithStates[triggerName] = toState;
        if (!fromState) {
            fromState = DEFAULT_STATE_VALUE;
        }
        else if (fromState === DELETED_STATE_VALUE) {
            return player;
        }
        var /** @type {?} */ isRemoval = toState.value === VOID_VALUE;
        // normally this isn't reached by here, however, if an object expression
        // is passed in then it may be a new object each time. Comparing the value
        // is important since that will stay the same despite there being a new object.
        // The removal arc here is special cased because the same element is triggered
        // twice in the event that it contains animations on the outer/inner portions
        // of the host container
        if (!isRemoval && fromState.value === toState.value) {
            // this means that despite the value not changing, some inner params
            // have changed which means that the animation final styles need to be applied
            if (!objEquals(fromState.params, toState.params)) {
                var /** @type {?} */ errors = [];
                var /** @type {?} */ fromStyles_1 = trigger.matchStyles(fromState.value, fromState.params, errors);
                var /** @type {?} */ toStyles_1 = trigger.matchStyles(toState.value, toState.params, errors);
                if (errors.length) {
                    this._engine.reportError(errors);
                }
                else {
                    this._engine.afterFlush(function () {
                        eraseStyles(element, fromStyles_1);
                        setStyles(element, toStyles_1);
                    });
                }
            }
            return;
        }
        var /** @type {?} */ playersOnElement = getOrSetAsInMap(this._engine.playersByElement, element, []);
        playersOnElement.forEach(function (player) {
            // only remove the player if it is queued on the EXACT same trigger/namespace
            // we only also deal with queued players here because if the animation has
            // started then we want to keep the player alive until the flush happens
            // (which is where the previousPlayers are passed into the new palyer)
            if (player.namespaceId == _this.id && player.triggerName == triggerName && player.queued) {
                player.destroy();
            }
        });
        var /** @type {?} */ transition = trigger.matchTransition(fromState.value, toState.value);
        var /** @type {?} */ isFallbackTransition = false;
        if (!transition) {
            if (!defaultToFallback)
                return;
            transition = trigger.fallbackTransition;
            isFallbackTransition = true;
        }
        this._engine.totalQueuedPlayers++;
        this._queue.push({ element: element, triggerName: triggerName, transition: transition, fromState: fromState, toState: toState, player: player, isFallbackTransition: isFallbackTransition });
        if (!isFallbackTransition) {
            addClass(element, QUEUED_CLASSNAME);
            player.onStart(function () { removeClass(element, QUEUED_CLASSNAME); });
        }
        player.onDone(function () {
            var /** @type {?} */ index = _this.players.indexOf(player);
            if (index >= 0) {
                _this.players.splice(index, 1);
            }
            var /** @type {?} */ players = _this._engine.playersByElement.get(element);
            if (players) {
                var /** @type {?} */ index_1 = players.indexOf(player);
                if (index_1 >= 0) {
                    players.splice(index_1, 1);
                }
            }
        });
        this.players.push(player);
        playersOnElement.push(player);
        return player;
    };
    /**
     * @param {?} name
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.deregister = function (name) {
        var _this = this;
        delete this._triggers[name];
        this._engine.statesByElement.forEach(function (stateMap, element) { delete stateMap[name]; });
        this._elementListeners.forEach(function (listeners, element) {
            _this._elementListeners.set(element, listeners.filter(function (entry) { return entry.name != name; }));
        });
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.clearElementCache = function (element) {
        this._engine.statesByElement.delete(element);
        this._elementListeners.delete(element);
        var /** @type {?} */ elementPlayers = this._engine.playersByElement.get(element);
        if (elementPlayers) {
            elementPlayers.forEach(function (player) { return player.destroy(); });
            this._engine.playersByElement.delete(element);
        }
    };
    /**
     * @param {?} rootElement
     * @param {?} context
     * @param {?=} animate
     * @return {?}
     */
    AnimationTransitionNamespace.prototype._destroyInnerNodes = function (rootElement, context, animate) {
        var _this = this;
        if (animate === void 0) { animate = false; }
        this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true).forEach(function (elm) {
            if (animate && containsClass(elm, _this._hostClassName)) {
                var /** @type {?} */ innerNs = _this._engine.namespacesByHostElement.get(elm);
                // special case for a host element with animations on the same element
                if (innerNs) {
                    innerNs.removeNode(elm, context, true);
                }
                _this.removeNode(elm, context, true);
            }
            else {
                _this.clearElementCache(elm);
            }
        });
    };
    /**
     * @param {?} element
     * @param {?} context
     * @param {?=} doNotRecurse
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.removeNode = function (element, context, doNotRecurse) {
        var _this = this;
        var /** @type {?} */ engine = this._engine;
        if (!doNotRecurse && element.childElementCount) {
            this._destroyInnerNodes(element, context, true);
        }
        var /** @type {?} */ triggerStates = engine.statesByElement.get(element);
        if (triggerStates) {
            var /** @type {?} */ players_1 = [];
            Object.keys(triggerStates).forEach(function (triggerName) {
                // this check is here in the event that an element is removed
                // twice (both on the host level and the component level)
                if (_this._triggers[triggerName]) {
                    var /** @type {?} */ player = _this.trigger(element, triggerName, VOID_VALUE, false);
                    if (player) {
                        players_1.push(player);
                    }
                }
            });
            if (players_1.length) {
                engine.markElementAsRemoved(this.id, element, true, context);
                optimizeGroupPlayer(players_1).onDone(function () { return engine.processLeaveNode(element); });
                return;
            }
        }
        // find the player that is animating and make sure that the
        // removal is delayed until that player has completed
        var /** @type {?} */ containsPotentialParentTransition = false;
        if (engine.totalAnimations) {
            var /** @type {?} */ currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];
            // when this `if statement` does not continue forward it means that
            // a previous animation query has selected the current element and
            // is animating it. In this situation want to continue fowards and
            // allow the element to be queued up for animation later.
            if (currentPlayers && currentPlayers.length) {
                containsPotentialParentTransition = true;
            }
            else {
                var /** @type {?} */ parent = element;
                while (parent = parent.parentNode) {
                    var /** @type {?} */ triggers = engine.statesByElement.get(parent);
                    if (triggers) {
                        containsPotentialParentTransition = true;
                        break;
                    }
                }
            }
        }
        // at this stage we know that the element will either get removed
        // during flush or will be picked up by a parent query. Either way
        // we need to fire the listeners for this element when it DOES get
        // removed (once the query parent animation is done or after flush)
        var /** @type {?} */ listeners = this._elementListeners.get(element);
        if (listeners) {
            var /** @type {?} */ visitedTriggers_1 = new Set();
            listeners.forEach(function (listener) {
                var /** @type {?} */ triggerName = listener.name;
                if (visitedTriggers_1.has(triggerName))
                    return;
                visitedTriggers_1.add(triggerName);
                var /** @type {?} */ trigger = _this._triggers[triggerName];
                var /** @type {?} */ transition = trigger.fallbackTransition;
                var /** @type {?} */ elementStates = ((engine.statesByElement.get(element)));
                var /** @type {?} */ fromState = elementStates[triggerName] || DEFAULT_STATE_VALUE;
                var /** @type {?} */ toState = new StateValue(VOID_VALUE);
                var /** @type {?} */ player = new TransitionAnimationPlayer(_this.id, triggerName, element);
                _this._engine.totalQueuedPlayers++;
                _this._queue.push({
                    element: element,
                    triggerName: triggerName,
                    transition: transition,
                    fromState: fromState,
                    toState: toState,
                    player: player,
                    isFallbackTransition: true
                });
            });
        }
        // whether or not a parent has an animation we need to delay the deferral of the leave
        // operation until we have more information (which we do after flush() has been called)
        if (containsPotentialParentTransition) {
            engine.markElementAsRemoved(this.id, element, false, context);
        }
        else {
            // we do this after the flush has occurred such
            // that the callbacks can be fired
            engine.afterFlush(function () { return _this.clearElementCache(element); });
            engine.destroyInnerAnimations(element);
            engine._onRemovalComplete(element, context);
        }
    };
    /**
     * @param {?} element
     * @param {?} parent
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.insertNode = function (element, parent) { addClass(element, this._hostClassName); };
    /**
     * @param {?} microtaskId
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.drainQueuedTransitions = function (microtaskId) {
        var _this = this;
        var /** @type {?} */ instructions = [];
        this._queue.forEach(function (entry) {
            var /** @type {?} */ player = entry.player;
            if (player.destroyed)
                return;
            var /** @type {?} */ element = entry.element;
            var /** @type {?} */ listeners = _this._elementListeners.get(element);
            if (listeners) {
                listeners.forEach(function (listener) {
                    if (listener.name == entry.triggerName) {
                        var /** @type {?} */ baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);
                        ((baseEvent))['_data'] = microtaskId;
                        listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);
                    }
                });
            }
            if (player.markedForDestroy) {
                _this._engine.afterFlush(function () {
                    // now we can destroy the element properly since the event listeners have
                    // been bound to the player
                    player.destroy();
                });
            }
            else {
                instructions.push(entry);
            }
        });
        this._queue = [];
        return instructions.sort(function (a, b) {
            // if depCount == 0 them move to front
            // otherwise if a contains b then move back
            var /** @type {?} */ d0 = a.transition.ast.depCount;
            var /** @type {?} */ d1 = b.transition.ast.depCount;
            if (d0 == 0 || d1 == 0) {
                return d0 - d1;
            }
            return _this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;
        });
    };
    /**
     * @param {?} context
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.destroy = function (context) {
        this.players.forEach(function (p) { return p.destroy(); });
        this._destroyInnerNodes(this.hostElement, context);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.elementContainsData = function (element) {
        var /** @type {?} */ containsData = false;
        if (this._elementListeners.has(element))
            containsData = true;
        containsData =
            (this._queue.find(function (entry) { return entry.element === element; }) ? true : false) || containsData;
        return containsData;
    };
    return AnimationTransitionNamespace;
}());
var TransitionAnimationEngine = (function () {
    /**
     * @param {?} driver
     * @param {?} _normalizer
     */
    function TransitionAnimationEngine(driver, _normalizer) {
        this.driver = driver;
        this._normalizer = _normalizer;
        this.players = [];
        this.newHostElements = new Map();
        this.playersByElement = new Map();
        this.playersByQueriedElement = new Map();
        this.statesByElement = new Map();
        this.disabledNodes = new Set();
        this.totalAnimations = 0;
        this.totalQueuedPlayers = 0;
        this._namespaceLookup = {};
        this._namespaceList = [];
        this._flushFns = [];
        this._whenQuietFns = [];
        this.namespacesByHostElement = new Map();
        this.collectedEnterElements = [];
        this.collectedLeaveElements = [];
        this.onRemovalComplete = function (element, context) { };
    }
    /**
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype._onRemovalComplete = function (element, context) { this.onRemovalComplete(element, context); };
    Object.defineProperty(TransitionAnimationEngine.prototype, "queuedPlayers", {
        /**
         * @return {?}
         */
        get: function () {
            var /** @type {?} */ players = [];
            this._namespaceList.forEach(function (ns) {
                ns.players.forEach(function (player) {
                    if (player.queued) {
                        players.push(player);
                    }
                });
            });
            return players;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype.createNamespace = function (namespaceId, hostElement) {
        var /** @type {?} */ ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);
        if (hostElement.parentNode) {
            this._balanceNamespaceList(ns, hostElement);
        }
        else {
            // defer this later until flush during when the host element has
            // been inserted so that we know exactly where to place it in
            // the namespace list
            this.newHostElements.set(hostElement, ns);
            // given that this host element is apart of the animation code, it
            // may or may not be inserted by a parent node that is an of an
            // animation renderer type. If this happens then we can still have
            // access to this item when we query for :enter nodes. If the parent
            // is a renderer then the set data-structure will normalize the entry
            this.collectEnterElement(hostElement);
        }
        return this._namespaceLookup[namespaceId] = ns;
    };
    /**
     * @param {?} ns
     * @param {?} hostElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype._balanceNamespaceList = function (ns, hostElement) {
        var /** @type {?} */ limit = this._namespaceList.length - 1;
        if (limit >= 0) {
            var /** @type {?} */ found = false;
            for (var /** @type {?} */ i = limit; i >= 0; i--) {
                var /** @type {?} */ nextNamespace = this._namespaceList[i];
                if (this.driver.containsElement(nextNamespace.hostElement, hostElement)) {
                    this._namespaceList.splice(i + 1, 0, ns);
                    found = true;
                    break;
                }
            }
            if (!found) {
                this._namespaceList.splice(0, 0, ns);
            }
        }
        else {
            this._namespaceList.push(ns);
        }
        this.namespacesByHostElement.set(hostElement, ns);
        return ns;
    };
    /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype.register = function (namespaceId, hostElement) {
        var /** @type {?} */ ns = this._namespaceLookup[namespaceId];
        if (!ns) {
            ns = this.createNamespace(namespaceId, hostElement);
        }
        return ns;
    };
    /**
     * @param {?} namespaceId
     * @param {?} name
     * @param {?} trigger
     * @return {?}
     */
    TransitionAnimationEngine.prototype.registerTrigger = function (namespaceId, name, trigger) {
        var /** @type {?} */ ns = this._namespaceLookup[namespaceId];
        if (ns && ns.register(name, trigger)) {
            this.totalAnimations++;
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype.destroy = function (namespaceId, context) {
        var _this = this;
        if (!namespaceId)
            return;
        var /** @type {?} */ ns = this._fetchNamespace(namespaceId);
        this.afterFlush(function () {
            _this.namespacesByHostElement.delete(ns.hostElement);
            delete _this._namespaceLookup[namespaceId];
            var /** @type {?} */ index = _this._namespaceList.indexOf(ns);
            if (index >= 0) {
                _this._namespaceList.splice(index, 1);
            }
        });
        this.afterFlushAnimationsDone(function () { return ns.destroy(context); });
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TransitionAnimationEngine.prototype._fetchNamespace = function (id) { return this._namespaceLookup[id]; };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    TransitionAnimationEngine.prototype.trigger = function (namespaceId, element, name, value) {
        if (isElementNode(element)) {
            this._fetchNamespace(namespaceId).trigger(element, name, value);
            return true;
        }
        return false;
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    TransitionAnimationEngine.prototype.insertNode = function (namespaceId, element, parent, insertBefore) {
        if (!isElementNode(element))
            return;
        // special case for when an element is removed and reinserted (move operation)
        // when this occurs we do not want to use the element for deletion later
        var /** @type {?} */ details = (element[REMOVAL_FLAG]);
        if (details && details.setForRemoval) {
            details.setForRemoval = false;
        }
        // in the event that the namespaceId is blank then the caller
        // code does not contain any animation code in it, but it is
        // just being called so that the node is marked as being inserted
        if (namespaceId) {
            this._fetchNamespace(namespaceId).insertNode(element, parent);
        }
        // only *directives and host elements are inserted before
        if (insertBefore) {
            this.collectEnterElement(element);
        }
    };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.collectEnterElement = function (element) { this.collectedEnterElements.push(element); };
    /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    TransitionAnimationEngine.prototype.markElementAsDisabled = function (element, value) {
        if (value) {
            if (!this.disabledNodes.has(element)) {
                this.disabledNodes.add(element);
                addClass(element, DISABLED_CLASSNAME);
            }
        }
        else if (this.disabledNodes.has(element)) {
            this.disabledNodes.delete(element);
            removeClass(element, DISABLED_CLASSNAME);
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @param {?=} doNotRecurse
     * @return {?}
     */
    TransitionAnimationEngine.prototype.removeNode = function (namespaceId, element, context, doNotRecurse) {
        if (!isElementNode(element)) {
            this._onRemovalComplete(element, context);
            return;
        }
        var /** @type {?} */ ns = namespaceId ? this._fetchNamespace(namespaceId) : null;
        if (ns) {
            ns.removeNode(element, context, doNotRecurse);
        }
        else {
            this.markElementAsRemoved(namespaceId, element, false, context);
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?=} hasAnimation
     * @param {?=} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype.markElementAsRemoved = function (namespaceId, element, hasAnimation, context) {
        this.collectedLeaveElements.push(element);
        element[REMOVAL_FLAG] = {
            namespaceId: namespaceId,
            setForRemoval: context, hasAnimation: hasAnimation,
            removedBeforeQueried: false
        };
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationEngine.prototype.listen = function (namespaceId, element, name, phase, callback) {
        if (isElementNode(element)) {
            return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);
        }
        return function () { };
    };
    /**
     * @param {?} entry
     * @param {?} subTimelines
     * @return {?}
     */
    TransitionAnimationEngine.prototype._buildInstruction = function (entry, subTimelines) {
        return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, entry.fromState.options, entry.toState.options, subTimelines);
    };
    /**
     * @param {?} containerElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype.destroyInnerAnimations = function (containerElement) {
        var _this = this;
        var /** @type {?} */ elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);
        elements.forEach(function (element) {
            var /** @type {?} */ players = _this.playersByElement.get(element);
            if (players) {
                players.forEach(function (player) {
                    // special case for when an element is set for destruction, but hasn't started.
                    // in this situation we want to delay the destruction until the flush occurs
                    // so that any event listeners attached to the player are triggered.
                    if (player.queued) {
                        player.markedForDestroy = true;
                    }
                    else {
                        player.destroy();
                    }
                });
            }
            var /** @type {?} */ stateMap = _this.statesByElement.get(element);
            if (stateMap) {
                Object.keys(stateMap).forEach(function (triggerName) { return stateMap[triggerName] = DELETED_STATE_VALUE; });
            }
        });
        if (this.playersByQueriedElement.size == 0)
            return;
        elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);
        if (elements.length) {
            elements.forEach(function (element) {
                var /** @type {?} */ players = _this.playersByQueriedElement.get(element);
                if (players) {
                    players.forEach(function (player) { return player.finish(); });
                }
            });
        }
    };
    /**
     * @return {?}
     */
    TransitionAnimationEngine.prototype.whenRenderingDone = function () {
        var _this = this;
        return new Promise(function (resolve) {
            if (_this.players.length) {
                return optimizeGroupPlayer(_this.players).onDone(function () { return resolve(); });
            }
            else {
                resolve();
            }
        });
    };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.processLeaveNode = function (element) {
        var _this = this;
        var /** @type {?} */ details = (element[REMOVAL_FLAG]);
        if (details && details.setForRemoval) {
            // this will prevent it from removing it twice
            element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;
            if (details.namespaceId) {
                this.destroyInnerAnimations(element);
                var /** @type {?} */ ns = this._fetchNamespace(details.namespaceId);
                if (ns) {
                    ns.clearElementCache(element);
                }
            }
            this._onRemovalComplete(element, details.setForRemoval);
        }
        if (this.driver.matchesElement(element, DISABLED_SELECTOR)) {
            this.markElementAsDisabled(element, false);
        }
        this.driver.query(element, DISABLED_SELECTOR, true).forEach(function (node) {
            _this.markElementAsDisabled(element, false);
        });
    };
    /**
     * @param {?=} microtaskId
     * @return {?}
     */
    TransitionAnimationEngine.prototype.flush = function (microtaskId) {
        var _this = this;
        if (microtaskId === void 0) { microtaskId = -1; }
        var /** @type {?} */ players = [];
        if (this.newHostElements.size) {
            this.newHostElements.forEach(function (ns, element) { return _this._balanceNamespaceList(ns, element); });
            this.newHostElements.clear();
        }
        if (this._namespaceList.length &&
            (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
            var /** @type {?} */ cleanupFns = [];
            try {
                players = this._flushAnimations(cleanupFns, microtaskId);
            }
            finally {
                for (var /** @type {?} */ i = 0; i < cleanupFns.length; i++) {
                    cleanupFns[i]();
                }
            }
        }
        else {
            for (var /** @type {?} */ i = 0; i < this.collectedLeaveElements.length; i++) {
                var /** @type {?} */ element = this.collectedLeaveElements[i];
                this.processLeaveNode(element);
            }
        }
        this.totalQueuedPlayers = 0;
        this.collectedEnterElements.length = 0;
        this.collectedLeaveElements.length = 0;
        this._flushFns.forEach(function (fn) { return fn(); });
        this._flushFns = [];
        if (this._whenQuietFns.length) {
            // we move these over to a variable so that
            // if any new callbacks are registered in another
            // flush they do not populate the existing set
            var /** @type {?} */ quietFns_1 = this._whenQuietFns;
            this._whenQuietFns = [];
            if (players.length) {
                optimizeGroupPlayer(players).onDone(function () { quietFns_1.forEach(function (fn) { return fn(); }); });
            }
            else {
                quietFns_1.forEach(function (fn) { return fn(); });
            }
        }
    };
    /**
     * @param {?} errors
     * @return {?}
     */
    TransitionAnimationEngine.prototype.reportError = function (errors) {
        throw new Error("Unable to process animations due to the following failed trigger transitions\n " + errors.join("\n"));
    };
    /**
     * @param {?} cleanupFns
     * @param {?} microtaskId
     * @return {?}
     */
    TransitionAnimationEngine.prototype._flushAnimations = function (cleanupFns, microtaskId) {
        var _this = this;
        var /** @type {?} */ subTimelines = new ElementInstructionMap();
        var /** @type {?} */ skippedPlayers = [];
        var /** @type {?} */ skippedPlayersMap = new Map();
        var /** @type {?} */ queuedInstructions = [];
        var /** @type {?} */ queriedElements = new Map();
        var /** @type {?} */ allPreStyleElements = new Map();
        var /** @type {?} */ allPostStyleElements = new Map();
        var /** @type {?} */ disabledElementsSet = new Set();
        this.disabledNodes.forEach(function (node) {
            disabledElementsSet.add(node);
            var /** @type {?} */ nodesThatAreDisabled = _this.driver.query(node, QUEUED_SELECTOR, true);
            for (var /** @type {?} */ i = 0; i < nodesThatAreDisabled.length; i++) {
                disabledElementsSet.add(nodesThatAreDisabled[i]);
            }
        });
        var /** @type {?} */ bodyNode = getBodyNode();
        var /** @type {?} */ allEnterNodes = this.collectedEnterElements.length ?
            this.collectedEnterElements.filter(createIsRootFilterFn(this.collectedEnterElements)) :
            [];
        // this must occur before the instructions are built below such that
        // the :enter queries match the elements (since the timeline queries
        // are fired during instruction building).
        for (var /** @type {?} */ i = 0; i < allEnterNodes.length; i++) {
            addClass(allEnterNodes[i], ENTER_CLASSNAME);
        }
        var /** @type {?} */ allLeaveNodes = [];
        var /** @type {?} */ leaveNodesWithoutAnimations = [];
        for (var /** @type {?} */ i = 0; i < this.collectedLeaveElements.length; i++) {
            var /** @type {?} */ element = this.collectedLeaveElements[i];
            var /** @type {?} */ details = (element[REMOVAL_FLAG]);
            if (details && details.setForRemoval) {
                addClass(element, LEAVE_CLASSNAME);
                allLeaveNodes.push(element);
                if (!details.hasAnimation) {
                    leaveNodesWithoutAnimations.push(element);
                }
            }
        }
        cleanupFns.push(function () {
            allEnterNodes.forEach(function (element) { return removeClass(element, ENTER_CLASSNAME); });
            allLeaveNodes.forEach(function (element) {
                removeClass(element, LEAVE_CLASSNAME);
                _this.processLeaveNode(element);
            });
        });
        var /** @type {?} */ allPlayers = [];
        var /** @type {?} */ erroneousTransitions = [];
        for (var /** @type {?} */ i = this._namespaceList.length - 1; i >= 0; i--) {
            var /** @type {?} */ ns = this._namespaceList[i];
            ns.drainQueuedTransitions(microtaskId).forEach(function (entry) {
                var /** @type {?} */ player = entry.player;
                allPlayers.push(player);
                var /** @type {?} */ element = entry.element;
                if (!bodyNode || !_this.driver.containsElement(bodyNode, element)) {
                    player.destroy();
                    return;
                }
                var /** @type {?} */ instruction = ((_this._buildInstruction(entry, subTimelines)));
                if (instruction.errors && instruction.errors.length) {
                    erroneousTransitions.push(instruction);
                    return;
                }
                // if a unmatched transition is queued to go then it SHOULD NOT render
                // an animation and cancel the previously running animations.
                if (entry.isFallbackTransition) {
                    player.onStart(function () { return eraseStyles(element, instruction.fromStyles); });
                    player.onDestroy(function () { return setStyles(element, instruction.toStyles); });
                    skippedPlayers.push(player);
                    return;
                }
                // this means that if a parent animation uses this animation as a sub trigger
                // then it will instruct the timeline builder to not add a player delay, but
                // instead stretch the first keyframe gap up until the animation starts. The
                // reason this is important is to prevent extra initialization styles from being
                // required by the user in the animation.
                instruction.timelines.forEach(function (tl) { return tl.stretchStartingKeyframe = true; });
                subTimelines.append(element, instruction.timelines);
                var /** @type {?} */ tuple = { instruction: instruction, player: player, element: element };
                queuedInstructions.push(tuple);
                instruction.queriedElements.forEach(function (element) { return getOrSetAsInMap(queriedElements, element, []).push(player); });
                instruction.preStyleProps.forEach(function (stringMap, element) {
                    var /** @type {?} */ props = Object.keys(stringMap);
                    if (props.length) {
                        var /** @type {?} */ setVal_1 = ((allPreStyleElements.get(element)));
                        if (!setVal_1) {
                            allPreStyleElements.set(element, setVal_1 = new Set());
                        }
                        props.forEach(function (prop) { return setVal_1.add(prop); });
                    }
                });
                instruction.postStyleProps.forEach(function (stringMap, element) {
                    var /** @type {?} */ props = Object.keys(stringMap);
                    var /** @type {?} */ setVal = ((allPostStyleElements.get(element)));
                    if (!setVal) {
                        allPostStyleElements.set(element, setVal = new Set());
                    }
                    props.forEach(function (prop) { return setVal.add(prop); });
                });
            });
        }
        if (erroneousTransitions.length) {
            var /** @type {?} */ errors_1 = [];
            erroneousTransitions.forEach(function (instruction) {
                errors_1.push("@" + instruction.triggerName + " has failed due to:\n"); /** @type {?} */
                ((instruction.errors)).forEach(function (error) { return errors_1.push("- " + error + "\n"); });
            });
            allPlayers.forEach(function (player) { return player.destroy(); });
            this.reportError(errors_1);
        }
        // these can only be detected here since we have a map of all the elements
        // that have animations attached to them...
        var /** @type {?} */ enterNodesWithoutAnimations = [];
        for (var /** @type {?} */ i = 0; i < allEnterNodes.length; i++) {
            var /** @type {?} */ element = allEnterNodes[i];
            if (!subTimelines.has(element)) {
                enterNodesWithoutAnimations.push(element);
            }
        }
        var /** @type {?} */ allPreviousPlayersMap = new Map();
        var /** @type {?} */ sortedParentElements = [];
        queuedInstructions.forEach(function (entry) {
            var /** @type {?} */ element = entry.element;
            if (subTimelines.has(element)) {
                sortedParentElements.unshift(element);
                _this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);
            }
        });
        skippedPlayers.forEach(function (player) {
            var /** @type {?} */ element = player.element;
            var /** @type {?} */ previousPlayers = _this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);
            previousPlayers.forEach(function (prevPlayer) {
                getOrSetAsInMap(allPreviousPlayersMap, element, []).push(prevPlayer);
                prevPlayer.destroy();
            });
        });
        // this is a special case for nodes that will be removed (either by)
        // having their own leave animations or by being queried in a container
        // that will be removed once a parent animation is complete. The idea
        // here is that * styles must be identical to ! styles because of
        // backwards compatibility (* is also filled in by default in many places).
        // Otherwise * styles will return an empty value or auto since the element
        // that is being getComputedStyle'd will not be visible (since * = destination)
        var /** @type {?} */ replaceNodes = allLeaveNodes.filter(function (node) {
            return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);
        });
        // POST STAGE: fill the * styles
        var _a = cloakAndComputeStyles(this.driver, leaveNodesWithoutAnimations, allPostStyleElements, _angular_animations.AUTO_STYLE), postStylesMap = _a[0], allLeaveQueriedNodes = _a[1];
        allLeaveQueriedNodes.forEach(function (node) {
            if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {
                replaceNodes.push(node);
            }
        });
        // PRE STAGE: fill the ! styles
        var preStylesMap = (allPreStyleElements.size ?
            cloakAndComputeStyles(this.driver, enterNodesWithoutAnimations, allPreStyleElements, _angular_animations.PRE_STYLE) :
            [new Map()])[0];
        replaceNodes.forEach(function (node) {
            var /** @type {?} */ post = postStylesMap.get(node);
            var /** @type {?} */ pre = preStylesMap.get(node);
            postStylesMap.set(node, /** @type {?} */ (Object.assign({}, post, pre)));
        });
        var /** @type {?} */ rootPlayers = [];
        var /** @type {?} */ subPlayers = [];
        queuedInstructions.forEach(function (entry) {
            var element = entry.element, player = entry.player, instruction = entry.instruction;
            // this means that it was never consumed by a parent animation which
            // means that it is independent and therefore should be set for animation
            if (subTimelines.has(element)) {
                if (disabledElementsSet.has(element)) {
                    skippedPlayers.push(player);
                    return;
                }
                var /** @type {?} */ innerPlayer = _this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);
                player.setRealPlayer(innerPlayer);
                var /** @type {?} */ parentHasPriority = null;
                for (var /** @type {?} */ i = 0; i < sortedParentElements.length; i++) {
                    var /** @type {?} */ parent = sortedParentElements[i];
                    if (parent === element)
                        break;
                    if (_this.driver.containsElement(parent, element)) {
                        parentHasPriority = parent;
                        break;
                    }
                }
                if (parentHasPriority) {
                    var /** @type {?} */ parentPlayers = _this.playersByElement.get(parentHasPriority);
                    if (parentPlayers && parentPlayers.length) {
                        player.parentPlayer = optimizeGroupPlayer(parentPlayers);
                    }
                    skippedPlayers.push(player);
                }
                else {
                    rootPlayers.push(player);
                }
            }
            else {
                eraseStyles(element, instruction.fromStyles);
                player.onDestroy(function () { return setStyles(element, instruction.toStyles); });
                // there still might be a ancestor player animating this
                // element therefore we will still add it as a sub player
                // even if its animation may be disabled
                subPlayers.push(player);
                if (disabledElementsSet.has(element)) {
                    skippedPlayers.push(player);
                }
            }
        });
        // find all of the sub players' corresponding inner animation player
        subPlayers.forEach(function (player) {
            // even if any players are not found for a sub animation then it
            // will still complete itself after the next tick since it's Noop
            var /** @type {?} */ playersForElement = skippedPlayersMap.get(player.element);
            if (playersForElement && playersForElement.length) {
                var /** @type {?} */ innerPlayer = optimizeGroupPlayer(playersForElement);
                player.setRealPlayer(innerPlayer);
            }
        });
        // the reason why we don't actually play the animation is
        // because all that a skipped player is designed to do is to
        // fire the start/done transition callback events
        skippedPlayers.forEach(function (player) {
            if (player.parentPlayer) {
                player.parentPlayer.onDestroy(function () { return player.destroy(); });
            }
            else {
                player.destroy();
            }
        });
        // run through all of the queued removals and see if they
        // were picked up by a query. If not then perform the removal
        // operation right away unless a parent animation is ongoing.
        for (var /** @type {?} */ i = 0; i < allLeaveNodes.length; i++) {
            var /** @type {?} */ element = allLeaveNodes[i];
            var /** @type {?} */ details = (element[REMOVAL_FLAG]);
            removeClass(element, LEAVE_CLASSNAME);
            // this means the element has a removal animation that is being
            // taken care of and therefore the inner elements will hang around
            // until that animation is over (or the parent queried animation)
            if (details && details.hasAnimation)
                continue;
            var /** @type {?} */ players = [];
            // if this element is queried or if it contains queried children
            // then we want for the element not to be removed from the page
            // until the queried animations have finished
            if (queriedElements.size) {
                var /** @type {?} */ queriedPlayerResults = queriedElements.get(element);
                if (queriedPlayerResults && queriedPlayerResults.length) {
                    players.push.apply(players, queriedPlayerResults);
                }
                var /** @type {?} */ queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);
                for (var /** @type {?} */ j = 0; j < queriedInnerElements.length; j++) {
                    var /** @type {?} */ queriedPlayers = queriedElements.get(queriedInnerElements[j]);
                    if (queriedPlayers && queriedPlayers.length) {
                        players.push.apply(players, queriedPlayers);
                    }
                }
            }
            var /** @type {?} */ activePlayers = players.filter(function (p) { return !p.destroyed; });
            if (activePlayers.length) {
                removeNodesAfterAnimationDone(this, element, activePlayers);
            }
            else {
                this.processLeaveNode(element);
            }
        }
        // this is required so the cleanup method doesn't remove them
        allLeaveNodes.length = 0;
        rootPlayers.forEach(function (player) {
            _this.players.push(player);
            player.onDone(function () {
                player.destroy();
                var /** @type {?} */ index = _this.players.indexOf(player);
                _this.players.splice(index, 1);
            });
            player.play();
        });
        return rootPlayers;
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.elementContainsData = function (namespaceId, element) {
        var /** @type {?} */ containsData = false;
        var /** @type {?} */ details = (element[REMOVAL_FLAG]);
        if (details && details.setForRemoval)
            containsData = true;
        if (this.playersByElement.has(element))
            containsData = true;
        if (this.playersByQueriedElement.has(element))
            containsData = true;
        if (this.statesByElement.has(element))
            containsData = true;
        return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;
    };
    /**
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationEngine.prototype.afterFlush = function (callback) { this._flushFns.push(callback); };
    /**
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationEngine.prototype.afterFlushAnimationsDone = function (callback) { this._whenQuietFns.push(callback); };
    /**
     * @param {?} element
     * @param {?} isQueriedElement
     * @param {?=} namespaceId
     * @param {?=} triggerName
     * @param {?=} toStateValue
     * @return {?}
     */
    TransitionAnimationEngine.prototype._getPreviousPlayers = function (element, isQueriedElement, namespaceId, triggerName, toStateValue) {
        var /** @type {?} */ players = [];
        if (isQueriedElement) {
            var /** @type {?} */ queriedElementPlayers = this.playersByQueriedElement.get(element);
            if (queriedElementPlayers) {
                players = queriedElementPlayers;
            }
        }
        else {
            var /** @type {?} */ elementPlayers = this.playersByElement.get(element);
            if (elementPlayers) {
                var /** @type {?} */ isRemovalAnimation_1 = !toStateValue || toStateValue == VOID_VALUE;
                elementPlayers.forEach(function (player) {
                    if (player.queued)
                        return;
                    if (!isRemovalAnimation_1 && player.triggerName != triggerName)
                        return;
                    players.push(player);
                });
            }
        }
        if (namespaceId || triggerName) {
            players = players.filter(function (player) {
                if (namespaceId && namespaceId != player.namespaceId)
                    return false;
                if (triggerName && triggerName != player.triggerName)
                    return false;
                return true;
            });
        }
        return players;
    };
    /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @return {?}
     */
    TransitionAnimationEngine.prototype._beforeAnimationBuild = function (namespaceId, instruction, allPreviousPlayersMap) {
        var _this = this;
        var /** @type {?} */ triggerName = instruction.triggerName;
        var /** @type {?} */ rootElement = instruction.element;
        // when a removal animation occurs, ALL previous players are collected
        // and destroyed (even if they are outside of the current namespace)
        var /** @type {?} */ targetNameSpaceId = instruction.isRemovalTransition ? undefined : namespaceId;
        var /** @type {?} */ targetTriggerName = instruction.isRemovalTransition ? undefined : triggerName;
        instruction.timelines.map(function (timelineInstruction) {
            var /** @type {?} */ element = timelineInstruction.element;
            var /** @type {?} */ isQueriedElement = element !== rootElement;
            var /** @type {?} */ players = getOrSetAsInMap(allPreviousPlayersMap, element, []);
            var /** @type {?} */ previousPlayers = _this._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);
            previousPlayers.forEach(function (player) {
                var /** @type {?} */ realPlayer = (player.getRealPlayer());
                if (realPlayer.beforeDestroy) {
                    realPlayer.beforeDestroy();
                }
                player.destroy();
                players.push(player);
            });
        });
        // this needs to be done so that the PRE/POST styles can be
        // computed properly without interfering with the previous animation
        eraseStyles(rootElement, instruction.fromStyles);
    };
    /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @param {?} skippedPlayersMap
     * @param {?} preStylesMap
     * @param {?} postStylesMap
     * @return {?}
     */
    TransitionAnimationEngine.prototype._buildAnimation = function (namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {
        var _this = this;
        var /** @type {?} */ triggerName = instruction.triggerName;
        var /** @type {?} */ rootElement = instruction.element;
        // we first run this so that the previous animation player
        // data can be passed into the successive animation players
        var /** @type {?} */ allQueriedPlayers = [];
        var /** @type {?} */ allConsumedElements = new Set();
        var /** @type {?} */ allSubElements = new Set();
        var /** @type {?} */ allNewPlayers = instruction.timelines.map(function (timelineInstruction) {
            var /** @type {?} */ element = timelineInstruction.element;
            allConsumedElements.add(element);
            // FIXME (matsko): make sure to-be-removed animations are removed properly
            var /** @type {?} */ details = element[REMOVAL_FLAG];
            if (details && details.removedBeforeQueried)
                return new _angular_animations.NoopAnimationPlayer();
            var /** @type {?} */ isQueriedElement = element !== rootElement;
            var /** @type {?} */ previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY)
                .map(function (p) { return p.getRealPlayer(); }))
                .filter(function (p) {
                // the `element` is not apart of the AnimationPlayer definition, but
                // Mock/WebAnimations
                // use the element within their implementation. This will be added in Angular5 to
                // AnimationPlayer
                var /** @type {?} */ pp = (p);
                return pp.element ? pp.element === element : false;
            });
            var /** @type {?} */ preStyles = preStylesMap.get(element);
            var /** @type {?} */ postStyles = postStylesMap.get(element);
            var /** @type {?} */ keyframes = normalizeKeyframes(_this.driver, _this._normalizer, element, timelineInstruction.keyframes, preStyles, postStyles);
            var /** @type {?} */ player = _this._buildPlayer(timelineInstruction, keyframes, previousPlayers);
            // this means that this particular player belongs to a sub trigger. It is
            // important that we match this player up with the corresponding (@trigger.listener)
            if (timelineInstruction.subTimeline && skippedPlayersMap) {
                allSubElements.add(element);
            }
            if (isQueriedElement) {
                var /** @type {?} */ wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);
                wrappedPlayer.setRealPlayer(player);
                allQueriedPlayers.push(wrappedPlayer);
            }
            return player;
        });
        allQueriedPlayers.forEach(function (player) {
            getOrSetAsInMap(_this.playersByQueriedElement, player.element, []).push(player);
            player.onDone(function () { return deleteOrUnsetInMap(_this.playersByQueriedElement, player.element, player); });
        });
        allConsumedElements.forEach(function (element) { return addClass(element, NG_ANIMATING_CLASSNAME); });
        var /** @type {?} */ player = optimizeGroupPlayer(allNewPlayers);
        player.onDestroy(function () {
            allConsumedElements.forEach(function (element) { return removeClass(element, NG_ANIMATING_CLASSNAME); });
            setStyles(rootElement, instruction.toStyles);
        });
        // this basically makes all of the callbacks for sub element animations
        // be dependent on the upper players for when they finish
        allSubElements.forEach(function (element) { getOrSetAsInMap(skippedPlayersMap, element, []).push(player); });
        return player;
    };
    /**
     * @param {?} instruction
     * @param {?} keyframes
     * @param {?} previousPlayers
     * @return {?}
     */
    TransitionAnimationEngine.prototype._buildPlayer = function (instruction, keyframes, previousPlayers) {
        if (keyframes.length > 0) {
            return this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers);
        }
        // special case for when an empty transition|definition is provided
        // ... there is no point in rendering an empty animation
        return new _angular_animations.NoopAnimationPlayer();
    };
    return TransitionAnimationEngine;
}());
var TransitionAnimationPlayer = (function () {
    /**
     * @param {?} namespaceId
     * @param {?} triggerName
     * @param {?} element
     */
    function TransitionAnimationPlayer(namespaceId, triggerName, element) {
        this.namespaceId = namespaceId;
        this.triggerName = triggerName;
        this.element = element;
        this._player = new _angular_animations.NoopAnimationPlayer();
        this._containsRealPlayer = false;
        this._queuedCallbacks = {};
        this._destroyed = false;
        this.markedForDestroy = false;
    }
    Object.defineProperty(TransitionAnimationPlayer.prototype, "queued", {
        /**
         * @return {?}
         */
        get: function () { return this._containsRealPlayer == false; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransitionAnimationPlayer.prototype, "destroyed", {
        /**
         * @return {?}
         */
        get: function () { return this._destroyed; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} player
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.setRealPlayer = function (player) {
        var _this = this;
        if (this._containsRealPlayer)
            return;
        this._player = player;
        Object.keys(this._queuedCallbacks).forEach(function (phase) {
            _this._queuedCallbacks[phase].forEach(function (callback) { return listenOnPlayer(player, phase, undefined, callback); });
        });
        this._queuedCallbacks = {};
        this._containsRealPlayer = true;
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.getRealPlayer = function () { return this._player; };
    /**
     * @param {?} name
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationPlayer.prototype._queueEvent = function (name, callback) {
        getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.onDone = function (fn) {
        if (this.queued) {
            this._queueEvent('done', fn);
        }
        this._player.onDone(fn);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.onStart = function (fn) {
        if (this.queued) {
            this._queueEvent('start', fn);
        }
        this._player.onStart(fn);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.onDestroy = function (fn) {
        if (this.queued) {
            this._queueEvent('destroy', fn);
        }
        this._player.onDestroy(fn);
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.init = function () { this._player.init(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.hasStarted = function () { return this.queued ? false : this._player.hasStarted(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.play = function () { !this.queued && this._player.play(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.pause = function () { !this.queued && this._player.pause(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.restart = function () { !this.queued && this._player.restart(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.finish = function () { this._player.finish(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.destroy = function () {
        this._destroyed = true;
        this._player.destroy();
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.reset = function () { !this.queued && this._player.reset(); };
    /**
     * @param {?} p
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.setPosition = function (p) {
        if (!this.queued) {
            this._player.setPosition(p);
        }
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.getPosition = function () { return this.queued ? 0 : this._player.getPosition(); };
    Object.defineProperty(TransitionAnimationPlayer.prototype, "totalTime", {
        /**
         * @return {?}
         */
        get: function () { return this._player.totalTime; },
        enumerable: true,
        configurable: true
    });
    return TransitionAnimationPlayer;
}());
/**
 * @param {?} map
 * @param {?} key
 * @param {?} value
 * @return {?}
 */
function deleteOrUnsetInMap(map, key, value) {
    var /** @type {?} */ currentValues;
    if (map instanceof Map) {
        currentValues = map.get(key);
        if (currentValues) {
            if (currentValues.length) {
                var /** @type {?} */ index = currentValues.indexOf(value);
                currentValues.splice(index, 1);
            }
            if (currentValues.length == 0) {
                map.delete(key);
            }
        }
    }
    else {
        currentValues = map[key];
        if (currentValues) {
            if (currentValues.length) {
                var /** @type {?} */ index = currentValues.indexOf(value);
                currentValues.splice(index, 1);
            }
            if (currentValues.length == 0) {
                delete map[key];
            }
        }
    }
    return currentValues;
}
/**
 * @param {?} value
 * @return {?}
 */
function normalizeTriggerValue(value) {
    switch (typeof value) {
        case 'boolean':
            return value ? '1' : '0';
        default:
            return value != null ? value.toString() : null;
    }
}
/**
 * @param {?} node
 * @return {?}
 */
function isElementNode(node) {
    return node && node['nodeType'] === 1;
}
/**
 * @param {?} eventName
 * @return {?}
 */
function isTriggerEventValid(eventName) {
    return eventName == 'start' || eventName == 'done';
}
/**
 * @param {?} element
 * @param {?=} value
 * @return {?}
 */
function cloakElement(element, value) {
    var /** @type {?} */ oldValue = element.style.display;
    element.style.display = value != null ? value : 'none';
    return oldValue;
}
/**
 * @param {?} driver
 * @param {?} elements
 * @param {?} elementPropsMap
 * @param {?} defaultStyle
 * @return {?}
 */
function cloakAndComputeStyles(driver, elements, elementPropsMap, defaultStyle) {
    var /** @type {?} */ cloakVals = elements.map(function (element) { return cloakElement(element); });
    var /** @type {?} */ valuesMap = new Map();
    var /** @type {?} */ failedElements = [];
    elementPropsMap.forEach(function (props, element) {
        var /** @type {?} */ styles = {};
        props.forEach(function (prop) {
            var /** @type {?} */ value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);
            // there is no easy way to detect this because a sub element could be removed
            // by a parent animation element being detached.
            if (!value || value.length == 0) {
                element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;
                failedElements.push(element);
            }
        });
        valuesMap.set(element, styles);
    });
    elements.forEach(function (element, i) { return cloakElement(element, cloakVals[i]); });
    return [valuesMap, failedElements];
}
/**
 * @param {?} nodes
 * @return {?}
 */
function createIsRootFilterFn(nodes) {
    var /** @type {?} */ nodeSet = new Set(nodes);
    var /** @type {?} */ knownRootContainer = new Set();
    var /** @type {?} */ isRoot;
    isRoot = function (node) {
        if (!node)
            return true;
        if (nodeSet.has(node.parentNode))
            return false;
        if (knownRootContainer.has(node.parentNode))
            return true;
        if (isRoot(node.parentNode)) {
            knownRootContainer.add(node);
            return true;
        }
        return false;
    };
    return isRoot;
}
var CLASSES_CACHE_KEY = '$$classes';
/**
 * @param {?} element
 * @param {?} className
 * @return {?}
 */
function containsClass(element, className) {
    if (element.classList) {
        return element.classList.contains(className);
    }
    else {
        var /** @type {?} */ classes = element[CLASSES_CACHE_KEY];
        return classes && classes[className];
    }
}
/**
 * @param {?} element
 * @param {?} className
 * @return {?}
 */
function addClass(element, className) {
    if (element.classList) {
        element.classList.add(className);
    }
    else {
        var /** @type {?} */ classes = element[CLASSES_CACHE_KEY];
        if (!classes) {
            classes = element[CLASSES_CACHE_KEY] = {};
        }
        classes[className] = true;
    }
}
/**
 * @param {?} element
 * @param {?} className
 * @return {?}
 */
function removeClass(element, className) {
    if (element.classList) {
        element.classList.remove(className);
    }
    else {
        var /** @type {?} */ classes = element[CLASSES_CACHE_KEY];
        if (classes) {
            delete classes[className];
        }
    }
}
/**
 * @return {?}
 */
function getBodyNode() {
    if (typeof document != 'undefined') {
        return document.body;
    }
    return null;
}
/**
 * @param {?} engine
 * @param {?} element
 * @param {?} players
 * @return {?}
 */
function removeNodesAfterAnimationDone(engine, element, players) {
    optimizeGroupPlayer(players).onDone(function () { return engine.processLeaveNode(element); });
}
/**
 * @param {?} players
 * @return {?}
 */
function flattenGroupPlayers(players) {
    var /** @type {?} */ finalPlayers = [];
    _flattenGroupPlayersRecur(players, finalPlayers);
    return finalPlayers;
}
/**
 * @param {?} players
 * @param {?} finalPlayers
 * @return {?}
 */
function _flattenGroupPlayersRecur(players, finalPlayers) {
    for (var /** @type {?} */ i = 0; i < players.length; i++) {
        var /** @type {?} */ player = players[i];
        if (player instanceof _angular_animations.AnimationGroupPlayer) {
            _flattenGroupPlayersRecur(player.players, finalPlayers);
        }
        else {
            finalPlayers.push(/** @type {?} */ (player));
        }
    }
}
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
function objEquals(a, b) {
    var /** @type {?} */ k1 = Object.keys(a);
    var /** @type {?} */ k2 = Object.keys(b);
    if (k1.length != k2.length)
        return false;
    for (var /** @type {?} */ i = 0; i < k1.length; i++) {
        var /** @type {?} */ prop = k1[i];
        if (!b.hasOwnProperty(prop) || a[prop] !== b[prop])
            return false;
    }
    return true;
}
/**
 * @param {?} element
 * @param {?} allPreStyleElements
 * @param {?} allPostStyleElements
 * @return {?}
 */
function replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {
    var /** @type {?} */ postEntry = allPostStyleElements.get(element);
    if (!postEntry)
        return false;
    var /** @type {?} */ preEntry = allPreStyleElements.get(element);
    if (preEntry) {
        postEntry.forEach(function (data) { return ((preEntry)).add(data); });
    }
    else {
        allPreStyleElements.set(element, postEntry);
    }
    allPostStyleElements.delete(element);
    return true;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var AnimationEngine = (function () {
    /**
     * @param {?} driver
     * @param {?} normalizer
     */
    function AnimationEngine(driver, normalizer) {
        var _this = this;
        this._triggerCache = {};
        this.onRemovalComplete = function (element, context) { };
        this._transitionEngine = new TransitionAnimationEngine(driver, normalizer);
        this._timelineEngine = new TimelineAnimationEngine(driver, normalizer);
        this._transitionEngine.onRemovalComplete = function (element, context) { return _this.onRemovalComplete(element, context); };
    }
    /**
     * @param {?} componentId
     * @param {?} namespaceId
     * @param {?} hostElement
     * @param {?} name
     * @param {?} metadata
     * @return {?}
     */
    AnimationEngine.prototype.registerTrigger = function (componentId, namespaceId, hostElement, name, metadata) {
        var /** @type {?} */ cacheKey = componentId + '-' + name;
        var /** @type {?} */ trigger = this._triggerCache[cacheKey];
        if (!trigger) {
            var /** @type {?} */ errors = [];
            var /** @type {?} */ ast = (buildAnimationAst(/** @type {?} */ (metadata), errors));
            if (errors.length) {
                throw new Error("The animation trigger \"" + name + "\" has failed to build due to the following errors:\n - " + errors.join("\n - "));
            }
            trigger = buildTrigger(name, ast);
            this._triggerCache[cacheKey] = trigger;
        }
        this._transitionEngine.registerTrigger(namespaceId, name, trigger);
    };
    /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    AnimationEngine.prototype.register = function (namespaceId, hostElement) {
        this._transitionEngine.register(namespaceId, hostElement);
    };
    /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    AnimationEngine.prototype.destroy = function (namespaceId, context) {
        this._transitionEngine.destroy(namespaceId, context);
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    AnimationEngine.prototype.onInsert = function (namespaceId, element, parent, insertBefore) {
        this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    AnimationEngine.prototype.onRemove = function (namespaceId, element, context) {
        this._transitionEngine.removeNode(namespaceId, element, context);
    };
    /**
     * @param {?} element
     * @param {?} disable
     * @return {?}
     */
    AnimationEngine.prototype.disableAnimations = function (element, disable) {
        this._transitionEngine.markElementAsDisabled(element, disable);
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} property
     * @param {?} value
     * @return {?}
     */
    AnimationEngine.prototype.process = function (namespaceId, element, property, value) {
        if (property.charAt(0) == '@') {
            var _a = parseTimelineCommand(property), id = _a[0], action = _a[1];
            var /** @type {?} */ args = (value);
            this._timelineEngine.command(id, element, action, args);
        }
        else {
            this._transitionEngine.trigger(namespaceId, element, property, value);
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} eventName
     * @param {?} eventPhase
     * @param {?} callback
     * @return {?}
     */
    AnimationEngine.prototype.listen = function (namespaceId, element, eventName, eventPhase, callback) {
        // @@listen
        if (eventName.charAt(0) == '@') {
            var _a = parseTimelineCommand(eventName), id = _a[0], action = _a[1];
            return this._timelineEngine.listen(id, element, action, callback);
        }
        return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);
    };
    /**
     * @param {?=} microtaskId
     * @return {?}
     */
    AnimationEngine.prototype.flush = function (microtaskId) {
        if (microtaskId === void 0) { microtaskId = -1; }
        this._transitionEngine.flush(microtaskId);
    };
    Object.defineProperty(AnimationEngine.prototype, "players", {
        /**
         * @return {?}
         */
        get: function () {
            return ((this._transitionEngine.players))
                .concat(/** @type {?} */ (this._timelineEngine.players));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AnimationEngine.prototype.whenRenderingDone = function () { return this._transitionEngine.whenRenderingDone(); };
    return AnimationEngine;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var WebAnimationsPlayer = (function () {
    /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} options
     * @param {?=} previousPlayers
     */
    function WebAnimationsPlayer(element, keyframes, options, previousPlayers) {
        if (previousPlayers === void 0) { previousPlayers = []; }
        var _this = this;
        this.element = element;
        this.keyframes = keyframes;
        this.options = options;
        this.previousPlayers = previousPlayers;
        this._onDoneFns = [];
        this._onStartFns = [];
        this._onDestroyFns = [];
        this._initialized = false;
        this._finished = false;
        this._started = false;
        this._destroyed = false;
        this.time = 0;
        this.parentPlayer = null;
        this.previousStyles = {};
        this.currentSnapshot = {};
        this._duration = options['duration'];
        this._delay = options['delay'] || 0;
        this.time = this._duration + this._delay;
        if (allowPreviousPlayerStylesMerge(this._duration, this._delay)) {
            previousPlayers.forEach(function (player) {
                var styles = player.currentSnapshot;
                Object.keys(styles).forEach(function (prop) { return _this.previousStyles[prop] = styles[prop]; });
            });
        }
    }
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._onFinish = function () {
        if (!this._finished) {
            this._finished = true;
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        }
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.init = function () {
        this._buildPlayer();
        this._preparePlayerBeforeStart();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._buildPlayer = function () {
        var _this = this;
        if (this._initialized)
            return;
        this._initialized = true;
        var /** @type {?} */ keyframes = this.keyframes.map(function (styles) { return copyStyles(styles, false); });
        var /** @type {?} */ previousStyleProps = Object.keys(this.previousStyles);
        if (previousStyleProps.length) {
            var /** @type {?} */ startingKeyframe_1 = keyframes[0];
            var /** @type {?} */ missingStyleProps_1 = [];
            previousStyleProps.forEach(function (prop) {
                if (!startingKeyframe_1.hasOwnProperty(prop)) {
                    missingStyleProps_1.push(prop);
                }
                startingKeyframe_1[prop] = _this.previousStyles[prop];
            });
            if (missingStyleProps_1.length) {
                var /** @type {?} */ self_1 = this;
                var _loop_1 = function () {
                    var /** @type {?} */ kf = keyframes[i];
                    missingStyleProps_1.forEach(function (prop) {
                        kf[prop] = _computeStyle(self_1.element, prop);
                    });
                };
                // tslint:disable-next-line
                for (var /** @type {?} */ i = 1; i < keyframes.length; i++) {
                    _loop_1();
                }
            }
        }
        this._player = this._triggerWebAnimation(this.element, keyframes, this.options);
        this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : {};
        this._player.addEventListener('finish', function () { return _this._onFinish(); });
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._preparePlayerBeforeStart = function () {
        // this is required so that the player doesn't start to animate right away
        if (this._delay) {
            this._resetDomPlayerState();
        }
        else {
            this._player.pause();
        }
    };
    /**
     * \@internal
     * @param {?} element
     * @param {?} keyframes
     * @param {?} options
     * @return {?}
     */
    WebAnimationsPlayer.prototype._triggerWebAnimation = function (element, keyframes, options) {
        // jscompiler doesn't seem to know animate is a native property because it's not fully
        // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]
        return (element['animate'](keyframes, options));
    };
    Object.defineProperty(WebAnimationsPlayer.prototype, "domPlayer", {
        /**
         * @return {?}
         */
        get: function () { return this._player; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} fn
     * @return {?}
     */
    WebAnimationsPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    WebAnimationsPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    WebAnimationsPlayer.prototype.onDestroy = function (fn) { this._onDestroyFns.push(fn); };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.play = function () {
        this._buildPlayer();
        if (!this.hasStarted()) {
            this._onStartFns.forEach(function (fn) { return fn(); });
            this._onStartFns = [];
            this._started = true;
        }
        this._player.play();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.pause = function () {
        this.init();
        this._player.pause();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.finish = function () {
        this.init();
        this._onFinish();
        this._player.finish();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.reset = function () {
        this._resetDomPlayerState();
        this._destroyed = false;
        this._finished = false;
        this._started = false;
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._resetDomPlayerState = function () {
        if (this._player) {
            this._player.cancel();
        }
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.restart = function () {
        this.reset();
        this.play();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.hasStarted = function () { return this._started; };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.destroy = function () {
        if (!this._destroyed) {
            this._destroyed = true;
            this._resetDomPlayerState();
            this._onFinish();
            this._onDestroyFns.forEach(function (fn) { return fn(); });
            this._onDestroyFns = [];
        }
    };
    /**
     * @param {?} p
     * @return {?}
     */
    WebAnimationsPlayer.prototype.setPosition = function (p) { this._player.currentTime = p * this.time; };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.getPosition = function () { return this._player.currentTime / this.time; };
    Object.defineProperty(WebAnimationsPlayer.prototype, "totalTime", {
        /**
         * @return {?}
         */
        get: function () { return this._delay + this._duration; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.beforeDestroy = function () {
        var _this = this;
        var /** @type {?} */ styles = {};
        if (this.hasStarted()) {
            Object.keys(this._finalKeyframe).forEach(function (prop) {
                if (prop != 'offset') {
                    styles[prop] =
                        _this._finished ? _this._finalKeyframe[prop] : _computeStyle(_this.element, prop);
                }
            });
        }
        this.currentSnapshot = styles;
    };
    return WebAnimationsPlayer;
}());
/**
 * @param {?} element
 * @param {?} prop
 * @return {?}
 */
function _computeStyle(element, prop) {
    return ((window.getComputedStyle(element)))[prop];
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var WebAnimationsDriver = (function () {
    function WebAnimationsDriver() {
    }
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    WebAnimationsDriver.prototype.matchesElement = function (element, selector) {
        return matchesElement(element, selector);
    };
    /**
     * @param {?} elm1
     * @param {?} elm2
     * @return {?}
     */
    WebAnimationsDriver.prototype.containsElement = function (elm1, elm2) { return containsElement(elm1, elm2); };
    /**
     * @param {?} element
     * @param {?} selector
     * @param {?} multi
     * @return {?}
     */
    WebAnimationsDriver.prototype.query = function (element, selector, multi) {
        return invokeQuery(element, selector, multi);
    };
    /**
     * @param {?} element
     * @param {?} prop
     * @param {?=} defaultValue
     * @return {?}
     */
    WebAnimationsDriver.prototype.computeStyle = function (element, prop, defaultValue) {
        return (((window.getComputedStyle(element)))[prop]);
    };
    /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} duration
     * @param {?} delay
     * @param {?} easing
     * @param {?=} previousPlayers
     * @return {?}
     */
    WebAnimationsDriver.prototype.animate = function (element, keyframes, duration, delay, easing, previousPlayers) {
        if (previousPlayers === void 0) { previousPlayers = []; }
        var /** @type {?} */ fill = delay == 0 ? 'both' : 'forwards';
        var /** @type {?} */ playerOptions = { duration: duration, delay: delay, fill: fill };
        // we check for this to avoid having a null|undefined value be present
        // for the easing (which results in an error for certain browsers #9752)
        if (easing) {
            playerOptions['easing'] = easing;
        }
        var /** @type {?} */ previousWebAnimationPlayers = (previousPlayers.filter(function (player) { return player instanceof WebAnimationsPlayer; }));
        return new WebAnimationsPlayer(element, keyframes, playerOptions, previousWebAnimationPlayers);
    };
    return WebAnimationsDriver;
}());
/**
 * @return {?}
 */
function supportsWebAnimations() {
    return typeof Element !== 'undefined' && typeof ((Element)).prototype['animate'] === 'function';
}

exports.AnimationDriver = AnimationDriver;
exports.Animation = Animation;
exports.AnimationStyleNormalizer = AnimationStyleNormalizer;
exports.NoopAnimationStyleNormalizer = NoopAnimationStyleNormalizer;
exports.WebAnimationsStyleNormalizer = WebAnimationsStyleNormalizer;
exports.NoopAnimationDriver = NoopAnimationDriver;
exports.AnimationEngine = AnimationEngine;
exports.WebAnimationsDriver = WebAnimationsDriver;
exports.supportsWebAnimations = supportsWebAnimations;
exports.WebAnimationsPlayer = WebAnimationsPlayer;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=animations-browser.umd.js.map


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v4.3.6
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports, __webpack_require__(288), __webpack_require__(1), __webpack_require__(77), __webpack_require__(302), __webpack_require__(42), __webpack_require__(73), __webpack_require__(11), __webpack_require__(5)) :
	typeof define === 'function' && define.amd ? define(['exports', 'tslib', '@angular/core', 'rxjs/observable/of', 'rxjs/operator/concatMap', 'rxjs/operator/filter', 'rxjs/operator/map', '@angular/common', 'rxjs/Observable'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.commmon = global.ng.commmon || {}, global.ng.commmon.http = global.ng.commmon.http || {}),global.tslib_1,global.ng.core,global.rxjs_observable_of,global.rxjs_operator_concatMap,global.rxjs_operator_filter,global.rxjs_operator_map,global._angular_common,global.Rx));
}(this, (function (exports,tslib_1,_angular_core,rxjs_observable_of,rxjs_operator_concatMap,rxjs_operator_filter,rxjs_operator_map,_angular_common,rxjs_Observable) { 'use strict';

/**
 * @license Angular v4.3.6
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Transforms an `HttpRequest` into a stream of `HttpEvent`s, one of which will likely be a
 * `HttpResponse`.
 *
 * `HttpHandler` is injectable. When injected, the handler instance dispatches requests to the
 * first interceptor in the chain, which dispatches to the second, etc, eventually reaching the
 * `HttpBackend`.
 *
 * In an `HttpInterceptor`, the `HttpHandler` parameter is the next interceptor in the chain.
 *
 * \@experimental
 * @abstract
 */
var HttpHandler = (function () {
    function HttpHandler() {
    }
    /**
     * @abstract
     * @param {?} req
     * @return {?}
     */
    HttpHandler.prototype.handle = function (req) { };
    return HttpHandler;
}());
/**
 * A final `HttpHandler` which will dispatch the request via browser HTTP APIs to a backend.
 *
 * Interceptors sit between the `HttpClient` interface and the `HttpBackend`.
 *
 * When injected, `HttpBackend` dispatches requests directly to the backend, without going
 * through the interceptor chain.
 *
 * \@experimental
 * @abstract
 */
var HttpBackend = (function () {
    function HttpBackend() {
    }
    /**
     * @abstract
     * @param {?} req
     * @return {?}
     */
    HttpBackend.prototype.handle = function (req) { };
    return HttpBackend;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to
 * serialize and parse URL parameter keys and values.
 *
 * \@experimental
 */
var HttpUrlEncodingCodec = (function () {
    function HttpUrlEncodingCodec() {
    }
    /**
     * @param {?} k
     * @return {?}
     */
    HttpUrlEncodingCodec.prototype.encodeKey = function (k) { return standardEncoding(k); };
    /**
     * @param {?} v
     * @return {?}
     */
    HttpUrlEncodingCodec.prototype.encodeValue = function (v) { return standardEncoding(v); };
    /**
     * @param {?} k
     * @return {?}
     */
    HttpUrlEncodingCodec.prototype.decodeKey = function (k) { return decodeURIComponent(k); };
    /**
     * @param {?} v
     * @return {?}
     */
    HttpUrlEncodingCodec.prototype.decodeValue = function (v) { return decodeURIComponent(v); };
    return HttpUrlEncodingCodec;
}());
/**
 * @param {?} rawParams
 * @param {?} codec
 * @return {?}
 */
function paramParser(rawParams, codec) {
    var /** @type {?} */ map$$1 = new Map();
    if (rawParams.length > 0) {
        var /** @type {?} */ params = rawParams.split('&');
        params.forEach(function (param) {
            var /** @type {?} */ eqIdx = param.indexOf('=');
            var _a = eqIdx == -1 ?
                [codec.decodeKey(param), ''] :
                [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))], key = _a[0], val = _a[1];
            var /** @type {?} */ list = map$$1.get(key) || [];
            list.push(val);
            map$$1.set(key, list);
        });
    }
    return map$$1;
}
/**
 * @param {?} v
 * @return {?}
 */
function standardEncoding(v) {
    return encodeURIComponent(v)
        .replace(/%40/gi, '@')
        .replace(/%3A/gi, ':')
        .replace(/%24/gi, '$')
        .replace(/%2C/gi, ',')
        .replace(/%3B/gi, ';')
        .replace(/%2B/gi, '+')
        .replace(/%3D/gi, '=')
        .replace(/%3F/gi, '?')
        .replace(/%2F/gi, '/');
}
/**
 * An HTTP request/response body that represents serialized parameters,
 * per the MIME type `application/x-www-form-urlencoded`.
 *
 * This class is immuatable - all mutation operations return a new instance.
 *
 * \@experimental
 */
var HttpParams = (function () {
    /**
     * @param {?=} options
     */
    function HttpParams(options) {
        if (options === void 0) { options = {}; }
        this.updates = null;
        this.cloneFrom = null;
        this.encoder = options.encoder || new HttpUrlEncodingCodec();
        this.map = !!options.fromString ? paramParser(options.fromString, this.encoder) : null;
    }
    /**
     * Check whether the body has one or more values for the given parameter name.
     * @param {?} param
     * @return {?}
     */
    HttpParams.prototype.has = function (param) {
        this.init();
        return ((this.map)).has(param);
    };
    /**
     * Get the first value for the given parameter name, or `null` if it's not present.
     * @param {?} param
     * @return {?}
     */
    HttpParams.prototype.get = function (param) {
        this.init();
        var /** @type {?} */ res = ((this.map)).get(param);
        return !!res ? res[0] : null;
    };
    /**
     * Get all values for the given parameter name, or `null` if it's not present.
     * @param {?} param
     * @return {?}
     */
    HttpParams.prototype.getAll = function (param) {
        this.init();
        return ((this.map)).get(param) || null;
    };
    /**
     * Get all the parameter names for this body.
     * @return {?}
     */
    HttpParams.prototype.keys = function () {
        this.init();
        return Array.from(/** @type {?} */ ((this.map)).keys());
    };
    /**
     * Construct a new body with an appended value for the given parameter name.
     * @param {?} param
     * @param {?} value
     * @return {?}
     */
    HttpParams.prototype.append = function (param, value) { return this.clone({ param: param, value: value, op: 'a' }); };
    /**
     * Construct a new body with a new value for the given parameter name.
     * @param {?} param
     * @param {?} value
     * @return {?}
     */
    HttpParams.prototype.set = function (param, value) { return this.clone({ param: param, value: value, op: 's' }); };
    /**
     * Construct a new body with either the given value for the given parameter
     * removed, if a value is given, or all values for the given parameter removed
     * if not.
     * @param {?} param
     * @param {?=} value
     * @return {?}
     */
    HttpParams.prototype.delete = function (param, value) { return this.clone({ param: param, value: value, op: 'd' }); };
    /**
     * Serialize the body to an encoded string, where key-value pairs (separated by `=`) are
     * separated by `&`s.
     * @return {?}
     */
    HttpParams.prototype.toString = function () {
        var _this = this;
        this.init();
        return this.keys()
            .map(function (key) {
            var /** @type {?} */ eKey = _this.encoder.encodeKey(key);
            return ((((_this.map)).get(key))).map(function (value) { return eKey + '=' + _this.encoder.encodeValue(value); })
                .join('&');
        })
            .join('&');
    };
    /**
     * @param {?} update
     * @return {?}
     */
    HttpParams.prototype.clone = function (update) {
        var /** @type {?} */ clone = new HttpParams({ encoder: this.encoder });
        clone.cloneFrom = this.cloneFrom || this;
        clone.updates = (this.updates || []).concat([update]);
        return clone;
    };
    /**
     * @return {?}
     */
    HttpParams.prototype.init = function () {
        var _this = this;
        if (this.map === null) {
            this.map = new Map();
        }
        if (this.cloneFrom !== null) {
            this.cloneFrom.init();
            this.cloneFrom.keys().forEach(function (key) { return ((_this.map)).set(key, /** @type {?} */ ((((((_this.cloneFrom)).map)).get(key)))); }); /** @type {?} */
            ((this.updates)).forEach(function (update) {
                switch (update.op) {
                    case 'a':
                    case 's':
                        var /** @type {?} */ base = (update.op === 'a' ? ((_this.map)).get(update.param) : undefined) || [];
                        base.push(/** @type {?} */ ((update.value))); /** @type {?} */
                        ((_this.map)).set(update.param, base);
                        break;
                    case 'd':
                        if (update.value !== undefined) {
                            var /** @type {?} */ base_1 = ((_this.map)).get(update.param) || [];
                            var /** @type {?} */ idx = base_1.indexOf(update.value);
                            if (idx !== -1) {
                                base_1.splice(idx, 1);
                            }
                            if (base_1.length > 0) {
                                ((_this.map)).set(update.param, base_1);
                            }
                            else {
                                ((_this.map)).delete(update.param);
                            }
                        }
                        else {
                            ((_this.map)).delete(update.param);
                            break;
                        }
                }
            });
            this.cloneFrom = null;
        }
    };
    return HttpParams;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Immutable set of Http headers, with lazy parsing.
 * \@experimental
 */
var HttpHeaders = (function () {
    /**
     * @param {?=} headers
     */
    function HttpHeaders(headers) {
        var _this = this;
        /**
         * Internal map of lowercased header names to the normalized
         * form of the name (the form seen first).
         */
        this.normalizedNames = new Map();
        /**
         * Queued updates to be materialized the next initialization.
         */
        this.lazyUpdate = null;
        if (!headers) {
            this.headers = new Map();
        }
        else if (typeof headers === 'string') {
            this.lazyInit = function () {
                _this.headers = new Map();
                headers.split('\n').forEach(function (line) {
                    var index = line.indexOf(':');
                    if (index > 0) {
                        var name = line.slice(0, index);
                        var key = name.toLowerCase();
                        var value = line.slice(index + 1).trim();
                        _this.maybeSetNormalizedName(name, key);
                        if (_this.headers.has(key)) {
                            _this.headers.get(key).push(value);
                        }
                        else {
                            _this.headers.set(key, [value]);
                        }
                    }
                });
            };
        }
        else {
            this.lazyInit = function () {
                _this.headers = new Map();
                Object.keys(headers).forEach(function (name) {
                    var values = headers[name];
                    var key = name.toLowerCase();
                    if (typeof values === 'string') {
                        values = [values];
                    }
                    if (values.length > 0) {
                        _this.headers.set(key, values);
                        _this.maybeSetNormalizedName(name, key);
                    }
                });
            };
        }
    }
    /**
     * Checks for existence of header by given name.
     * @param {?} name
     * @return {?}
     */
    HttpHeaders.prototype.has = function (name) {
        this.init();
        return this.headers.has(name.toLowerCase());
    };
    /**
     * Returns first header that matches given name.
     * @param {?} name
     * @return {?}
     */
    HttpHeaders.prototype.get = function (name) {
        this.init();
        var /** @type {?} */ values = this.headers.get(name.toLowerCase());
        return values && values.length > 0 ? values[0] : null;
    };
    /**
     * Returns the names of the headers
     * @return {?}
     */
    HttpHeaders.prototype.keys = function () {
        this.init();
        return Array.from(this.normalizedNames.values());
    };
    /**
     * Returns list of header values for a given name.
     * @param {?} name
     * @return {?}
     */
    HttpHeaders.prototype.getAll = function (name) {
        this.init();
        return this.headers.get(name.toLowerCase()) || null;
    };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    HttpHeaders.prototype.append = function (name, value) {
        return this.clone({ name: name, value: value, op: 'a' });
    };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    HttpHeaders.prototype.set = function (name, value) {
        return this.clone({ name: name, value: value, op: 's' });
    };
    /**
     * @param {?} name
     * @param {?=} value
     * @return {?}
     */
    HttpHeaders.prototype.delete = function (name, value) {
        return this.clone({ name: name, value: value, op: 'd' });
    };
    /**
     * @param {?} name
     * @param {?} lcName
     * @return {?}
     */
    HttpHeaders.prototype.maybeSetNormalizedName = function (name, lcName) {
        if (!this.normalizedNames.has(lcName)) {
            this.normalizedNames.set(lcName, name);
        }
    };
    /**
     * @return {?}
     */
    HttpHeaders.prototype.init = function () {
        var _this = this;
        if (!!this.lazyInit) {
            if (this.lazyInit instanceof HttpHeaders) {
                this.copyFrom(this.lazyInit);
            }
            else {
                this.lazyInit();
            }
            this.lazyInit = null;
            if (!!this.lazyUpdate) {
                this.lazyUpdate.forEach(function (update) { return _this.applyUpdate(update); });
                this.lazyUpdate = null;
            }
        }
    };
    /**
     * @param {?} other
     * @return {?}
     */
    HttpHeaders.prototype.copyFrom = function (other) {
        var _this = this;
        other.init();
        Array.from(other.headers.keys()).forEach(function (key) {
            _this.headers.set(key, /** @type {?} */ ((other.headers.get(key))));
            _this.normalizedNames.set(key, /** @type {?} */ ((other.normalizedNames.get(key))));
        });
    };
    /**
     * @param {?} update
     * @return {?}
     */
    HttpHeaders.prototype.clone = function (update) {
        var /** @type {?} */ clone = new HttpHeaders();
        clone.lazyInit =
            (!!this.lazyInit && this.lazyInit instanceof HttpHeaders) ? this.lazyInit : this;
        clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
        return clone;
    };
    /**
     * @param {?} update
     * @return {?}
     */
    HttpHeaders.prototype.applyUpdate = function (update) {
        var /** @type {?} */ key = update.name.toLowerCase();
        switch (update.op) {
            case 'a':
            case 's':
                var /** @type {?} */ value = ((update.value));
                if (typeof value === 'string') {
                    value = [value];
                }
                if (value.length === 0) {
                    return;
                }
                this.maybeSetNormalizedName(update.name, key);
                var /** @type {?} */ base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];
                base.push.apply(base, value);
                this.headers.set(key, base);
                break;
            case 'd':
                var /** @type {?} */ toDelete_1 = (update.value);
                if (!toDelete_1) {
                    this.headers.delete(key);
                    this.normalizedNames.delete(key);
                }
                else {
                    var /** @type {?} */ existing = this.headers.get(key);
                    if (!existing) {
                        return;
                    }
                    existing = existing.filter(function (value) { return toDelete_1.indexOf(value) === -1; });
                    if (existing.length === 0) {
                        this.headers.delete(key);
                        this.normalizedNames.delete(key);
                    }
                    else {
                        this.headers.set(key, existing);
                    }
                }
                break;
        }
    };
    /**
     * \@internal
     * @param {?} fn
     * @return {?}
     */
    HttpHeaders.prototype.forEach = function (fn) {
        var _this = this;
        this.init();
        Array.from(this.normalizedNames.keys())
            .forEach(function (key) { return fn(/** @type {?} */ ((_this.normalizedNames.get(key))), /** @type {?} */ ((_this.headers.get(key)))); });
    };
    return HttpHeaders;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Determine whether the given HTTP method may include a body.
 * @param {?} method
 * @return {?}
 */
function mightHaveBody(method) {
    switch (method) {
        case 'DELETE':
        case 'GET':
        case 'HEAD':
        case 'OPTIONS':
        case 'JSONP':
            return false;
        default:
            return true;
    }
}
/**
 * Safely assert whether the given value is an ArrayBuffer.
 *
 * In some execution environments ArrayBuffer is not defined.
 * @param {?} value
 * @return {?}
 */
function isArrayBuffer(value) {
    return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;
}
/**
 * Safely assert whether the given value is a Blob.
 *
 * In some execution environments Blob is not defined.
 * @param {?} value
 * @return {?}
 */
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
/**
 * Safely assert whether the given value is a FormData instance.
 *
 * In some execution environments FormData is not defined.
 * @param {?} value
 * @return {?}
 */
function isFormData(value) {
    return typeof FormData !== 'undefined' && value instanceof FormData;
}
/**
 * An outgoing HTTP request with an optional typed body.
 *
 * `HttpRequest` represents an outgoing request, including URL, method,
 * headers, body, and other request configuration options. Instances should be
 * assumed to be immutable. To modify a `HttpRequest`, the `clone`
 * method should be used.
 *
 * \@experimental
 */
var HttpRequest = (function () {
    /**
     * @param {?} method
     * @param {?} url
     * @param {?=} third
     * @param {?=} fourth
     */
    function HttpRequest(method, url, third, fourth) {
        this.url = url;
        /**
         * The request body, or `null` if one isn't set.
         *
         * Bodies are not enforced to be immutable, as they can include a reference to any
         * user-defined data type. However, interceptors should take care to preserve
         * idempotence by treating them as such.
         */
        this.body = null;
        /**
         * Whether this request should be made in a way that exposes progress events.
         *
         * Progress events are expensive (change detection runs on each event) and so
         * they should only be requested if the consumer intends to monitor them.
         */
        this.reportProgress = false;
        /**
         * Whether this request should be sent with outgoing credentials (cookies).
         */
        this.withCredentials = false;
        /**
         * The expected response type of the server.
         *
         * This is used to parse the response appropriately before returning it to
         * the requestee.
         */
        this.responseType = 'json';
        this.method = method.toUpperCase();
        // Next, need to figure out which argument holds the HttpRequestInit
        // options, if any.
        var options;
        // Check whether a body argument is expected. The only valid way to omit
        // the body argument is to use a known no-body method like GET.
        if (mightHaveBody(this.method) || !!fourth) {
            // Body is the third argument, options are the fourth.
            this.body = third || null;
            options = fourth;
        }
        else {
            // No body required, options are the third argument. The body stays null.
            options = third;
        }
        // If options have been passed, interpret them.
        if (options) {
            // Normalize reportProgress and withCredentials.
            this.reportProgress = !!options.reportProgress;
            this.withCredentials = !!options.withCredentials;
            // Override default response type of 'json' if one is provided.
            if (!!options.responseType) {
                this.responseType = options.responseType;
            }
            // Override headers if they're provided.
            if (!!options.headers) {
                this.headers = options.headers;
            }
            if (!!options.params) {
                this.params = options.params;
            }
        }
        // If no headers have been passed in, construct a new HttpHeaders instance.
        if (!this.headers) {
            this.headers = new HttpHeaders();
        }
        // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.
        if (!this.params) {
            this.params = new HttpParams();
            this.urlWithParams = url;
        }
        else {
            // Encode the parameters to a string in preparation for inclusion in the URL.
            var params = this.params.toString();
            if (params.length === 0) {
                // No parameters, the visible URL is just the URL given at creation time.
                this.urlWithParams = url;
            }
            else {
                // Does the URL already have query parameters? Look for '?'.
                var qIdx = url.indexOf('?');
                // There are 3 cases to handle:
                // 1) No existing parameters -> append '?' followed by params.
                // 2) '?' exists and is followed by existing query string ->
                //    append '&' followed by params.
                // 3) '?' exists at the end of the url -> append params directly.
                // This basically amounts to determining the character, if any, with
                // which to join the URL and parameters.
                var sep = qIdx === -1 ? '?' : (qIdx < url.length - 1 ? '&' : '');
                this.urlWithParams = url + sep + params;
            }
        }
    }
    /**
     * Transform the free-form body into a serialized format suitable for
     * transmission to the server.
     * @return {?}
     */
    HttpRequest.prototype.serializeBody = function () {
        // If no body is present, no need to serialize it.
        if (this.body === null) {
            return null;
        }
        // Check whether the body is already in a serialized form. If so,
        // it can just be returned directly.
        if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||
            typeof this.body === 'string') {
            return this.body;
        }
        // Check whether the body is an instance of HttpUrlEncodedParams.
        if (this.body instanceof HttpParams) {
            return this.body.toString();
        }
        // Check whether the body is an object or array, and serialize with JSON if so.
        if (typeof this.body === 'object' || typeof this.body === 'boolean' ||
            Array.isArray(this.body)) {
            return JSON.stringify(this.body);
        }
        // Fall back on toString() for everything else.
        return ((this.body)).toString();
    };
    /**
     * Examine the body and attempt to infer an appropriate MIME type
     * for it.
     *
     * If no such type can be inferred, this method will return `null`.
     * @return {?}
     */
    HttpRequest.prototype.detectContentTypeHeader = function () {
        // An empty body has no content type.
        if (this.body === null) {
            return null;
        }
        // FormData bodies rely on the browser's content type assignment.
        if (isFormData(this.body)) {
            return null;
        }
        // Blobs usually have their own content type. If it doesn't, then
        // no type can be inferred.
        if (isBlob(this.body)) {
            return this.body.type || null;
        }
        // Array buffers have unknown contents and thus no type can be inferred.
        if (isArrayBuffer(this.body)) {
            return null;
        }
        // Technically, strings could be a form of JSON data, but it's safe enough
        // to assume they're plain strings.
        if (typeof this.body === 'string') {
            return 'text/plain';
        }
        // `HttpUrlEncodedParams` has its own content-type.
        if (this.body instanceof HttpParams) {
            return 'application/x-www-form-urlencoded;charset=UTF-8';
        }
        // Arrays, objects, and numbers will be encoded as JSON.
        if (typeof this.body === 'object' || typeof this.body === 'number' ||
            Array.isArray(this.body)) {
            return 'application/json';
        }
        // No type could be inferred.
        return null;
    };
    /**
     * @param {?=} update
     * @return {?}
     */
    HttpRequest.prototype.clone = function (update) {
        if (update === void 0) { update = {}; }
        // For method, url, and responseType, take the current value unless
        // it is overridden in the update hash.
        var /** @type {?} */ method = update.method || this.method;
        var /** @type {?} */ url = update.url || this.url;
        var /** @type {?} */ responseType = update.responseType || this.responseType;
        // The body is somewhat special - a `null` value in update.body means
        // whatever current body is present is being overridden with an empty
        // body, whereas an `undefined` value in update.body implies no
        // override.
        var /** @type {?} */ body = (update.body !== undefined) ? update.body : this.body;
        // Carefully handle the boolean options to differentiate between
        // `false` and `undefined` in the update args.
        var /** @type {?} */ withCredentials = (update.withCredentials !== undefined) ? update.withCredentials : this.withCredentials;
        var /** @type {?} */ reportProgress = (update.reportProgress !== undefined) ? update.reportProgress : this.reportProgress;
        // Headers and params may be appended to if `setHeaders` or
        // `setParams` are used.
        var /** @type {?} */ headers = update.headers || this.headers;
        var /** @type {?} */ params = update.params || this.params;
        // Check whether the caller has asked to add headers.
        if (update.setHeaders !== undefined) {
            // Set every requested header.
            headers =
                Object.keys(update.setHeaders)
                    .reduce(function (headers, name) { return headers.set(name, /** @type {?} */ ((update.setHeaders))[name]); }, headers);
        }
        // Check whether the caller has asked to set params.
        if (update.setParams) {
            // Set every requested param.
            params = Object.keys(update.setParams)
                .reduce(function (params, param) { return params.set(param, /** @type {?} */ ((update.setParams))[param]); }, params);
        }
        // Finally, construct the new HttpRequest using the pieces from above.
        return new HttpRequest(method, url, body, {
            params: params, headers: headers, reportProgress: reportProgress, responseType: responseType, withCredentials: withCredentials,
        });
    };
    return HttpRequest;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var HttpEventType = {};
HttpEventType.Sent = 0;
HttpEventType.UploadProgress = 1;
HttpEventType.ResponseHeader = 2;
HttpEventType.DownloadProgress = 3;
HttpEventType.Response = 4;
HttpEventType.User = 5;
HttpEventType[HttpEventType.Sent] = "Sent";
HttpEventType[HttpEventType.UploadProgress] = "UploadProgress";
HttpEventType[HttpEventType.ResponseHeader] = "ResponseHeader";
HttpEventType[HttpEventType.DownloadProgress] = "DownloadProgress";
HttpEventType[HttpEventType.Response] = "Response";
HttpEventType[HttpEventType.User] = "User";
/**
 * Base class for both `HttpResponse` and `HttpHeaderResponse`.
 *
 * \@experimental
 * @abstract
 */
var HttpResponseBase = (function () {
    /**
     * Super-constructor for all responses.
     *
     * The single parameter accepted is an initialization hash. Any properties
     * of the response passed there will override the default values.
     * @param {?} init
     * @param {?=} defaultStatus
     * @param {?=} defaultStatusText
     */
    function HttpResponseBase(init, defaultStatus, defaultStatusText) {
        if (defaultStatus === void 0) { defaultStatus = 200; }
        if (defaultStatusText === void 0) { defaultStatusText = 'OK'; }
        // If the hash has values passed, use them to initialize the response.
        // Otherwise use the default values.
        this.headers = init.headers || new HttpHeaders();
        this.status = init.status !== undefined ? init.status : defaultStatus;
        this.statusText = init.statusText || defaultStatusText;
        this.url = init.url || null;
        // Cache the ok value to avoid defining a getter.
        this.ok = this.status >= 200 && this.status < 300;
    }
    return HttpResponseBase;
}());
/**
 * A partial HTTP response which only includes the status and header data,
 * but no response body.
 *
 * `HttpHeaderResponse` is a `HttpEvent` available on the response
 * event stream, only when progress events are requested.
 *
 * \@experimental
 */
var HttpHeaderResponse = (function (_super) {
    tslib_1.__extends(HttpHeaderResponse, _super);
    /**
     * Create a new `HttpHeaderResponse` with the given parameters.
     * @param {?=} init
     */
    function HttpHeaderResponse(init) {
        if (init === void 0) { init = {}; }
        var _this = _super.call(this, init) || this;
        _this.type = HttpEventType.ResponseHeader;
        return _this;
    }
    /**
     * Copy this `HttpHeaderResponse`, overriding its contents with the
     * given parameter hash.
     * @param {?=} update
     * @return {?}
     */
    HttpHeaderResponse.prototype.clone = function (update) {
        if (update === void 0) { update = {}; }
        // Perform a straightforward initialization of the new HttpHeaderResponse,
        // overriding the current parameters with new ones if given.
        return new HttpHeaderResponse({
            headers: update.headers || this.headers,
            status: update.status !== undefined ? update.status : this.status,
            statusText: update.statusText || this.statusText,
            url: update.url || this.url || undefined,
        });
    };
    return HttpHeaderResponse;
}(HttpResponseBase));
/**
 * A full HTTP response, including a typed response body (which may be `null`
 * if one was not returned).
 *
 * `HttpResponse` is a `HttpEvent` available on the response event
 * stream.
 *
 * \@experimental
 */
var HttpResponse = (function (_super) {
    tslib_1.__extends(HttpResponse, _super);
    /**
     * Construct a new `HttpResponse`.
     * @param {?=} init
     */
    function HttpResponse(init) {
        if (init === void 0) { init = {}; }
        var _this = _super.call(this, init) || this;
        _this.type = HttpEventType.Response;
        _this.body = init.body || null;
        return _this;
    }
    /**
     * @param {?=} update
     * @return {?}
     */
    HttpResponse.prototype.clone = function (update) {
        if (update === void 0) { update = {}; }
        return new HttpResponse({
            body: (update.body !== undefined) ? update.body : this.body,
            headers: update.headers || this.headers,
            status: (update.status !== undefined) ? update.status : this.status,
            statusText: update.statusText || this.statusText,
            url: update.url || this.url || undefined,
        });
    };
    return HttpResponse;
}(HttpResponseBase));
/**
 * A response that represents an error or failure, either from a
 * non-successful HTTP status, an error while executing the request,
 * or some other failure which occurred during the parsing of the response.
 *
 * Any error returned on the `Observable` response stream will be
 * wrapped in an `HttpErrorResponse` to provide additional context about
 * the state of the HTTP layer when the error occurred. The error property
 * will contain either a wrapped Error object or the error response returned
 * from the server.
 *
 * \@experimental
 */
var HttpErrorResponse = (function (_super) {
    tslib_1.__extends(HttpErrorResponse, _super);
    /**
     * @param {?} init
     */
    function HttpErrorResponse(init) {
        var _this = 
        // Initialize with a default status of 0 / Unknown Error.
        _super.call(this, init, 0, 'Unknown Error') || this;
        _this.name = 'HttpErrorResponse';
        /**
         * Errors are never okay, even when the status code is in the 2xx success range.
         */
        _this.ok = false;
        // If the response was successful, then this was a parse error. Otherwise, it was
        // a protocol-level failure of some sort. Either the request failed in transit
        // or the server returned an unsuccessful status code.
        if (_this.status >= 200 && _this.status < 300) {
            _this.message = "Http failure during parsing for " + (init.url || '(unknown url)');
        }
        else {
            _this.message =
                "Http failure response for " + (init.url || '(unknown url)') + ": " + init.status + " " + init.statusText;
        }
        _this.error = init.error || null;
        return _this;
    }
    return HttpErrorResponse;
}(HttpResponseBase));
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Construct an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and
 * the given `body`. Basically, this clones the object and adds the body.
 * @template T
 * @param {?} options
 * @param {?} body
 * @return {?}
 */
function addBody(options, body) {
    return {
        body: body,
        headers: options.headers,
        observe: options.observe,
        params: options.params,
        reportProgress: options.reportProgress,
        responseType: options.responseType,
        withCredentials: options.withCredentials,
    };
}
/**
 * Perform HTTP requests.
 *
 * `HttpClient` is available as an injectable class, with methods to perform HTTP requests.
 * Each request method has multiple signatures, and the return type varies according to which
 * signature is called (mainly the values of `observe` and `responseType`).
 *
 * \@experimental
 */
var HttpClient = (function () {
    /**
     * @param {?} handler
     */
    function HttpClient(handler) {
        this.handler = handler;
    }
    /**
     * Constructs an `Observable` for a particular HTTP request that, when subscribed,
     * fires the request through the chain of registered interceptors and on to the
     * server.
     *
     * This method can be called in one of two ways. Either an `HttpRequest`
     * instance can be passed directly as the only parameter, or a method can be
     * passed as the first parameter, a string URL as the second, and an
     * options hash as the third.
     *
     * If a `HttpRequest` object is passed directly, an `Observable` of the
     * raw `HttpEvent` stream will be returned.
     *
     * If a request is instead built by providing a URL, the options object
     * determines the return type of `request()`. In addition to configuring
     * request parameters such as the outgoing headers and/or the body, the options
     * hash specifies two key pieces of information about the request: the
     * `responseType` and what to `observe`.
     *
     * The `responseType` value determines how a successful response body will be
     * parsed. If `responseType` is the default `json`, a type interface for the
     * resulting object may be passed as a type parameter to `request()`.
     *
     * The `observe` value determines the return type of `request()`, based on what
     * the consumer is interested in observing. A value of `events` will return an
     * `Observable<HttpEvent>` representing the raw `HttpEvent` stream,
     * including progress events by default. A value of `response` will return an
     * `Observable<HttpResponse<T>>` where the `T` parameter of `HttpResponse`
     * depends on the `responseType` and any optionally provided type parameter.
     * A value of `body` will return an `Observable<T>` with the same `T` body type.
     * @param {?} first
     * @param {?=} url
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.request = function (first, url, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var /** @type {?} */ req;
        // Firstly, check whether the primary argument is an instance of `HttpRequest`.
        if (first instanceof HttpRequest) {
            // It is. The other arguments must be undefined (per the signatures) and can be
            // ignored.
            req = (first);
        }
        else {
            // It's a string, so it represents a URL. Construct a request based on it,
            // and incorporate the remaining arguments (assuming GET unless a method is
            // provided.
            req = new HttpRequest(first, /** @type {?} */ ((url)), options.body || null, {
                headers: options.headers,
                params: options.params,
                reportProgress: options.reportProgress,
                // By default, JSON is assumed to be returned for all calls.
                responseType: options.responseType || 'json',
                withCredentials: options.withCredentials,
            });
        }
        // Start with an Observable.of() the initial request, and run the handler (which
        // includes all interceptors) inside a concatMap(). This way, the handler runs
        // inside an Observable chain, which causes interceptors to be re-run on every
        // subscription (this also makes retries re-run the handler, including interceptors).
        var /** @type {?} */ events$ = rxjs_operator_concatMap.concatMap.call(rxjs_observable_of.of(req), function (req) { return _this.handler.handle(req); });
        // If coming via the API signature which accepts a previously constructed HttpRequest,
        // the only option is to get the event stream. Otherwise, return the event stream if
        // that is what was requested.
        if (first instanceof HttpRequest || options.observe === 'events') {
            return events$;
        }
        // The requested stream contains either the full response or the body. In either
        // case, the first step is to filter the event stream to extract a stream of
        // responses(s).
        var /** @type {?} */ res$ = rxjs_operator_filter.filter.call(events$, function (event) { return event instanceof HttpResponse; });
        // Decide which stream to return.
        switch (options.observe || 'body') {
            case 'body':
                // The requested stream is the body. Map the response stream to the response
                // body. This could be done more simply, but a misbehaving interceptor might
                // transform the response body into a different format and ignore the requested
                // responseType. Guard against this by validating that the response is of the
                // requested type.
                switch (req.responseType) {
                    case 'arraybuffer':
                        return rxjs_operator_map.map.call(res$, function (res) {
                            // Validate that the body is an ArrayBuffer.
                            if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                                throw new Error('Response is not an ArrayBuffer.');
                            }
                            return res.body;
                        });
                    case 'blob':
                        return rxjs_operator_map.map.call(res$, function (res) {
                            // Validate that the body is a Blob.
                            if (res.body !== null && !(res.body instanceof Blob)) {
                                throw new Error('Response is not a Blob.');
                            }
                            return res.body;
                        });
                    case 'text':
                        return rxjs_operator_map.map.call(res$, function (res) {
                            // Validate that the body is a string.
                            if (res.body !== null && typeof res.body !== 'string') {
                                throw new Error('Response is not a string.');
                            }
                            return res.body;
                        });
                    case 'json':
                    default:
                        // No validation needed for JSON responses, as they can be of any type.
                        return rxjs_operator_map.map.call(res$, function (res) { return res.body; });
                }
            case 'response':
                // The response stream was requested directly, so return it.
                return res$;
            default:
                // Guard against new future observe types being added.
                throw new Error("Unreachable: unhandled observe type " + options.observe + "}");
        }
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * DELETE request to be executed on the server. See the individual overloads for
     * details of `delete()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.delete = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('DELETE', url, /** @type {?} */ (options));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * GET request to be executed on the server. See the individual overloads for
     * details of `get()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.get = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('GET', url, /** @type {?} */ (options));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * HEAD request to be executed on the server. See the individual overloads for
     * details of `head()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.head = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('HEAD', url, /** @type {?} */ (options));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause a request
     * with the special method `JSONP` to be dispatched via the interceptor pipeline.
     *
     * A suitable interceptor must be installed (e.g. via the `HttpClientJsonpModule`).
     * If no such interceptor is reached, then the `JSONP` request will likely be
     * rejected by the configured backend.
     * @template T
     * @param {?} url
     * @param {?} callbackParam
     * @return {?}
     */
    HttpClient.prototype.jsonp = function (url, callbackParam) {
        return this.request('JSONP', url, {
            params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),
            observe: 'body',
            responseType: 'json',
        });
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * OPTIONS request to be executed on the server. See the individual overloads for
     * details of `options()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.options = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('OPTIONS', url, /** @type {?} */ (options));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * PATCH request to be executed on the server. See the individual overloads for
     * details of `patch()`'s return type based on the provided options.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.patch = function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('PATCH', url, addBody(options, body));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.post = function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('POST', url, addBody(options, body));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.put = function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('PUT', url, addBody(options, body));
    };
    return HttpClient;
}());
HttpClient.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
HttpClient.ctorParameters = function () { return [
    { type: HttpHandler, },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * `HttpHandler` which applies an `HttpInterceptor` to an `HttpRequest`.
 *
 * \@experimental
 */
var HttpInterceptorHandler = (function () {
    /**
     * @param {?} next
     * @param {?} interceptor
     */
    function HttpInterceptorHandler(next, interceptor) {
        this.next = next;
        this.interceptor = interceptor;
    }
    /**
     * @param {?} req
     * @return {?}
     */
    HttpInterceptorHandler.prototype.handle = function (req) {
        return this.interceptor.intercept(req, this.next);
    };
    return HttpInterceptorHandler;
}());
/**
 * A multi-provider token which represents the array of `HttpInterceptor`s that
 * are registered.
 *
 * \@experimental
 */
var HTTP_INTERCEPTORS = new _angular_core.InjectionToken('HTTP_INTERCEPTORS');
var NoopInterceptor = (function () {
    function NoopInterceptor() {
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    NoopInterceptor.prototype.intercept = function (req, next) {
        return next.handle(req);
    };
    return NoopInterceptor;
}());
NoopInterceptor.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
NoopInterceptor.ctorParameters = function () { return []; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Every request made through JSONP needs a callback name that's unique across the
// whole page. Each request is assigned an id and the callback name is constructed
// from that. The next id to be assigned is tracked in a global variable here that
// is shared among all applications on the page.
var nextRequestId = 0;
// Error text given when a JSONP script is injected, but doesn't invoke the callback
// passed in its URL.
var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
// Error text given when a request is passed to the JsonpClientBackend that doesn't
// have a request method JSONP.
var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';
var JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';
/**
 * DI token/abstract type representing a map of JSONP callbacks.
 *
 * In the browser, this should always be the `window` object.
 *
 * \@experimental
 * @abstract
 */
var JsonpCallbackContext = (function () {
    function JsonpCallbackContext() {
    }
    return JsonpCallbackContext;
}());
/**
 * `HttpBackend` that only processes `HttpRequest` with the JSONP method,
 * by performing JSONP style requests.
 *
 * \@experimental
 */
var JsonpClientBackend = (function () {
    /**
     * @param {?} callbackMap
     * @param {?} document
     */
    function JsonpClientBackend(callbackMap, document) {
        this.callbackMap = callbackMap;
        this.document = document;
    }
    /**
     * Get the name of the next callback method, by incrementing the global `nextRequestId`.
     * @return {?}
     */
    JsonpClientBackend.prototype.nextCallback = function () { return "ng_jsonp_callback_" + nextRequestId++; };
    /**
     * Process a JSONP request and return an event stream of the results.
     * @param {?} req
     * @return {?}
     */
    JsonpClientBackend.prototype.handle = function (req) {
        var _this = this;
        // Firstly, check both the method and response type. If either doesn't match
        // then the request was improperly routed here and cannot be handled.
        if (req.method !== 'JSONP') {
            throw new Error(JSONP_ERR_WRONG_METHOD);
        }
        else if (req.responseType !== 'json') {
            throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);
        }
        // Everything else happens inside the Observable boundary.
        return new rxjs_Observable.Observable(function (observer) {
            // The first step to make a request is to generate the callback name, and replace the
            // callback placeholder in the URL with the name. Care has to be taken here to ensure
            // a trailing &, if matched, gets inserted back into the URL in the correct place.
            var /** @type {?} */ callback = _this.nextCallback();
            var /** @type {?} */ url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, "=" + callback + "$1");
            // Construct the <script> tag and point it at the URL.
            var /** @type {?} */ node = _this.document.createElement('script');
            node.src = url;
            // A JSONP request requires waiting for multiple callbacks. These variables
            // are closed over and track state across those callbacks.
            // The response object, if one has been received, or null otherwise.
            var /** @type {?} */ body = null;
            // Whether the response callback has been called.
            var /** @type {?} */ finished = false;
            // Whether the request has been cancelled (and thus any other callbacks)
            // should be ignored.
            var /** @type {?} */ cancelled = false;
            // Set the response callback in this.callbackMap (which will be the window
            // object in the browser. The script being loaded via the <script> tag will
            // eventually call this callback.
            _this.callbackMap[callback] = function (data) {
                // Data has been received from the JSONP script. Firstly, delete this callback.
                delete _this.callbackMap[callback];
                // Next, make sure the request wasn't cancelled in the meantime.
                if (cancelled) {
                    return;
                }
                // Set state to indicate data was received.
                body = data;
                finished = true;
            };
            // cleanup() is a utility closure that removes the <script> from the page and
            // the response callback from the window. This logic is used in both the
            // success, error, and cancellation paths, so it's extracted out for convenience.
            var /** @type {?} */ cleanup = function () {
                // Remove the <script> tag if it's still on the page.
                if (node.parentNode) {
                    node.parentNode.removeChild(node);
                }
                // Remove the response callback from the callbackMap (window object in the
                // browser).
                delete _this.callbackMap[callback];
            };
            // onLoad() is the success callback which runs after the response callback
            // if the JSONP script loads successfully. The event itself is unimportant.
            // If something went wrong, onLoad() may run without the response callback
            // having been invoked.
            var /** @type {?} */ onLoad = function (event) {
                // Do nothing if the request has been cancelled.
                if (cancelled) {
                    return;
                }
                // Cleanup the page.
                cleanup();
                // Check whether the response callback has run.
                if (!finished) {
                    // It hasn't, something went wrong with the request. Return an error via
                    // the Observable error path. All JSONP errors have status 0.
                    observer.error(new HttpErrorResponse({
                        url: url,
                        status: 0,
                        statusText: 'JSONP Error',
                        error: new Error(JSONP_ERR_NO_CALLBACK),
                    }));
                    return;
                }
                // Success. body either contains the response body or null if none was
                // returned.
                observer.next(new HttpResponse({
                    body: body,
                    status: 200,
                    statusText: 'OK', url: url,
                }));
                // Complete the stream, the resposne is over.
                observer.complete();
            };
            // onError() is the error callback, which runs if the script returned generates
            // a Javascript error. It emits the error via the Observable error channel as
            // a HttpErrorResponse.
            var /** @type {?} */ onError = function (error) {
                // If the request was already cancelled, no need to emit anything.
                if (cancelled) {
                    return;
                }
                cleanup();
                // Wrap the error in a HttpErrorResponse.
                observer.error(new HttpErrorResponse({
                    error: error,
                    status: 0,
                    statusText: 'JSONP Error', url: url,
                }));
            };
            // Subscribe to both the success (load) and error events on the <script> tag,
            // and add it to the page.
            node.addEventListener('load', onLoad);
            node.addEventListener('error', onError);
            _this.document.body.appendChild(node);
            // The request has now been successfully sent.
            observer.next({ type: HttpEventType.Sent });
            // Cancellation handler.
            return function () {
                // Track the cancellation so event listeners won't do anything even if already scheduled.
                cancelled = true;
                // Remove the event listeners so they won't run if the events later fire.
                node.removeEventListener('load', onLoad);
                node.removeEventListener('error', onError);
                // And finally, clean up the page.
                cleanup();
            };
        });
    };
    return JsonpClientBackend;
}());
JsonpClientBackend.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
JsonpClientBackend.ctorParameters = function () { return [
    { type: JsonpCallbackContext, },
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_common.DOCUMENT,] },] },
]; };
/**
 * An `HttpInterceptor` which identifies requests with the method JSONP and
 * shifts them to the `JsonpClientBackend`.
 *
 * \@experimental
 */
var JsonpInterceptor = (function () {
    /**
     * @param {?} jsonp
     */
    function JsonpInterceptor(jsonp) {
        this.jsonp = jsonp;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    JsonpInterceptor.prototype.intercept = function (req, next) {
        if (req.method === 'JSONP') {
            return this.jsonp.handle(/** @type {?} */ (req));
        }
        // Fall through for normal HTTP requests.
        return next.handle(req);
    };
    return JsonpInterceptor;
}());
JsonpInterceptor.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
JsonpInterceptor.ctorParameters = function () { return [
    { type: JsonpClientBackend, },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var XSSI_PREFIX = /^\)\]\}',?\n/;
/**
 * Determine an appropriate URL for the response, by checking either
 * XMLHttpRequest.responseURL or the X-Request-URL header.
 * @param {?} xhr
 * @return {?}
 */
function getResponseUrl(xhr) {
    if ('responseURL' in xhr && xhr.responseURL) {
        return xhr.responseURL;
    }
    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
        return xhr.getResponseHeader('X-Request-URL');
    }
    return null;
}
/**
 * A wrapper around the `XMLHttpRequest` constructor.
 *
 * \@experimental
 * @abstract
 */
var XhrFactory = (function () {
    function XhrFactory() {
    }
    /**
     * @abstract
     * @return {?}
     */
    XhrFactory.prototype.build = function () { };
    return XhrFactory;
}());
/**
 * A factory for \@{link HttpXhrBackend} that uses the `XMLHttpRequest` browser API.
 *
 * \@experimental
 */
var BrowserXhr = (function () {
    function BrowserXhr() {
    }
    /**
     * @return {?}
     */
    BrowserXhr.prototype.build = function () { return ((new XMLHttpRequest())); };
    return BrowserXhr;
}());
BrowserXhr.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
BrowserXhr.ctorParameters = function () { return []; };
/**
 * An `HttpBackend` which uses the XMLHttpRequest API to send
 * requests to a backend server.
 *
 * \@experimental
 */
var HttpXhrBackend = (function () {
    /**
     * @param {?} xhrFactory
     */
    function HttpXhrBackend(xhrFactory) {
        this.xhrFactory = xhrFactory;
    }
    /**
     * Process a request and return a stream of response events.
     * @param {?} req
     * @return {?}
     */
    HttpXhrBackend.prototype.handle = function (req) {
        var _this = this;
        // Quick check to give a better error message when a user attempts to use
        // HttpClient.jsonp() without installing the JsonpClientModule
        if (req.method === 'JSONP') {
            throw new Error("Attempted to construct Jsonp request without JsonpClientModule installed.");
        }
        // Everything happens on Observable subscription.
        return new rxjs_Observable.Observable(function (observer) {
            // Start by setting up the XHR object with request method, URL, and withCredentials flag.
            var /** @type {?} */ xhr = _this.xhrFactory.build();
            xhr.open(req.method, req.urlWithParams);
            if (!!req.withCredentials) {
                xhr.withCredentials = true;
            }
            // Add all the requested headers.
            req.headers.forEach(function (name, values) { return xhr.setRequestHeader(name, values.join(',')); });
            // Add an Accept header if one isn't present already.
            if (!req.headers.has('Accept')) {
                xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');
            }
            // Auto-detect the Content-Type header if one isn't present already.
            if (!req.headers.has('Content-Type')) {
                var /** @type {?} */ detectedType = req.detectContentTypeHeader();
                // Sometimes Content-Type detection fails.
                if (detectedType !== null) {
                    xhr.setRequestHeader('Content-Type', detectedType);
                }
            }
            // Set the responseType if one was requested.
            if (req.responseType) {
                xhr.responseType = (req.responseType.toLowerCase());
            }
            // Serialize the request body if one is present. If not, this will be set to null.
            var /** @type {?} */ reqBody = req.serializeBody();
            // If progress events are enabled, response headers will be delivered
            // in two events - the HttpHeaderResponse event and the full HttpResponse
            // event. However, since response headers don't change in between these
            // two events, it doesn't make sense to parse them twice. So headerResponse
            // caches the data extracted from the response whenever it's first parsed,
            // to ensure parsing isn't duplicated.
            var /** @type {?} */ headerResponse = null;
            // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest
            // state, and memoizes it into headerResponse.
            var /** @type {?} */ partialFromXhr = function () {
                if (headerResponse !== null) {
                    return headerResponse;
                }
                // Read status and normalize an IE9 bug (http://bugs.jquery.com/ticket/1450).
                var /** @type {?} */ status = xhr.status === 1223 ? 204 : xhr.status;
                var /** @type {?} */ statusText = xhr.statusText || 'OK';
                // Parse headers from XMLHttpRequest - this step is lazy.
                var /** @type {?} */ headers = new HttpHeaders(xhr.getAllResponseHeaders());
                // Read the response URL from the XMLHttpResponse instance and fall back on the
                // request URL.
                var /** @type {?} */ url = getResponseUrl(xhr) || req.url;
                // Construct the HttpHeaderResponse and memoize it.
                headerResponse = new HttpHeaderResponse({ headers: headers, status: status, statusText: statusText, url: url });
                return headerResponse;
            };
            // Next, a few closures are defined for the various events which XMLHttpRequest can
            // emit. This allows them to be unregistered as event listeners later.
            // First up is the load event, which represents a response being fully available.
            var /** @type {?} */ onLoad = function () {
                // Read response state from the memoized partial data.
                var _a = partialFromXhr(), headers = _a.headers, status = _a.status, statusText = _a.statusText, url = _a.url;
                // The body will be read out if present.
                var /** @type {?} */ body = null;
                if (status !== 204) {
                    // Use XMLHttpRequest.response if set, responseText otherwise.
                    body = (typeof xhr.response === 'undefined') ? xhr.responseText : xhr.response;
                    // Strip a common XSSI prefix from string responses.
                    // TODO: determine if this behavior should be optional and moved to an interceptor.
                    if (typeof body === 'string') {
                        body = body.replace(XSSI_PREFIX, '');
                    }
                }
                // Normalize another potential bug (this one comes from CORS).
                if (status === 0) {
                    status = !!body ? 200 : 0;
                }
                // ok determines whether the response will be transmitted on the event or
                // error channel. Unsuccessful status codes (not 2xx) will always be errors,
                // but a successful status code can still result in an error if the user
                // asked for JSON data and the body cannot be parsed as such.
                var /** @type {?} */ ok = status >= 200 && status < 300;
                // Check whether the body needs to be parsed as JSON (in many cases the browser
                // will have done that already).
                if (ok && typeof body === 'string' && req.responseType === 'json') {
                    // Attempt the parse. If it fails, a parse error should be delivered to the user.
                    try {
                        body = JSON.parse(body);
                    }
                    catch (error) {
                        // Even though the response status was 2xx, this is still an error.
                        ok = false;
                        // The parse error contains the text of the body that failed to parse.
                        body = ({ error: error, text: body });
                    }
                }
                if (ok) {
                    // A successful response is delivered on the event stream.
                    observer.next(new HttpResponse({
                        body: body,
                        headers: headers,
                        status: status,
                        statusText: statusText,
                        url: url || undefined,
                    }));
                    // The full body has been received and delivered, no further events
                    // are possible. This request is complete.
                    observer.complete();
                }
                else {
                    // An unsuccessful request is delivered on the error channel.
                    observer.error(new HttpErrorResponse({
                        // The error in this case is the response body (error from the server).
                        error: body,
                        headers: headers,
                        status: status,
                        statusText: statusText,
                        url: url || undefined,
                    }));
                }
            };
            // The onError callback is called when something goes wrong at the network level.
            // Connection timeout, DNS error, offline, etc. These are actual errors, and are
            // transmitted on the error channel.
            var /** @type {?} */ onError = function (error) {
                var /** @type {?} */ res = new HttpErrorResponse({
                    error: error,
                    status: xhr.status || 0,
                    statusText: xhr.statusText || 'Unknown Error',
                });
                observer.error(res);
            };
            // The sentHeaders flag tracks whether the HttpResponseHeaders event
            // has been sent on the stream. This is necessary to track if progress
            // is enabled since the event will be sent on only the first download
            // progerss event.
            var /** @type {?} */ sentHeaders = false;
            // The download progress event handler, which is only registered if
            // progress events are enabled.
            var /** @type {?} */ onDownProgress = function (event) {
                // Send the HttpResponseHeaders event if it hasn't been sent already.
                if (!sentHeaders) {
                    observer.next(partialFromXhr());
                    sentHeaders = true;
                }
                // Start building the download progress event to deliver on the response
                // event stream.
                var /** @type {?} */ progressEvent = {
                    type: HttpEventType.DownloadProgress,
                    loaded: event.loaded,
                };
                // Set the total number of bytes in the event if it's available.
                if (event.lengthComputable) {
                    progressEvent.total = event.total;
                }
                // If the request was for text content and a partial response is
                // available on XMLHttpRequest, include it in the progress event
                // to allow for streaming reads.
                if (req.responseType === 'text' && !!xhr.responseText) {
                    progressEvent.partialText = xhr.responseText;
                }
                // Finally, fire the event.
                observer.next(progressEvent);
            };
            // The upload progress event handler, which is only registered if
            // progress events are enabled.
            var /** @type {?} */ onUpProgress = function (event) {
                // Upload progress events are simpler. Begin building the progress
                // event.
                var /** @type {?} */ progress = {
                    type: HttpEventType.UploadProgress,
                    loaded: event.loaded,
                };
                // If the total number of bytes being uploaded is available, include
                // it.
                if (event.lengthComputable) {
                    progress.total = event.total;
                }
                // Send the event.
                observer.next(progress);
            };
            // By default, register for load and error events.
            xhr.addEventListener('load', onLoad);
            xhr.addEventListener('error', onError);
            // Progress events are only enabled if requested.
            if (req.reportProgress) {
                // Download progress is always enabled if requested.
                xhr.addEventListener('progress', onDownProgress);
                // Upload progress depends on whether there is a body to upload.
                if (reqBody !== null && xhr.upload) {
                    xhr.upload.addEventListener('progress', onUpProgress);
                }
            }
            // Fire the request, and notify the event stream that it was fired.
            xhr.send(reqBody);
            observer.next({ type: HttpEventType.Sent });
            // This is the return from the Observable function, which is the
            // request cancellation handler.
            return function () {
                // On a cancellation, remove all registered event listeners.
                xhr.removeEventListener('error', onError);
                xhr.removeEventListener('load', onLoad);
                if (req.reportProgress) {
                    xhr.removeEventListener('progress', onDownProgress);
                    if (reqBody !== null && xhr.upload) {
                        xhr.upload.removeEventListener('progress', onUpProgress);
                    }
                }
                // Finally, abort the in-flight request.
                xhr.abort();
            };
        });
    };
    return HttpXhrBackend;
}());
HttpXhrBackend.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
HttpXhrBackend.ctorParameters = function () { return [
    { type: XhrFactory, },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var XSRF_COOKIE_NAME = new _angular_core.InjectionToken('XSRF_COOKIE_NAME');
var XSRF_HEADER_NAME = new _angular_core.InjectionToken('XSRF_HEADER_NAME');
/**
 * Retrieves the current XSRF token to use with the next outgoing request.
 *
 * \@experimental
 * @abstract
 */
var HttpXsrfTokenExtractor = (function () {
    function HttpXsrfTokenExtractor() {
    }
    /**
     * Get the XSRF token to use with an outgoing request.
     *
     * Will be called for every request, so the token may change between requests.
     * @abstract
     * @return {?}
     */
    HttpXsrfTokenExtractor.prototype.getToken = function () { };
    return HttpXsrfTokenExtractor;
}());
/**
 * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.
 */
var HttpXsrfCookieExtractor = (function () {
    /**
     * @param {?} doc
     * @param {?} platform
     * @param {?} cookieName
     */
    function HttpXsrfCookieExtractor(doc, platform, cookieName) {
        this.doc = doc;
        this.platform = platform;
        this.cookieName = cookieName;
        this.lastCookieString = '';
        this.lastToken = null;
        /**
         * \@internal for testing
         */
        this.parseCount = 0;
    }
    /**
     * @return {?}
     */
    HttpXsrfCookieExtractor.prototype.getToken = function () {
        if (this.platform === 'server') {
            return null;
        }
        var /** @type {?} */ cookieString = this.doc.cookie || '';
        if (cookieString !== this.lastCookieString) {
            this.parseCount++;
            this.lastToken = _angular_common.parseCookieValue(cookieString, this.cookieName);
            this.lastCookieString = cookieString;
        }
        return this.lastToken;
    };
    return HttpXsrfCookieExtractor;
}());
HttpXsrfCookieExtractor.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
HttpXsrfCookieExtractor.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_common.DOCUMENT,] },] },
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.PLATFORM_ID,] },] },
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [XSRF_COOKIE_NAME,] },] },
]; };
/**
 * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.
 */
var HttpXsrfInterceptor = (function () {
    /**
     * @param {?} tokenService
     * @param {?} headerName
     */
    function HttpXsrfInterceptor(tokenService, headerName) {
        this.tokenService = tokenService;
        this.headerName = headerName;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    HttpXsrfInterceptor.prototype.intercept = function (req, next) {
        var /** @type {?} */ lcUrl = req.url.toLowerCase();
        // Skip both non-mutating requests and absolute URLs.
        // Non-mutating requests don't require a token, and absolute URLs require special handling
        // anyway as the cookie set
        // on our origin is not the same as the token expected by another origin.
        if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') ||
            lcUrl.startsWith('https://')) {
            return next.handle(req);
        }
        var /** @type {?} */ token = this.tokenService.getToken();
        // Be careful not to overwrite an existing header of the same name.
        if (token !== null && !req.headers.has(this.headerName)) {
            req = req.clone({ headers: req.headers.set(this.headerName, token) });
        }
        return next.handle(req);
    };
    return HttpXsrfInterceptor;
}());
HttpXsrfInterceptor.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
HttpXsrfInterceptor.ctorParameters = function () { return [
    { type: HttpXsrfTokenExtractor, },
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [XSRF_HEADER_NAME,] },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Constructs an `HttpHandler` that applies a bunch of `HttpInterceptor`s
 * to a request before passing it to the given `HttpBackend`.
 *
 * Meant to be used as a factory function within `HttpClientModule`.
 *
 * \@experimental
 * @param {?} backend
 * @param {?=} interceptors
 * @return {?}
 */
function interceptingHandler(backend, interceptors) {
    if (interceptors === void 0) { interceptors = []; }
    if (!interceptors) {
        return backend;
    }
    return interceptors.reduceRight(function (next, interceptor) { return new HttpInterceptorHandler(next, interceptor); }, backend);
}
/**
 * Factory function that determines where to store JSONP callbacks.
 *
 * Ordinarily JSONP callbacks are stored on the `window` object, but this may not exist
 * in test environments. In that case, callbacks are stored on an anonymous object instead.
 *
 * \@experimental
 * @return {?}
 */
function jsonpCallbackContext() {
    if (typeof window === 'object') {
        return window;
    }
    return {};
}
/**
 * `NgModule` which adds XSRF protection support to outgoing requests.
 *
 * Provided the server supports a cookie-based XSRF protection system, this
 * module can be used directly to configure XSRF protection with the correct
 * cookie and header names.
 *
 * If no such names are provided, the default is to use `X-XSRF-TOKEN` for
 * the header name and `XSRF-TOKEN` for the cookie name.
 *
 * \@experimental
 */
var HttpClientXsrfModule = (function () {
    function HttpClientXsrfModule() {
    }
    /**
     * Disable the default XSRF protection.
     * @return {?}
     */
    HttpClientXsrfModule.disable = function () {
        return {
            ngModule: HttpClientXsrfModule,
            providers: [
                { provide: HttpXsrfInterceptor, useClass: NoopInterceptor },
            ],
        };
    };
    /**
     * Configure XSRF protection to use the given cookie name or header name,
     * or the default names (as described above) if not provided.
     * @param {?=} options
     * @return {?}
     */
    HttpClientXsrfModule.withOptions = function (options) {
        if (options === void 0) { options = {}; }
        return {
            ngModule: HttpClientXsrfModule,
            providers: [
                options.cookieName ? { provide: XSRF_COOKIE_NAME, useValue: options.cookieName } : [],
                options.headerName ? { provide: XSRF_HEADER_NAME, useValue: options.headerName } : [],
            ],
        };
    };
    return HttpClientXsrfModule;
}());
HttpClientXsrfModule.decorators = [
    { type: _angular_core.NgModule, args: [{
                providers: [
                    HttpXsrfInterceptor,
                    { provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true },
                    { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },
                    { provide: XSRF_COOKIE_NAME, useValue: 'XSRF-TOKEN' },
                    { provide: XSRF_HEADER_NAME, useValue: 'X-XSRF-TOKEN' },
                ],
            },] },
];
/**
 * @nocollapse
 */
HttpClientXsrfModule.ctorParameters = function () { return []; };
/**
 * `NgModule` which provides the `HttpClient` and associated services.
 *
 * Interceptors can be added to the chain behind `HttpClient` by binding them
 * to the multiprovider for `HTTP_INTERCEPTORS`.
 *
 * \@experimental
 */
var HttpClientModule = (function () {
    function HttpClientModule() {
    }
    return HttpClientModule;
}());
HttpClientModule.decorators = [
    { type: _angular_core.NgModule, args: [{
                imports: [
                    HttpClientXsrfModule.withOptions({
                        cookieName: 'XSRF-TOKEN',
                        headerName: 'X-XSRF-TOKEN',
                    }),
                ],
                providers: [
                    HttpClient,
                    // HttpHandler is the backend + interceptors and is constructed
                    // using the interceptingHandler factory function.
                    {
                        provide: HttpHandler,
                        useFactory: interceptingHandler,
                        deps: [HttpBackend, [new _angular_core.Optional(), new _angular_core.Inject(HTTP_INTERCEPTORS)]],
                    },
                    HttpXhrBackend,
                    { provide: HttpBackend, useExisting: HttpXhrBackend },
                    BrowserXhr,
                    { provide: XhrFactory, useExisting: BrowserXhr },
                ],
            },] },
];
/**
 * @nocollapse
 */
HttpClientModule.ctorParameters = function () { return []; };
/**
 * `NgModule` which enables JSONP support in `HttpClient`.
 *
 * Without this module, Jsonp requests will reach the backend
 * with method JSONP, where they'll be rejected.
 *
 * \@experimental
 */
var HttpClientJsonpModule = (function () {
    function HttpClientJsonpModule() {
    }
    return HttpClientJsonpModule;
}());
HttpClientJsonpModule.decorators = [
    { type: _angular_core.NgModule, args: [{
                providers: [
                    JsonpClientBackend,
                    { provide: JsonpCallbackContext, useFactory: jsonpCallbackContext },
                    { provide: HTTP_INTERCEPTORS, useClass: JsonpInterceptor, multi: true },
                ],
            },] },
];
/**
 * @nocollapse
 */
HttpClientJsonpModule.ctorParameters = function () { return []; };

exports.HttpBackend = HttpBackend;
exports.HttpHandler = HttpHandler;
exports.HttpClient = HttpClient;
exports.HttpHeaders = HttpHeaders;
exports.HTTP_INTERCEPTORS = HTTP_INTERCEPTORS;
exports.JsonpClientBackend = JsonpClientBackend;
exports.JsonpInterceptor = JsonpInterceptor;
exports.HttpClientJsonpModule = HttpClientJsonpModule;
exports.HttpClientModule = HttpClientModule;
exports.HttpClientXsrfModule = HttpClientXsrfModule;
exports.interceptingHandler = interceptingHandler;
exports.HttpParams = HttpParams;
exports.HttpUrlEncodingCodec = HttpUrlEncodingCodec;
exports.HttpRequest = HttpRequest;
exports.HttpErrorResponse = HttpErrorResponse;
exports.HttpEventType = HttpEventType;
exports.HttpHeaderResponse = HttpHeaderResponse;
exports.HttpResponse = HttpResponse;
exports.HttpResponseBase = HttpResponseBase;
exports.HttpXhrBackend = HttpXhrBackend;
exports.XhrFactory = XhrFactory;
exports.HttpXsrfTokenExtractor = HttpXsrfTokenExtractor;
exports.a = NoopInterceptor;
exports.b = JsonpCallbackContext;
exports.c = jsonpCallbackContext;
exports.d = BrowserXhr;
exports.g = HttpXsrfCookieExtractor;
exports.h = HttpXsrfInterceptor;
exports.e = XSRF_COOKIE_NAME;
exports.f = XSRF_HEADER_NAME;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=common-http.umd.js.map


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_router__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var AppComponent = (function () {
    function AppComponent(router) {
        this.router = router;
    }
    AppComponent.prototype.ngOnDestroy = function () {
        this.route$.unsubscribe();
    };
    AppComponent.prototype.ngOnInit = function () {
        this.route$ = this.router.events.subscribe(function (evt) {
            if (!(evt instanceof __WEBPACK_IMPORTED_MODULE_1__angular_router__["NavigationEnd"])) {
                return;
            }
            if (typeof window != 'undefined') {
                window.scrollTo(0, 0);
            }
        });
    };
    AppComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'app',
            template: __webpack_require__(150),
            styles: [__webpack_require__(274)]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_router__["Router"]])
    ], AppComponent);
    return AppComponent;
}());



/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ErrorComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var ErrorComponent = (function () {
    function ErrorComponent() {
    }
    ErrorComponent.prototype.ngOnInit = function () { };
    ErrorComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-error',
            template: __webpack_require__(151)
        }),
        __metadata("design:paramtypes", [])
    ], ErrorComponent);
    return ErrorComponent;
}());



/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DirectiveModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_common__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__hoverEffect_directive__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__directives_ripple_directive__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__directives_clickOutside_directive__ = __webpack_require__(111);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





var DirectiveModule = (function () {
    function DirectiveModule() {
    }
    DirectiveModule = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["NgModule"])({
            declarations: [__WEBPACK_IMPORTED_MODULE_2__hoverEffect_directive__["a" /* HoverEffect */], __WEBPACK_IMPORTED_MODULE_4__directives_clickOutside_directive__["a" /* ClickOutsideDirective */], __WEBPACK_IMPORTED_MODULE_3__directives_ripple_directive__["a" /* RippleDirective */]],
            imports: [__WEBPACK_IMPORTED_MODULE_1__angular_common__["CommonModule"]],
            exports: [__WEBPACK_IMPORTED_MODULE_2__hoverEffect_directive__["a" /* HoverEffect */], __WEBPACK_IMPORTED_MODULE_4__directives_clickOutside_directive__["a" /* ClickOutsideDirective */], __WEBPACK_IMPORTED_MODULE_3__directives_ripple_directive__["a" /* RippleDirective */]],
            providers: [],
        })
    ], DirectiveModule);
    return DirectiveModule;
}());



/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PipeModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_common__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shared_pipes_limit_text_pipe__ = __webpack_require__(118);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



var PipeModule = (function () {
    function PipeModule() {
    }
    PipeModule = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["NgModule"])({
            declarations: [__WEBPACK_IMPORTED_MODULE_2__shared_pipes_limit_text_pipe__["a" /* LimitTextPipe */]],
            imports: [__WEBPACK_IMPORTED_MODULE_1__angular_common__["CommonModule"]],
            exports: [__WEBPACK_IMPORTED_MODULE_2__shared_pipes_limit_text_pipe__["a" /* LimitTextPipe */]],
            providers: [],
        })
    ], PipeModule);
    return PipeModule;
}());



/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LocalService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var LocalService = (function () {
    function LocalService() {
    }
    LocalService.prototype.getGuid = function () {
        if (typeof window != "undefined") {
            return localStorage.getItem('userId');
        }
    };
    LocalService = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [])
    ], LocalService);
    return LocalService;
}());



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DataService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var DataService = (function () {
    /**
     *
     */
    function DataService() {
    }
    DataService = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [])
    ], DataService);
    return DataService;
}());



/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DropdownComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var DropdownComponent = (function () {
    function DropdownComponent() {
        // change return DropdownItemComponent => this.value to get value
        this.change = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["EventEmitter"]();
        this.placeholder = "Hello";
        // isActivated = true => dropdown show items
        this.isActivated = false;
        this.items = [];
    }
    DropdownComponent.prototype.addItem = function (item) {
        this.items.push(item);
    };
    DropdownComponent.prototype.selectItemEmit = function (item) {
        this.selectItem(item);
        this.change.emit(item);
        this.isActivated = false;
    };
    DropdownComponent.prototype.selectItem = function (item) {
        this.items.forEach(function (i) { return i.isSelected = false; });
        item.isSelected = true;
        this.placeholder = item.text;
        this.selectedItem = item;
    };
    DropdownComponent.prototype.ngOnInit = function () { };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Output"])(),
        __metadata("design:type", Object)
    ], DropdownComponent.prototype, "change", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Object)
    ], DropdownComponent.prototype, "placeholder", void 0);
    DropdownComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-dropdown',
            template: __webpack_require__(158),
            styles: [__webpack_require__(281)]
        }),
        __metadata("design:paramtypes", [])
    ], DropdownComponent);
    return DropdownComponent;
}());



/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TabbedComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var TabbedComponent = (function () {
    function TabbedComponent() {
        this.height = 300;
        this.tabs = [];
    }
    TabbedComponent.prototype.addTab = function (tab) {
        this.tabs.push(tab);
    };
    TabbedComponent.prototype.selectTab = function (tab) {
        this.tabs.forEach(function (t) { return t.isActivated = false; });
        setTimeout(function () { return tab.isActivated = true; }, 250);
    };
    TabbedComponent.prototype.ngOnInit = function () {
    };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Number)
    ], TabbedComponent.prototype, "height", void 0);
    TabbedComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-tabbed',
            template: __webpack_require__(167)
        }),
        __metadata("design:paramtypes", [])
    ], TabbedComponent);
    return TabbedComponent;
}());



/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Tokenizer = __webpack_require__(21),
    HTML = __webpack_require__(10);

//Aliases
var $ = HTML.TAG_NAMES,
    NS = HTML.NAMESPACES,
    ATTRS = HTML.ATTRS;


//MIME types
var MIME_TYPES = {
    TEXT_HTML: 'text/html',
    APPLICATION_XML: 'application/xhtml+xml'
};

//Attributes
var DEFINITION_URL_ATTR = 'definitionurl',
    ADJUSTED_DEFINITION_URL_ATTR = 'definitionURL',
    SVG_ATTRS_ADJUSTMENT_MAP = {
        'attributename': 'attributeName',
        'attributetype': 'attributeType',
        'basefrequency': 'baseFrequency',
        'baseprofile': 'baseProfile',
        'calcmode': 'calcMode',
        'clippathunits': 'clipPathUnits',
        'diffuseconstant': 'diffuseConstant',
        'edgemode': 'edgeMode',
        'filterunits': 'filterUnits',
        'glyphref': 'glyphRef',
        'gradienttransform': 'gradientTransform',
        'gradientunits': 'gradientUnits',
        'kernelmatrix': 'kernelMatrix',
        'kernelunitlength': 'kernelUnitLength',
        'keypoints': 'keyPoints',
        'keysplines': 'keySplines',
        'keytimes': 'keyTimes',
        'lengthadjust': 'lengthAdjust',
        'limitingconeangle': 'limitingConeAngle',
        'markerheight': 'markerHeight',
        'markerunits': 'markerUnits',
        'markerwidth': 'markerWidth',
        'maskcontentunits': 'maskContentUnits',
        'maskunits': 'maskUnits',
        'numoctaves': 'numOctaves',
        'pathlength': 'pathLength',
        'patterncontentunits': 'patternContentUnits',
        'patterntransform': 'patternTransform',
        'patternunits': 'patternUnits',
        'pointsatx': 'pointsAtX',
        'pointsaty': 'pointsAtY',
        'pointsatz': 'pointsAtZ',
        'preservealpha': 'preserveAlpha',
        'preserveaspectratio': 'preserveAspectRatio',
        'primitiveunits': 'primitiveUnits',
        'refx': 'refX',
        'refy': 'refY',
        'repeatcount': 'repeatCount',
        'repeatdur': 'repeatDur',
        'requiredextensions': 'requiredExtensions',
        'requiredfeatures': 'requiredFeatures',
        'specularconstant': 'specularConstant',
        'specularexponent': 'specularExponent',
        'spreadmethod': 'spreadMethod',
        'startoffset': 'startOffset',
        'stddeviation': 'stdDeviation',
        'stitchtiles': 'stitchTiles',
        'surfacescale': 'surfaceScale',
        'systemlanguage': 'systemLanguage',
        'tablevalues': 'tableValues',
        'targetx': 'targetX',
        'targety': 'targetY',
        'textlength': 'textLength',
        'viewbox': 'viewBox',
        'viewtarget': 'viewTarget',
        'xchannelselector': 'xChannelSelector',
        'ychannelselector': 'yChannelSelector',
        'zoomandpan': 'zoomAndPan'
    },
    XML_ATTRS_ADJUSTMENT_MAP = {
        'xlink:actuate': {prefix: 'xlink', name: 'actuate', namespace: NS.XLINK},
        'xlink:arcrole': {prefix: 'xlink', name: 'arcrole', namespace: NS.XLINK},
        'xlink:href': {prefix: 'xlink', name: 'href', namespace: NS.XLINK},
        'xlink:role': {prefix: 'xlink', name: 'role', namespace: NS.XLINK},
        'xlink:show': {prefix: 'xlink', name: 'show', namespace: NS.XLINK},
        'xlink:title': {prefix: 'xlink', name: 'title', namespace: NS.XLINK},
        'xlink:type': {prefix: 'xlink', name: 'type', namespace: NS.XLINK},
        'xml:base': {prefix: 'xml', name: 'base', namespace: NS.XML},
        'xml:lang': {prefix: 'xml', name: 'lang', namespace: NS.XML},
        'xml:space': {prefix: 'xml', name: 'space', namespace: NS.XML},
        'xmlns': {prefix: '', name: 'xmlns', namespace: NS.XMLNS},
        'xmlns:xlink': {prefix: 'xmlns', name: 'xlink', namespace: NS.XMLNS}

    };

//SVG tag names adjustment map
var SVG_TAG_NAMES_ADJUSTMENT_MAP = exports.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
    'altglyph': 'altGlyph',
    'altglyphdef': 'altGlyphDef',
    'altglyphitem': 'altGlyphItem',
    'animatecolor': 'animateColor',
    'animatemotion': 'animateMotion',
    'animatetransform': 'animateTransform',
    'clippath': 'clipPath',
    'feblend': 'feBlend',
    'fecolormatrix': 'feColorMatrix',
    'fecomponenttransfer': 'feComponentTransfer',
    'fecomposite': 'feComposite',
    'feconvolvematrix': 'feConvolveMatrix',
    'fediffuselighting': 'feDiffuseLighting',
    'fedisplacementmap': 'feDisplacementMap',
    'fedistantlight': 'feDistantLight',
    'feflood': 'feFlood',
    'fefunca': 'feFuncA',
    'fefuncb': 'feFuncB',
    'fefuncg': 'feFuncG',
    'fefuncr': 'feFuncR',
    'fegaussianblur': 'feGaussianBlur',
    'feimage': 'feImage',
    'femerge': 'feMerge',
    'femergenode': 'feMergeNode',
    'femorphology': 'feMorphology',
    'feoffset': 'feOffset',
    'fepointlight': 'fePointLight',
    'fespecularlighting': 'feSpecularLighting',
    'fespotlight': 'feSpotLight',
    'fetile': 'feTile',
    'feturbulence': 'feTurbulence',
    'foreignobject': 'foreignObject',
    'glyphref': 'glyphRef',
    'lineargradient': 'linearGradient',
    'radialgradient': 'radialGradient',
    'textpath': 'textPath'
};

//Tags that causes exit from foreign content
var EXITS_FOREIGN_CONTENT = Object.create(null);

EXITS_FOREIGN_CONTENT[$.B] = true;
EXITS_FOREIGN_CONTENT[$.BIG] = true;
EXITS_FOREIGN_CONTENT[$.BLOCKQUOTE] = true;
EXITS_FOREIGN_CONTENT[$.BODY] = true;
EXITS_FOREIGN_CONTENT[$.BR] = true;
EXITS_FOREIGN_CONTENT[$.CENTER] = true;
EXITS_FOREIGN_CONTENT[$.CODE] = true;
EXITS_FOREIGN_CONTENT[$.DD] = true;
EXITS_FOREIGN_CONTENT[$.DIV] = true;
EXITS_FOREIGN_CONTENT[$.DL] = true;
EXITS_FOREIGN_CONTENT[$.DT] = true;
EXITS_FOREIGN_CONTENT[$.EM] = true;
EXITS_FOREIGN_CONTENT[$.EMBED] = true;
EXITS_FOREIGN_CONTENT[$.H1] = true;
EXITS_FOREIGN_CONTENT[$.H2] = true;
EXITS_FOREIGN_CONTENT[$.H3] = true;
EXITS_FOREIGN_CONTENT[$.H4] = true;
EXITS_FOREIGN_CONTENT[$.H5] = true;
EXITS_FOREIGN_CONTENT[$.H6] = true;
EXITS_FOREIGN_CONTENT[$.HEAD] = true;
EXITS_FOREIGN_CONTENT[$.HR] = true;
EXITS_FOREIGN_CONTENT[$.I] = true;
EXITS_FOREIGN_CONTENT[$.IMG] = true;
EXITS_FOREIGN_CONTENT[$.LI] = true;
EXITS_FOREIGN_CONTENT[$.LISTING] = true;
EXITS_FOREIGN_CONTENT[$.MENU] = true;
EXITS_FOREIGN_CONTENT[$.META] = true;
EXITS_FOREIGN_CONTENT[$.NOBR] = true;
EXITS_FOREIGN_CONTENT[$.OL] = true;
EXITS_FOREIGN_CONTENT[$.P] = true;
EXITS_FOREIGN_CONTENT[$.PRE] = true;
EXITS_FOREIGN_CONTENT[$.RUBY] = true;
EXITS_FOREIGN_CONTENT[$.S] = true;
EXITS_FOREIGN_CONTENT[$.SMALL] = true;
EXITS_FOREIGN_CONTENT[$.SPAN] = true;
EXITS_FOREIGN_CONTENT[$.STRONG] = true;
EXITS_FOREIGN_CONTENT[$.STRIKE] = true;
EXITS_FOREIGN_CONTENT[$.SUB] = true;
EXITS_FOREIGN_CONTENT[$.SUP] = true;
EXITS_FOREIGN_CONTENT[$.TABLE] = true;
EXITS_FOREIGN_CONTENT[$.TT] = true;
EXITS_FOREIGN_CONTENT[$.U] = true;
EXITS_FOREIGN_CONTENT[$.UL] = true;
EXITS_FOREIGN_CONTENT[$.VAR] = true;

//Check exit from foreign content
exports.causesExit = function (startTagToken) {
    var tn = startTagToken.tagName;
    var isFontWithAttrs = tn === $.FONT && (Tokenizer.getTokenAttr(startTagToken, ATTRS.COLOR) !== null ||
                                            Tokenizer.getTokenAttr(startTagToken, ATTRS.SIZE) !== null ||
                                            Tokenizer.getTokenAttr(startTagToken, ATTRS.FACE) !== null);

    return isFontWithAttrs ? true : EXITS_FOREIGN_CONTENT[tn];
};

//Token adjustments
exports.adjustTokenMathMLAttrs = function (token) {
    for (var i = 0; i < token.attrs.length; i++) {
        if (token.attrs[i].name === DEFINITION_URL_ATTR) {
            token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
            break;
        }
    }
};

exports.adjustTokenSVGAttrs = function (token) {
    for (var i = 0; i < token.attrs.length; i++) {
        var adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];

        if (adjustedAttrName)
            token.attrs[i].name = adjustedAttrName;
    }
};

exports.adjustTokenXMLAttrs = function (token) {
    for (var i = 0; i < token.attrs.length; i++) {
        var adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];

        if (adjustedAttrEntry) {
            token.attrs[i].prefix = adjustedAttrEntry.prefix;
            token.attrs[i].name = adjustedAttrEntry.name;
            token.attrs[i].namespace = adjustedAttrEntry.namespace;
        }
    }
};

exports.adjustTokenSVGTagName = function (token) {
    var adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP[token.tagName];

    if (adjustedTagName)
        token.tagName = adjustedTagName;
};

//Integration points
function isMathMLTextIntegrationPoint(tn, ns) {
    return ns === NS.MATHML && (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS || tn === $.MTEXT);
}

function isHtmlIntegrationPoint(tn, ns, attrs) {
    if (ns === NS.MATHML && tn === $.ANNOTATION_XML) {
        for (var i = 0; i < attrs.length; i++) {
            if (attrs[i].name === ATTRS.ENCODING) {
                var value = attrs[i].value.toLowerCase();

                return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
            }
        }
    }

    return ns === NS.SVG && (tn === $.FOREIGN_OBJECT || tn === $.DESC || tn === $.TITLE);
}

exports.isIntegrationPoint = function (tn, ns, attrs, foreignNS) {
    if ((!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs))
        return true;

    if ((!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns))
        return true;

    return false;
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Tokenizer = __webpack_require__(21),
    OpenElementStack = __webpack_require__(55),
    FormattingElementList = __webpack_require__(171),
    locationInfoMixin = __webpack_require__(169),
    defaultTreeAdapter = __webpack_require__(33),
    doctype = __webpack_require__(30),
    foreignContent = __webpack_require__(53),
    mergeOptions = __webpack_require__(31),
    UNICODE = __webpack_require__(20),
    HTML = __webpack_require__(10);

//Aliases
var $ = HTML.TAG_NAMES,
    NS = HTML.NAMESPACES,
    ATTRS = HTML.ATTRS;

var DEFAULT_OPTIONS = {
    locationInfo: false,
    treeAdapter: defaultTreeAdapter
};

//Misc constants
var HIDDEN_INPUT_TYPE = 'hidden';

//Adoption agency loops iteration count
var AA_OUTER_LOOP_ITER = 8,
    AA_INNER_LOOP_ITER = 3;

//Insertion modes
var INITIAL_MODE = 'INITIAL_MODE',
    BEFORE_HTML_MODE = 'BEFORE_HTML_MODE',
    BEFORE_HEAD_MODE = 'BEFORE_HEAD_MODE',
    IN_HEAD_MODE = 'IN_HEAD_MODE',
    AFTER_HEAD_MODE = 'AFTER_HEAD_MODE',
    IN_BODY_MODE = 'IN_BODY_MODE',
    TEXT_MODE = 'TEXT_MODE',
    IN_TABLE_MODE = 'IN_TABLE_MODE',
    IN_TABLE_TEXT_MODE = 'IN_TABLE_TEXT_MODE',
    IN_CAPTION_MODE = 'IN_CAPTION_MODE',
    IN_COLUMN_GROUP_MODE = 'IN_COLUMN_GROUP_MODE',
    IN_TABLE_BODY_MODE = 'IN_TABLE_BODY_MODE',
    IN_ROW_MODE = 'IN_ROW_MODE',
    IN_CELL_MODE = 'IN_CELL_MODE',
    IN_SELECT_MODE = 'IN_SELECT_MODE',
    IN_SELECT_IN_TABLE_MODE = 'IN_SELECT_IN_TABLE_MODE',
    IN_TEMPLATE_MODE = 'IN_TEMPLATE_MODE',
    AFTER_BODY_MODE = 'AFTER_BODY_MODE',
    IN_FRAMESET_MODE = 'IN_FRAMESET_MODE',
    AFTER_FRAMESET_MODE = 'AFTER_FRAMESET_MODE',
    AFTER_AFTER_BODY_MODE = 'AFTER_AFTER_BODY_MODE',
    AFTER_AFTER_FRAMESET_MODE = 'AFTER_AFTER_FRAMESET_MODE';

//Insertion mode reset map
var INSERTION_MODE_RESET_MAP = Object.create(null);

INSERTION_MODE_RESET_MAP[$.TR] = IN_ROW_MODE;
INSERTION_MODE_RESET_MAP[$.TBODY] =
INSERTION_MODE_RESET_MAP[$.THEAD] =
INSERTION_MODE_RESET_MAP[$.TFOOT] = IN_TABLE_BODY_MODE;
INSERTION_MODE_RESET_MAP[$.CAPTION] = IN_CAPTION_MODE;
INSERTION_MODE_RESET_MAP[$.COLGROUP] = IN_COLUMN_GROUP_MODE;
INSERTION_MODE_RESET_MAP[$.TABLE] = IN_TABLE_MODE;
INSERTION_MODE_RESET_MAP[$.BODY] = IN_BODY_MODE;
INSERTION_MODE_RESET_MAP[$.FRAMESET] = IN_FRAMESET_MODE;

//Template insertion mode switch map
var TEMPLATE_INSERTION_MODE_SWITCH_MAP = Object.create(null);

TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.CAPTION] =
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.COLGROUP] =
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.TBODY] =
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.TFOOT] =
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.THEAD] = IN_TABLE_MODE;
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.COL] = IN_COLUMN_GROUP_MODE;
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.TR] = IN_TABLE_BODY_MODE;
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.TD] =
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.TH] = IN_ROW_MODE;

//Token handlers map for insertion modes
var _ = Object.create(null);

_[INITIAL_MODE] = Object.create(null);
_[INITIAL_MODE][Tokenizer.CHARACTER_TOKEN] =
_[INITIAL_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenInInitialMode;
_[INITIAL_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = ignoreToken;
_[INITIAL_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[INITIAL_MODE][Tokenizer.DOCTYPE_TOKEN] = doctypeInInitialMode;
_[INITIAL_MODE][Tokenizer.START_TAG_TOKEN] =
_[INITIAL_MODE][Tokenizer.END_TAG_TOKEN] =
_[INITIAL_MODE][Tokenizer.EOF_TOKEN] = tokenInInitialMode;

_[BEFORE_HTML_MODE] = Object.create(null);
_[BEFORE_HTML_MODE][Tokenizer.CHARACTER_TOKEN] =
_[BEFORE_HTML_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenBeforeHtml;
_[BEFORE_HTML_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = ignoreToken;
_[BEFORE_HTML_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[BEFORE_HTML_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[BEFORE_HTML_MODE][Tokenizer.START_TAG_TOKEN] = startTagBeforeHtml;
_[BEFORE_HTML_MODE][Tokenizer.END_TAG_TOKEN] = endTagBeforeHtml;
_[BEFORE_HTML_MODE][Tokenizer.EOF_TOKEN] = tokenBeforeHtml;

_[BEFORE_HEAD_MODE] = Object.create(null);
_[BEFORE_HEAD_MODE][Tokenizer.CHARACTER_TOKEN] =
_[BEFORE_HEAD_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenBeforeHead;
_[BEFORE_HEAD_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = ignoreToken;
_[BEFORE_HEAD_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[BEFORE_HEAD_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[BEFORE_HEAD_MODE][Tokenizer.START_TAG_TOKEN] = startTagBeforeHead;
_[BEFORE_HEAD_MODE][Tokenizer.END_TAG_TOKEN] = endTagBeforeHead;
_[BEFORE_HEAD_MODE][Tokenizer.EOF_TOKEN] = tokenBeforeHead;

_[IN_HEAD_MODE] = Object.create(null);
_[IN_HEAD_MODE][Tokenizer.CHARACTER_TOKEN] =
_[IN_HEAD_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenInHead;
_[IN_HEAD_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[IN_HEAD_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_HEAD_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_HEAD_MODE][Tokenizer.START_TAG_TOKEN] = startTagInHead;
_[IN_HEAD_MODE][Tokenizer.END_TAG_TOKEN] = endTagInHead;
_[IN_HEAD_MODE][Tokenizer.EOF_TOKEN] = tokenInHead;

_[AFTER_HEAD_MODE] = Object.create(null);
_[AFTER_HEAD_MODE][Tokenizer.CHARACTER_TOKEN] =
_[AFTER_HEAD_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenAfterHead;
_[AFTER_HEAD_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[AFTER_HEAD_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[AFTER_HEAD_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[AFTER_HEAD_MODE][Tokenizer.START_TAG_TOKEN] = startTagAfterHead;
_[AFTER_HEAD_MODE][Tokenizer.END_TAG_TOKEN] = endTagAfterHead;
_[AFTER_HEAD_MODE][Tokenizer.EOF_TOKEN] = tokenAfterHead;

_[IN_BODY_MODE] = Object.create(null);
_[IN_BODY_MODE][Tokenizer.CHARACTER_TOKEN] = characterInBody;
_[IN_BODY_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_BODY_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_[IN_BODY_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_BODY_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_BODY_MODE][Tokenizer.START_TAG_TOKEN] = startTagInBody;
_[IN_BODY_MODE][Tokenizer.END_TAG_TOKEN] = endTagInBody;
_[IN_BODY_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[TEXT_MODE] = Object.create(null);
_[TEXT_MODE][Tokenizer.CHARACTER_TOKEN] =
_[TEXT_MODE][Tokenizer.NULL_CHARACTER_TOKEN] =
_[TEXT_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[TEXT_MODE][Tokenizer.COMMENT_TOKEN] =
_[TEXT_MODE][Tokenizer.DOCTYPE_TOKEN] =
_[TEXT_MODE][Tokenizer.START_TAG_TOKEN] = ignoreToken;
_[TEXT_MODE][Tokenizer.END_TAG_TOKEN] = endTagInText;
_[TEXT_MODE][Tokenizer.EOF_TOKEN] = eofInText;

_[IN_TABLE_MODE] = Object.create(null);
_[IN_TABLE_MODE][Tokenizer.CHARACTER_TOKEN] =
_[IN_TABLE_MODE][Tokenizer.NULL_CHARACTER_TOKEN] =
_[IN_TABLE_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = characterInTable;
_[IN_TABLE_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_TABLE_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_TABLE_MODE][Tokenizer.START_TAG_TOKEN] = startTagInTable;
_[IN_TABLE_MODE][Tokenizer.END_TAG_TOKEN] = endTagInTable;
_[IN_TABLE_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_TABLE_TEXT_MODE] = Object.create(null);
_[IN_TABLE_TEXT_MODE][Tokenizer.CHARACTER_TOKEN] = characterInTableText;
_[IN_TABLE_TEXT_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_TABLE_TEXT_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInTableText;
_[IN_TABLE_TEXT_MODE][Tokenizer.COMMENT_TOKEN] =
_[IN_TABLE_TEXT_MODE][Tokenizer.DOCTYPE_TOKEN] =
_[IN_TABLE_TEXT_MODE][Tokenizer.START_TAG_TOKEN] =
_[IN_TABLE_TEXT_MODE][Tokenizer.END_TAG_TOKEN] =
_[IN_TABLE_TEXT_MODE][Tokenizer.EOF_TOKEN] = tokenInTableText;

_[IN_CAPTION_MODE] = Object.create(null);
_[IN_CAPTION_MODE][Tokenizer.CHARACTER_TOKEN] = characterInBody;
_[IN_CAPTION_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_CAPTION_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_[IN_CAPTION_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_CAPTION_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_CAPTION_MODE][Tokenizer.START_TAG_TOKEN] = startTagInCaption;
_[IN_CAPTION_MODE][Tokenizer.END_TAG_TOKEN] = endTagInCaption;
_[IN_CAPTION_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_COLUMN_GROUP_MODE] = Object.create(null);
_[IN_COLUMN_GROUP_MODE][Tokenizer.CHARACTER_TOKEN] =
_[IN_COLUMN_GROUP_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenInColumnGroup;
_[IN_COLUMN_GROUP_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[IN_COLUMN_GROUP_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_COLUMN_GROUP_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_COLUMN_GROUP_MODE][Tokenizer.START_TAG_TOKEN] = startTagInColumnGroup;
_[IN_COLUMN_GROUP_MODE][Tokenizer.END_TAG_TOKEN] = endTagInColumnGroup;
_[IN_COLUMN_GROUP_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_TABLE_BODY_MODE] = Object.create(null);
_[IN_TABLE_BODY_MODE][Tokenizer.CHARACTER_TOKEN] =
_[IN_TABLE_BODY_MODE][Tokenizer.NULL_CHARACTER_TOKEN] =
_[IN_TABLE_BODY_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = characterInTable;
_[IN_TABLE_BODY_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_TABLE_BODY_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_TABLE_BODY_MODE][Tokenizer.START_TAG_TOKEN] = startTagInTableBody;
_[IN_TABLE_BODY_MODE][Tokenizer.END_TAG_TOKEN] = endTagInTableBody;
_[IN_TABLE_BODY_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_ROW_MODE] = Object.create(null);
_[IN_ROW_MODE][Tokenizer.CHARACTER_TOKEN] =
_[IN_ROW_MODE][Tokenizer.NULL_CHARACTER_TOKEN] =
_[IN_ROW_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = characterInTable;
_[IN_ROW_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_ROW_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_ROW_MODE][Tokenizer.START_TAG_TOKEN] = startTagInRow;
_[IN_ROW_MODE][Tokenizer.END_TAG_TOKEN] = endTagInRow;
_[IN_ROW_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_CELL_MODE] = Object.create(null);
_[IN_CELL_MODE][Tokenizer.CHARACTER_TOKEN] = characterInBody;
_[IN_CELL_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_CELL_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_[IN_CELL_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_CELL_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_CELL_MODE][Tokenizer.START_TAG_TOKEN] = startTagInCell;
_[IN_CELL_MODE][Tokenizer.END_TAG_TOKEN] = endTagInCell;
_[IN_CELL_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_SELECT_MODE] = Object.create(null);
_[IN_SELECT_MODE][Tokenizer.CHARACTER_TOKEN] = insertCharacters;
_[IN_SELECT_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_SELECT_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[IN_SELECT_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_SELECT_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_SELECT_MODE][Tokenizer.START_TAG_TOKEN] = startTagInSelect;
_[IN_SELECT_MODE][Tokenizer.END_TAG_TOKEN] = endTagInSelect;
_[IN_SELECT_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_SELECT_IN_TABLE_MODE] = Object.create(null);
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.CHARACTER_TOKEN] = insertCharacters;
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.START_TAG_TOKEN] = startTagInSelectInTable;
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.END_TAG_TOKEN] = endTagInSelectInTable;
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_TEMPLATE_MODE] = Object.create(null);
_[IN_TEMPLATE_MODE][Tokenizer.CHARACTER_TOKEN] = characterInBody;
_[IN_TEMPLATE_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_TEMPLATE_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_[IN_TEMPLATE_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_TEMPLATE_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_TEMPLATE_MODE][Tokenizer.START_TAG_TOKEN] = startTagInTemplate;
_[IN_TEMPLATE_MODE][Tokenizer.END_TAG_TOKEN] = endTagInTemplate;
_[IN_TEMPLATE_MODE][Tokenizer.EOF_TOKEN] = eofInTemplate;

_[AFTER_BODY_MODE] = Object.create(null);
_[AFTER_BODY_MODE][Tokenizer.CHARACTER_TOKEN] =
_[AFTER_BODY_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenAfterBody;
_[AFTER_BODY_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_[AFTER_BODY_MODE][Tokenizer.COMMENT_TOKEN] = appendCommentToRootHtmlElement;
_[AFTER_BODY_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[AFTER_BODY_MODE][Tokenizer.START_TAG_TOKEN] = startTagAfterBody;
_[AFTER_BODY_MODE][Tokenizer.END_TAG_TOKEN] = endTagAfterBody;
_[AFTER_BODY_MODE][Tokenizer.EOF_TOKEN] = stopParsing;

_[IN_FRAMESET_MODE] = Object.create(null);
_[IN_FRAMESET_MODE][Tokenizer.CHARACTER_TOKEN] =
_[IN_FRAMESET_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_FRAMESET_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[IN_FRAMESET_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_FRAMESET_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_FRAMESET_MODE][Tokenizer.START_TAG_TOKEN] = startTagInFrameset;
_[IN_FRAMESET_MODE][Tokenizer.END_TAG_TOKEN] = endTagInFrameset;
_[IN_FRAMESET_MODE][Tokenizer.EOF_TOKEN] = stopParsing;

_[AFTER_FRAMESET_MODE] = Object.create(null);
_[AFTER_FRAMESET_MODE][Tokenizer.CHARACTER_TOKEN] =
_[AFTER_FRAMESET_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[AFTER_FRAMESET_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[AFTER_FRAMESET_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[AFTER_FRAMESET_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[AFTER_FRAMESET_MODE][Tokenizer.START_TAG_TOKEN] = startTagAfterFrameset;
_[AFTER_FRAMESET_MODE][Tokenizer.END_TAG_TOKEN] = endTagAfterFrameset;
_[AFTER_FRAMESET_MODE][Tokenizer.EOF_TOKEN] = stopParsing;

_[AFTER_AFTER_BODY_MODE] = Object.create(null);
_[AFTER_AFTER_BODY_MODE][Tokenizer.CHARACTER_TOKEN] = tokenAfterAfterBody;
_[AFTER_AFTER_BODY_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenAfterAfterBody;
_[AFTER_AFTER_BODY_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_[AFTER_AFTER_BODY_MODE][Tokenizer.COMMENT_TOKEN] = appendCommentToDocument;
_[AFTER_AFTER_BODY_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[AFTER_AFTER_BODY_MODE][Tokenizer.START_TAG_TOKEN] = startTagAfterAfterBody;
_[AFTER_AFTER_BODY_MODE][Tokenizer.END_TAG_TOKEN] = tokenAfterAfterBody;
_[AFTER_AFTER_BODY_MODE][Tokenizer.EOF_TOKEN] = stopParsing;

_[AFTER_AFTER_FRAMESET_MODE] = Object.create(null);
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.CHARACTER_TOKEN] =
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.COMMENT_TOKEN] = appendCommentToDocument;
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.START_TAG_TOKEN] = startTagAfterAfterFrameset;
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.END_TAG_TOKEN] = ignoreToken;
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.EOF_TOKEN] = stopParsing;


//Parser
var Parser = module.exports = function (options) {
    this.options = mergeOptions(DEFAULT_OPTIONS, options);

    this.treeAdapter = this.options.treeAdapter;
    this.pendingScript = null;

    if (this.options.locationInfo)
        locationInfoMixin.assign(this);
};

// API
Parser.prototype.parse = function (html) {
    var document = this.treeAdapter.createDocument();

    this._bootstrap(document, null);
    this.tokenizer.write(html, true);
    this._runParsingLoop(null);

    return document;
};

Parser.prototype.parseFragment = function (html, fragmentContext) {
    //NOTE: use <template> element as a fragment context if context element was not provided,
    //so we will parse in "forgiving" manner
    if (!fragmentContext)
        fragmentContext = this.treeAdapter.createElement($.TEMPLATE, NS.HTML, []);

    //NOTE: create fake element which will be used as 'document' for fragment parsing.
    //This is important for jsdom there 'document' can't be recreated, therefore
    //fragment parsing causes messing of the main `document`.
    var documentMock = this.treeAdapter.createElement('documentmock', NS.HTML, []);

    this._bootstrap(documentMock, fragmentContext);

    if (this.treeAdapter.getTagName(fragmentContext) === $.TEMPLATE)
        this._pushTmplInsertionMode(IN_TEMPLATE_MODE);

    this._initTokenizerForFragmentParsing();
    this._insertFakeRootElement();
    this._resetInsertionMode();
    this._findFormInFragmentContext();
    this.tokenizer.write(html, true);
    this._runParsingLoop(null);

    var rootElement = this.treeAdapter.getFirstChild(documentMock),
        fragment = this.treeAdapter.createDocumentFragment();

    this._adoptNodes(rootElement, fragment);

    return fragment;
};

//Bootstrap parser
Parser.prototype._bootstrap = function (document, fragmentContext) {
    this.tokenizer = new Tokenizer(this.options);

    this.stopped = false;

    this.insertionMode = INITIAL_MODE;
    this.originalInsertionMode = '';

    this.document = document;
    this.fragmentContext = fragmentContext;

    this.headElement = null;
    this.formElement = null;

    this.openElements = new OpenElementStack(this.document, this.treeAdapter);
    this.activeFormattingElements = new FormattingElementList(this.treeAdapter);

    this.tmplInsertionModeStack = [];
    this.tmplInsertionModeStackTop = -1;
    this.currentTmplInsertionMode = null;

    this.pendingCharacterTokens = [];
    this.hasNonWhitespacePendingCharacterToken = false;

    this.framesetOk = true;
    this.skipNextNewLine = false;
    this.fosterParentingEnabled = false;
};

//Parsing loop
Parser.prototype._runParsingLoop  = function (scriptHandler) {
    while (!this.stopped) {
        this._setupTokenizerCDATAMode();

        var token = this.tokenizer.getNextToken();

        if (token.type === Tokenizer.HIBERNATION_TOKEN)
            break;

        if (this.skipNextNewLine) {
            this.skipNextNewLine = false;

            if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === '\n') {
                if (token.chars.length === 1)
                    continue;

                token.chars = token.chars.substr(1);
            }
        }

        this._processInputToken(token);

        if (scriptHandler && this.pendingScript)
            break;
    }
};

Parser.prototype.runParsingLoopForCurrentChunk = function (writeCallback, scriptHandler) {
    this._runParsingLoop(scriptHandler);

    if (scriptHandler && this.pendingScript) {
        var script = this.pendingScript;

        this.pendingScript = null;

        scriptHandler(script);

        return;
    }

    if (writeCallback)
        writeCallback();
};

//Text parsing
Parser.prototype._setupTokenizerCDATAMode = function () {
    var current = this._getAdjustedCurrentElement();

    this.tokenizer.allowCDATA = current && current !== this.document &&
                                this.treeAdapter.getNamespaceURI(current) !== NS.HTML && !this._isIntegrationPoint(current);
};

Parser.prototype._switchToTextParsing = function (currentToken, nextTokenizerState) {
    this._insertElement(currentToken, NS.HTML);
    this.tokenizer.state = nextTokenizerState;
    this.originalInsertionMode = this.insertionMode;
    this.insertionMode = TEXT_MODE;
};

Parser.prototype.switchToPlaintextParsing = function () {
    this.insertionMode = TEXT_MODE;
    this.originalInsertionMode = IN_BODY_MODE;
    this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
};

//Fragment parsing
Parser.prototype._getAdjustedCurrentElement = function () {
    return this.openElements.stackTop === 0 && this.fragmentContext ?
        this.fragmentContext :
        this.openElements.current;
};

Parser.prototype._findFormInFragmentContext = function () {
    var node = this.fragmentContext;

    do {
        if (this.treeAdapter.getTagName(node) === $.FORM) {
            this.formElement = node;
            break;
        }

        node = this.treeAdapter.getParentNode(node);
    } while (node);
};

Parser.prototype._initTokenizerForFragmentParsing = function () {
    if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS.HTML) {
        var tn = this.treeAdapter.getTagName(this.fragmentContext);

        if (tn === $.TITLE || tn === $.TEXTAREA)
            this.tokenizer.state = Tokenizer.MODE.RCDATA;

        else if (tn === $.STYLE || tn === $.XMP || tn === $.IFRAME ||
                 tn === $.NOEMBED || tn === $.NOFRAMES || tn === $.NOSCRIPT)
            this.tokenizer.state = Tokenizer.MODE.RAWTEXT;

        else if (tn === $.SCRIPT)
            this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;

        else if (tn === $.PLAINTEXT)
            this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
    }
};

//Tree mutation
Parser.prototype._setDocumentType = function (token) {
    this.treeAdapter.setDocumentType(this.document, token.name, token.publicId, token.systemId);
};

Parser.prototype._attachElementToTree = function (element) {
    if (this._shouldFosterParentOnInsertion())
        this._fosterParentElement(element);

    else {
        var parent = this.openElements.currentTmplContent || this.openElements.current;

        this.treeAdapter.appendChild(parent, element);
    }
};

Parser.prototype._appendElement = function (token, namespaceURI) {
    var element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);

    this._attachElementToTree(element);
};

Parser.prototype._insertElement = function (token, namespaceURI) {
    var element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);

    this._attachElementToTree(element);
    this.openElements.push(element);
};

Parser.prototype._insertFakeElement = function (tagName) {
    var element = this.treeAdapter.createElement(tagName, NS.HTML, []);

    this._attachElementToTree(element);
    this.openElements.push(element);
};

Parser.prototype._insertTemplate = function (token) {
    var tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs),
        content = this.treeAdapter.createDocumentFragment();

    this.treeAdapter.setTemplateContent(tmpl, content);
    this._attachElementToTree(tmpl);
    this.openElements.push(tmpl);
};

Parser.prototype._insertFakeRootElement = function () {
    var element = this.treeAdapter.createElement($.HTML, NS.HTML, []);

    this.treeAdapter.appendChild(this.openElements.current, element);
    this.openElements.push(element);
};

Parser.prototype._appendCommentNode = function (token, parent) {
    var commentNode = this.treeAdapter.createCommentNode(token.data);

    this.treeAdapter.appendChild(parent, commentNode);
};

Parser.prototype._insertCharacters = function (token) {
    if (this._shouldFosterParentOnInsertion())
        this._fosterParentText(token.chars);

    else {
        var parent = this.openElements.currentTmplContent || this.openElements.current;

        this.treeAdapter.insertText(parent, token.chars);
    }
};

Parser.prototype._adoptNodes = function (donor, recipient) {
    while (true) {
        var child = this.treeAdapter.getFirstChild(donor);

        if (!child)
            break;

        this.treeAdapter.detachNode(child);
        this.treeAdapter.appendChild(recipient, child);
    }
};

//Token processing
Parser.prototype._shouldProcessTokenInForeignContent = function (token) {
    var current = this._getAdjustedCurrentElement();

    if (!current || current === this.document)
        return false;

    var ns = this.treeAdapter.getNamespaceURI(current);

    if (ns === NS.HTML)
        return false;

    if (this.treeAdapter.getTagName(current) === $.ANNOTATION_XML && ns === NS.MATHML &&
        token.type === Tokenizer.START_TAG_TOKEN && token.tagName === $.SVG)
        return false;

    var isCharacterToken = token.type === Tokenizer.CHARACTER_TOKEN ||
                           token.type === Tokenizer.NULL_CHARACTER_TOKEN ||
                           token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN,
        isMathMLTextStartTag = token.type === Tokenizer.START_TAG_TOKEN &&
                               token.tagName !== $.MGLYPH &&
                               token.tagName !== $.MALIGNMARK;

    if ((isMathMLTextStartTag || isCharacterToken) && this._isIntegrationPoint(current, NS.MATHML))
        return false;

    if ((token.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) && this._isIntegrationPoint(current, NS.HTML))
        return false;

    return token.type !== Tokenizer.EOF_TOKEN;
};

Parser.prototype._processToken = function (token) {
    _[this.insertionMode][token.type](this, token);
};

Parser.prototype._processTokenInBodyMode = function (token) {
    _[IN_BODY_MODE][token.type](this, token);
};

Parser.prototype._processTokenInForeignContent = function (token) {
    if (token.type === Tokenizer.CHARACTER_TOKEN)
        characterInForeignContent(this, token);

    else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN)
        nullCharacterInForeignContent(this, token);

    else if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN)
        insertCharacters(this, token);

    else if (token.type === Tokenizer.COMMENT_TOKEN)
        appendComment(this, token);

    else if (token.type === Tokenizer.START_TAG_TOKEN)
        startTagInForeignContent(this, token);

    else if (token.type === Tokenizer.END_TAG_TOKEN)
        endTagInForeignContent(this, token);
};

Parser.prototype._processInputToken = function (token) {
    if (this._shouldProcessTokenInForeignContent(token))
        this._processTokenInForeignContent(token);

    else
        this._processToken(token);
};

//Integration points
Parser.prototype._isIntegrationPoint = function (element, foreignNS) {
    var tn = this.treeAdapter.getTagName(element),
        ns = this.treeAdapter.getNamespaceURI(element),
        attrs = this.treeAdapter.getAttrList(element);

    return foreignContent.isIntegrationPoint(tn, ns, attrs, foreignNS);
};

//Active formatting elements reconstruction
Parser.prototype._reconstructActiveFormattingElements = function () {
    var listLength = this.activeFormattingElements.length;

    if (listLength) {
        var unopenIdx = listLength,
            entry = null;

        do {
            unopenIdx--;
            entry = this.activeFormattingElements.entries[unopenIdx];

            if (entry.type === FormattingElementList.MARKER_ENTRY || this.openElements.contains(entry.element)) {
                unopenIdx++;
                break;
            }
        } while (unopenIdx > 0);

        for (var i = unopenIdx; i < listLength; i++) {
            entry = this.activeFormattingElements.entries[i];
            this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
            entry.element = this.openElements.current;
        }
    }
};

//Close elements
Parser.prototype._closeTableCell = function () {
    this.openElements.generateImpliedEndTags();
    this.openElements.popUntilTableCellPopped();
    this.activeFormattingElements.clearToLastMarker();
    this.insertionMode = IN_ROW_MODE;
};

Parser.prototype._closePElement = function () {
    this.openElements.generateImpliedEndTagsWithExclusion($.P);
    this.openElements.popUntilTagNamePopped($.P);
};

//Insertion modes
Parser.prototype._resetInsertionMode = function () {
    for (var i = this.openElements.stackTop, last = false; i >= 0; i--) {
        var element = this.openElements.items[i];

        if (i === 0) {
            last = true;

            if (this.fragmentContext)
                element = this.fragmentContext;
        }

        var tn = this.treeAdapter.getTagName(element),
            newInsertionMode = INSERTION_MODE_RESET_MAP[tn];

        if (newInsertionMode) {
            this.insertionMode = newInsertionMode;
            break;
        }

        else if (!last && (tn === $.TD || tn === $.TH)) {
            this.insertionMode = IN_CELL_MODE;
            break;
        }

        else if (!last && tn === $.HEAD) {
            this.insertionMode = IN_HEAD_MODE;
            break;
        }

        else if (tn === $.SELECT) {
            this._resetInsertionModeForSelect(i);
            break;
        }

        else if (tn === $.TEMPLATE) {
            this.insertionMode = this.currentTmplInsertionMode;
            break;
        }

        else if (tn === $.HTML) {
            this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;
            break;
        }

        else if (last) {
            this.insertionMode = IN_BODY_MODE;
            break;
        }
    }
};

Parser.prototype._resetInsertionModeForSelect = function (selectIdx) {
    if (selectIdx > 0) {
        for (var i = selectIdx - 1; i > 0; i--) {
            var ancestor = this.openElements.items[i],
                tn = this.treeAdapter.getTagName(ancestor);

            if (tn === $.TEMPLATE)
                break;

            else if (tn === $.TABLE) {
                this.insertionMode = IN_SELECT_IN_TABLE_MODE;
                return;
            }
        }
    }

    this.insertionMode = IN_SELECT_MODE;
};

Parser.prototype._pushTmplInsertionMode = function (mode) {
    this.tmplInsertionModeStack.push(mode);
    this.tmplInsertionModeStackTop++;
    this.currentTmplInsertionMode = mode;
};

Parser.prototype._popTmplInsertionMode = function () {
    this.tmplInsertionModeStack.pop();
    this.tmplInsertionModeStackTop--;
    this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
};

//Foster parenting
Parser.prototype._isElementCausesFosterParenting = function (element) {
    var tn = this.treeAdapter.getTagName(element);

    return tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR;
};

Parser.prototype._shouldFosterParentOnInsertion = function () {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);
};

Parser.prototype._findFosterParentingLocation = function () {
    var location = {
        parent: null,
        beforeElement: null
    };

    for (var i = this.openElements.stackTop; i >= 0; i--) {
        var openElement = this.openElements.items[i],
            tn = this.treeAdapter.getTagName(openElement),
            ns = this.treeAdapter.getNamespaceURI(openElement);

        if (tn === $.TEMPLATE && ns === NS.HTML) {
            location.parent = this.treeAdapter.getTemplateContent(openElement);
            break;
        }

        else if (tn === $.TABLE) {
            location.parent = this.treeAdapter.getParentNode(openElement);

            if (location.parent)
                location.beforeElement = openElement;
            else
                location.parent = this.openElements.items[i - 1];

            break;
        }
    }

    if (!location.parent)
        location.parent = this.openElements.items[0];

    return location;
};

Parser.prototype._fosterParentElement = function (element) {
    var location = this._findFosterParentingLocation();

    if (location.beforeElement)
        this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);
    else
        this.treeAdapter.appendChild(location.parent, element);
};

Parser.prototype._fosterParentText = function (chars) {
    var location = this._findFosterParentingLocation();

    if (location.beforeElement)
        this.treeAdapter.insertTextBefore(location.parent, chars, location.beforeElement);
    else
        this.treeAdapter.insertText(location.parent, chars);
};

//Special elements
Parser.prototype._isSpecialElement = function (element) {
    var tn = this.treeAdapter.getTagName(element),
        ns = this.treeAdapter.getNamespaceURI(element);

    return HTML.SPECIAL_ELEMENTS[ns][tn];
};

//Adoption agency algorithm
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency)
//------------------------------------------------------------------

//Steps 5-8 of the algorithm
function aaObtainFormattingElementEntry(p, token) {
    var formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);

    if (formattingElementEntry) {
        if (!p.openElements.contains(formattingElementEntry.element)) {
            p.activeFormattingElements.removeEntry(formattingElementEntry);
            formattingElementEntry = null;
        }

        else if (!p.openElements.hasInScope(token.tagName))
            formattingElementEntry = null;
    }

    else
        genericEndTagInBody(p, token);

    return formattingElementEntry;
}

//Steps 9 and 10 of the algorithm
function aaObtainFurthestBlock(p, formattingElementEntry) {
    var furthestBlock = null;

    for (var i = p.openElements.stackTop; i >= 0; i--) {
        var element = p.openElements.items[i];

        if (element === formattingElementEntry.element)
            break;

        if (p._isSpecialElement(element))
            furthestBlock = element;
    }

    if (!furthestBlock) {
        p.openElements.popUntilElementPopped(formattingElementEntry.element);
        p.activeFormattingElements.removeEntry(formattingElementEntry);
    }

    return furthestBlock;
}

//Step 13 of the algorithm
function aaInnerLoop(p, furthestBlock, formattingElement) {
    var lastElement = furthestBlock,
        nextElement = p.openElements.getCommonAncestor(furthestBlock);

    for (var i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
        //NOTE: store next element for the next loop iteration (it may be deleted from the stack by step 9.5)
        nextElement = p.openElements.getCommonAncestor(element);

        var elementEntry = p.activeFormattingElements.getElementEntry(element),
            counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER,
            shouldRemoveFromOpenElements = !elementEntry || counterOverflow;

        if (shouldRemoveFromOpenElements) {
            if (counterOverflow)
                p.activeFormattingElements.removeEntry(elementEntry);

            p.openElements.remove(element);
        }

        else {
            element = aaRecreateElementFromEntry(p, elementEntry);

            if (lastElement === furthestBlock)
                p.activeFormattingElements.bookmark = elementEntry;

            p.treeAdapter.detachNode(lastElement);
            p.treeAdapter.appendChild(element, lastElement);
            lastElement = element;
        }
    }

    return lastElement;
}

//Step 13.7 of the algorithm
function aaRecreateElementFromEntry(p, elementEntry) {
    var ns = p.treeAdapter.getNamespaceURI(elementEntry.element),
        newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);

    p.openElements.replace(elementEntry.element, newElement);
    elementEntry.element = newElement;

    return newElement;
}

//Step 14 of the algorithm
function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
    if (p._isElementCausesFosterParenting(commonAncestor))
        p._fosterParentElement(lastElement);

    else {
        var tn = p.treeAdapter.getTagName(commonAncestor),
            ns = p.treeAdapter.getNamespaceURI(commonAncestor);

        if (tn === $.TEMPLATE && ns === NS.HTML)
            commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);

        p.treeAdapter.appendChild(commonAncestor, lastElement);
    }
}

//Steps 15-19 of the algorithm
function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
    var ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element),
        token = formattingElementEntry.token,
        newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);

    p._adoptNodes(furthestBlock, newElement);
    p.treeAdapter.appendChild(furthestBlock, newElement);

    p.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);
    p.activeFormattingElements.removeEntry(formattingElementEntry);

    p.openElements.remove(formattingElementEntry.element);
    p.openElements.insertAfter(furthestBlock, newElement);
}

//Algorithm entry point
function callAdoptionAgency(p, token) {
    var formattingElementEntry;

    for (var i = 0; i < AA_OUTER_LOOP_ITER; i++) {
        formattingElementEntry = aaObtainFormattingElementEntry(p, token, formattingElementEntry);

        if (!formattingElementEntry)
            break;

        var furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);

        if (!furthestBlock)
            break;

        p.activeFormattingElements.bookmark = formattingElementEntry;

        var lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element),
            commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);

        p.treeAdapter.detachNode(lastElement);
        aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
        aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
    }
}


//Generic token handlers
//------------------------------------------------------------------
function ignoreToken() {
    //NOTE: do nothing =)
}

function appendComment(p, token) {
    p._appendCommentNode(token, p.openElements.currentTmplContent || p.openElements.current);
}

function appendCommentToRootHtmlElement(p, token) {
    p._appendCommentNode(token, p.openElements.items[0]);
}

function appendCommentToDocument(p, token) {
    p._appendCommentNode(token, p.document);
}

function insertCharacters(p, token) {
    p._insertCharacters(token);
}

function stopParsing(p) {
    p.stopped = true;
}

//12.2.5.4.1 The "initial" insertion mode
//------------------------------------------------------------------
function doctypeInInitialMode(p, token) {
    p._setDocumentType(token);

    var mode = token.forceQuirks ?
        HTML.DOCUMENT_MODE.QUIRKS :
        doctype.getDocumentMode(token.name, token.publicId, token.systemId);

    p.treeAdapter.setDocumentMode(p.document, mode);

    p.insertionMode = BEFORE_HTML_MODE;
}

function tokenInInitialMode(p, token) {
    p.treeAdapter.setDocumentMode(p.document, HTML.DOCUMENT_MODE.QUIRKS);
    p.insertionMode = BEFORE_HTML_MODE;
    p._processToken(token);
}


//12.2.5.4.2 The "before html" insertion mode
//------------------------------------------------------------------
function startTagBeforeHtml(p, token) {
    if (token.tagName === $.HTML) {
        p._insertElement(token, NS.HTML);
        p.insertionMode = BEFORE_HEAD_MODE;
    }

    else
        tokenBeforeHtml(p, token);
}

function endTagBeforeHtml(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML || tn === $.HEAD || tn === $.BODY || tn === $.BR)
        tokenBeforeHtml(p, token);
}

function tokenBeforeHtml(p, token) {
    p._insertFakeRootElement();
    p.insertionMode = BEFORE_HEAD_MODE;
    p._processToken(token);
}


//12.2.5.4.3 The "before head" insertion mode
//------------------------------------------------------------------
function startTagBeforeHead(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.HEAD) {
        p._insertElement(token, NS.HTML);
        p.headElement = p.openElements.current;
        p.insertionMode = IN_HEAD_MODE;
    }

    else
        tokenBeforeHead(p, token);
}

function endTagBeforeHead(p, token) {
    var tn = token.tagName;

    if (tn === $.HEAD || tn === $.BODY || tn === $.HTML || tn === $.BR)
        tokenBeforeHead(p, token);
}

function tokenBeforeHead(p, token) {
    p._insertFakeElement($.HEAD);
    p.headElement = p.openElements.current;
    p.insertionMode = IN_HEAD_MODE;
    p._processToken(token);
}


//12.2.5.4.4 The "in head" insertion mode
//------------------------------------------------------------------
function startTagInHead(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META)
        p._appendElement(token, NS.HTML);

    else if (tn === $.TITLE)
        p._switchToTextParsing(token, Tokenizer.MODE.RCDATA);

    //NOTE: here we assume that we always act as an interactive user agent with enabled scripting, so we parse
    //<noscript> as a rawtext.
    else if (tn === $.NOSCRIPT || tn === $.NOFRAMES || tn === $.STYLE)
        p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);

    else if (tn === $.SCRIPT)
        p._switchToTextParsing(token, Tokenizer.MODE.SCRIPT_DATA);

    else if (tn === $.TEMPLATE) {
        p._insertTemplate(token, NS.HTML);
        p.activeFormattingElements.insertMarker();
        p.framesetOk = false;
        p.insertionMode = IN_TEMPLATE_MODE;
        p._pushTmplInsertionMode(IN_TEMPLATE_MODE);
    }

    else if (tn !== $.HEAD)
        tokenInHead(p, token);
}

function endTagInHead(p, token) {
    var tn = token.tagName;

    if (tn === $.HEAD) {
        p.openElements.pop();
        p.insertionMode = AFTER_HEAD_MODE;
    }

    else if (tn === $.BODY || tn === $.BR || tn === $.HTML)
        tokenInHead(p, token);

    else if (tn === $.TEMPLATE && p.openElements.tmplCount > 0) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped($.TEMPLATE);
        p.activeFormattingElements.clearToLastMarker();
        p._popTmplInsertionMode();
        p._resetInsertionMode();
    }
}

function tokenInHead(p, token) {
    p.openElements.pop();
    p.insertionMode = AFTER_HEAD_MODE;
    p._processToken(token);
}


//12.2.5.4.6 The "after head" insertion mode
//------------------------------------------------------------------
function startTagAfterHead(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.BODY) {
        p._insertElement(token, NS.HTML);
        p.framesetOk = false;
        p.insertionMode = IN_BODY_MODE;
    }

    else if (tn === $.FRAMESET) {
        p._insertElement(token, NS.HTML);
        p.insertionMode = IN_FRAMESET_MODE;
    }

    else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META ||
             tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE) {
        p.openElements.push(p.headElement);
        startTagInHead(p, token);
        p.openElements.remove(p.headElement);
    }

    else if (tn !== $.HEAD)
        tokenAfterHead(p, token);
}

function endTagAfterHead(p, token) {
    var tn = token.tagName;

    if (tn === $.BODY || tn === $.HTML || tn === $.BR)
        tokenAfterHead(p, token);

    else if (tn === $.TEMPLATE)
        endTagInHead(p, token);
}

function tokenAfterHead(p, token) {
    p._insertFakeElement($.BODY);
    p.insertionMode = IN_BODY_MODE;
    p._processToken(token);
}


//12.2.5.4.7 The "in body" insertion mode
//------------------------------------------------------------------
function whitespaceCharacterInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertCharacters(token);
}

function characterInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertCharacters(token);
    p.framesetOk = false;
}

function htmlStartTagInBody(p, token) {
    if (p.openElements.tmplCount === 0)
        p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
}

function bodyStartTagInBody(p, token) {
    var bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();

    if (bodyElement && p.openElements.tmplCount === 0) {
        p.framesetOk = false;
        p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
    }
}

function framesetStartTagInBody(p, token) {
    var bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();

    if (p.framesetOk && bodyElement) {
        p.treeAdapter.detachNode(bodyElement);
        p.openElements.popAllUpToHtmlElement();
        p._insertElement(token, NS.HTML);
        p.insertionMode = IN_FRAMESET_MODE;
    }
}

function addressStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($.P))
        p._closePElement();

    p._insertElement(token, NS.HTML);
}

function numberedHeaderStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($.P))
        p._closePElement();

    var tn = p.openElements.currentTagName;

    if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6)
        p.openElements.pop();

    p._insertElement(token, NS.HTML);
}

function preStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($.P))
        p._closePElement();

    p._insertElement(token, NS.HTML);
    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
    //on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)
    p.skipNextNewLine = true;
    p.framesetOk = false;
}

function formStartTagInBody(p, token) {
    var inTemplate = p.openElements.tmplCount > 0;

    if (!p.formElement || inTemplate) {
        if (p.openElements.hasInButtonScope($.P))
            p._closePElement();

        p._insertElement(token, NS.HTML);

        if (!inTemplate)
            p.formElement = p.openElements.current;
    }
}

function listItemStartTagInBody(p, token) {
    p.framesetOk = false;

    var tn = token.tagName;

    for (var i = p.openElements.stackTop; i >= 0; i--) {
        var element = p.openElements.items[i],
            elementTn = p.treeAdapter.getTagName(element),
            closeTn = null;

        if (tn === $.LI && elementTn === $.LI)
            closeTn = $.LI;

        else if ((tn === $.DD || tn === $.DT) && (elementTn === $.DD || elementTn === $.DT))
            closeTn = elementTn;

        if (closeTn) {
            p.openElements.generateImpliedEndTagsWithExclusion(closeTn);
            p.openElements.popUntilTagNamePopped(closeTn);
            break;
        }

        if (elementTn !== $.ADDRESS && elementTn !== $.DIV && elementTn !== $.P && p._isSpecialElement(element))
            break;
    }

    if (p.openElements.hasInButtonScope($.P))
        p._closePElement();

    p._insertElement(token, NS.HTML);
}

function plaintextStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($.P))
        p._closePElement();

    p._insertElement(token, NS.HTML);
    p.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
}

function buttonStartTagInBody(p, token) {
    if (p.openElements.hasInScope($.BUTTON)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped($.BUTTON);
    }

    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
    p.framesetOk = false;
}

function aStartTagInBody(p, token) {
    var activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName($.A);

    if (activeElementEntry) {
        callAdoptionAgency(p, token);
        p.openElements.remove(activeElementEntry.element);
        p.activeFormattingElements.removeEntry(activeElementEntry);
    }

    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
    p.activeFormattingElements.pushElement(p.openElements.current, token);
}

function bStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
    p.activeFormattingElements.pushElement(p.openElements.current, token);
}

function nobrStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();

    if (p.openElements.hasInScope($.NOBR)) {
        callAdoptionAgency(p, token);
        p._reconstructActiveFormattingElements();
    }

    p._insertElement(token, NS.HTML);
    p.activeFormattingElements.pushElement(p.openElements.current, token);
}

function appletStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
    p.activeFormattingElements.insertMarker();
    p.framesetOk = false;
}

function tableStartTagInBody(p, token) {
    if (p.treeAdapter.getDocumentMode(p.document) !== HTML.DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope($.P))
        p._closePElement();

    p._insertElement(token, NS.HTML);
    p.framesetOk = false;
    p.insertionMode = IN_TABLE_MODE;
}

function areaStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._appendElement(token, NS.HTML);
    p.framesetOk = false;
}

function inputStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._appendElement(token, NS.HTML);

    var inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);

    if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE)
        p.framesetOk = false;

}

function paramStartTagInBody(p, token) {
    p._appendElement(token, NS.HTML);
}

function hrStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($.P))
        p._closePElement();

    if (p.openElements.currentTagName === $.MENUITEM)
        p.openElements.pop();

    p._appendElement(token, NS.HTML);
    p.framesetOk = false;
}

function imageStartTagInBody(p, token) {
    token.tagName = $.IMG;
    areaStartTagInBody(p, token);
}

function textareaStartTagInBody(p, token) {
    p._insertElement(token, NS.HTML);
    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
    //on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
    p.skipNextNewLine = true;
    p.tokenizer.state = Tokenizer.MODE.RCDATA;
    p.originalInsertionMode = p.insertionMode;
    p.framesetOk = false;
    p.insertionMode = TEXT_MODE;
}

function xmpStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($.P))
        p._closePElement();

    p._reconstructActiveFormattingElements();
    p.framesetOk = false;
    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
}

function iframeStartTagInBody(p, token) {
    p.framesetOk = false;
    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
}

//NOTE: here we assume that we always act as an user agent with enabled plugins, so we parse
//<noembed> as a rawtext.
function noembedStartTagInBody(p, token) {
    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
}

function selectStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
    p.framesetOk = false;

    if (p.insertionMode === IN_TABLE_MODE ||
        p.insertionMode === IN_CAPTION_MODE ||
        p.insertionMode === IN_TABLE_BODY_MODE ||
        p.insertionMode === IN_ROW_MODE ||
        p.insertionMode === IN_CELL_MODE)

        p.insertionMode = IN_SELECT_IN_TABLE_MODE;

    else
        p.insertionMode = IN_SELECT_MODE;
}

function optgroupStartTagInBody(p, token) {
    if (p.openElements.currentTagName === $.OPTION)
        p.openElements.pop();

    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
}

function rbStartTagInBody(p, token) {
    if (p.openElements.hasInScope($.RUBY))
        p.openElements.generateImpliedEndTags();

    p._insertElement(token, NS.HTML);
}

function rtStartTagInBody(p, token) {
    if (p.openElements.hasInScope($.RUBY))
        p.openElements.generateImpliedEndTagsWithExclusion($.RTC);

    p._insertElement(token, NS.HTML);
}

function menuitemStartTagInBody(p, token) {
    if (p.openElements.currentTagName === $.MENUITEM)
        p.openElements.pop();

    // TODO needs clarification, see https://github.com/whatwg/html/pull/907/files#r73505877
    p._reconstructActiveFormattingElements();

    p._insertElement(token, NS.HTML);
}

function menuStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($.P))
        p._closePElement();

    if (p.openElements.currentTagName === $.MENUITEM)
        p.openElements.pop();

    p._insertElement(token, NS.HTML);
}

function mathStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();

    foreignContent.adjustTokenMathMLAttrs(token);
    foreignContent.adjustTokenXMLAttrs(token);

    if (token.selfClosing)
        p._appendElement(token, NS.MATHML);
    else
        p._insertElement(token, NS.MATHML);
}

function svgStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();

    foreignContent.adjustTokenSVGAttrs(token);
    foreignContent.adjustTokenXMLAttrs(token);

    if (token.selfClosing)
        p._appendElement(token, NS.SVG);
    else
        p._insertElement(token, NS.SVG);
}

function genericStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
}

//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
//It's faster than using dictionary.
function startTagInBody(p, token) {
    var tn = token.tagName;

    switch (tn.length) {
        case 1:
            if (tn === $.I || tn === $.S || tn === $.B || tn === $.U)
                bStartTagInBody(p, token);

            else if (tn === $.P)
                addressStartTagInBody(p, token);

            else if (tn === $.A)
                aStartTagInBody(p, token);

            else
                genericStartTagInBody(p, token);

            break;

        case 2:
            if (tn === $.DL || tn === $.OL || tn === $.UL)
                addressStartTagInBody(p, token);

            else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6)
                numberedHeaderStartTagInBody(p, token);

            else if (tn === $.LI || tn === $.DD || tn === $.DT)
                listItemStartTagInBody(p, token);

            else if (tn === $.EM || tn === $.TT)
                bStartTagInBody(p, token);

            else if (tn === $.BR)
                areaStartTagInBody(p, token);

            else if (tn === $.HR)
                hrStartTagInBody(p, token);

            else if (tn === $.RB)
                rbStartTagInBody(p, token);

            else if (tn === $.RT || tn === $.RP)
                rtStartTagInBody(p, token);

            else if (tn !== $.TH && tn !== $.TD && tn !== $.TR)
                genericStartTagInBody(p, token);

            break;

        case 3:
            if (tn === $.DIV || tn === $.DIR || tn === $.NAV)
                addressStartTagInBody(p, token);

            else if (tn === $.PRE)
                preStartTagInBody(p, token);

            else if (tn === $.BIG)
                bStartTagInBody(p, token);

            else if (tn === $.IMG || tn === $.WBR)
                areaStartTagInBody(p, token);

            else if (tn === $.XMP)
                xmpStartTagInBody(p, token);

            else if (tn === $.SVG)
                svgStartTagInBody(p, token);

            else if (tn === $.RTC)
                rbStartTagInBody(p, token);

            else if (tn !== $.COL)
                genericStartTagInBody(p, token);

            break;

        case 4:
            if (tn === $.HTML)
                htmlStartTagInBody(p, token);

            else if (tn === $.BASE || tn === $.LINK || tn === $.META)
                startTagInHead(p, token);

            else if (tn === $.BODY)
                bodyStartTagInBody(p, token);

            else if (tn === $.MAIN)
                addressStartTagInBody(p, token);

            else if (tn === $.FORM)
                formStartTagInBody(p, token);

            else if (tn === $.CODE || tn === $.FONT)
                bStartTagInBody(p, token);

            else if (tn === $.NOBR)
                nobrStartTagInBody(p, token);

            else if (tn === $.AREA)
                areaStartTagInBody(p, token);

            else if (tn === $.MATH)
                mathStartTagInBody(p, token);

            else if (tn === $.MENU)
                menuStartTagInBody(p, token);

            else if (tn !== $.HEAD)
                genericStartTagInBody(p, token);

            break;

        case 5:
            if (tn === $.STYLE || tn === $.TITLE)
                startTagInHead(p, token);

            else if (tn === $.ASIDE)
                addressStartTagInBody(p, token);

            else if (tn === $.SMALL)
                bStartTagInBody(p, token);

            else if (tn === $.TABLE)
                tableStartTagInBody(p, token);

            else if (tn === $.EMBED)
                areaStartTagInBody(p, token);

            else if (tn === $.INPUT)
                inputStartTagInBody(p, token);

            else if (tn === $.PARAM || tn === $.TRACK)
                paramStartTagInBody(p, token);

            else if (tn === $.IMAGE)
                imageStartTagInBody(p, token);

            else if (tn !== $.FRAME && tn !== $.TBODY && tn !== $.TFOOT && tn !== $.THEAD)
                genericStartTagInBody(p, token);

            break;

        case 6:
            if (tn === $.SCRIPT)
                startTagInHead(p, token);

            else if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP)
                addressStartTagInBody(p, token);

            else if (tn === $.BUTTON)
                buttonStartTagInBody(p, token);

            else if (tn === $.STRIKE || tn === $.STRONG)
                bStartTagInBody(p, token);

            else if (tn === $.APPLET || tn === $.OBJECT)
                appletStartTagInBody(p, token);

            else if (tn === $.KEYGEN)
                areaStartTagInBody(p, token);

            else if (tn === $.SOURCE)
                paramStartTagInBody(p, token);

            else if (tn === $.IFRAME)
                iframeStartTagInBody(p, token);

            else if (tn === $.SELECT)
                selectStartTagInBody(p, token);

            else if (tn === $.OPTION)
                optgroupStartTagInBody(p, token);

            else
                genericStartTagInBody(p, token);

            break;

        case 7:
            if (tn === $.BGSOUND)
                startTagInHead(p, token);

            else if (tn === $.DETAILS || tn === $.ADDRESS || tn === $.ARTICLE || tn === $.SECTION || tn === $.SUMMARY)
                addressStartTagInBody(p, token);

            else if (tn === $.LISTING)
                preStartTagInBody(p, token);

            else if (tn === $.MARQUEE)
                appletStartTagInBody(p, token);

            else if (tn === $.NOEMBED)
                noembedStartTagInBody(p, token);

            else if (tn !== $.CAPTION)
                genericStartTagInBody(p, token);

            break;

        case 8:
            if (tn === $.BASEFONT)
                startTagInHead(p, token);

            else if (tn === $.MENUITEM)
                menuitemStartTagInBody(p, token);

            else if (tn === $.FRAMESET)
                framesetStartTagInBody(p, token);

            else if (tn === $.FIELDSET)
                addressStartTagInBody(p, token);

            else if (tn === $.TEXTAREA)
                textareaStartTagInBody(p, token);

            else if (tn === $.TEMPLATE)
                startTagInHead(p, token);

            else if (tn === $.NOSCRIPT)
                noembedStartTagInBody(p, token);

            else if (tn === $.OPTGROUP)
                optgroupStartTagInBody(p, token);

            else if (tn !== $.COLGROUP)
                genericStartTagInBody(p, token);

            break;

        case 9:
            if (tn === $.PLAINTEXT)
                plaintextStartTagInBody(p, token);

            else
                genericStartTagInBody(p, token);

            break;

        case 10:
            if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION)
                addressStartTagInBody(p, token);

            else
                genericStartTagInBody(p, token);

            break;

        default:
            genericStartTagInBody(p, token);
    }
}

function bodyEndTagInBody(p) {
    if (p.openElements.hasInScope($.BODY))
        p.insertionMode = AFTER_BODY_MODE;
}

function htmlEndTagInBody(p, token) {
    if (p.openElements.hasInScope($.BODY)) {
        p.insertionMode = AFTER_BODY_MODE;
        p._processToken(token);
    }
}

function addressEndTagInBody(p, token) {
    var tn = token.tagName;

    if (p.openElements.hasInScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
    }
}

function formEndTagInBody(p) {
    var inTemplate = p.openElements.tmplCount > 0,
        formElement = p.formElement;

    if (!inTemplate)
        p.formElement = null;

    if ((formElement || inTemplate) && p.openElements.hasInScope($.FORM)) {
        p.openElements.generateImpliedEndTags();

        if (inTemplate)
            p.openElements.popUntilTagNamePopped($.FORM);

        else
            p.openElements.remove(formElement);
    }
}

function pEndTagInBody(p) {
    if (!p.openElements.hasInButtonScope($.P))
        p._insertFakeElement($.P);

    p._closePElement();
}

function liEndTagInBody(p) {
    if (p.openElements.hasInListItemScope($.LI)) {
        p.openElements.generateImpliedEndTagsWithExclusion($.LI);
        p.openElements.popUntilTagNamePopped($.LI);
    }
}

function ddEndTagInBody(p, token) {
    var tn = token.tagName;

    if (p.openElements.hasInScope(tn)) {
        p.openElements.generateImpliedEndTagsWithExclusion(tn);
        p.openElements.popUntilTagNamePopped(tn);
    }
}

function numberedHeaderEndTagInBody(p) {
    if (p.openElements.hasNumberedHeaderInScope()) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilNumberedHeaderPopped();
    }
}

function appletEndTagInBody(p, token) {
    var tn = token.tagName;

    if (p.openElements.hasInScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
        p.activeFormattingElements.clearToLastMarker();
    }
}

function brEndTagInBody(p) {
    p._reconstructActiveFormattingElements();
    p._insertFakeElement($.BR);
    p.openElements.pop();
    p.framesetOk = false;
}

function genericEndTagInBody(p, token) {
    var tn = token.tagName;

    for (var i = p.openElements.stackTop; i > 0; i--) {
        var element = p.openElements.items[i];

        if (p.treeAdapter.getTagName(element) === tn) {
            p.openElements.generateImpliedEndTagsWithExclusion(tn);
            p.openElements.popUntilElementPopped(element);
            break;
        }

        if (p._isSpecialElement(element))
            break;
    }
}

//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
//It's faster than using dictionary.
function endTagInBody(p, token) {
    var tn = token.tagName;

    switch (tn.length) {
        case 1:
            if (tn === $.A || tn === $.B || tn === $.I || tn === $.S || tn === $.U)
                callAdoptionAgency(p, token);

            else if (tn === $.P)
                pEndTagInBody(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 2:
            if (tn === $.DL || tn === $.UL || tn === $.OL)
                addressEndTagInBody(p, token);

            else if (tn === $.LI)
                liEndTagInBody(p, token);

            else if (tn === $.DD || tn === $.DT)
                ddEndTagInBody(p, token);

            else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6)
                numberedHeaderEndTagInBody(p, token);

            else if (tn === $.BR)
                brEndTagInBody(p, token);

            else if (tn === $.EM || tn === $.TT)
                callAdoptionAgency(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 3:
            if (tn === $.BIG)
                callAdoptionAgency(p, token);

            else if (tn === $.DIR || tn === $.DIV || tn === $.NAV)
                addressEndTagInBody(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 4:
            if (tn === $.BODY)
                bodyEndTagInBody(p, token);

            else if (tn === $.HTML)
                htmlEndTagInBody(p, token);

            else if (tn === $.FORM)
                formEndTagInBody(p, token);

            else if (tn === $.CODE || tn === $.FONT || tn === $.NOBR)
                callAdoptionAgency(p, token);

            else if (tn === $.MAIN || tn === $.MENU)
                addressEndTagInBody(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 5:
            if (tn === $.ASIDE)
                addressEndTagInBody(p, token);

            else if (tn === $.SMALL)
                callAdoptionAgency(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 6:
            if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP)
                addressEndTagInBody(p, token);

            else if (tn === $.APPLET || tn === $.OBJECT)
                appletEndTagInBody(p, token);

            else if (tn === $.STRIKE || tn === $.STRONG)
                callAdoptionAgency(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 7:
            if (tn === $.ADDRESS || tn === $.ARTICLE || tn === $.DETAILS || tn === $.SECTION || tn === $.SUMMARY)
                addressEndTagInBody(p, token);

            else if (tn === $.MARQUEE)
                appletEndTagInBody(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 8:
            if (tn === $.FIELDSET)
                addressEndTagInBody(p, token);

            else if (tn === $.TEMPLATE)
                endTagInHead(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 10:
            if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION)
                addressEndTagInBody(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        default :
            genericEndTagInBody(p, token);
    }
}

function eofInBody(p, token) {
    if (p.tmplInsertionModeStackTop > -1)
        eofInTemplate(p, token);

    else
        p.stopped = true;
}

//12.2.5.4.8 The "text" insertion mode
//------------------------------------------------------------------
function endTagInText(p, token) {
    if (token.tagName === $.SCRIPT)
        p.pendingScript = p.openElements.current;

    p.openElements.pop();
    p.insertionMode = p.originalInsertionMode;
}


function eofInText(p, token) {
    p.openElements.pop();
    p.insertionMode = p.originalInsertionMode;
    p._processToken(token);
}


//12.2.5.4.9 The "in table" insertion mode
//------------------------------------------------------------------
function characterInTable(p, token) {
    var curTn = p.openElements.currentTagName;

    if (curTn === $.TABLE || curTn === $.TBODY || curTn === $.TFOOT || curTn === $.THEAD || curTn === $.TR) {
        p.pendingCharacterTokens = [];
        p.hasNonWhitespacePendingCharacterToken = false;
        p.originalInsertionMode = p.insertionMode;
        p.insertionMode = IN_TABLE_TEXT_MODE;
        p._processToken(token);
    }

    else
        tokenInTable(p, token);
}

function captionStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p.activeFormattingElements.insertMarker();
    p._insertElement(token, NS.HTML);
    p.insertionMode = IN_CAPTION_MODE;
}

function colgroupStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertElement(token, NS.HTML);
    p.insertionMode = IN_COLUMN_GROUP_MODE;
}

function colStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertFakeElement($.COLGROUP);
    p.insertionMode = IN_COLUMN_GROUP_MODE;
    p._processToken(token);
}

function tbodyStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertElement(token, NS.HTML);
    p.insertionMode = IN_TABLE_BODY_MODE;
}

function tdStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertFakeElement($.TBODY);
    p.insertionMode = IN_TABLE_BODY_MODE;
    p._processToken(token);
}

function tableStartTagInTable(p, token) {
    if (p.openElements.hasInTableScope($.TABLE)) {
        p.openElements.popUntilTagNamePopped($.TABLE);
        p._resetInsertionMode();
        p._processToken(token);
    }
}

function inputStartTagInTable(p, token) {
    var inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);

    if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE)
        p._appendElement(token, NS.HTML);

    else
        tokenInTable(p, token);
}

function formStartTagInTable(p, token) {
    if (!p.formElement && p.openElements.tmplCount === 0) {
        p._insertElement(token, NS.HTML);
        p.formElement = p.openElements.current;
        p.openElements.pop();
    }
}

function startTagInTable(p, token) {
    var tn = token.tagName;

    switch (tn.length) {
        case 2:
            if (tn === $.TD || tn === $.TH || tn === $.TR)
                tdStartTagInTable(p, token);

            else
                tokenInTable(p, token);

            break;

        case 3:
            if (tn === $.COL)
                colStartTagInTable(p, token);

            else
                tokenInTable(p, token);

            break;

        case 4:
            if (tn === $.FORM)
                formStartTagInTable(p, token);

            else
                tokenInTable(p, token);

            break;

        case 5:
            if (tn === $.TABLE)
                tableStartTagInTable(p, token);

            else if (tn === $.STYLE)
                startTagInHead(p, token);

            else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD)
                tbodyStartTagInTable(p, token);

            else if (tn === $.INPUT)
                inputStartTagInTable(p, token);

            else
                tokenInTable(p, token);

            break;

        case 6:
            if (tn === $.SCRIPT)
                startTagInHead(p, token);

            else
                tokenInTable(p, token);

            break;

        case 7:
            if (tn === $.CAPTION)
                captionStartTagInTable(p, token);

            else
                tokenInTable(p, token);

            break;

        case 8:
            if (tn === $.COLGROUP)
                colgroupStartTagInTable(p, token);

            else if (tn === $.TEMPLATE)
                startTagInHead(p, token);

            else
                tokenInTable(p, token);

            break;

        default:
            tokenInTable(p, token);
    }

}

function endTagInTable(p, token) {
    var tn = token.tagName;

    if (tn === $.TABLE) {
        if (p.openElements.hasInTableScope($.TABLE)) {
            p.openElements.popUntilTagNamePopped($.TABLE);
            p._resetInsertionMode();
        }
    }

    else if (tn === $.TEMPLATE)
        endTagInHead(p, token);

    else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML &&
             tn !== $.TBODY && tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR)
        tokenInTable(p, token);
}

function tokenInTable(p, token) {
    var savedFosterParentingState = p.fosterParentingEnabled;

    p.fosterParentingEnabled = true;
    p._processTokenInBodyMode(token);
    p.fosterParentingEnabled = savedFosterParentingState;
}


//12.2.5.4.10 The "in table text" insertion mode
//------------------------------------------------------------------
function whitespaceCharacterInTableText(p, token) {
    p.pendingCharacterTokens.push(token);
}

function characterInTableText(p, token) {
    p.pendingCharacterTokens.push(token);
    p.hasNonWhitespacePendingCharacterToken = true;
}

function tokenInTableText(p, token) {
    var i = 0;

    if (p.hasNonWhitespacePendingCharacterToken) {
        for (; i < p.pendingCharacterTokens.length; i++)
            tokenInTable(p, p.pendingCharacterTokens[i]);
    }

    else {
        for (; i < p.pendingCharacterTokens.length; i++)
            p._insertCharacters(p.pendingCharacterTokens[i]);
    }

    p.insertionMode = p.originalInsertionMode;
    p._processToken(token);
}


//12.2.5.4.11 The "in caption" insertion mode
//------------------------------------------------------------------
function startTagInCaption(p, token) {
    var tn = token.tagName;

    if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY ||
        tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {
        if (p.openElements.hasInTableScope($.CAPTION)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped($.CAPTION);
            p.activeFormattingElements.clearToLastMarker();
            p.insertionMode = IN_TABLE_MODE;
            p._processToken(token);
        }
    }

    else
        startTagInBody(p, token);
}

function endTagInCaption(p, token) {
    var tn = token.tagName;

    if (tn === $.CAPTION || tn === $.TABLE) {
        if (p.openElements.hasInTableScope($.CAPTION)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped($.CAPTION);
            p.activeFormattingElements.clearToLastMarker();
            p.insertionMode = IN_TABLE_MODE;

            if (tn === $.TABLE)
                p._processToken(token);
        }
    }

    else if (tn !== $.BODY && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML && tn !== $.TBODY &&
             tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR)
        endTagInBody(p, token);
}


//12.2.5.4.12 The "in column group" insertion mode
//------------------------------------------------------------------
function startTagInColumnGroup(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.COL)
        p._appendElement(token, NS.HTML);

    else if (tn === $.TEMPLATE)
        startTagInHead(p, token);

    else
        tokenInColumnGroup(p, token);
}

function endTagInColumnGroup(p, token) {
    var tn = token.tagName;

    if (tn === $.COLGROUP) {
        if (p.openElements.currentTagName === $.COLGROUP) {
            p.openElements.pop();
            p.insertionMode = IN_TABLE_MODE;
        }
    }

    else if (tn === $.TEMPLATE)
        endTagInHead(p, token);

    else if (tn !== $.COL)
        tokenInColumnGroup(p, token);
}

function tokenInColumnGroup(p, token) {
    if (p.openElements.currentTagName === $.COLGROUP) {
        p.openElements.pop();
        p.insertionMode = IN_TABLE_MODE;
        p._processToken(token);
    }
}

//12.2.5.4.13 The "in table body" insertion mode
//------------------------------------------------------------------
function startTagInTableBody(p, token) {
    var tn = token.tagName;

    if (tn === $.TR) {
        p.openElements.clearBackToTableBodyContext();
        p._insertElement(token, NS.HTML);
        p.insertionMode = IN_ROW_MODE;
    }

    else if (tn === $.TH || tn === $.TD) {
        p.openElements.clearBackToTableBodyContext();
        p._insertFakeElement($.TR);
        p.insertionMode = IN_ROW_MODE;
        p._processToken(token);
    }

    else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP ||
             tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {

        if (p.openElements.hasTableBodyContextInTableScope()) {
            p.openElements.clearBackToTableBodyContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_MODE;
            p._processToken(token);
        }
    }

    else
        startTagInTable(p, token);
}

function endTagInTableBody(p, token) {
    var tn = token.tagName;

    if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
        if (p.openElements.hasInTableScope(tn)) {
            p.openElements.clearBackToTableBodyContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_MODE;
        }
    }

    else if (tn === $.TABLE) {
        if (p.openElements.hasTableBodyContextInTableScope()) {
            p.openElements.clearBackToTableBodyContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_MODE;
            p._processToken(token);
        }
    }

    else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP ||
             tn !== $.HTML && tn !== $.TD && tn !== $.TH && tn !== $.TR)
        endTagInTable(p, token);
}

//12.2.5.4.14 The "in row" insertion mode
//------------------------------------------------------------------
function startTagInRow(p, token) {
    var tn = token.tagName;

    if (tn === $.TH || tn === $.TD) {
        p.openElements.clearBackToTableRowContext();
        p._insertElement(token, NS.HTML);
        p.insertionMode = IN_CELL_MODE;
        p.activeFormattingElements.insertMarker();
    }

    else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY ||
             tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
        if (p.openElements.hasInTableScope($.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_BODY_MODE;
            p._processToken(token);
        }
    }

    else
        startTagInTable(p, token);
}

function endTagInRow(p, token) {
    var tn = token.tagName;

    if (tn === $.TR) {
        if (p.openElements.hasInTableScope($.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_BODY_MODE;
        }
    }

    else if (tn === $.TABLE) {
        if (p.openElements.hasInTableScope($.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_BODY_MODE;
            p._processToken(token);
        }
    }

    else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
        if (p.openElements.hasInTableScope(tn) || p.openElements.hasInTableScope($.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_BODY_MODE;
            p._processToken(token);
        }
    }

    else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP ||
             tn !== $.HTML && tn !== $.TD && tn !== $.TH)
        endTagInTable(p, token);
}


//12.2.5.4.15 The "in cell" insertion mode
//------------------------------------------------------------------
function startTagInCell(p, token) {
    var tn = token.tagName;

    if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY ||
        tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {

        if (p.openElements.hasInTableScope($.TD) || p.openElements.hasInTableScope($.TH)) {
            p._closeTableCell();
            p._processToken(token);
        }
    }

    else
        startTagInBody(p, token);
}

function endTagInCell(p, token) {
    var tn = token.tagName;

    if (tn === $.TD || tn === $.TH) {
        if (p.openElements.hasInTableScope(tn)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped(tn);
            p.activeFormattingElements.clearToLastMarker();
            p.insertionMode = IN_ROW_MODE;
        }
    }

    else if (tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
        if (p.openElements.hasInTableScope(tn)) {
            p._closeTableCell();
            p._processToken(token);
        }
    }

    else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML)
        endTagInBody(p, token);
}

//12.2.5.4.16 The "in select" insertion mode
//------------------------------------------------------------------
function startTagInSelect(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.OPTION) {
        if (p.openElements.currentTagName === $.OPTION)
            p.openElements.pop();

        p._insertElement(token, NS.HTML);
    }

    else if (tn === $.OPTGROUP) {
        if (p.openElements.currentTagName === $.OPTION)
            p.openElements.pop();

        if (p.openElements.currentTagName === $.OPTGROUP)
            p.openElements.pop();

        p._insertElement(token, NS.HTML);
    }

    else if (tn === $.INPUT || tn === $.KEYGEN || tn === $.TEXTAREA || tn === $.SELECT) {
        if (p.openElements.hasInSelectScope($.SELECT)) {
            p.openElements.popUntilTagNamePopped($.SELECT);
            p._resetInsertionMode();

            if (tn !== $.SELECT)
                p._processToken(token);
        }
    }

    else if (tn === $.SCRIPT || tn === $.TEMPLATE)
        startTagInHead(p, token);
}

function endTagInSelect(p, token) {
    var tn = token.tagName;

    if (tn === $.OPTGROUP) {
        var prevOpenElement = p.openElements.items[p.openElements.stackTop - 1],
            prevOpenElementTn = prevOpenElement && p.treeAdapter.getTagName(prevOpenElement);

        if (p.openElements.currentTagName === $.OPTION && prevOpenElementTn === $.OPTGROUP)
            p.openElements.pop();

        if (p.openElements.currentTagName === $.OPTGROUP)
            p.openElements.pop();
    }

    else if (tn === $.OPTION) {
        if (p.openElements.currentTagName === $.OPTION)
            p.openElements.pop();
    }

    else if (tn === $.SELECT && p.openElements.hasInSelectScope($.SELECT)) {
        p.openElements.popUntilTagNamePopped($.SELECT);
        p._resetInsertionMode();
    }

    else if (tn === $.TEMPLATE)
        endTagInHead(p, token);
}

//12.2.5.4.17 The "in select in table" insertion mode
//------------------------------------------------------------------
function startTagInSelectInTable(p, token) {
    var tn = token.tagName;

    if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT ||
        tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {
        p.openElements.popUntilTagNamePopped($.SELECT);
        p._resetInsertionMode();
        p._processToken(token);
    }

    else
        startTagInSelect(p, token);
}

function endTagInSelectInTable(p, token) {
    var tn = token.tagName;

    if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT ||
        tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {
        if (p.openElements.hasInTableScope(tn)) {
            p.openElements.popUntilTagNamePopped($.SELECT);
            p._resetInsertionMode();
            p._processToken(token);
        }
    }

    else
        endTagInSelect(p, token);
}

//12.2.5.4.18 The "in template" insertion mode
//------------------------------------------------------------------
function startTagInTemplate(p, token) {
    var tn = token.tagName;

    if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META ||
        tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE)
        startTagInHead(p, token);

    else {
        var newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;

        p._popTmplInsertionMode();
        p._pushTmplInsertionMode(newInsertionMode);
        p.insertionMode = newInsertionMode;
        p._processToken(token);
    }
}

function endTagInTemplate(p, token) {
    if (token.tagName === $.TEMPLATE)
        endTagInHead(p, token);
}

function eofInTemplate(p, token) {
    if (p.openElements.tmplCount > 0) {
        p.openElements.popUntilTagNamePopped($.TEMPLATE);
        p.activeFormattingElements.clearToLastMarker();
        p._popTmplInsertionMode();
        p._resetInsertionMode();
        p._processToken(token);
    }

    else
        p.stopped = true;
}


//12.2.5.4.19 The "after body" insertion mode
//------------------------------------------------------------------
function startTagAfterBody(p, token) {
    if (token.tagName === $.HTML)
        startTagInBody(p, token);

    else
        tokenAfterBody(p, token);
}

function endTagAfterBody(p, token) {
    if (token.tagName === $.HTML) {
        if (!p.fragmentContext)
            p.insertionMode = AFTER_AFTER_BODY_MODE;
    }

    else
        tokenAfterBody(p, token);
}

function tokenAfterBody(p, token) {
    p.insertionMode = IN_BODY_MODE;
    p._processToken(token);
}

//12.2.5.4.20 The "in frameset" insertion mode
//------------------------------------------------------------------
function startTagInFrameset(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.FRAMESET)
        p._insertElement(token, NS.HTML);

    else if (tn === $.FRAME)
        p._appendElement(token, NS.HTML);

    else if (tn === $.NOFRAMES)
        startTagInHead(p, token);
}

function endTagInFrameset(p, token) {
    if (token.tagName === $.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
        p.openElements.pop();

        if (!p.fragmentContext && p.openElements.currentTagName !== $.FRAMESET)
            p.insertionMode = AFTER_FRAMESET_MODE;
    }
}

//12.2.5.4.21 The "after frameset" insertion mode
//------------------------------------------------------------------
function startTagAfterFrameset(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.NOFRAMES)
        startTagInHead(p, token);
}

function endTagAfterFrameset(p, token) {
    if (token.tagName === $.HTML)
        p.insertionMode = AFTER_AFTER_FRAMESET_MODE;
}

//12.2.5.4.22 The "after after body" insertion mode
//------------------------------------------------------------------
function startTagAfterAfterBody(p, token) {
    if (token.tagName === $.HTML)
        startTagInBody(p, token);

    else
        tokenAfterAfterBody(p, token);
}

function tokenAfterAfterBody(p, token) {
    p.insertionMode = IN_BODY_MODE;
    p._processToken(token);
}

//12.2.5.4.23 The "after after frameset" insertion mode
//------------------------------------------------------------------
function startTagAfterAfterFrameset(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.NOFRAMES)
        startTagInHead(p, token);
}


//12.2.5.5 The rules for parsing tokens in foreign content
//------------------------------------------------------------------
function nullCharacterInForeignContent(p, token) {
    token.chars = UNICODE.REPLACEMENT_CHARACTER;
    p._insertCharacters(token);
}

function characterInForeignContent(p, token) {
    p._insertCharacters(token);
    p.framesetOk = false;
}

function startTagInForeignContent(p, token) {
    if (foreignContent.causesExit(token) && !p.fragmentContext) {
        while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML && !p._isIntegrationPoint(p.openElements.current))
            p.openElements.pop();

        p._processToken(token);
    }

    else {
        var current = p._getAdjustedCurrentElement(),
            currentNs = p.treeAdapter.getNamespaceURI(current);

        if (currentNs === NS.MATHML)
            foreignContent.adjustTokenMathMLAttrs(token);

        else if (currentNs === NS.SVG) {
            foreignContent.adjustTokenSVGTagName(token);
            foreignContent.adjustTokenSVGAttrs(token);
        }

        foreignContent.adjustTokenXMLAttrs(token);

        if (token.selfClosing)
            p._appendElement(token, currentNs);
        else
            p._insertElement(token, currentNs);
    }
}

function endTagInForeignContent(p, token) {
    for (var i = p.openElements.stackTop; i > 0; i--) {
        var element = p.openElements.items[i];

        if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {
            p._processToken(token);
            break;
        }

        if (p.treeAdapter.getTagName(element).toLowerCase() === token.tagName) {
            p.openElements.popUntilElementPopped(element);
            break;
        }
    }
}


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var HTML = __webpack_require__(10);

//Aliases
var $ = HTML.TAG_NAMES,
    NS = HTML.NAMESPACES;

//Element utils

//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
//It's faster than using dictionary.
function isImpliedEndTagRequired(tn) {
    switch (tn.length) {
        case 1:
            return tn === $.P;

        case 2:
            return tn === $.RB || tn === $.RP || tn === $.RT || tn === $.DD || tn === $.DT || tn === $.LI;

        case 3:
            return tn === $.RTC;

        case 6:
            return tn === $.OPTION;

        case 8:
            return tn === $.OPTGROUP || tn === $.MENUITEM;
    }

    return false;
}

function isScopingElement(tn, ns) {
    switch (tn.length) {
        case 2:
            if (tn === $.TD || tn === $.TH)
                return ns === NS.HTML;

            else if (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS)
                return ns === NS.MATHML;

            break;

        case 4:
            if (tn === $.HTML)
                return ns === NS.HTML;

            else if (tn === $.DESC)
                return ns === NS.SVG;

            break;

        case 5:
            if (tn === $.TABLE)
                return ns === NS.HTML;

            else if (tn === $.MTEXT)
                return ns === NS.MATHML;

            else if (tn === $.TITLE)
                return ns === NS.SVG;

            break;

        case 6:
            return (tn === $.APPLET || tn === $.OBJECT) && ns === NS.HTML;

        case 7:
            return (tn === $.CAPTION || tn === $.MARQUEE) && ns === NS.HTML;

        case 8:
            return tn === $.TEMPLATE && ns === NS.HTML;

        case 13:
            return tn === $.FOREIGN_OBJECT && ns === NS.SVG;

        case 14:
            return tn === $.ANNOTATION_XML && ns === NS.MATHML;
    }

    return false;
}

//Stack of open elements
var OpenElementStack = module.exports = function (document, treeAdapter) {
    this.stackTop = -1;
    this.items = [];
    this.current = document;
    this.currentTagName = null;
    this.currentTmplContent = null;
    this.tmplCount = 0;
    this.treeAdapter = treeAdapter;
};

//Index of element
OpenElementStack.prototype._indexOf = function (element) {
    var idx = -1;

    for (var i = this.stackTop; i >= 0; i--) {
        if (this.items[i] === element) {
            idx = i;
            break;
        }
    }
    return idx;
};

//Update current element
OpenElementStack.prototype._isInTemplate = function () {
    return this.currentTagName === $.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
};

OpenElementStack.prototype._updateCurrentElement = function () {
    this.current = this.items[this.stackTop];
    this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);

    this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;
};

//Mutations
OpenElementStack.prototype.push = function (element) {
    this.items[++this.stackTop] = element;
    this._updateCurrentElement();

    if (this._isInTemplate())
        this.tmplCount++;

};

OpenElementStack.prototype.pop = function () {
    this.stackTop--;

    if (this.tmplCount > 0 && this._isInTemplate())
        this.tmplCount--;

    this._updateCurrentElement();
};

OpenElementStack.prototype.replace = function (oldElement, newElement) {
    var idx = this._indexOf(oldElement);

    this.items[idx] = newElement;

    if (idx === this.stackTop)
        this._updateCurrentElement();
};

OpenElementStack.prototype.insertAfter = function (referenceElement, newElement) {
    var insertionIdx = this._indexOf(referenceElement) + 1;

    this.items.splice(insertionIdx, 0, newElement);

    if (insertionIdx === ++this.stackTop)
        this._updateCurrentElement();
};

OpenElementStack.prototype.popUntilTagNamePopped = function (tagName) {
    while (this.stackTop > -1) {
        var tn = this.currentTagName,
            ns = this.treeAdapter.getNamespaceURI(this.current);

        this.pop();

        if (tn === tagName && ns === NS.HTML)
            break;
    }
};

OpenElementStack.prototype.popUntilElementPopped = function (element) {
    while (this.stackTop > -1) {
        var poppedElement = this.current;

        this.pop();

        if (poppedElement === element)
            break;
    }
};

OpenElementStack.prototype.popUntilNumberedHeaderPopped = function () {
    while (this.stackTop > -1) {
        var tn = this.currentTagName,
            ns = this.treeAdapter.getNamespaceURI(this.current);

        this.pop();

        if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6 && ns === NS.HTML)
            break;
    }
};

OpenElementStack.prototype.popUntilTableCellPopped = function () {
    while (this.stackTop > -1) {
        var tn = this.currentTagName,
            ns = this.treeAdapter.getNamespaceURI(this.current);

        this.pop();

        if (tn === $.TD || tn === $.TH && ns === NS.HTML)
            break;
    }
};

OpenElementStack.prototype.popAllUpToHtmlElement = function () {
    //NOTE: here we assume that root <html> element is always first in the open element stack, so
    //we perform this fast stack clean up.
    this.stackTop = 0;
    this._updateCurrentElement();
};

OpenElementStack.prototype.clearBackToTableContext = function () {
    while (this.currentTagName !== $.TABLE &&
           this.currentTagName !== $.TEMPLATE &&
           this.currentTagName !== $.HTML ||
           this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML)
        this.pop();
};

OpenElementStack.prototype.clearBackToTableBodyContext = function () {
    while (this.currentTagName !== $.TBODY &&
           this.currentTagName !== $.TFOOT &&
           this.currentTagName !== $.THEAD &&
           this.currentTagName !== $.TEMPLATE &&
           this.currentTagName !== $.HTML ||
           this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML)
        this.pop();
};

OpenElementStack.prototype.clearBackToTableRowContext = function () {
    while (this.currentTagName !== $.TR &&
           this.currentTagName !== $.TEMPLATE &&
           this.currentTagName !== $.HTML ||
           this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML)
        this.pop();
};

OpenElementStack.prototype.remove = function (element) {
    for (var i = this.stackTop; i >= 0; i--) {
        if (this.items[i] === element) {
            this.items.splice(i, 1);
            this.stackTop--;
            this._updateCurrentElement();
            break;
        }
    }
};

//Search
OpenElementStack.prototype.tryPeekProperlyNestedBodyElement = function () {
    //Properly nested <body> element (should be second element in stack).
    var element = this.items[1];

    return element && this.treeAdapter.getTagName(element) === $.BODY ? element : null;
};

OpenElementStack.prototype.contains = function (element) {
    return this._indexOf(element) > -1;
};

OpenElementStack.prototype.getCommonAncestor = function (element) {
    var elementIdx = this._indexOf(element);

    return --elementIdx >= 0 ? this.items[elementIdx] : null;
};

OpenElementStack.prototype.isRootHtmlElementCurrent = function () {
    return this.stackTop === 0 && this.currentTagName === $.HTML;
};

//Element in scope
OpenElementStack.prototype.hasInScope = function (tagName) {
    for (var i = this.stackTop; i >= 0; i--) {
        var tn = this.treeAdapter.getTagName(this.items[i]),
            ns = this.treeAdapter.getNamespaceURI(this.items[i]);

        if (tn === tagName && ns === NS.HTML)
            return true;

        if (isScopingElement(tn, ns))
            return false;
    }

    return true;
};

OpenElementStack.prototype.hasNumberedHeaderInScope = function () {
    for (var i = this.stackTop; i >= 0; i--) {
        var tn = this.treeAdapter.getTagName(this.items[i]),
            ns = this.treeAdapter.getNamespaceURI(this.items[i]);

        if ((tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) && ns === NS.HTML)
            return true;

        if (isScopingElement(tn, ns))
            return false;
    }

    return true;
};

OpenElementStack.prototype.hasInListItemScope = function (tagName) {
    for (var i = this.stackTop; i >= 0; i--) {
        var tn = this.treeAdapter.getTagName(this.items[i]),
            ns = this.treeAdapter.getNamespaceURI(this.items[i]);

        if (tn === tagName && ns === NS.HTML)
            return true;

        if ((tn === $.UL || tn === $.OL) && ns === NS.HTML || isScopingElement(tn, ns))
            return false;
    }

    return true;
};

OpenElementStack.prototype.hasInButtonScope = function (tagName) {
    for (var i = this.stackTop; i >= 0; i--) {
        var tn = this.treeAdapter.getTagName(this.items[i]),
            ns = this.treeAdapter.getNamespaceURI(this.items[i]);

        if (tn === tagName && ns === NS.HTML)
            return true;

        if (tn === $.BUTTON && ns === NS.HTML || isScopingElement(tn, ns))
            return false;
    }

    return true;
};

OpenElementStack.prototype.hasInTableScope = function (tagName) {
    for (var i = this.stackTop; i >= 0; i--) {
        var tn = this.treeAdapter.getTagName(this.items[i]),
            ns = this.treeAdapter.getNamespaceURI(this.items[i]);

        if (ns !== NS.HTML)
            continue;

        if (tn === tagName)
            return true;

        if (tn === $.TABLE || tn === $.TEMPLATE || tn === $.HTML)
            return false;
    }

    return true;
};

OpenElementStack.prototype.hasTableBodyContextInTableScope = function () {
    for (var i = this.stackTop; i >= 0; i--) {
        var tn = this.treeAdapter.getTagName(this.items[i]),
            ns = this.treeAdapter.getNamespaceURI(this.items[i]);

        if (ns !== NS.HTML)
            continue;

        if (tn === $.TBODY || tn === $.THEAD || tn === $.TFOOT)
            return true;

        if (tn === $.TABLE || tn === $.HTML)
            return false;
    }

    return true;
};

OpenElementStack.prototype.hasInSelectScope = function (tagName) {
    for (var i = this.stackTop; i >= 0; i--) {
        var tn = this.treeAdapter.getTagName(this.items[i]),
            ns = this.treeAdapter.getNamespaceURI(this.items[i]);

        if (ns !== NS.HTML)
            continue;

        if (tn === tagName)
            return true;

        if (tn !== $.OPTION && tn !== $.OPTGROUP)
            return false;
    }

    return true;
};

//Implied end tags
OpenElementStack.prototype.generateImpliedEndTags = function () {
    while (isImpliedEndTagRequired(this.currentTagName))
        this.pop();
};

OpenElementStack.prototype.generateImpliedEndTagsWithExclusion = function (exclusionTagName) {
    while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName)
        this.pop();
};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var WritableStream = __webpack_require__(28).Writable,
    inherits = __webpack_require__(24).inherits,
    Parser = __webpack_require__(54);

var ParserStream = module.exports = function (options) {
    WritableStream.call(this);

    this.parser = new Parser(options);

    this.lastChunkWritten = false;
    this.writeCallback = null;
    this.pausedByScript = false;

    this.document = this.parser.treeAdapter.createDocument();

    this.pendingHtmlInsertions = [];

    this._resume = this._resume.bind(this);
    this._documentWrite = this._documentWrite.bind(this);
    this._scriptHandler = this._scriptHandler.bind(this);

    this.parser._bootstrap(this.document, null);
};

inherits(ParserStream, WritableStream);

//WritableStream implementation
ParserStream.prototype._write = function (chunk, encoding, callback) {
    this.writeCallback = callback;
    this.parser.tokenizer.write(chunk.toString('utf8'), this.lastChunkWritten);
    this._runParsingLoop();
};

ParserStream.prototype.end = function (chunk, encoding, callback) {
    this.lastChunkWritten = true;
    WritableStream.prototype.end.call(this, chunk, encoding, callback);
};

//Scriptable parser implementation
ParserStream.prototype._runParsingLoop = function () {
    this.parser.runParsingLoopForCurrentChunk(this.writeCallback, this._scriptHandler);
};

ParserStream.prototype._resume = function () {
    if (!this.pausedByScript)
        throw new Error('Parser was already resumed');

    while (this.pendingHtmlInsertions.length) {
        var html = this.pendingHtmlInsertions.pop();

        this.parser.tokenizer.insertHtmlAtCurrentPos(html);
    }

    this.pausedByScript = false;

    //NOTE: keep parsing if we don't wait for the next input chunk
    if (this.parser.tokenizer.active)
        this._runParsingLoop();
};

ParserStream.prototype._documentWrite = function (html) {
    if (!this.parser.stopped)
        this.pendingHtmlInsertions.push(html);
};

ParserStream.prototype._scriptHandler = function (scriptElement) {
    if (this.listeners('script').length) {
        this.pausedByScript = true;
        this.emit('script', scriptElement, this._documentWrite, this._resume);
    }
    else
        this._runParsingLoop();
};



/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaultTreeAdapter = __webpack_require__(33),
    doctype = __webpack_require__(30),
    mergeOptions = __webpack_require__(31),
    HTML = __webpack_require__(10);

//Aliases
var $ = HTML.TAG_NAMES,
    NS = HTML.NAMESPACES;

//Default serializer options
var DEFAULT_OPTIONS = {
    treeAdapter: defaultTreeAdapter
};

//Escaping regexes
var AMP_REGEX = /&/g,
    NBSP_REGEX = /\u00a0/g,
    DOUBLE_QUOTE_REGEX = /"/g,
    LT_REGEX = /</g,
    GT_REGEX = />/g;

//Serializer
var Serializer = module.exports = function (node, options) {
    this.options = mergeOptions(DEFAULT_OPTIONS, options);
    this.treeAdapter = this.options.treeAdapter;

    this.html = '';
    this.startNode = node;
};

// NOTE: exported as static method for the testing purposes
Serializer.escapeString = function (str, attrMode) {
    str = str
        .replace(AMP_REGEX, '&amp;')
        .replace(NBSP_REGEX, '&nbsp;');

    if (attrMode)
        str = str.replace(DOUBLE_QUOTE_REGEX, '&quot;');

    else {
        str = str
            .replace(LT_REGEX, '&lt;')
            .replace(GT_REGEX, '&gt;');
    }

    return str;
};


//API
Serializer.prototype.serialize = function () {
    this._serializeChildNodes(this.startNode);

    return this.html;
};


//Internals
Serializer.prototype._serializeChildNodes = function (parentNode) {
    var childNodes = this.treeAdapter.getChildNodes(parentNode);

    if (childNodes) {
        for (var i = 0, cnLength = childNodes.length; i < cnLength; i++) {
            var currentNode = childNodes[i];

            if (this.treeAdapter.isElementNode(currentNode))
                this._serializeElement(currentNode);

            else if (this.treeAdapter.isTextNode(currentNode))
                this._serializeTextNode(currentNode);

            else if (this.treeAdapter.isCommentNode(currentNode))
                this._serializeCommentNode(currentNode);

            else if (this.treeAdapter.isDocumentTypeNode(currentNode))
                this._serializeDocumentTypeNode(currentNode);
        }
    }
};

Serializer.prototype._serializeElement = function (node) {
    var tn = this.treeAdapter.getTagName(node),
        ns = this.treeAdapter.getNamespaceURI(node);

    this.html += '<' + tn;
    this._serializeAttributes(node);
    this.html += '>';

    if (tn !== $.AREA && tn !== $.BASE && tn !== $.BASEFONT && tn !== $.BGSOUND && tn !== $.BR && tn !== $.BR &&
        tn !== $.COL && tn !== $.EMBED && tn !== $.FRAME && tn !== $.HR && tn !== $.IMG && tn !== $.INPUT &&
        tn !== $.KEYGEN && tn !== $.LINK && tn !== $.MENUITEM && tn !== $.META && tn !== $.PARAM && tn !== $.SOURCE &&
        tn !== $.TRACK && tn !== $.WBR) {

        var childNodesHolder = tn === $.TEMPLATE && ns === NS.HTML ?
            this.treeAdapter.getTemplateContent(node) :
            node;

        this._serializeChildNodes(childNodesHolder);
        this.html += '</' + tn + '>';
    }
};

Serializer.prototype._serializeAttributes = function (node) {
    var attrs = this.treeAdapter.getAttrList(node);

    for (var i = 0, attrsLength = attrs.length; i < attrsLength; i++) {
        var attr = attrs[i],
            value = Serializer.escapeString(attr.value, true);

        this.html += ' ';

        if (!attr.namespace)
            this.html += attr.name;

        else if (attr.namespace === NS.XML)
            this.html += 'xml:' + attr.name;

        else if (attr.namespace === NS.XMLNS) {
            if (attr.name !== 'xmlns')
                this.html += 'xmlns:';

            this.html += attr.name;
        }

        else if (attr.namespace === NS.XLINK)
            this.html += 'xlink:' + attr.name;

        else
            this.html += attr.namespace + ':' + attr.name;

        this.html += '="' + value + '"';
    }
};

Serializer.prototype._serializeTextNode = function (node) {
    var content = this.treeAdapter.getTextNodeContent(node),
        parent = this.treeAdapter.getParentNode(node),
        parentTn = void 0;

    if (parent && this.treeAdapter.isElementNode(parent))
        parentTn = this.treeAdapter.getTagName(parent);

    if (parentTn === $.STYLE || parentTn === $.SCRIPT || parentTn === $.XMP || parentTn === $.IFRAME ||
        parentTn === $.NOEMBED || parentTn === $.NOFRAMES || parentTn === $.PLAINTEXT || parentTn === $.NOSCRIPT)

        this.html += content;

    else
        this.html += Serializer.escapeString(content, false);
};

Serializer.prototype._serializeCommentNode = function (node) {
    this.html += '<!--' + this.treeAdapter.getCommentNodeContent(node) + '-->';
};

Serializer.prototype._serializeDocumentTypeNode = function (node) {
    var name = this.treeAdapter.getDocumentTypeNodeName(node);

    this.html += '<' + doctype.serializeContent(name, null, null) + '>';
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(6);
var queue_1 = __webpack_require__(267);
var Subscription_1 = __webpack_require__(14);
var observeOn_1 = __webpack_require__(82);
var ObjectUnsubscribedError_1 = __webpack_require__(297);
var SubjectSubscription_1 = __webpack_require__(298);
/**
 * @class ReplaySubject<T>
 */
var ReplaySubject = (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        _super.call(this);
        this.scheduler = scheduler;
        this._events = [];
        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        this._windowTime = windowTime < 1 ? 1 : windowTime;
    }
    ReplaySubject.prototype.next = function (value) {
        var now = this._getNow();
        this._events.push(new ReplayEvent(now, value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _events = this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        var len = _events.length;
        for (var i = 0; i < len && !subscriber.closed; i++) {
            subscriber.next(_events[i].value);
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue_1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        // Trim events that fall out of the time window.
        // Start at the front of the list. Break early once
        // we encounter an event that falls within the window.
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());
//# sourceMappingURL=ReplaySubject.js.map

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(5);
var catch_1 = __webpack_require__(301);
Observable_1.Observable.prototype.catch = catch_1._catch;
Observable_1.Observable.prototype._catch = catch_1._catch;
//# sourceMappingURL=catch.js.map

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(5);
var map_1 = __webpack_require__(73);
Observable_1.Observable.prototype.map = map_1.map;
//# sourceMappingURL=map.js.map

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(5);
var share_1 = __webpack_require__(304);
Observable_1.Observable.prototype.share = share_1.share;
//# sourceMappingURL=share.js.map

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(9);
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/**
 * Ignores source values for a duration determined by another Observable, then
 * emits the most recent value from the source Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link auditTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/audit.png" width="100%">
 *
 * `audit` is similar to `throttle`, but emits the last value from the silenced
 * time window, instead of the first value. `audit` emits the most recent value
 * from the source Observable on the output Observable as soon as its internal
 * timer becomes disabled, and ignores source values while the timer is enabled.
 * Initially, the timer is disabled. As soon as the first source value arrives,
 * the timer is enabled by calling the `durationSelector` function with the
 * source value, which returns the "duration" Observable. When the duration
 * Observable emits a value or completes, the timer is disabled, then the most
 * recent source value is emitted on the output Observable, and this process
 * repeats for the next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.audit(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttle}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration, returned as an Observable or a Promise.
 * @return {Observable<T>} An Observable that performs rate-limiting of
 * emissions from the source Observable.
 * @method audit
 * @owner Observable
 */
function audit(durationSelector) {
    return function auditOperatorFunction(source) {
        return source.lift(new AuditOperator(durationSelector));
    };
}
exports.audit = audit;
var AuditOperator = (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AuditSubscriber = (function (_super) {
    __extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        _super.call(this, destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);
            if (duration === errorObject_1.errorObject) {
                this.destination.error(errorObject_1.errorObject.e);
            }
            else {
                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);
                if (innerSubscription.closed) {
                    this.clearThrottle();
                }
                else {
                    this.add(this.throttled = innerSubscription);
                }
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=audit.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = __webpack_require__(26);
var isArray_1 = __webpack_require__(17);
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
var none = {};
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from this Observable with values from
 * Observables passed as arguments. This is done by subscribing to each
 * Observable, in order, and collecting an array of each of the most recent
 * values any time any of the input Observables emits, then either taking that
 * array and passing it as arguments to an optional `project` function and
 * emitting the return value of that, or just emitting the array of recent
 * values directly if there is no `project` function.
 *
 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method combineLatest
 * @owner Observable
 */
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0].slice();
    }
    return function (source) { return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project)); };
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = (function () {
    function CombineLatestOperator(project) {
        this.project = project;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
    };
    return CombineLatestOperator;
}());
exports.CombineLatestOperator = CombineLatestOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CombineLatestSubscriber = (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, project) {
        _super.call(this, destination);
        this.project = project;
        this.active = 0;
        this.values = [];
        this.observables = [];
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(none);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === none ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.project) {
                this._tryProject(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryProject = function (values) {
        var result;
        try {
            result = this.project.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.CombineLatestSubscriber = CombineLatestSubscriber;
//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(9);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.hasKey = false;
        if (typeof compare === 'function') {
            this.compare = compare;
        }
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch_1.tryCatch(this.keySelector)(value);
            if (key === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
            if (result === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
/**
 * Emits only the first value emitted by the source Observable that meets some
 * condition.
 *
 * <span class="informal">Finds the first value that passes some test and emits
 * that.</span>
 *
 * <img src="./img/find.png" width="100%">
 *
 * `find` searches for the first item in the source Observable that matches the
 * specified condition embodied by the `predicate`, and returns the first
 * occurrence in the source. Unlike {@link first}, the `predicate` is required
 * in `find`, and does not emit an error if a valid value is not found.
 *
 * @example <caption>Find and emit the first click that happens on a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.find(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link first}
 * @see {@link findIndex}
 * @see {@link take}
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
 * A function called with each item to test for condition matching.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable<T>} An Observable of the first item that matches the
 * condition.
 * @method find
 * @owner Observable
 */
function find(predicate, thisArg) {
    if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
    }
    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };
}
exports.find = find;
var FindValueOperator = (function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}());
exports.FindValueOperator = FindValueOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FindValueSubscriber = (function (_super) {
    __extends(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
        this.index = 0;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber_1.Subscriber));
exports.FindValueSubscriber = FindValueSubscriber;
//# sourceMappingURL=find.js.map

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
exports.defaultThrottleConfig = {
    leading: true,
    trailing: false
};
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for a duration determined by another Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link throttleTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/throttle.png" width="100%">
 *
 * `throttle` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled by calling the `durationSelector` function with the source value,
 * which returns the "duration" Observable. When the duration Observable emits a
 * value or completes, the timer is disabled, and this process repeats for the
 * next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration for each source value, returned as an Observable or a Promise.
 * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults
 * to `{ leading: true, trailing: false }`.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttle
 * @owner Observable
 */
function throttle(durationSelector, config) {
    if (config === void 0) { config = exports.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };
}
exports.throttle = throttle;
var ThrottleOperator = (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc
 * @ignore
 * @extends {Ignored}
 */
var ThrottleSubscriber = (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        _super.call(this, destination);
        this.destination = destination;
        this.durationSelector = durationSelector;
        this._leading = _leading;
        this._trailing = _trailing;
        this._hasTrailingValue = false;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this._trailing) {
                this._hasTrailingValue = true;
                this._trailingValue = value;
            }
        }
        else {
            var duration = this.tryDurationSelector(value);
            if (duration) {
                this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
            }
            if (this._leading) {
                this.destination.next(value);
                if (this._trailing) {
                    this._hasTrailingValue = true;
                    this._trailingValue = value;
                }
            }
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype._unsubscribe = function () {
        var _a = this, throttled = _a.throttled, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue, _trailing = _a._trailing;
        this._trailingValue = null;
        this._hasTrailingValue = false;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
    };
    ThrottleSubscriber.prototype._sendTrailing = function () {
        var _a = this, destination = _a.destination, throttled = _a.throttled, _trailing = _a._trailing, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue;
        if (throttled && _trailing && _hasTrailingValue) {
            destination.next(_trailingValue);
            this._trailingValue = null;
            this._hasTrailingValue = false;
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._sendTrailing();
        this._unsubscribe();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this._sendTrailing();
        this._unsubscribe();
    };
    return ThrottleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=throttle.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(6);
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/**
 * Branch out the source Observable values as a nested Observable whenever
 * `windowBoundaries` emits.
 *
 * <span class="informal">It's like {@link buffer}, but emits a nested Observable
 * instead of an array.</span>
 *
 * <img src="./img/window.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping
 * windows. It emits the current window and opens a new one whenever the
 * Observable `windowBoundaries` emits an item. Because each window is an
 * Observable, the output is a higher-order Observable.
 *
 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var result = clicks.window(interval)
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link buffer}
 *
 * @param {Observable<any>} windowBoundaries An Observable that completes the
 * previous window and starts a new window.
 * @return {Observable<Observable<T>>} An Observable of windows, which are
 * Observables emitting values of the source Observable.
 * @method window
 * @owner Observable
 */
function window(windowBoundaries) {
    return function windowOperatorFunction(source) {
        return source.lift(new WindowOperator(windowBoundaries));
    };
}
exports.window = window;
var WindowOperator = (function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowSubscriber = (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        _super.call(this, destination);
        this.window = new Subject_1.Subject();
        destination.next(this.window);
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject_1.Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=window.js.map

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = __webpack_require__(26);
var isArray_1 = __webpack_require__(17);
var Subscriber_1 = __webpack_require__(2);
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
var iterator_1 = __webpack_require__(291);
/* tslint:enable:max-line-length */
/**
 * @param observables
 * @return {Observable<R>}
 * @method zip
 * @owner Observable
 */
function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return function zipOperatorFunction(source) {
        return source.lift.call(zipStatic.apply(void 0, [source].concat(observables)));
    };
}
exports.zip = zip;
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
 * of its input Observables.
 *
 * If the latest parameter is a function, this function is used to compute the created value from the input values.
 * Otherwise, an array of the input values is returned.
 *
 * @example <caption>Combine age and name from different sources</caption>
 *
 * let age$ = Observable.of<number>(27, 25, 29);
 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
 * let isDev$ = Observable.of<boolean>(true, true, false);
 *
 * Observable
 *     .zip(age$,
 *          name$,
 *          isDev$,
 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
 *     .subscribe(x => console.log(x));
 *
 * // outputs
 * // { age: 27, name: 'Foo', isDev: true }
 * // { age: 25, name: 'Bar', isDev: true }
 * // { age: 29, name: 'Beer', isDev: false }
 *
 * @param observables
 * @return {Observable<R>}
 * @static true
 * @name zip
 * @owner Observable
 */
function zipStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = observables[observables.length - 1];
    if (typeof project === 'function') {
        observables.pop();
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
}
exports.zipStatic = zipStatic;
var ZipOperator = (function () {
    function ZipOperator(project) {
        this.project = project;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.project));
    };
    return ZipOperator;
}());
exports.ZipOperator = ZipOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, project, values) {
        if (values === void 0) { values = Object.create(null); }
        _super.call(this, destination);
        this.iterators = [];
        this.active = 0;
        this.project = (typeof project === 'function') ? project : null;
        this.values = values;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator_1.iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1.iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                this.add(iterator.subscribe(iterator, i));
            }
            else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.project) {
            this._tryProject(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber));
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = (function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        _super.call(this, destination);
        this.parent = parent;
        this.observable = observable;
        this.stillUnsubscribed = true;
        this.buffer = [];
        this.isComplete = false;
    }
    ZipBufferIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=zip.js.map

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(35);
var Action_1 = __webpack_require__(264);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // or the action has been rescheduled before it's executed, clear the interval id
        return root_1.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
exports.AsyncAction = AsyncAction;
//# sourceMappingURL=AsyncAction.js.map

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = __webpack_require__(181);
var AsyncScheduler = (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
exports.AsyncScheduler = AsyncScheduler;
//# sourceMappingURL=AsyncScheduler.js.map

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray_1 = __webpack_require__(17);
function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
exports.isNumeric = isNumeric;
;
//# sourceMappingURL=isNumeric.js.map

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(13);

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(29);

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(4);

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(59);

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(68);

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(69);

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(75);

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(82);

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(83);

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(86);

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(91);

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_server__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_server___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_platform_server__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app_shared_module__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__app_app_component__ = __webpack_require__(45);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




var AppModule = (function () {
    function AppModule() {
    }
    AppModule = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["NgModule"])({
            bootstrap: [__WEBPACK_IMPORTED_MODULE_3__app_app_component__["a" /* AppComponent */]],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_platform_server__["ServerModule"],
                __WEBPACK_IMPORTED_MODULE_2__app_shared_module__["a" /* AppModuleShared */]
            ],
            providers: []
        })
    ], AppModule);
    return AppModule;
}());



/***/ }),
/* 85 */
/***/ (function(module, exports) {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    // feature test for Symbol support
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var HashMap;
    (function (HashMap) {
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        // create an object in dictionary mode (a.k.a. "slow" mode in v8)
        HashMap.create = supportsCreate
            ? function () { return MakeDictionary(Object.create(null)); }
            : supportsProto
                ? function () { return MakeDictionary({ __proto__: null }); }
                : function () { return MakeDictionary({}); };
        HashMap.has = downLevel
            ? function (map, key) { return hasOwn.call(map, key); }
            : function (map, key) { return key in map; };
        HashMap.get = downLevel
            ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
            : function (map, key) { return map[key]; };
    })(HashMap || (HashMap = {}));
    // Load global or shim versions of Map, Set, and WeakMap
    var functionPrototype = Object.getPrototypeOf(Function);
    var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
    var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    // [[Metadata]] internal slot
    // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
    var Metadata = new _WeakMap();
    /**
      * Applies a set of decorators to a property of a target object.
      * @param decorators An array of decorators.
      * @param target The target object.
      * @param propertyKey (Optional) The property key to decorate.
      * @param attributes (Optional) The property descriptor for the target key.
      * @remarks Decorators are applied in reverse order.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     Example = Reflect.decorate(decoratorsArray, Example);
      *
      *     // property (on constructor)
      *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
      *
      *     // method (on constructor)
      *     Object.defineProperty(Example, "staticMethod",
      *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
      *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
      *
      *     // method (on prototype)
      *     Object.defineProperty(Example.prototype, "method",
      *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
      *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
      *
      */
    function decorate(decorators, target, propertyKey, attributes) {
        if (!IsUndefined(propertyKey)) {
            if (!IsArray(decorators))
                throw new TypeError();
            if (!IsObject(target))
                throw new TypeError();
            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                throw new TypeError();
            if (IsNull(attributes))
                attributes = undefined;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target, propertyKey, attributes);
        }
        else {
            if (!IsArray(decorators))
                throw new TypeError();
            if (!IsConstructor(target))
                throw new TypeError();
            return DecorateConstructor(decorators, target);
        }
    }
    Reflect.decorate = decorate;
    // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
    // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
    /**
      * A default metadata decorator factory that can be used on a class, class member, or parameter.
      * @param metadataKey The key for the metadata entry.
      * @param metadataValue The value for the metadata entry.
      * @returns A decorator function.
      * @remarks
      * If `metadataKey` is already defined for the target and target key, the
      * metadataValue for that key will be overwritten.
      * @example
      *
      *     // constructor
      *     @Reflect.metadata(key, value)
      *     class Example {
      *     }
      *
      *     // property (on constructor, TypeScript only)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         static staticProperty;
      *     }
      *
      *     // property (on prototype, TypeScript only)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         property;
      *     }
      *
      *     // method (on constructor)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         static staticMethod() { }
      *     }
      *
      *     // method (on prototype)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         method() { }
      *     }
      *
      */
    function metadata(metadataKey, metadataValue) {
        function decorator(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        return decorator;
    }
    Reflect.metadata = metadata;
    /**
      * Define a unique metadata entry on the target.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param metadataValue A value that contains attached metadata.
      * @param target The target object on which to define metadata.
      * @param propertyKey (Optional) The property key for the target.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     Reflect.defineMetadata("custom:annotation", options, Example);
      *
      *     // property (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
      *
      *     // method (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
      *
      *     // method (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
      *
      *     // decorator factory as metadata-producing annotation.
      *     function MyAnnotation(options): Decorator {
      *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
      *     }
      *
      */
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    Reflect.defineMetadata = defineMetadata;
    /**
      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function hasMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    Reflect.hasMetadata = hasMetadata;
    /**
      * Gets a value indicating whether the target object has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function hasOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    Reflect.hasOwnMetadata = hasOwnMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function getMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    Reflect.getMetadata = getMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function getOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    Reflect.getOwnMetadata = getOwnMetadata;
    /**
      * Gets the metadata keys defined on the target object or its prototype chain.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadataKeys(Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadataKeys(Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadataKeys(Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadataKeys(Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadataKeys(Example.prototype, "method");
      *
      */
    function getMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryMetadataKeys(target, propertyKey);
    }
    Reflect.getMetadataKeys = getMetadataKeys;
    /**
      * Gets the unique metadata keys defined on the target object.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadataKeys(Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
      *
      */
    function getOwnMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;
    /**
      * Deletes the metadata entry from the target object with the provided key.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns `true` if the metadata entry was found and deleted; otherwise, false.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.deleteMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function deleteMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return false;
        if (!metadataMap.delete(metadataKey))
            return false;
        if (metadataMap.size > 0)
            return true;
        var targetMetadata = Metadata.get(target);
        targetMetadata.delete(propertyKey);
        if (targetMetadata.size > 0)
            return true;
        Metadata.delete(target);
        return true;
    }
    Reflect.deleteMetadata = deleteMetadata;
    function DecorateConstructor(decorators, target) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsConstructor(decorated))
                    throw new TypeError();
                target = decorated;
            }
        }
        return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsObject(decorated))
                    throw new TypeError();
                descriptor = decorated;
            }
        }
        return descriptor;
    }
    function GetOrCreateMetadataMap(O, P, Create) {
        var targetMetadata = Metadata.get(O);
        if (IsUndefined(targetMetadata)) {
            if (!Create)
                return undefined;
            targetMetadata = new _Map();
            Metadata.set(O, targetMetadata);
        }
        var metadataMap = targetMetadata.get(P);
        if (IsUndefined(metadataMap)) {
            if (!Create)
                return undefined;
            metadataMap = new _Map();
            targetMetadata.set(P, metadataMap);
        }
        return metadataMap;
    }
    // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
    function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn)
            return true;
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P);
        return false;
    }
    // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return false;
        return ToBoolean(metadataMap.has(MetadataKey));
    }
    // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
    function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn)
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P);
        return undefined;
    }
    // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return undefined;
        return metadataMap.get(MetadataKey);
    }
    // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
        metadataMap.set(MetadataKey, MetadataValue);
    }
    // 3.1.6.1 OrdinaryMetadataKeys(O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
    function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (parent === null)
            return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length <= 0)
            return ownKeys;
        if (ownKeys.length <= 0)
            return parentKeys;
        var set = new _Set();
        var keys = [];
        for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
            var key = ownKeys_1[_i];
            var hasKey = set.has(key);
            if (!hasKey) {
                set.add(key);
                keys.push(key);
            }
        }
        for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
            var key = parentKeys_1[_a];
            var hasKey = set.has(key);
            if (!hasKey) {
                set.add(key);
                keys.push(key);
            }
        }
        return keys;
    }
    // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
    function OrdinaryOwnMetadataKeys(O, P) {
        var keys = [];
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return keys;
        var keysObj = metadataMap.keys();
        var iterator = GetIterator(keysObj);
        var k = 0;
        while (true) {
            var next = IteratorStep(iterator);
            if (!next) {
                keys.length = k;
                return keys;
            }
            var nextValue = IteratorValue(next);
            try {
                keys[k] = nextValue;
            }
            catch (e) {
                try {
                    IteratorClose(iterator);
                }
                finally {
                    throw e;
                }
            }
            k++;
        }
    }
    // 6 ECMAScript Data Typ0es and Values
    // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
    function Type(x) {
        if (x === null)
            return 1 /* Null */;
        switch (typeof x) {
            case "undefined": return 0 /* Undefined */;
            case "boolean": return 2 /* Boolean */;
            case "string": return 3 /* String */;
            case "symbol": return 4 /* Symbol */;
            case "number": return 5 /* Number */;
            case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
            default: return 6 /* Object */;
        }
    }
    // 6.1.1 The Undefined Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
    function IsUndefined(x) {
        return x === undefined;
    }
    // 6.1.2 The Null Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
    function IsNull(x) {
        return x === null;
    }
    // 6.1.5 The Symbol Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
    function IsSymbol(x) {
        return typeof x === "symbol";
    }
    // 6.1.7 The Object Type
    // https://tc39.github.io/ecma262/#sec-object-type
    function IsObject(x) {
        return typeof x === "object" ? x !== null : typeof x === "function";
    }
    // 7.1 Type Conversion
    // https://tc39.github.io/ecma262/#sec-type-conversion
    // 7.1.1 ToPrimitive(input [, PreferredType])
    // https://tc39.github.io/ecma262/#sec-toprimitive
    function ToPrimitive(input, PreferredType) {
        switch (Type(input)) {
            case 0 /* Undefined */: return input;
            case 1 /* Null */: return input;
            case 2 /* Boolean */: return input;
            case 3 /* String */: return input;
            case 4 /* Symbol */: return input;
            case 5 /* Number */: return input;
        }
        var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
        if (exoticToPrim !== undefined) {
            var result = exoticToPrim.call(input, hint);
            if (IsObject(result))
                throw new TypeError();
            return result;
        }
        return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    // 7.1.1.1 OrdinaryToPrimitive(O, hint)
    // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
    function OrdinaryToPrimitive(O, hint) {
        if (hint === "string") {
            var toString_1 = O.toString;
            if (IsCallable(toString_1)) {
                var result = toString_1.call(O);
                if (!IsObject(result))
                    return result;
            }
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
                var result = valueOf.call(O);
                if (!IsObject(result))
                    return result;
            }
        }
        else {
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
                var result = valueOf.call(O);
                if (!IsObject(result))
                    return result;
            }
            var toString_2 = O.toString;
            if (IsCallable(toString_2)) {
                var result = toString_2.call(O);
                if (!IsObject(result))
                    return result;
            }
        }
        throw new TypeError();
    }
    // 7.1.2 ToBoolean(argument)
    // https://tc39.github.io/ecma262/2016/#sec-toboolean
    function ToBoolean(argument) {
        return !!argument;
    }
    // 7.1.12 ToString(argument)
    // https://tc39.github.io/ecma262/#sec-tostring
    function ToString(argument) {
        return "" + argument;
    }
    // 7.1.14 ToPropertyKey(argument)
    // https://tc39.github.io/ecma262/#sec-topropertykey
    function ToPropertyKey(argument) {
        var key = ToPrimitive(argument, 3 /* String */);
        if (IsSymbol(key))
            return key;
        return ToString(key);
    }
    // 7.2 Testing and Comparison Operations
    // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
    // 7.2.2 IsArray(argument)
    // https://tc39.github.io/ecma262/#sec-isarray
    function IsArray(argument) {
        return Array.isArray
            ? Array.isArray(argument)
            : argument instanceof Object
                ? argument instanceof Array
                : Object.prototype.toString.call(argument) === "[object Array]";
    }
    // 7.2.3 IsCallable(argument)
    // https://tc39.github.io/ecma262/#sec-iscallable
    function IsCallable(argument) {
        // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
        return typeof argument === "function";
    }
    // 7.2.4 IsConstructor(argument)
    // https://tc39.github.io/ecma262/#sec-isconstructor
    function IsConstructor(argument) {
        // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
        return typeof argument === "function";
    }
    // 7.2.7 IsPropertyKey(argument)
    // https://tc39.github.io/ecma262/#sec-ispropertykey
    function IsPropertyKey(argument) {
        switch (Type(argument)) {
            case 3 /* String */: return true;
            case 4 /* Symbol */: return true;
            default: return false;
        }
    }
    // 7.3 Operations on Objects
    // https://tc39.github.io/ecma262/#sec-operations-on-objects
    // 7.3.9 GetMethod(V, P)
    // https://tc39.github.io/ecma262/#sec-getmethod
    function GetMethod(V, P) {
        var func = V[P];
        if (func === undefined || func === null)
            return undefined;
        if (!IsCallable(func))
            throw new TypeError();
        return func;
    }
    // 7.4 Operations on Iterator Objects
    // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
    function GetIterator(obj) {
        var method = GetMethod(obj, iteratorSymbol);
        if (!IsCallable(method))
            throw new TypeError(); // from Call
        var iterator = method.call(obj);
        if (!IsObject(iterator))
            throw new TypeError();
        return iterator;
    }
    // 7.4.4 IteratorValue(iterResult)
    // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
    function IteratorValue(iterResult) {
        return iterResult.value;
    }
    // 7.4.5 IteratorStep(iterator)
    // https://tc39.github.io/ecma262/#sec-iteratorstep
    function IteratorStep(iterator) {
        var result = iterator.next();
        return result.done ? false : result;
    }
    // 7.4.6 IteratorClose(iterator, completion)
    // https://tc39.github.io/ecma262/#sec-iteratorclose
    function IteratorClose(iterator) {
        var f = iterator["return"];
        if (f)
            f.call(iterator);
    }
    // 9.1 Ordinary Object Internal Methods and Internal Slots
    // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
    // 9.1.1.1 OrdinaryGetPrototypeOf(O)
    // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
    function OrdinaryGetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype)
            return proto;
        // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
        // Try to determine the superclass constructor. Compatible implementations
        // must either set __proto__ on a subclass constructor to the superclass constructor,
        // or ensure each class has a valid `constructor` property on its prototype that
        // points back to the constructor.
        // If this is not the same as Function.[[Prototype]], then this is definately inherited.
        // This is the case when in ES6 or when using __proto__ in a compatible browser.
        if (proto !== functionPrototype)
            return proto;
        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
        var prototype = O.prototype;
        var prototypeProto = prototype && Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
        // If the constructor was not a function, then we cannot determine the heritage.
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function")
            return proto;
        // If we have some kind of self-reference, then we cannot determine the heritage.
        if (constructor === O)
            return proto;
        // we have a pretty good guess at the heritage.
        return constructor;
    }
    // naive Map shim
    function CreateMapPolyfill() {
        var cacheSentinel = {};
        var arraySentinel = [];
        var MapIterator = (function () {
            function MapIterator(keys, values, selector) {
                this._index = 0;
                this._keys = keys;
                this._values = values;
                this._selector = selector;
            }
            MapIterator.prototype["@@iterator"] = function () { return this; };
            MapIterator.prototype[iteratorSymbol] = function () { return this; };
            MapIterator.prototype.next = function () {
                var index = this._index;
                if (index >= 0 && index < this._keys.length) {
                    var result = this._selector(this._keys[index], this._values[index]);
                    if (index + 1 >= this._keys.length) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    else {
                        this._index++;
                    }
                    return { value: result, done: false };
                }
                return { value: undefined, done: true };
            };
            MapIterator.prototype.throw = function (error) {
                if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                }
                throw error;
            };
            MapIterator.prototype.return = function (value) {
                if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                }
                return { value: value, done: true };
            };
            return MapIterator;
        }());
        return (function () {
            function Map() {
                this._keys = [];
                this._values = [];
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
            }
            Object.defineProperty(Map.prototype, "size", {
                get: function () { return this._keys.length; },
                enumerable: true,
                configurable: true
            });
            Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
            Map.prototype.get = function (key) {
                var index = this._find(key, /*insert*/ false);
                return index >= 0 ? this._values[index] : undefined;
            };
            Map.prototype.set = function (key, value) {
                var index = this._find(key, /*insert*/ true);
                this._values[index] = value;
                return this;
            };
            Map.prototype.delete = function (key) {
                var index = this._find(key, /*insert*/ false);
                if (index >= 0) {
                    var size = this._keys.length;
                    for (var i = index + 1; i < size; i++) {
                        this._keys[i - 1] = this._keys[i];
                        this._values[i - 1] = this._values[i];
                    }
                    this._keys.length--;
                    this._values.length--;
                    if (key === this._cacheKey) {
                        this._cacheKey = cacheSentinel;
                        this._cacheIndex = -2;
                    }
                    return true;
                }
                return false;
            };
            Map.prototype.clear = function () {
                this._keys.length = 0;
                this._values.length = 0;
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
            };
            Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
            Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
            Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
            Map.prototype["@@iterator"] = function () { return this.entries(); };
            Map.prototype[iteratorSymbol] = function () { return this.entries(); };
            Map.prototype._find = function (key, insert) {
                if (this._cacheKey !== key) {
                    this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                }
                if (this._cacheIndex < 0 && insert) {
                    this._cacheIndex = this._keys.length;
                    this._keys.push(key);
                    this._values.push(undefined);
                }
                return this._cacheIndex;
            };
            return Map;
        }());
        function getKey(key, _) {
            return key;
        }
        function getValue(_, value) {
            return value;
        }
        function getEntry(key, value) {
            return [key, value];
        }
    }
    // naive Set shim
    function CreateSetPolyfill() {
        return (function () {
            function Set() {
                this._map = new _Map();
            }
            Object.defineProperty(Set.prototype, "size", {
                get: function () { return this._map.size; },
                enumerable: true,
                configurable: true
            });
            Set.prototype.has = function (value) { return this._map.has(value); };
            Set.prototype.add = function (value) { return this._map.set(value, value), this; };
            Set.prototype.delete = function (value) { return this._map.delete(value); };
            Set.prototype.clear = function () { this._map.clear(); };
            Set.prototype.keys = function () { return this._map.keys(); };
            Set.prototype.values = function () { return this._map.values(); };
            Set.prototype.entries = function () { return this._map.entries(); };
            Set.prototype["@@iterator"] = function () { return this.keys(); };
            Set.prototype[iteratorSymbol] = function () { return this.keys(); };
            return Set;
        }());
    }
    // naive WeakMap shim
    function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = HashMap.create();
        var rootKey = CreateUniqueKey();
        return (function () {
            function WeakMap() {
                this._key = CreateUniqueKey();
            }
            WeakMap.prototype.has = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? HashMap.has(table, this._key) : false;
            };
            WeakMap.prototype.get = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? HashMap.get(table, this._key) : undefined;
            };
            WeakMap.prototype.set = function (target, value) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                table[this._key] = value;
                return this;
            };
            WeakMap.prototype.delete = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? delete table[this._key] : false;
            };
            WeakMap.prototype.clear = function () {
                // NOTE: not a real clear, just makes the previous data unreachable
                this._key = CreateUniqueKey();
            };
            return WeakMap;
        }());
        function CreateUniqueKey() {
            var key;
            do
                key = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys, key));
            keys[key] = true;
            return key;
        }
        function GetOrCreateWeakMapTable(target, create) {
            if (!hasOwn.call(target, rootKey)) {
                if (!create)
                    return undefined;
                Object.defineProperty(target, rootKey, { value: HashMap.create() });
            }
            return target[rootKey];
        }
        function FillRandomBytes(buffer, size) {
            for (var i = 0; i < size; ++i)
                buffer[i] = Math.random() * 0xff | 0;
            return buffer;
        }
        function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
                if (typeof crypto !== "undefined")
                    return crypto.getRandomValues(new Uint8Array(size));
                if (typeof msCrypto !== "undefined")
                    return msCrypto.getRandomValues(new Uint8Array(size));
                return FillRandomBytes(new Uint8Array(size), size);
            }
            return FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            // mark as random - RFC 4122  4.4
            data[6] = data[6] & 0x4f | 0x40;
            data[8] = data[8] & 0xbf | 0x80;
            var result = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
                var byte = data[offset];
                if (offset === 4 || offset === 6 || offset === 8)
                    result += "-";
                if (byte < 16)
                    result += "0";
                result += byte.toString(16).toLowerCase();
            }
            return result;
        }
    }
    // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
    function MakeDictionary(obj) {
        obj.__ = undefined;
        delete obj.__;
        return obj;
    }
    // patch global Reflect
    (function (__global) {
        if (typeof __global.Reflect !== "undefined") {
            if (__global.Reflect !== Reflect) {
                for (var p in Reflect) {
                    if (hasOwn.call(Reflect, p)) {
                        __global.Reflect[p] = Reflect[p];
                    }
                }
            }
        }
        else {
            __global.Reflect = Reflect;
        }
    })(typeof global !== "undefined" ? global :
        typeof self !== "undefined" ? self :
            Function("return this;")());
})(Reflect || (Reflect = {}));
//# sourceMappingURL=Reflect.js.map

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(5);
var first_1 = __webpack_require__(78);
Observable_1.Observable.prototype.first = first_1.first;
//# sourceMappingURL=first.js.map

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(44);

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(50);

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(40);

/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SharedModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ui_ui_module__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__directives_directive_module__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__guards_guard_module__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__shared_pipes_pipe_module__ = __webpack_require__(48);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





var SharedModule = (function () {
    function SharedModule() {
    }
    SharedModule = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["NgModule"])({
            imports: [__WEBPACK_IMPORTED_MODULE_1__ui_ui_module__["a" /* UIModule */], __WEBPACK_IMPORTED_MODULE_2__directives_directive_module__["a" /* DirectiveModule */], __WEBPACK_IMPORTED_MODULE_3__guards_guard_module__["a" /* GuardModule */], __WEBPACK_IMPORTED_MODULE_4__shared_pipes_pipe_module__["a" /* PipeModule */]],
            exports: [__WEBPACK_IMPORTED_MODULE_2__directives_directive_module__["a" /* DirectiveModule */], __WEBPACK_IMPORTED_MODULE_1__ui_ui_module__["a" /* UIModule */], __WEBPACK_IMPORTED_MODULE_3__guards_guard_module__["a" /* GuardModule */], __WEBPACK_IMPORTED_MODULE_4__shared_pipes_pipe_module__["a" /* PipeModule */]],
            declarations: [],
            providers: [],
        })
    ], SharedModule);
    return SharedModule;
}());



/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AuthService; });
/* unused harmony export TokenProvider */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_angular2_jwt_angular2_jwt__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_angular2_jwt_angular2_jwt___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_angular2_jwt_angular2_jwt__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shared_variables__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__services_backend_common_http_service__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_http__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_http___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__angular_http__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_operators_window__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_operators_window___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_operators_window__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__services_frontend_alert_service__ = __webpack_require__(29);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};







var AuthService = (function () {
    function AuthService(httpClient, toaster) {
        this.httpClient = httpClient;
        this.toaster = toaster;
        this.login$ = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["EventEmitter"]();
    }
    AuthService.prototype.createHeader = function () {
        var headers = new __WEBPACK_IMPORTED_MODULE_4__angular_http__["Headers"]();
        headers.set("Content-Type", "application/json");
        // .set("Content-Type", "application/json");
        return headers;
    };
    AuthService.prototype.signUp = function (user, isCompany) {
        if (isCompany === void 0) { isCompany = false; }
        return __awaiter(this, void 0, void 0, function () {
            var body, result, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        body = {
                            username: user.username,
                            email: user.email,
                            password: user.password,
                            companyName: user.companyName,
                            companyWebsite: user.companyWebsite,
                            roleId: user.roleId
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        result = void 0;
                        if (!isCompany) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.httpClient.post("/api/sign-up/company", body, this.createHeader())
                                .toPromise()];
                    case 2:
                        result = _a.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, this.httpClient.post("/api/sign-up/student", body, this.createHeader())
                            .toPromise()];
                    case 4:
                        result = _a.sent();
                        _a.label = 5;
                    case 5:
                        if (result == true) {
                            this.toaster.show("ng k thnh cng", "ng nhp  s dng.");
                        }
                        else {
                            this.toaster.show("ng k tht bi", "Vui lng th li sau.");
                        }
                        return [2 /*return*/, result];
                    case 6:
                        err_1 = _a.sent();
                        return [2 /*return*/, false];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    AuthService.prototype.login = function (user) {
        return __awaiter(this, void 0, void 0, function () {
            var body, token, tokenAuth, err_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        body = {
                            username: user.username,
                            password: user.password
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.httpClient.post(__WEBPACK_IMPORTED_MODULE_2__shared_variables__["a" /* UrlVariable */].URL_LOGIN, body, this.createHeader()).toPromise()];
                    case 2:
                        token = _a.sent();
                        tokenAuth = token;
                        if (typeof __WEBPACK_IMPORTED_MODULE_5_rxjs_operators_window__["window"] != "undefined") {
                            localStorage.setItem('token_hure', tokenAuth.token);
                            localStorage.setItem('userId', tokenAuth.guid.toString());
                        }
                        this.login$.emit(true);
                        return [2 /*return*/, true];
                    case 3:
                        err_2 = _a.sent();
                        return [2 /*return*/, false];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    AuthService.prototype.extractdata = function (res) {
        var body = res.json();
        return body || {};
    };
    AuthService.prototype.isLogged = function () {
        if (typeof __WEBPACK_IMPORTED_MODULE_5_rxjs_operators_window__["window"] != "undefined") {
            if (localStorage) {
                var token = localStorage.getItem("token_hure");
                if (token) {
                    var jwt = new __WEBPACK_IMPORTED_MODULE_1_angular2_jwt_angular2_jwt__["JwtHelper"]();
                    if (!jwt.isTokenExpired(token)) {
                        return true;
                    }
                    return false;
                }
                return false;
            }
        }
        return false;
    };
    AuthService.prototype.logout = function () {
        if (typeof __WEBPACK_IMPORTED_MODULE_5_rxjs_operators_window__["window"] != "undefined") {
            localStorage.clear();
            this.login$.emit(false);
        }
    };
    AuthService = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__services_backend_common_http_service__["a" /* CommonHttpService */], __WEBPACK_IMPORTED_MODULE_6__services_frontend_alert_service__["a" /* AlertService */]])
    ], AuthService);
    return AuthService;
}());

var TokenProvider = (function () {
    function TokenProvider(token, guid, expiresin) {
        this.token = token;
        this.guid = guid;
        this.expires_in = expiresin;
    }
    return TokenProvider;
}());



/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var audit_1 = __webpack_require__(62);
exports.audit = audit_1.audit;
var auditTime_1 = __webpack_require__(191);
exports.auditTime = auditTime_1.auditTime;
var buffer_1 = __webpack_require__(192);
exports.buffer = buffer_1.buffer;
var bufferCount_1 = __webpack_require__(193);
exports.bufferCount = bufferCount_1.bufferCount;
var bufferTime_1 = __webpack_require__(194);
exports.bufferTime = bufferTime_1.bufferTime;
var bufferToggle_1 = __webpack_require__(195);
exports.bufferToggle = bufferToggle_1.bufferToggle;
var bufferWhen_1 = __webpack_require__(196);
exports.bufferWhen = bufferWhen_1.bufferWhen;
var catchError_1 = __webpack_require__(305);
exports.catchError = catchError_1.catchError;
var combineAll_1 = __webpack_require__(197);
exports.combineAll = combineAll_1.combineAll;
var combineLatest_1 = __webpack_require__(63);
exports.combineLatest = combineLatest_1.combineLatest;
var concat_1 = __webpack_require__(198);
exports.concat = concat_1.concat;
var concatAll_1 = __webpack_require__(79);
exports.concatAll = concatAll_1.concatAll;
var concatMap_1 = __webpack_require__(80);
exports.concatMap = concatMap_1.concatMap;
var concatMapTo_1 = __webpack_require__(199);
exports.concatMapTo = concatMapTo_1.concatMapTo;
var count_1 = __webpack_require__(200);
exports.count = count_1.count;
var debounce_1 = __webpack_require__(201);
exports.debounce = debounce_1.debounce;
var debounceTime_1 = __webpack_require__(202);
exports.debounceTime = debounceTime_1.debounceTime;
var defaultIfEmpty_1 = __webpack_require__(306);
exports.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;
var delay_1 = __webpack_require__(203);
exports.delay = delay_1.delay;
var delayWhen_1 = __webpack_require__(204);
exports.delayWhen = delayWhen_1.delayWhen;
var dematerialize_1 = __webpack_require__(205);
exports.dematerialize = dematerialize_1.dematerialize;
var distinct_1 = __webpack_require__(206);
exports.distinct = distinct_1.distinct;
var distinctUntilChanged_1 = __webpack_require__(64);
exports.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;
var distinctUntilKeyChanged_1 = __webpack_require__(207);
exports.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;
var elementAt_1 = __webpack_require__(208);
exports.elementAt = elementAt_1.elementAt;
var every_1 = __webpack_require__(307);
exports.every = every_1.every;
var exhaust_1 = __webpack_require__(209);
exports.exhaust = exhaust_1.exhaust;
var exhaustMap_1 = __webpack_require__(210);
exports.exhaustMap = exhaustMap_1.exhaustMap;
var expand_1 = __webpack_require__(211);
exports.expand = expand_1.expand;
var filter_1 = __webpack_require__(81);
exports.filter = filter_1.filter;
var finalize_1 = __webpack_require__(212);
exports.finalize = finalize_1.finalize;
var find_1 = __webpack_require__(65);
exports.find = find_1.find;
var findIndex_1 = __webpack_require__(213);
exports.findIndex = findIndex_1.findIndex;
var first_1 = __webpack_require__(308);
exports.first = first_1.first;
var groupBy_1 = __webpack_require__(214);
exports.groupBy = groupBy_1.groupBy;
var ignoreElements_1 = __webpack_require__(215);
exports.ignoreElements = ignoreElements_1.ignoreElements;
var isEmpty_1 = __webpack_require__(216);
exports.isEmpty = isEmpty_1.isEmpty;
var last_1 = __webpack_require__(309);
exports.last = last_1.last;
var map_1 = __webpack_require__(37);
exports.map = map_1.map;
var mapTo_1 = __webpack_require__(217);
exports.mapTo = mapTo_1.mapTo;
var materialize_1 = __webpack_require__(218);
exports.materialize = materialize_1.materialize;
var max_1 = __webpack_require__(219);
exports.max = max_1.max;
var merge_1 = __webpack_require__(220);
exports.merge = merge_1.merge;
var mergeAll_1 = __webpack_require__(290);
exports.mergeAll = mergeAll_1.mergeAll;
var mergeMap_1 = __webpack_require__(72);
exports.mergeMap = mergeMap_1.mergeMap;
var mergeMap_2 = __webpack_require__(72);
exports.flatMap = mergeMap_2.mergeMap;
var mergeMapTo_1 = __webpack_require__(221);
exports.mergeMapTo = mergeMapTo_1.mergeMapTo;
var mergeScan_1 = __webpack_require__(222);
exports.mergeScan = mergeScan_1.mergeScan;
var min_1 = __webpack_require__(223);
exports.min = min_1.min;
var multicast_1 = __webpack_require__(23);
exports.multicast = multicast_1.multicast;
var observeOn_1 = __webpack_require__(82);
exports.observeOn = observeOn_1.observeOn;
var onErrorResumeNext_1 = __webpack_require__(224);
exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
var pairwise_1 = __webpack_require__(225);
exports.pairwise = pairwise_1.pairwise;
var partition_1 = __webpack_require__(226);
exports.partition = partition_1.partition;
var pluck_1 = __webpack_require__(227);
exports.pluck = pluck_1.pluck;
var publish_1 = __webpack_require__(228);
exports.publish = publish_1.publish;
var publishBehavior_1 = __webpack_require__(229);
exports.publishBehavior = publishBehavior_1.publishBehavior;
var publishLast_1 = __webpack_require__(230);
exports.publishLast = publishLast_1.publishLast;
var publishReplay_1 = __webpack_require__(231);
exports.publishReplay = publishReplay_1.publishReplay;
var race_1 = __webpack_require__(232);
exports.race = race_1.race;
var reduce_1 = __webpack_require__(27);
exports.reduce = reduce_1.reduce;
var repeat_1 = __webpack_require__(233);
exports.repeat = repeat_1.repeat;
var repeatWhen_1 = __webpack_require__(234);
exports.repeatWhen = repeatWhen_1.repeatWhen;
var retry_1 = __webpack_require__(235);
exports.retry = retry_1.retry;
var retryWhen_1 = __webpack_require__(236);
exports.retryWhen = retryWhen_1.retryWhen;
var refCount_1 = __webpack_require__(296);
exports.refCount = refCount_1.refCount;
var sample_1 = __webpack_require__(237);
exports.sample = sample_1.sample;
var sampleTime_1 = __webpack_require__(238);
exports.sampleTime = sampleTime_1.sampleTime;
var scan_1 = __webpack_require__(310);
exports.scan = scan_1.scan;
var sequenceEqual_1 = __webpack_require__(239);
exports.sequenceEqual = sequenceEqual_1.sequenceEqual;
var share_1 = __webpack_require__(311);
exports.share = share_1.share;
var shareReplay_1 = __webpack_require__(240);
exports.shareReplay = shareReplay_1.shareReplay;
var single_1 = __webpack_require__(241);
exports.single = single_1.single;
var skip_1 = __webpack_require__(242);
exports.skip = skip_1.skip;
var skipLast_1 = __webpack_require__(243);
exports.skipLast = skipLast_1.skipLast;
var skipUntil_1 = __webpack_require__(244);
exports.skipUntil = skipUntil_1.skipUntil;
var skipWhile_1 = __webpack_require__(245);
exports.skipWhile = skipWhile_1.skipWhile;
var startWith_1 = __webpack_require__(246);
exports.startWith = startWith_1.startWith;
/**
 * TODO(https://github.com/ReactiveX/rxjs/issues/2900): Add back subscribeOn once it can be
 * treeshaken. Currently if this export is added back, it
 * forces apps to bring in asap scheduler along with
 * Immediate, root, and other supporting code.
 */
// export { subscribeOn } from './operators/subscribeOn';
var switchAll_1 = __webpack_require__(247);
exports.switchAll = switchAll_1.switchAll;
var switchMap_1 = __webpack_require__(41);
exports.switchMap = switchMap_1.switchMap;
var switchMapTo_1 = __webpack_require__(248);
exports.switchMapTo = switchMapTo_1.switchMapTo;
var take_1 = __webpack_require__(249);
exports.take = take_1.take;
var takeLast_1 = __webpack_require__(312);
exports.takeLast = takeLast_1.takeLast;
var takeUntil_1 = __webpack_require__(250);
exports.takeUntil = takeUntil_1.takeUntil;
var takeWhile_1 = __webpack_require__(251);
exports.takeWhile = takeWhile_1.takeWhile;
var tap_1 = __webpack_require__(103);
exports.tap = tap_1.tap;
var throttle_1 = __webpack_require__(66);
exports.throttle = throttle_1.throttle;
var throttleTime_1 = __webpack_require__(252);
exports.throttleTime = throttleTime_1.throttleTime;
var timeInterval_1 = __webpack_require__(253);
exports.timeInterval = timeInterval_1.timeInterval;
var timeout_1 = __webpack_require__(254);
exports.timeout = timeout_1.timeout;
var timeoutWith_1 = __webpack_require__(255);
exports.timeoutWith = timeoutWith_1.timeoutWith;
var timestamp_1 = __webpack_require__(256);
exports.timestamp = timestamp_1.timestamp;
var toArray_1 = __webpack_require__(257);
exports.toArray = toArray_1.toArray;
var window_1 = __webpack_require__(67);
exports.window = window_1.window;
var windowCount_1 = __webpack_require__(258);
exports.windowCount = windowCount_1.windowCount;
var windowTime_1 = __webpack_require__(259);
exports.windowTime = windowTime_1.windowTime;
var windowToggle_1 = __webpack_require__(260);
exports.windowToggle = windowToggle_1.windowToggle;
var windowWhen_1 = __webpack_require__(261);
exports.windowWhen = windowWhen_1.windowWhen;
var withLatestFrom_1 = __webpack_require__(262);
exports.withLatestFrom = withLatestFrom_1.withLatestFrom;
var zip_1 = __webpack_require__(68);
exports.zip = zip_1.zip;
var zipAll_1 = __webpack_require__(263);
exports.zipAll = zipAll_1.zipAll;
//# sourceMappingURL=operators.js.map

/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ConfirmService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var ConfirmService = (function () {
    function ConfirmService() {
        var _this = this;
        this.confirmChanged = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["EventEmitter"]();
        this.showConfirm = function (title, message, actions) {
            return _this.confirmChanged.emit({ message: message, title: title, actions: actions });
        };
    }
    ConfirmService = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])()
    ], ConfirmService);
    return ConfirmService;
}());



/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return JobService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__services_backend_common_http_service__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__services_service_variables__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_add_operator_share__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_add_operator_share___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_add_operator_share__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




var JobService = (function () {
    function JobService(http) {
        this.http = http;
        this.URL = __WEBPACK_IMPORTED_MODULE_2__services_service_variables__["a" /* URL */].JOB_URL;
        this.OJOB_URL = __WEBPACK_IMPORTED_MODULE_2__services_service_variables__["a" /* URL */].JOB_URL + '/only-jobs';
        this.OINTERN_URL = __WEBPACK_IMPORTED_MODULE_2__services_service_variables__["a" /* URL */].JOB_URL + '/only-interns';
    }
    JobService.prototype.getJobDetail = function (id) {
        return this.http.get(this.URL, id, this.http.createHeader()).share();
    };
    JobService.prototype.getJobs = function () {
        if (!this.getJobs$) {
            this.getJobs$ = this.http.gets(this.URL, this.http.createHeader()).share();
        }
        return this.getJobs$;
    };
    JobService.prototype.getSearchJobs = function (keyword, jobGroupId, workTypeId) {
        if (jobGroupId === void 0) { jobGroupId = 0; }
        if (workTypeId === void 0) { workTypeId = 0; }
        if (!this.getJobs$) {
            this.getJobs();
        }
        return this.getJobs$.map(function (jobs) {
            var jobFilterKeyword = jobs.filter(function (job) {
                return job.contactAddress.toUpperCase().includes(keyword.toUpperCase()) || job.majorTag.toUpperCase().includes(keyword.toUpperCase())
                    || job.title.toUpperCase().includes(keyword.toUpperCase()) || job.shortDescription.toUpperCase().includes(keyword.toUpperCase())
                    || job.benefit.toUpperCase().includes(keyword.toUpperCase()) || job.place.toUpperCase().includes(keyword.toUpperCase())
                    || job.requirement.toUpperCase().includes(keyword.toUpperCase()) || job.position.toUpperCase().includes(keyword.toUpperCase())
                    || job.company.address.toUpperCase().includes(keyword.toUpperCase()) || job.company.description.toUpperCase().includes(keyword.toUpperCase())
                    || job.company.name.toUpperCase().includes(keyword.toUpperCase()) || job.company.shortName.toUpperCase().includes(keyword.toUpperCase())
                    || job.workType.name.toUpperCase().includes(keyword.toUpperCase()) || job.workType.shortName.toUpperCase().includes(keyword.toUpperCase())
                    || job.jobGroup.name.toUpperCase().includes(keyword.toUpperCase()) || job.jobGroup.shortName.toUpperCase().includes(keyword.toUpperCase());
            });
            if (jobGroupId != 0 && workTypeId != 0) {
                return jobFilterKeyword.filter(function (j) { return j.workTypeId == workTypeId && j.jobGroupId == jobGroupId; });
            }
            else if (jobGroupId == 0 && workTypeId != 0) {
                return jobFilterKeyword.filter(function (j) { return j.workTypeId == workTypeId; });
            }
            else if (jobGroupId != 0 && workTypeId == 0) {
                return jobFilterKeyword.filter(function (j) { return j.jobGroupId == jobGroupId; });
            }
            else {
                return jobFilterKeyword;
            }
        });
    };
    JobService.prototype.getOnlyJobs = function () {
        return this.http.gets(this.OJOB_URL, this.http.createHeader()).share();
    };
    JobService.prototype.getOnlyInterns = function () {
        return this.http.gets(this.OINTERN_URL, this.http.createHeader()).share();
    };
    JobService = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__services_backend_common_http_service__["a" /* CommonHttpService */]])
    ], JobService);
    return JobService;
}());



/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EventService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__services_backend_common_http_service__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__services_service_variables__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_add_operator_share__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_add_operator_share___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_add_operator_share__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_common_http__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_common_http___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__angular_common_http__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





var EventService = (function () {
    function EventService(http) {
        this.http = http;
        this.URL = __WEBPACK_IMPORTED_MODULE_2__services_service_variables__["a" /* URL */].EVENT_URL;
        this.headers = new __WEBPACK_IMPORTED_MODULE_4__angular_common_http__["HttpHeaders"]()
            .set("Content-Type", "application/json");
    }
    EventService.prototype.getEvents = function () {
        if (!this.getEvents$) {
            this.getEvents$ = this.http.gets(this.URL, this.http.createHeader()).share();
        }
        return this.getEvents$;
    };
    EventService.prototype.getEventsPage = function (currentPage, numberItemPage) {
        var body = {
            CurrentPage: currentPage,
            NumberItemPage: numberItemPage
        };
        return this.http.post(__WEBPACK_IMPORTED_MODULE_2__services_service_variables__["a" /* URL */].EVENT_URL, body, this.http.createHeader()).toPromise();
    };
    EventService = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__services_backend_common_http_service__["a" /* CommonHttpService */]])
    ], EventService);
    return EventService;
}());



/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return JobGroupService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__services_backend_common_http_service__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__services_service_variables__ = __webpack_require__(15);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var JobGroupService = (function () {
    function JobGroupService(http) {
        this.http = http;
        this.URL = __WEBPACK_IMPORTED_MODULE_2__services_service_variables__["a" /* URL */].JOB_GROUP_URL;
    }
    JobGroupService.prototype.getJobs = function () {
        if (!this.getJobG$) {
            this.getJobG$ = this.http.gets(this.URL, this.http.createHeader()).share();
        }
        return this.getJobG$;
    };
    JobGroupService = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__services_backend_common_http_service__["a" /* CommonHttpService */]])
    ], JobGroupService);
    return JobGroupService;
}());



/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(24);

/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return NAV_MENU; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UrlVariable; });
var NAV_MENU = [
    {
        link: "/", text: "trang ch"
    }, {
        link: "/about", text: "gii thiu"
    }, {
        link: "/jobs/list/internship", text: "thc tp"
    }, {
        link: "/jobs/list", text: "vic lm"
    }, {
        link: "/company", text: "doanh nghip"
    }, {
        link: "/events", text: "s kin"
    }, {
        link: "/skills", text: "k nng"
    }, {
        link: "/contact", text: "lin h"
    }
];
var UrlVariable = (function () {
    function UrlVariable() {
    }
    UrlVariable.URL_LOGIN = 'api/login';
    return UrlVariable;
}());



/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AdminGuard; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_router__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular2_jwt__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular2_jwt___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_angular2_jwt__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var AdminGuard = (function () {
    function AdminGuard(_router) {
        this._router = _router;
    }
    AdminGuard.prototype.canActivate = function (route, state) {
        if (typeof window !== "undefined") {
            var jwt = new __WEBPACK_IMPORTED_MODULE_2_angular2_jwt__["JwtHelper"]();
            var token = localStorage.getItem('token_hure');
            if (token) {
                if (jwt.isTokenExpired(token)) {
                    this._router.navigate(["admin/login"]);
                    return false;
                }
                else {
                    var roleJson = jwt.decodeToken(token);
                    var role = roleJson.Role;
                    if (role == "Admin") {
                        return true;
                    }
                    return false;
                }
            }
            else {
                this._router.navigate(["admin/login"]);
            }
            return false;
        }
        else {
            return false;
        }
    };
    AdminGuard = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_router__["Router"]])
    ], AdminGuard);
    return AdminGuard;
}());



/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ProfileService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_add_operator_map__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_add_operator_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_add_operator_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_add_operator_catch__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_add_operator_catch___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_add_operator_catch__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__services_backend_common_http_service__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__services_service_variables__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__services_backend_local_service__ = __webpack_require__(49);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






var ProfileService = (function () {
    function ProfileService(http, localSvc) {
        this.http = http;
        this.localSvc = localSvc;
        this.URL = __WEBPACK_IMPORTED_MODULE_4__services_service_variables__["a" /* URL */].PROFILE_URL;
    }
    ProfileService.prototype.getProfile = function () {
        var guid = this.localSvc.getGuid();
        return this.http.post(this.URL, { guid: guid });
    };
    ProfileService = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__services_backend_common_http_service__["a" /* CommonHttpService */], __WEBPACK_IMPORTED_MODULE_5__services_backend_local_service__["a" /* LocalService */]])
    ], ProfileService);
    return ProfileService;
}());



/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RoleService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__services_backend_common_http_service__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__services_service_variables__ = __webpack_require__(15);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var RoleService = (function () {
    function RoleService(http) {
        this.http = http;
        this.URL = __WEBPACK_IMPORTED_MODULE_2__services_service_variables__["a" /* URL */].ROLE_URL;
    }
    RoleService.prototype.gets = function () {
        if (!this.getRoles$) {
            this.getRoles$ = this.http.gets(this.URL, this.http.createHeader()).share();
        }
        return this.getRoles$;
    };
    RoleService = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__services_backend_common_http_service__["a" /* CommonHttpService */]])
    ], RoleService);
    return RoleService;
}());



/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WorkTypeService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__services_service_variables__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__services_backend_common_http_service__ = __webpack_require__(12);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var WorkTypeService = (function () {
    function WorkTypeService(http) {
        this.http = http;
        this.URL = __WEBPACK_IMPORTED_MODULE_1__services_service_variables__["a" /* URL */].WORKTYPE_URL;
    }
    WorkTypeService.prototype.getWorkTypes = function () {
        if (!this.workTypes$) {
            this.workTypes$ = this.http.gets(this.URL, this.http.createHeader()).share();
        }
        return this.workTypes$;
    };
    WorkTypeService = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__services_backend_common_http_service__["a" /* CommonHttpService */]])
    ], WorkTypeService);
    return WorkTypeService;
}());



/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source as long as errors don't occur.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @name tap
 */
function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
exports.tap = tap;
var DoOperator = (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = (function (_super) {
    __extends(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=tap.js.map

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(57);

/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CompanyService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__services_service_variables__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__services_backend_common_http_service__ = __webpack_require__(12);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var CompanyService = (function () {
    function CompanyService(http) {
        this.http = http;
        this.URL = __WEBPACK_IMPORTED_MODULE_1__services_service_variables__["a" /* URL */].COMPANY_URL;
    }
    CompanyService.prototype.getJobOfCompany = function (id) {
        return this.http.gets(this.URL + ("/" + id + "/jobs"), this.http.createHeader()).share();
    };
    CompanyService = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__services_backend_common_http_service__["a" /* CommonHttpService */]])
    ], CompanyService);
    return CompanyService;
}());



/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UIModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_common__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__group_group_component__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tabbed_tabbed_component__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__dropdown_dropdown_component__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__dropdown_dropdownItem_dropdownItem_component__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__tabbed_tab_tab_component__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__job_job_component__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__blog_blog_component__ = __webpack_require__(123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__rating_rating_component__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__expansible_card_expansible_card_component__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__popover_popover_component__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__directives_directive_module__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__ui_card_card_component__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__ui_waiter_waiter_component__ = __webpack_require__(134);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__ui_carousel_list_carousel_list_component__ = __webpack_require__(125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__ui_action_menu_action_menu_component__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__ui_action_menu_action_item_action_item_component__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__shared_pipes_pipe_module__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__overlay_overlay_component__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__app_end_user_home_components_jobs_container_jobs_container_component__ = __webpack_require__(110);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





















var UIModule = (function () {
    function UIModule() {
    }
    UIModule = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["NgModule"])({
            declarations: [__WEBPACK_IMPORTED_MODULE_2__group_group_component__["a" /* GroupComponent */], __WEBPACK_IMPORTED_MODULE_3__tabbed_tabbed_component__["a" /* TabbedComponent */], __WEBPACK_IMPORTED_MODULE_4__dropdown_dropdown_component__["a" /* DropdownComponent */],
                __WEBPACK_IMPORTED_MODULE_5__dropdown_dropdownItem_dropdownItem_component__["a" /* DropdownItemComponent */], __WEBPACK_IMPORTED_MODULE_6__tabbed_tab_tab_component__["a" /* TabComponent */], __WEBPACK_IMPORTED_MODULE_7__job_job_component__["a" /* JobComponent */], __WEBPACK_IMPORTED_MODULE_8__blog_blog_component__["a" /* BlogComponent */], __WEBPACK_IMPORTED_MODULE_14__ui_waiter_waiter_component__["a" /* WaiterComponent */],
                __WEBPACK_IMPORTED_MODULE_9__rating_rating_component__["a" /* RatingBarComponent */], __WEBPACK_IMPORTED_MODULE_10__expansible_card_expansible_card_component__["a" /* ExpansibleCardComponent */], __WEBPACK_IMPORTED_MODULE_11__popover_popover_component__["a" /* PopoverComponent */], __WEBPACK_IMPORTED_MODULE_13__ui_card_card_component__["a" /* CardComponent */], __WEBPACK_IMPORTED_MODULE_15__ui_carousel_list_carousel_list_component__["a" /* CarouselListComponent */],
                __WEBPACK_IMPORTED_MODULE_16__ui_action_menu_action_menu_component__["a" /* ActionMenuComponent */], __WEBPACK_IMPORTED_MODULE_17__ui_action_menu_action_item_action_item_component__["a" /* ActionItemComponent */],
                __WEBPACK_IMPORTED_MODULE_19__overlay_overlay_component__["a" /* OverlayComponent */], __WEBPACK_IMPORTED_MODULE_20__app_end_user_home_components_jobs_container_jobs_container_component__["a" /* JobsContainerComponent */]
            ],
            imports: [__WEBPACK_IMPORTED_MODULE_1__angular_common__["CommonModule"], __WEBPACK_IMPORTED_MODULE_12__directives_directive_module__["a" /* DirectiveModule */], __WEBPACK_IMPORTED_MODULE_18__shared_pipes_pipe_module__["a" /* PipeModule */]],
            exports: [__WEBPACK_IMPORTED_MODULE_2__group_group_component__["a" /* GroupComponent */], __WEBPACK_IMPORTED_MODULE_3__tabbed_tabbed_component__["a" /* TabbedComponent */], __WEBPACK_IMPORTED_MODULE_4__dropdown_dropdown_component__["a" /* DropdownComponent */],
                __WEBPACK_IMPORTED_MODULE_5__dropdown_dropdownItem_dropdownItem_component__["a" /* DropdownItemComponent */], __WEBPACK_IMPORTED_MODULE_6__tabbed_tab_tab_component__["a" /* TabComponent */], __WEBPACK_IMPORTED_MODULE_7__job_job_component__["a" /* JobComponent */], __WEBPACK_IMPORTED_MODULE_13__ui_card_card_component__["a" /* CardComponent */], __WEBPACK_IMPORTED_MODULE_14__ui_waiter_waiter_component__["a" /* WaiterComponent */],
                __WEBPACK_IMPORTED_MODULE_19__overlay_overlay_component__["a" /* OverlayComponent */], __WEBPACK_IMPORTED_MODULE_20__app_end_user_home_components_jobs_container_jobs_container_component__["a" /* JobsContainerComponent */],
                __WEBPACK_IMPORTED_MODULE_8__blog_blog_component__["a" /* BlogComponent */], __WEBPACK_IMPORTED_MODULE_9__rating_rating_component__["a" /* RatingBarComponent */], __WEBPACK_IMPORTED_MODULE_10__expansible_card_expansible_card_component__["a" /* ExpansibleCardComponent */], __WEBPACK_IMPORTED_MODULE_11__popover_popover_component__["a" /* PopoverComponent */], __WEBPACK_IMPORTED_MODULE_15__ui_carousel_list_carousel_list_component__["a" /* CarouselListComponent */],
                __WEBPACK_IMPORTED_MODULE_16__ui_action_menu_action_menu_component__["a" /* ActionMenuComponent */], __WEBPACK_IMPORTED_MODULE_17__ui_action_menu_action_item_action_item_component__["a" /* ActionItemComponent */]],
            providers: [],
        })
    ], UIModule);
    return UIModule;
}());



/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v4.3.6
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports, __webpack_require__(1), __webpack_require__(74), __webpack_require__(16), __webpack_require__(43)) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/platform-browser', '@angular/animations', '@angular/animations/browser'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.platformBrowser = global.ng.platformBrowser || {}, global.ng.platformBrowser.animations = global.ng.platformBrowser.animations || {}),global.ng.core,global.ng.platformBrowser,global.ng.animations,global.ng.animations.browser));
}(this, (function (exports,_angular_core,_angular_platformBrowser,_angular_animations,_angular_animations_browser) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * @license Angular v4.3.6
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var BrowserAnimationBuilder = (function (_super) {
    __extends(BrowserAnimationBuilder, _super);
    /**
     * @param {?} rootRenderer
     * @param {?} doc
     */
    function BrowserAnimationBuilder(rootRenderer, doc) {
        var _this = _super.call(this) || this;
        _this._nextAnimationId = 0;
        var typeData = {
            id: '0',
            encapsulation: _angular_core.ViewEncapsulation.None,
            styles: [],
            data: { animation: [] }
        };
        _this._renderer = rootRenderer.createRenderer(doc.body, typeData);
        return _this;
    }
    /**
     * @param {?} animation
     * @return {?}
     */
    BrowserAnimationBuilder.prototype.build = function (animation) {
        var /** @type {?} */ id = this._nextAnimationId.toString();
        this._nextAnimationId++;
        var /** @type {?} */ entry = Array.isArray(animation) ? _angular_animations.sequence(animation) : animation;
        issueAnimationCommand(this._renderer, null, id, 'register', [entry]);
        return new BrowserAnimationFactory(id, this._renderer);
    };
    return BrowserAnimationBuilder;
}(_angular_animations.AnimationBuilder));
BrowserAnimationBuilder.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
BrowserAnimationBuilder.ctorParameters = function () { return [
    { type: _angular_core.RendererFactory2, },
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
]; };
var BrowserAnimationFactory = (function (_super) {
    __extends(BrowserAnimationFactory, _super);
    /**
     * @param {?} _id
     * @param {?} _renderer
     */
    function BrowserAnimationFactory(_id, _renderer) {
        var _this = _super.call(this) || this;
        _this._id = _id;
        _this._renderer = _renderer;
        return _this;
    }
    /**
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    BrowserAnimationFactory.prototype.create = function (element, options) {
        return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
    };
    return BrowserAnimationFactory;
}(_angular_animations.AnimationFactory));
var RendererAnimationPlayer = (function () {
    /**
     * @param {?} id
     * @param {?} element
     * @param {?} options
     * @param {?} _renderer
     */
    function RendererAnimationPlayer(id, element, options, _renderer) {
        this.id = id;
        this.element = element;
        this._renderer = _renderer;
        this.parentPlayer = null;
        this._started = false;
        this.totalTime = 0;
        this._command('create', options);
    }
    /**
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    RendererAnimationPlayer.prototype._listen = function (eventName, callback) {
        return this._renderer.listen(this.element, "@@" + this.id + ":" + eventName, callback);
    };
    /**
     * @param {?} command
     * @param {...?} args
     * @return {?}
     */
    RendererAnimationPlayer.prototype._command = function (command) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return issueAnimationCommand(this._renderer, this.element, this.id, command, args);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onDone = function (fn) { this._listen('done', fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onStart = function (fn) { this._listen('start', fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onDestroy = function (fn) { this._listen('destroy', fn); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.init = function () { this._command('init'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.hasStarted = function () { return this._started; };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.play = function () {
        this._command('play');
        this._started = true;
    };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.pause = function () { this._command('pause'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.restart = function () { this._command('restart'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.finish = function () { this._command('finish'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.destroy = function () { this._command('destroy'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.reset = function () { this._command('reset'); };
    /**
     * @param {?} p
     * @return {?}
     */
    RendererAnimationPlayer.prototype.setPosition = function (p) { this._command('setPosition', p); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.getPosition = function () { return 0; };
    return RendererAnimationPlayer;
}());
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} id
 * @param {?} command
 * @param {?} args
 * @return {?}
 */
function issueAnimationCommand(renderer, element, id, command, args) {
    return renderer.setProperty(element, "@@" + id + ":" + command, args);
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ANIMATION_PREFIX = '@';
var DISABLE_ANIMATIONS_FLAG = '@.disabled';
var AnimationRendererFactory = (function () {
    /**
     * @param {?} delegate
     * @param {?} engine
     * @param {?} _zone
     */
    function AnimationRendererFactory(delegate, engine, _zone) {
        this.delegate = delegate;
        this.engine = engine;
        this._zone = _zone;
        this._currentId = 0;
        this._microtaskId = 1;
        this._animationCallbacksBuffer = [];
        this._rendererCache = new Map();
        this._cdRecurDepth = 0;
        engine.onRemovalComplete = function (element, delegate) {
            // Note: if an component element has a leave animation, and the component
            // a host leave animation, the view engine will call `removeChild` for the parent
            // component renderer as well as for the child component renderer.
            // Therefore, we need to check if we already removed the element.
            if (delegate && delegate.parentNode(element)) {
                delegate.removeChild(element.parentNode, element);
            }
        };
    }
    /**
     * @param {?} hostElement
     * @param {?} type
     * @return {?}
     */
    AnimationRendererFactory.prototype.createRenderer = function (hostElement, type) {
        var _this = this;
        var /** @type {?} */ EMPTY_NAMESPACE_ID = '';
        // cache the delegates to find out which cached delegate can
        // be used by which cached renderer
        var /** @type {?} */ delegate = this.delegate.createRenderer(hostElement, type);
        if (!hostElement || !type || !type.data || !type.data['animation']) {
            var /** @type {?} */ renderer = this._rendererCache.get(delegate);
            if (!renderer) {
                renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine);
                // only cache this result when the base renderer is used
                this._rendererCache.set(delegate, renderer);
            }
            return renderer;
        }
        var /** @type {?} */ componentId = type.id;
        var /** @type {?} */ namespaceId = type.id + '-' + this._currentId;
        this._currentId++;
        this.engine.register(namespaceId, hostElement);
        var /** @type {?} */ animationTriggers = (type.data['animation']);
        animationTriggers.forEach(function (trigger) { return _this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger); });
        return new AnimationRenderer(this, namespaceId, delegate, this.engine);
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.begin = function () {
        this._cdRecurDepth++;
        if (this.delegate.begin) {
            this.delegate.begin();
        }
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype._scheduleCountTask = function () {
        var _this = this;
        Zone.current.scheduleMicroTask('incremenet the animation microtask', function () { return _this._microtaskId++; });
    };
    /**
     * @param {?} count
     * @param {?} fn
     * @param {?} data
     * @return {?}
     */
    AnimationRendererFactory.prototype.scheduleListenerCallback = function (count, fn, data) {
        var _this = this;
        if (count >= 0 && count < this._microtaskId) {
            this._zone.run(function () { return fn(data); });
            return;
        }
        if (this._animationCallbacksBuffer.length == 0) {
            Promise.resolve(null).then(function () {
                _this._zone.run(function () {
                    _this._animationCallbacksBuffer.forEach(function (tuple) {
                        var fn = tuple[0], data = tuple[1];
                        fn(data);
                    });
                    _this._animationCallbacksBuffer = [];
                });
            });
        }
        this._animationCallbacksBuffer.push([fn, data]);
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.end = function () {
        var _this = this;
        this._cdRecurDepth--;
        // this is to prevent animations from running twice when an inner
        // component does CD when a parent component insted has inserted it
        if (this._cdRecurDepth == 0) {
            this._zone.runOutsideAngular(function () {
                _this._scheduleCountTask();
                _this.engine.flush(_this._microtaskId);
            });
        }
        if (this.delegate.end) {
            this.delegate.end();
        }
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.whenRenderingDone = function () { return this.engine.whenRenderingDone(); };
    return AnimationRendererFactory;
}());
AnimationRendererFactory.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
AnimationRendererFactory.ctorParameters = function () { return [
    { type: _angular_core.RendererFactory2, },
    { type: _angular_animations_browser.AnimationEngine, },
    { type: _angular_core.NgZone, },
]; };
var BaseAnimationRenderer = (function () {
    /**
     * @param {?} namespaceId
     * @param {?} delegate
     * @param {?} engine
     */
    function BaseAnimationRenderer(namespaceId, delegate, engine) {
        this.namespaceId = namespaceId;
        this.delegate = delegate;
        this.engine = engine;
        this.destroyNode = this.delegate.destroyNode ? function (n) { return delegate.destroyNode(n); } : null;
    }
    Object.defineProperty(BaseAnimationRenderer.prototype, "data", {
        /**
         * @return {?}
         */
        get: function () { return this.delegate.data; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    BaseAnimationRenderer.prototype.destroy = function () {
        this.engine.destroy(this.namespaceId, this.delegate);
        this.delegate.destroy();
    };
    /**
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createElement = function (name, namespace) {
        return this.delegate.createElement(name, namespace);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createComment = function (value) { return this.delegate.createComment(value); };
    /**
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createText = function (value) { return this.delegate.createText(value); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.appendChild = function (parent, newChild) {
        this.delegate.appendChild(parent, newChild);
        this.engine.onInsert(this.namespaceId, newChild, parent, false);
    };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.insertBefore = function (parent, newChild, refChild) {
        this.delegate.insertBefore(parent, newChild, refChild);
        this.engine.onInsert(this.namespaceId, newChild, parent, true);
    };
    /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeChild = function (parent, oldChild) {
        this.engine.onRemove(this.namespaceId, oldChild, this.delegate);
    };
    /**
     * @param {?} selectorOrNode
     * @return {?}
     */
    BaseAnimationRenderer.prototype.selectRootElement = function (selectorOrNode) { return this.delegate.selectRootElement(selectorOrNode); };
    /**
     * @param {?} node
     * @return {?}
     */
    BaseAnimationRenderer.prototype.parentNode = function (node) { return this.delegate.parentNode(node); };
    /**
     * @param {?} node
     * @return {?}
     */
    BaseAnimationRenderer.prototype.nextSibling = function (node) { return this.delegate.nextSibling(node); };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setAttribute = function (el, name, value, namespace) {
        this.delegate.setAttribute(el, name, value, namespace);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeAttribute = function (el, name, namespace) {
        this.delegate.removeAttribute(el, name, namespace);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    BaseAnimationRenderer.prototype.addClass = function (el, name) { this.delegate.addClass(el, name); };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeClass = function (el, name) { this.delegate.removeClass(el, name); };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?=} flags
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setStyle = function (el, style, value, flags) {
        this.delegate.setStyle(el, style, value, flags);
    };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?=} flags
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeStyle = function (el, style, flags) {
        this.delegate.removeStyle(el, style, flags);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setProperty = function (el, name, value) {
        if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {
            this.disableAnimations(el, !!value);
        }
        else {
            this.delegate.setProperty(el, name, value);
        }
    };
    /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setValue = function (node, value) { this.delegate.setValue(node, value); };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    BaseAnimationRenderer.prototype.listen = function (target, eventName, callback) {
        return this.delegate.listen(target, eventName, callback);
    };
    /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.disableAnimations = function (element, value) {
        this.engine.disableAnimations(element, value);
    };
    return BaseAnimationRenderer;
}());
var AnimationRenderer = (function (_super) {
    __extends(AnimationRenderer, _super);
    /**
     * @param {?} factory
     * @param {?} namespaceId
     * @param {?} delegate
     * @param {?} engine
     */
    function AnimationRenderer(factory, namespaceId, delegate, engine) {
        var _this = _super.call(this, namespaceId, delegate, engine) || this;
        _this.factory = factory;
        _this.namespaceId = namespaceId;
        return _this;
    }
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    AnimationRenderer.prototype.setProperty = function (el, name, value) {
        if (name.charAt(0) == ANIMATION_PREFIX) {
            if (name.charAt(1) == '.' && name == DISABLE_ANIMATIONS_FLAG) {
                value = value === undefined ? true : !!value;
                this.disableAnimations(el, /** @type {?} */ (value));
            }
            else {
                this.engine.process(this.namespaceId, el, name.substr(1), value);
            }
        }
        else {
            this.delegate.setProperty(el, name, value);
        }
    };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    AnimationRenderer.prototype.listen = function (target, eventName, callback) {
        var _this = this;
        if (eventName.charAt(0) == ANIMATION_PREFIX) {
            var /** @type {?} */ element = resolveElementFromTarget(target);
            var /** @type {?} */ name = eventName.substr(1);
            var /** @type {?} */ phase = '';
            // @listener.phase is for trigger animation callbacks
            // @@listener is for animation builder callbacks
            if (name.charAt(0) != ANIMATION_PREFIX) {
                _a = parseTriggerCallbackName(name), name = _a[0], phase = _a[1];
            }
            return this.engine.listen(this.namespaceId, element, name, phase, function (event) {
                var /** @type {?} */ countId = ((event))['_data'] || -1;
                _this.factory.scheduleListenerCallback(countId, callback, event);
            });
        }
        return this.delegate.listen(target, eventName, callback);
        var _a;
    };
    return AnimationRenderer;
}(BaseAnimationRenderer));
/**
 * @param {?} target
 * @return {?}
 */
function resolveElementFromTarget(target) {
    switch (target) {
        case 'body':
            return document.body;
        case 'document':
            return document;
        case 'window':
            return window;
        default:
            return target;
    }
}
/**
 * @param {?} triggerName
 * @return {?}
 */
function parseTriggerCallbackName(triggerName) {
    var /** @type {?} */ dotIndex = triggerName.indexOf('.');
    var /** @type {?} */ trigger = triggerName.substring(0, dotIndex);
    var /** @type {?} */ phase = triggerName.substr(dotIndex + 1);
    return [trigger, phase];
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var InjectableAnimationEngine = (function (_super) {
    __extends(InjectableAnimationEngine, _super);
    /**
     * @param {?} driver
     * @param {?} normalizer
     */
    function InjectableAnimationEngine(driver, normalizer) {
        return _super.call(this, driver, normalizer) || this;
    }
    return InjectableAnimationEngine;
}(_angular_animations_browser.AnimationEngine));
InjectableAnimationEngine.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
InjectableAnimationEngine.ctorParameters = function () { return [
    { type: _angular_animations_browser.AnimationDriver, },
    { type: _angular_animations_browser.AnimationStyleNormalizer, },
]; };
/**
 * @return {?}
 */
function instantiateSupportedAnimationDriver() {
    if (_angular_animations_browser.supportsWebAnimations()) {
        return new _angular_animations_browser.WebAnimationsDriver();
    }
    return new _angular_animations_browser.NoopAnimationDriver();
}
/**
 * @return {?}
 */
function instantiateDefaultStyleNormalizer() {
    return new _angular_animations_browser.WebAnimationsStyleNormalizer();
}
/**
 * @param {?} renderer
 * @param {?} engine
 * @param {?} zone
 * @return {?}
 */
function instantiateRendererFactory(renderer, engine, zone) {
    return new AnimationRendererFactory(renderer, engine, zone);
}
var SHARED_ANIMATION_PROVIDERS = [
    { provide: _angular_animations.AnimationBuilder, useClass: BrowserAnimationBuilder },
    { provide: _angular_animations_browser.AnimationStyleNormalizer, useFactory: instantiateDefaultStyleNormalizer },
    { provide: _angular_animations_browser.AnimationEngine, useClass: InjectableAnimationEngine }, {
        provide: _angular_core.RendererFactory2,
        useFactory: instantiateRendererFactory,
        deps: [_angular_platformBrowser.DomRendererFactory2, _angular_animations_browser.AnimationEngine, _angular_core.NgZone]
    }
];
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserModule.
 */
var BROWSER_ANIMATIONS_PROVIDERS = [
    { provide: _angular_animations_browser.AnimationDriver, useFactory: instantiateSupportedAnimationDriver }
].concat(SHARED_ANIMATION_PROVIDERS);
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserTestingModule.
 */
var BROWSER_NOOP_ANIMATIONS_PROVIDERS = [{ provide: _angular_animations_browser.AnimationDriver, useClass: _angular_animations_browser.NoopAnimationDriver }].concat(SHARED_ANIMATION_PROVIDERS);
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@experimental Animation support is experimental.
 */
var BrowserAnimationsModule = (function () {
    function BrowserAnimationsModule() {
    }
    return BrowserAnimationsModule;
}());
BrowserAnimationsModule.decorators = [
    { type: _angular_core.NgModule, args: [{
                exports: [_angular_platformBrowser.BrowserModule],
                providers: BROWSER_ANIMATIONS_PROVIDERS,
            },] },
];
/**
 * @nocollapse
 */
BrowserAnimationsModule.ctorParameters = function () { return []; };
/**
 * \@experimental Animation support is experimental.
 */
var NoopAnimationsModule = (function () {
    function NoopAnimationsModule() {
    }
    return NoopAnimationsModule;
}());
NoopAnimationsModule.decorators = [
    { type: _angular_core.NgModule, args: [{
                exports: [_angular_platformBrowser.BrowserModule],
                providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,
            },] },
];
/**
 * @nocollapse
 */
NoopAnimationsModule.ctorParameters = function () { return []; };

exports.BrowserAnimationsModule = BrowserAnimationsModule;
exports.NoopAnimationsModule = NoopAnimationsModule;
exports.BrowserAnimationBuilder = BrowserAnimationBuilder;
exports.BrowserAnimationFactory = BrowserAnimationFactory;
exports.AnimationRenderer = AnimationRenderer;
exports.AnimationRendererFactory = AnimationRendererFactory;
exports.a = BaseAnimationRenderer;
exports.f = BROWSER_ANIMATIONS_PROVIDERS;
exports.g = BROWSER_NOOP_ANIMATIONS_PROVIDERS;
exports.b = InjectableAnimationEngine;
exports.d = instantiateDefaultStyleNormalizer;
exports.e = instantiateRendererFactory;
exports.c = instantiateSupportedAnimationDriver;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=platform-browser-animations.umd.js.map


/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export routes */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return routing; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_router__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_router___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_router__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__app_end_user_error_error_component__ = __webpack_require__(46);


var routes = [
    {
        path: '', loadChildren: function () { return new Promise(function (resolve) { __webpack_require__.e/* require.ensure */(1).then((function (require) { resolve(__webpack_require__(319)['EndUserModule']); }).bind(null, __webpack_require__)).catch(__webpack_require__.oe); }); }
    },
    {
        path: 'admin', loadChildren: function () { return new Promise(function (resolve) { __webpack_require__.e/* require.ensure */(0).then((function (require) { resolve(__webpack_require__(318)['AdminModule']); }).bind(null, __webpack_require__)).catch(__webpack_require__.oe); }); }
    },
    { path: '**', component: __WEBPACK_IMPORTED_MODULE_1__app_end_user_error_error_component__["a" /* ErrorComponent */] }
];
var routing = __WEBPACK_IMPORTED_MODULE_0__angular_router__["RouterModule"].forRoot(routes);


/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppModuleShared; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_common__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__angular_forms__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_http__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_http___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__angular_http__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__app_router__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__app_app_component__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__services_service_module__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__shared_shared_module__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__app_end_user_error_error_component__ = __webpack_require__(46);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};









var AppModuleShared = (function () {
    function AppModuleShared() {
    }
    AppModuleShared = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["NgModule"])({
            declarations: [__WEBPACK_IMPORTED_MODULE_5__app_app_component__["a" /* AppComponent */], __WEBPACK_IMPORTED_MODULE_8__app_end_user_error_error_component__["a" /* ErrorComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["CommonModule"],
                __WEBPACK_IMPORTED_MODULE_3__angular_http__["HttpModule"],
                __WEBPACK_IMPORTED_MODULE_6__services_service_module__["a" /* ServiceModule */],
                __WEBPACK_IMPORTED_MODULE_7__shared_shared_module__["a" /* SharedModule */],
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["FormsModule"],
                __WEBPACK_IMPORTED_MODULE_4__app_router__["a" /* routing */],
            ]
        })
    ], AppModuleShared);
    return AppModuleShared;
}());



/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return JobsContainerComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_operators__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_operators___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_operators__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var JobsContainerComponent = (function () {
    function JobsContainerComponent() {
        this.title = "Cng vic";
        this.limit = 5;
        this.size = 'medium';
    }
    JobsContainerComponent.prototype.ngOnDestroy = function () {
    };
    JobsContainerComponent.prototype.ngOnInit = function () {
    };
    JobsContainerComponent.prototype.ngAfterViewInit = function () {
        this.getDataAsync();
    };
    JobsContainerComponent.prototype.getDataAsync = function () {
        try {
            if (!this.jobs$) {
                this.jobs$ = this.jobsObserver.pipe(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_rxjs_operators__["share"])());
            }
        }
        catch (err) {
            console.log(err);
        }
    };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"])
    ], JobsContainerComponent.prototype, "jobsObserver", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], JobsContainerComponent.prototype, "title", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Number)
    ], JobsContainerComponent.prototype, "limit", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], JobsContainerComponent.prototype, "size", void 0);
    JobsContainerComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-jobs-container',
            template: __webpack_require__(152),
            styles: [__webpack_require__(275)]
        }),
        __metadata("design:paramtypes", [])
    ], JobsContainerComponent);
    return JobsContainerComponent;
}());



/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ClickOutsideDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var ClickOutsideDirective = (function () {
    function ClickOutsideDirective(_elementRef) {
        this._elementRef = _elementRef;
        this.clickOutside = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["EventEmitter"]();
    }
    ClickOutsideDirective.prototype.onClick = function (targetElement) {
        var clickedInside = this._elementRef.nativeElement.contains(targetElement);
        if (!clickedInside) {
            this.clickOutside.emit(null);
        }
    };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Output"])(),
        __metadata("design:type", Object)
    ], ClickOutsideDirective.prototype, "clickOutside", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["HostListener"])('document:click', ['$event.target']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], ClickOutsideDirective.prototype, "onClick", null);
    ClickOutsideDirective = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Directive"])({
            selector: '[clickOutside]'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"]])
    ], ClickOutsideDirective);
    return ClickOutsideDirective;
}());



/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HoverEffect; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var HoverEffect = (function () {
    function HoverEffect(renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
    }
    HoverEffect.prototype.onmouseenter = function () {
        this.renderer.addClass(this.elementRef.nativeElement, 'active');
    };
    HoverEffect.prototype.onmouseleave = function () {
        this.renderer.removeClass(this.elementRef.nativeElement, 'active');
    };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["HostListener"])('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], HoverEffect.prototype, "onmouseenter", null);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["HostListener"])('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], HoverEffect.prototype, "onmouseleave", null);
    HoverEffect = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Directive"])({
            selector: '[hoverEffect]',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["Renderer2"], __WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"]])
    ], HoverEffect);
    return HoverEffect;
}());



/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RippleDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var RippleDirective = (function () {
    function RippleDirective(el, renderer, renderer2) {
        this.el = el;
        this.renderer = renderer;
        this.renderer2 = renderer2;
        this.renderer.setElementStyle(this.el.nativeElement, 'overflow', 'hidden');
        this.renderer.setElementStyle(this.el.nativeElement, 'position', 'relative');
    }
    RippleDirective.prototype.onmousedown = function (event) {
        this.createShapeRipple(event.offsetX, event.offsetY);
    };
    RippleDirective.prototype.createShapeRipple = function (x, y) {
        var _this = this;
        var ripple = this.renderer.createElement(this.el.nativeElement, 'div');
        this.renderer.setElementStyle(ripple, 'border-radius', '20px');
        this.renderer.setElementStyle(ripple, 'position', 'absolute');
        this.renderer.setElementStyle(ripple, 'height', '40px');
        this.renderer.setElementStyle(ripple, 'width', '40px');
        this.renderer.setElementStyle(ripple, 'pointer-events', 'none');
        var colorBackground = window.getComputedStyle(this.el.nativeElement).backgroundColor || "rgba(0,0,0,0)";
        var colorArr = colorBackground.replace('rgba', '').replace('rgb', '').replace(')', '').replace('(', '').split(',');
        if (colorArr.filter(function (t) { return t.trim() === "0"; }).length >= 3 || colorBackground == "transparent") {
            this.renderer.setElementStyle(ripple, 'background', 'black');
        }
        else {
            this.renderer.setElementStyle(ripple, 'background', 'white');
        }
        this.renderer.setElementStyle(ripple, 'left', (x - 10).toString() + 'px');
        this.renderer.setElementStyle(ripple, 'top', (y - 10).toString() + 'px');
        this.renderer.setElementStyle(ripple, 'opacity', '0.5');
        var scaleNumber = this.el.nativeElement.offsetWidth / 40;
        this.renderer.setElementStyle(ripple, 'transition', 'all .8s ease-out');
        this.renderer.setElementStyle(ripple, 'opacity', '0');
        this.renderer.setElementStyle(ripple, 'transform', 'scale(' + scaleNumber * 2 + ')');
        setTimeout(function () { return _this.renderer2.removeChild(_this.el.nativeElement, ripple); }, 800);
    };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["HostListener"])('mousedown', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], RippleDirective.prototype, "onmousedown", null);
    RippleDirective = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Directive"])({ selector: '[rippleEffect]' }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"], __WEBPACK_IMPORTED_MODULE_0__angular_core__["Renderer"], __WEBPACK_IMPORTED_MODULE_0__angular_core__["Renderer2"]])
    ], RippleDirective);
    return RippleDirective;
}());



/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AuthGuard; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_router__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular2_jwt__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular2_jwt___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_angular2_jwt__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var AuthGuard = (function () {
    function AuthGuard(router) {
        this.router = router;
    }
    AuthGuard.prototype.canActivate = function (route, state) {
        if (typeof window !== "undefined") {
            var jwt = new __WEBPACK_IMPORTED_MODULE_2_angular2_jwt__["JwtHelper"]();
            var token = localStorage.getItem('token_hure');
            if (token) {
                if (jwt.isTokenExpired(token)) {
                    this.router.navigate([""]);
                    return false;
                }
                return true;
            }
            this.router.navigate([""]);
            return false;
        }
        else {
            return false;
        }
    };
    AuthGuard = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_router__["Router"]])
    ], AuthGuard);
    return AuthGuard;
}());



/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CompanyGuard; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_router__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular2_jwt__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular2_jwt___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_angular2_jwt__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var CompanyGuard = (function () {
    function CompanyGuard(_router) {
        this._router = _router;
    }
    CompanyGuard.prototype.canActivate = function (route, state) {
        if (typeof window !== "undefined") {
            var jwt = new __WEBPACK_IMPORTED_MODULE_2_angular2_jwt__["JwtHelper"]();
            var token = localStorage.getItem('token_hure');
            if (token) {
                if (jwt.isTokenExpired(token)) {
                    this._router.navigate(["doanhnghiep/login"]);
                    return false;
                }
                else {
                    var roleJson = jwt.decodeToken(token);
                    var role = roleJson.Role;
                    if (role == "Company") {
                        return true;
                    }
                    return false;
                }
            }
            else {
                this._router.navigate(["doanhnghiep/login"]);
            }
            return false;
        }
        else {
            return false;
        }
    };
    CompanyGuard = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_router__["Router"]])
    ], CompanyGuard);
    return CompanyGuard;
}());



/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GuardModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__guards_admin_guard__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__guards_auth_guard__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__guards_student_guard__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__guards_company_guard__ = __webpack_require__(115);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





var GuardModule = (function () {
    function GuardModule() {
    }
    GuardModule = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["NgModule"])({
            imports: [],
            exports: [],
            declarations: [],
            providers: [__WEBPACK_IMPORTED_MODULE_1__guards_admin_guard__["a" /* AdminGuard */], __WEBPACK_IMPORTED_MODULE_2__guards_auth_guard__["a" /* AuthGuard */], __WEBPACK_IMPORTED_MODULE_3__guards_student_guard__["a" /* StudentGuard */], __WEBPACK_IMPORTED_MODULE_4__guards_company_guard__["a" /* CompanyGuard */]],
        })
    ], GuardModule);
    return GuardModule;
}());



/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return StudentGuard; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_router__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular2_jwt__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular2_jwt___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_angular2_jwt__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var StudentGuard = (function () {
    function StudentGuard(_router) {
        this._router = _router;
    }
    StudentGuard.prototype.canActivate = function (route, state) {
        if (typeof window !== "undefined") {
            var jwt = new __WEBPACK_IMPORTED_MODULE_2_angular2_jwt__["JwtHelper"]();
            var token = localStorage.getItem('token_hure');
            if (token) {
                if (jwt.isTokenExpired(token)) {
                    this._router.navigate(["sinhvien/login"]);
                    return false;
                }
                else {
                    var roleJson = jwt.decodeToken(token);
                    var role = roleJson.Role;
                    if (role == "Student") {
                        return true;
                    }
                    return false;
                }
            }
            else {
                this._router.navigate(["sinhvien/login"]);
            }
            return false;
        }
        else {
            return false;
        }
    };
    StudentGuard = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_router__["Router"]])
    ], StudentGuard);
    return StudentGuard;
}());



/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LimitTextPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var LimitTextPipe = (function () {
    function LimitTextPipe() {
    }
    LimitTextPipe.prototype.transform = function (value, limit) {
        if (limit === void 0) { limit = 100; }
        var val = value;
        if (val.length > limit) {
            return val.slice(0, limit - 3) + "...";
        }
        return val;
    };
    LimitTextPipe = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Pipe"])({
            name: 'limitText'
        })
    ], LimitTextPipe);
    return LimitTextPipe;
}());



/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ProgressService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var ProgressService = (function () {
    function ProgressService() {
        var _this = this;
        this.progressChanged = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["EventEmitter"]();
        this.setPercent = function (percent) {
            return _this.progressChanged.emit(percent);
        };
    }
    ProgressService = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])()
    ], ProgressService);
    return ProgressService;
}());



/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ServiceModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_common__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__frontend_confirm_service__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__frontend_alert_service__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__frontend_progress_service__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__frontend_loading_service__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__backend_common_http_service__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__services_backend_auth_service__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__services_backend_job_service__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__angular_http__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__angular_http___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__angular_http__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__services_backend_profile_service__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__services_backend_local_service__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__services_backend_event_service__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__services_backend_job_group_service__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__services_backend_role_service__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__services_backend_work_type_service__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__services_backend_company_service__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__services_frontend_data_service__ = __webpack_require__(50);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


















var ServiceModule = (function () {
    function ServiceModule() {
    }
    ServiceModule = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["NgModule"])({
            declarations: [],
            imports: [__WEBPACK_IMPORTED_MODULE_1__angular_common__["CommonModule"], __WEBPACK_IMPORTED_MODULE_9__angular_http__["HttpModule"]],
            exports: [],
            providers: [__WEBPACK_IMPORTED_MODULE_2__frontend_confirm_service__["a" /* ConfirmService */], __WEBPACK_IMPORTED_MODULE_3__frontend_alert_service__["a" /* AlertService */], __WEBPACK_IMPORTED_MODULE_4__frontend_progress_service__["a" /* ProgressService */], __WEBPACK_IMPORTED_MODULE_5__frontend_loading_service__["a" /* LoadingService */], __WEBPACK_IMPORTED_MODULE_6__backend_common_http_service__["a" /* CommonHttpService */], __WEBPACK_IMPORTED_MODULE_7__services_backend_auth_service__["a" /* AuthService */], __WEBPACK_IMPORTED_MODULE_17__services_frontend_data_service__["a" /* DataService */],
                __WEBPACK_IMPORTED_MODULE_8__services_backend_job_service__["a" /* JobService */], __WEBPACK_IMPORTED_MODULE_10__services_backend_profile_service__["a" /* ProfileService */], __WEBPACK_IMPORTED_MODULE_11__services_backend_local_service__["a" /* LocalService */], __WEBPACK_IMPORTED_MODULE_12__services_backend_event_service__["a" /* EventService */], __WEBPACK_IMPORTED_MODULE_13__services_backend_job_group_service__["a" /* JobGroupService */], __WEBPACK_IMPORTED_MODULE_14__services_backend_role_service__["a" /* RoleService */], __WEBPACK_IMPORTED_MODULE_15__services_backend_work_type_service__["a" /* WorkTypeService */], __WEBPACK_IMPORTED_MODULE_16__services_backend_company_service__["a" /* CompanyService */]],
        })
    ], ServiceModule);
    return ServiceModule;
}());



/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ActionItemComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var ActionItemComponent = (function () {
    function ActionItemComponent() {
    }
    ActionItemComponent.prototype.ngOnInit = function () { };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Object)
    ], ActionItemComponent.prototype, "item", void 0);
    ActionItemComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-action-item',
            template: __webpack_require__(153),
            styles: [__webpack_require__(276)]
        }),
        __metadata("design:paramtypes", [])
    ], ActionItemComponent);
    return ActionItemComponent;
}());



/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ActionMenuComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var ActionMenuComponent = (function () {
    function ActionMenuComponent() {
    }
    ActionMenuComponent.prototype.ngOnInit = function () { };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Array)
    ], ActionMenuComponent.prototype, "items", void 0);
    ActionMenuComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-action-menu',
            template: __webpack_require__(154),
            styles: [__webpack_require__(277)]
        }),
        __metadata("design:paramtypes", [])
    ], ActionMenuComponent);
    return ActionMenuComponent;
}());



/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BlogComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var BlogComponent = (function () {
    function BlogComponent() {
    }
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], BlogComponent.prototype, "image", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], BlogComponent.prototype, "link", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], BlogComponent.prototype, "linktotime", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], BlogComponent.prototype, "linkcomment", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], BlogComponent.prototype, "title", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], BlogComponent.prototype, "content", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], BlogComponent.prototype, "time", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], BlogComponent.prototype, "comment", void 0);
    BlogComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-blog',
            template: __webpack_require__(155),
            styles: [__webpack_require__(278)]
        })
    ], BlogComponent);
    return BlogComponent;
}());



/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CardComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_router__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var CardComponent = (function () {
    function CardComponent(router) {
        this.router = router;
    }
    CardComponent.prototype.ngOnInit = function () {
    };
    CardComponent.prototype.apply = function () {
        if (this.event) {
            this.router.navigate(['events', this.event ? this.event.id.toString() : 1]);
        }
    };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "event", void 0);
    CardComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-card',
            template: __webpack_require__(156),
            styles: [__webpack_require__(279)],
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_router__["Router"]])
    ], CardComponent);
    return CardComponent;
}());



/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CarouselListComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_animations__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_animations___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_animations__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var CarouselListComponent = (function () {
    function CarouselListComponent() {
        this.show = 4;
        this.size = 136;
    }
    CarouselListComponent.prototype.ngAfterViewInit = function () {
        this.slide();
    };
    CarouselListComponent.prototype.ngOnInit = function () {
    };
    CarouselListComponent.prototype.slide = function () {
        var _this = this;
        var item = this.listItem.shift();
        this.listItem.push(item);
        setTimeout(function () { return _this.slide(); }, 3000);
    };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Array)
    ], CarouselListComponent.prototype, "listItem", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Number)
    ], CarouselListComponent.prototype, "show", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Number)
    ], CarouselListComponent.prototype, "size", void 0);
    CarouselListComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-carousel-list',
            template: __webpack_require__(157),
            styles: [__webpack_require__(280)],
            animations: [
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["trigger"])('itemDis', [
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["state"])('void', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])({ transform: 'translateX(0)' })),
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["transition"])('void => *', [
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])({ transform: 'translateX(100%)' }),
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["animate"])('500ms ease-out')
                    ]),
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["transition"])('* => void', [
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["animate"])('500ms ease-in', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])({ transform: 'translateX(-100%)' }))
                    ])
                ])
            ]
        }),
        __metadata("design:paramtypes", [])
    ], CarouselListComponent);
    return CarouselListComponent;
}());



/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DropdownItemComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dropdown_component__ = __webpack_require__(51);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var DropdownItemComponent = (function () {
    function DropdownItemComponent(dropdown) {
        this.dropdown = dropdown;
        this.dropdown.addItem(this);
    }
    DropdownItemComponent.prototype.selectItem = function () {
        this.dropdown.selectItemEmit(this);
    };
    DropdownItemComponent.prototype.ngOnInit = function () {
        if (this.isSelected) {
            this.dropdown.selectItem(this);
        }
    };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Object)
    ], DropdownItemComponent.prototype, "value", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], DropdownItemComponent.prototype, "text", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Boolean)
    ], DropdownItemComponent.prototype, "isSelected", void 0);
    DropdownItemComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-dropdown-item',
            template: __webpack_require__(159)
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__dropdown_component__["a" /* DropdownComponent */]])
    ], DropdownItemComponent);
    return DropdownItemComponent;
}());



/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ExpansibleCardComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_animations__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_animations___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_animations__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var ExpansibleCardComponent = (function () {
    function ExpansibleCardComponent() {
        this.isExpanded = false;
    }
    ExpansibleCardComponent.prototype.ngOnInit = function () { };
    ExpansibleCardComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-expansible-card',
            template: __webpack_require__(160),
            styles: [__webpack_require__(282)],
            animations: [
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["trigger"])('expandChanged', [
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["state"])('0', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])({
                        height: '200px'
                    })),
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["state"])('1', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])({
                        height: 'auto',
                    })),
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["transition"])('1 => 0', [
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])({ height: '*' }),
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["animate"])(100, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])({ height: 200 }))
                    ]), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["transition"])('0 => 1', [
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])({ height: 200 }),
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["animate"])(100, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])({ height: '*' }))
                    ]),
                ])
            ]
        }),
        __metadata("design:paramtypes", [])
    ], ExpansibleCardComponent);
    return ExpansibleCardComponent;
}());



/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GroupComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var GroupComponent = (function () {
    function GroupComponent() {
    }
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], GroupComponent.prototype, "image", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], GroupComponent.prototype, "link", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], GroupComponent.prototype, "text", void 0);
    GroupComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-group',
            template: __webpack_require__(161),
            styles: [__webpack_require__(283)]
        })
    ], GroupComponent);
    return GroupComponent;
}());



/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return JobComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_router__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__services_frontend_data_service__ = __webpack_require__(50);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var JobComponent = (function () {
    function JobComponent(router, data) {
        this.router = router;
        this.data = data;
        this.size = 'medium';
    }
    JobComponent.prototype.apply = function () {
        if (this.job) {
            this.data.data = this.job;
            this.router.navigate(['jobs', 'details', this.job ? this.job.id.toString() : 1]);
            //  this.router.navigateByUrl(`/jobs/details/${this.job?this.job.id.toString():1}`)
        }
    };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Object)
    ], JobComponent.prototype, "job", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], JobComponent.prototype, "size", void 0);
    JobComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-job',
            template: __webpack_require__(162),
            styles: [__webpack_require__(284)]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_router__["Router"], __WEBPACK_IMPORTED_MODULE_2__services_frontend_data_service__["a" /* DataService */]])
    ], JobComponent);
    return JobComponent;
}());



/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OverlayComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var OverlayComponent = (function () {
    function OverlayComponent() {
        this.isActivated = false;
    }
    OverlayComponent.prototype.ngOnInit = function () {
    };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Boolean)
    ], OverlayComponent.prototype, "isActivated", void 0);
    OverlayComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-overlay',
            template: __webpack_require__(163),
            styles: [__webpack_require__(285)]
        }),
        __metadata("design:paramtypes", [])
    ], OverlayComponent);
    return OverlayComponent;
}());



/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PopoverComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_animations__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_animations___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_animations__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var PopoverComponent = (function () {
    function PopoverComponent(renderer, element, renderer2) {
        this.renderer = renderer;
        this.element = element;
        this.renderer2 = renderer2;
        this.state = false;
        this.enabled = false;
    }
    PopoverComponent.prototype.change = function () {
        var _this = this;
        if (!this.enabled) {
            var parenTop = this.element.nativeElement.offsetTop;
            var parentLeft = this.element.nativeElement.offsetLeft || window.innerWidth - this.element.nativeElement.offsetRight - this.element.nativeElement.offsetWidth;
            var parentHeight = this.element.nativeElement.offsetHeight;
            var parentWidth = this.element.nativeElement.offsetWidth;
            var parentRight = this.element.nativeElement.offsetRight || window.innerWidth - this.element.nativeElement.offsetLeft - this.element.nativeElement.offsetWidth;
            var popoverWidth = this.popover.nativeElement.offsetWidth;
            this.renderer.setElementStyle(this.popover.nativeElement, 'top', parentHeight + 22 + 'px');
            this.renderer.setElementStyle(this.popover.nativeElement, 'left', '0');
            var sizeOutRight = parentLeft + parentWidth / 2 + popoverWidth / 2 - window.innerWidth;
            var sizeOutLeft = parentRight + parentWidth / 2 + popoverWidth / 2 - window.innerWidth;
            if (sizeOutLeft > 0) {
                var valToTransform = sizeOutLeft + 8;
                this.renderer.setElementStyle(this.popover.nativeElement, 'transform', 'translateX(' + 1 + 'px)');
            }
            else if (sizeOutRight > 0) {
                var valToTransform = sizeOutRight + 8;
                this.renderer.setElementStyle(this.popover.nativeElement, 'transform', 'translateX(' + (-popoverWidth / 2 - valToTransform) + 'px)');
            }
            this.state = !this.state;
            setTimeout(function () {
                _this.enabled = true;
            }, 100);
        }
        else {
            this.closeIt();
        }
    };
    PopoverComponent.prototype.closeIt = function () {
        if (this.enabled) {
            this.renderer.setElementStyle(this.popover.nativeElement, 'top', -10000 + 'px');
            this.state = false;
            this.enabled = false;
            return;
        }
        else {
            return;
        }
    };
    PopoverComponent.prototype.ngOnInit = function () { };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('btn'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"])
    ], PopoverComponent.prototype, "btn", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('popover'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"])
    ], PopoverComponent.prototype, "popover", void 0);
    PopoverComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-popover',
            template: __webpack_require__(164),
            styles: [__webpack_require__(286)], animations: [
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["trigger"])('menuChanged', [
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["state"])('0', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])({
                        height: '0',
                        opacity: 0,
                    })),
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["state"])('1', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])({
                        height: 'auto',
                        opacity: 1,
                    }))
                ])
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["Renderer"], __WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"], __WEBPACK_IMPORTED_MODULE_0__angular_core__["Renderer2"]])
    ], PopoverComponent);
    return PopoverComponent;
}());



/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RatingBarComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var RatingBarComponent = (function () {
    function RatingBarComponent() {
        this.textRating = ["Very Bad", "Bad", "So so", "Good", "Perfect"];
        this.rating = 0;
        this.max = 5;
    }
    RatingBarComponent.prototype.range = function (star) {
        var arr = [];
        for (var index = 1; index <= this.max; index++) {
            arr.push(index);
        }
        return arr;
    };
    RatingBarComponent.prototype.selectStar = function (i) {
        this.rating = i;
    };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Number)
    ], RatingBarComponent.prototype, "rating", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Number)
    ], RatingBarComponent.prototype, "max", void 0);
    RatingBarComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-rating-bar',
            template: __webpack_require__(165),
            styles: ["\n        .fill{\n            background: black;\n        }\n    "]
        })
    ], RatingBarComponent);
    return RatingBarComponent;
}());



/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TabComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tabbed_component__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_animations__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_animations___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__angular_animations__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var TabComponent = (function () {
    function TabComponent(tabbed) {
        this.tabbed = tabbed;
        this.tabbed.addTab(this);
    }
    TabComponent.prototype.ngOnInit = function () {
        if (this.isActivated) {
            this.tabbed.selectTab(this);
        }
    };
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", String)
    ], TabComponent.prototype, "title", void 0);
    __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
        __metadata("design:type", Boolean)
    ], TabComponent.prototype, "isActivated", void 0);
    TabComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-tab',
            template: __webpack_require__(166),
            animations: [
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__angular_animations__["trigger"])('tabChanged', [
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__angular_animations__["transition"])('void => *', [
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__angular_animations__["style"])({ opacity: 1, transform: 'translateX(-100%)' }),
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__angular_animations__["animate"])(250)
                    ]),
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__angular_animations__["transition"])('* => void', [
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__angular_animations__["animate"])(250, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__angular_animations__["style"])({ opacity: 0, transform: 'translateX(100%)' }))
                    ])
                ])
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__tabbed_component__["a" /* TabbedComponent */]])
    ], TabComponent);
    return TabComponent;
}());



/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WaiterComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var WaiterComponent = (function () {
    function WaiterComponent() {
    }
    WaiterComponent.prototype.ngOnInit = function () { };
    WaiterComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'hure-waiter',
            template: __webpack_require__(168),
            styles: [__webpack_require__(287)],
        }),
        __metadata("design:paramtypes", [])
    ], WaiterComponent);
    return WaiterComponent;
}());



/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_reflect_metadata__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_reflect_metadata___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_reflect_metadata__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_zone_js__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_zone_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_zone_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_add_operator_first__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_add_operator_first___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_add_operator_first__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_common__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_common___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__angular_common__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__angular_platform_server__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__angular_platform_server___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__angular_platform_server__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_aspnet_prerendering__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_aspnet_prerendering___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_aspnet_prerendering__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__app_app_server_module__ = __webpack_require__(84);








__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__angular_core__["enableProdMode"])();
/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_aspnet_prerendering__["createServerRenderer"])(function (params) {
    var providers = [
        { provide: __WEBPACK_IMPORTED_MODULE_5__angular_platform_server__["INITIAL_CONFIG"], useValue: { document: '<app></app>', url: params.url } },
        { provide: __WEBPACK_IMPORTED_MODULE_3__angular_common__["APP_BASE_HREF"], useValue: params.baseUrl },
        { provide: 'BASE_URL', useValue: params.origin + params.baseUrl },
    ];
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__angular_platform_server__["platformDynamicServer"])(providers).bootstrapModule(__WEBPACK_IMPORTED_MODULE_7__app_app_server_module__["a" /* AppModule */]).then(function (moduleRef) {
        var appRef = moduleRef.injector.get(__WEBPACK_IMPORTED_MODULE_4__angular_core__["ApplicationRef"]);
        var state = moduleRef.injector.get(__WEBPACK_IMPORTED_MODULE_5__angular_platform_server__["PlatformState"]);
        var zone = moduleRef.injector.get(__WEBPACK_IMPORTED_MODULE_4__angular_core__["NgZone"]);
        return new Promise(function (resolve, reject) {
            zone.onError.subscribe(function (errorInfo) { return reject(errorInfo); });
            appRef.isStable.first(function (isStable) { return isStable; }).subscribe(function () {
                // Because 'onStable' fires before 'onError', we have to delay slightly before
                // completing the request in case there's an error to report
                setImmediate(function () {
                    resolve({
                        html: state.renderToString()
                    });
                    moduleRef.destroy();
                });
            });
        });
    });
}));


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(97)(undefined);
// imports


// module
exports.push([module.i, "", ""]);

// exports


/***/ }),
/* 137 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 138 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 139 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 140 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 141 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 142 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 143 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 144 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 145 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 146 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 147 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 148 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 149 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 150 */
/***/ (function(module, exports) {

module.exports = "<router-outlet></router-outlet>\r\n";

/***/ }),
/* 151 */
/***/ (function(module, exports) {

module.exports = "<div style=\"height: 600px;\">\r\n    <h1 class=\"align-middle text-center\">\r\n        This feature is in develop process. Back off.\r\n    </h1>\r\n</div>";

/***/ }),
/* 152 */
/***/ (function(module, exports) {

module.exports = "<div class=\"hures-container\">\r\n    <h5 class=\"text-center m-2\">{{title}}</h5>\r\n    <div *ngIf=\"jobs$ | async; let jobs; else waiting\" class=\"d-flex flex-column\">\r\n        <ng-container *ngFor=\"let job of jobs;let i=index\">\r\n            <hure-job *ngIf=\"i<limit\" [job]=\"job\" class=\"m-1\" [size]=\"size\"></hure-job>\r\n            <hr *ngIf=\"i<jobs.length-1 && i<limit-1\" style=\"width:100%;\">\r\n        </ng-container>\r\n    </div>\r\n    <ng-template #waiting>\r\n        <hure-waiter></hure-waiter>\r\n    </ng-template>\r\n</div>";

/***/ }),
/* 153 */
/***/ (function(module, exports) {

module.exports = "<div class=\"d-flex justify-content-center hures-menu-item\">\r\n    <button (click)=\"item.action()\" class=\"hures-menu-button\" rippleEffect>\r\n        <span class=\"text-size\">\r\n\r\n            <i class=\"{{ item.iconClass }}\"></i> {{ item.text }}</span>\r\n    </button>\r\n</div>";

/***/ }),
/* 154 */
/***/ (function(module, exports) {

module.exports = "<div class=\"d-flex justify-content-center hures-menu\">\r\n    <ng-container *ngFor=\"let item of items; let i=index\">\r\n        <hure-action-item [item]=\"item\"></hure-action-item>\r\n    </ng-container>\r\n</div>";

/***/ }),
/* 155 */
/***/ (function(module, exports) {

module.exports = "<div class=\"blog-component\">\r\n    <div class=\"cs-blog\">\r\n        <div class=\"cs-media\">\r\n            <figure>\r\n                <a href=\"{{link}}\" title=\"\">\r\n                    <img alt=\"\" src=\"{{image}}\">\r\n                </a>\r\n            </figure>\r\n        </div>\r\n        <div class=\"blog-text\">\r\n            <div class=\"cs-inner-bolg\">\r\n                <div class=\"post-option\">\r\n                    <span class=\"post-date\">\r\n                        <a href=\"{{linktotime}}\">\r\n                            {{time}}\r\n                        </a>\r\n                    </span>\r\n                    <a href=\"{{linktotime}}\">\r\n                    <span class=\"post-comment\">\r\n                        </span>\r\n                    </a>\r\n                    <a href=\"{{linkcomment}}\">\r\n                        {{comment}}\r\n                    </a>\r\n                </div>\r\n                <div class=\"cs-post-title\">\r\n                    <h5>\r\n                        <a href=\"{{link}}\" title=\"Candidates for This Position Should Love Producing\">\r\n                            {{title}}\r\n                        </a>\r\n                    </h5>\r\n                    <p> \r\n                        {{content}}\r\n                    </p>\r\n                    <a href=\"{{link}}g/\" class=\"read-more\">\r\n                        Read More\r\n                    </a>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>";

/***/ }),
/* 156 */
/***/ (function(module, exports) {

module.exports = "<div class=\"hures-event-card\">\r\n  <div class=\"checktime\">CHA BIT @@</div>\r\n  <a href=\"#\" class=\"hures-event-img\">\r\n    <img alt=\"logo\" src=\"https://static.topcv.vn/event/images/7cc2b33becb3fd4c82b85e26a368e9b6-5a37ee89e176c.jpg\" class=\"imgne\"\r\n    />\r\n    <div class=\"img-hover\"></div>\r\n  </a>\r\n  <div class=\"hures-event-relative\">\r\n    <div class=\"hures-event-button\">\r\n      <div class=\"label\">TH LOI</div>\r\n    </div>\r\n    <div href=\"#\" class=\"hures-event-name\"><a href=\"#\">{{ event?.name }}</a></div>\r\n    <hr>\r\n    <div class=\"hures-event-region\">\r\n\r\n      <div class=\"hures-event-region-place\">\r\n        <i class=\"fa fa-map-marker\"></i> {{ event?.place }}</div>\r\n      <div class=\"hures-event-region-date\">\r\n        <i class=\"fa fa-calendar\"></i> Hn cht: {{ event?.endTime | date : format }}</div>\r\n\r\n\r\n    </div>\r\n\r\n\r\n  </div>\r\n</div>";

/***/ }),
/* 157 */
/***/ (function(module, exports) {

module.exports = "<div class=\"container\">\r\n    <div class=\"app-carousel\">\r\n        <ul class=\"slides row\" >\r\n            <li [@itemDis]=\"item.state\" *ngFor=\"let item of listItem\"   class=\"app-carousel-img-container col-12 col-sm-4 col-md-3 col-xl-2\">\r\n                <a [href]=\"item?.url\" >\r\n                    <img [src]=\"item?.img\" alt=\"{{ item?.text }}\">\r\n                </a>\r\n            </li>\r\n        </ul>\r\n    </div>\r\n</div>";

/***/ }),
/* 158 */
/***/ (function(module, exports) {

module.exports = "<div class=\"w-100 hures-dropdown-container\">\r\n    <div class=\"hures-dropdown w-100\" (click)=\"isActivated=!isActivated\">\r\n        <p>{{ selectItem.text || placeholder | limitText:25 }}</p>\r\n    </div>\r\n    <hure-overlay [isActivated]=\"isActivated\">\r\n        <div class=\"hures-picker\">\r\n            <div class=\"h-100\" style=\"padding:8px\">\r\n                <div class=\"hures-picker-items\" style=\"overflow-y:auto; overflow-x:hidden;\">\r\n                    <ng-content></ng-content>\r\n                </div>\r\n                <button class=\"hures-dropdown-close-btn\" (click)=\"isActivated=!isActivated\" rippleEffect>Close</button>\r\n            </div>\r\n        </div>\r\n    </hure-overlay>\r\n</div>";

/***/ }),
/* 159 */
/***/ (function(module, exports) {

module.exports = "<a class=\"dropdown-item\" (click)=\"selectItem()\" style=\"cursor:pointer;\" >\r\n    {{text | limitText: 30}}\r\n</a>";

/***/ }),
/* 160 */
/***/ (function(module, exports) {

module.exports = "<div class=\"card app-card-container\" >\r\n    <div [@expandChanged]=\"isExpanded\" class=\"card-body app-card\">\r\n        <ng-content></ng-content>\r\n    </div>\r\n    <button class=\"text-capitalize\" (click)=\"isExpanded=!isExpanded\" rippleEffect> {{ isExpanded?'Collapse':'See more' }}</button>\r\n</div>";

/***/ }),
/* 161 */
/***/ (function(module, exports) {

module.exports = "<!--<div class=\"col-md-3\">-->\r\n<div class=\"group-component\">\r\n  <div class=\"row\" style=\"padding: 5px; text-align: center;align-items: center;\">\r\n    \r\n    <!--<div class=\"col-md-6\">-->\r\n      <a href=\"link\" class=\"img-position\">\r\n        <img [src]=\"image\" alt=\"\" style=\"width: 64px; height: 64px;\">\r\n      </a>\r\n    <!--</div>-->\r\n    <!--<div class=\"col-md-6\">-->\r\n      <strong class=\"text-position\">{{text}}</strong>\r\n    <!--</div>-->\r\n  </div>\r\n</div>\r\n<!--</div>-->\r\n<!--<div class=\"group-component\">\r\n  <div class=\"cs-media\">\r\n    <figure>\r\n      <a href=\"link\">\r\n        <img [src]=\"image\" alt=\"\">\r\n      </a>\r\n    </figure>\r\n  </div>\r\n  <div class=\"cs-text\" style=\"text-align: center\">\r\n    <a href=\"link\">\r\n\r\n    </a>\r\n  </div>\r\n</div>-->";

/***/ }),
/* 162 */
/***/ (function(module, exports) {

module.exports = "<div *ngIf=\"size=='medium'\" class=\"hures-job-card d-flex flex-row align-content-stretch\" id=\"hures-job-card\">\r\n  <img alt=\"logo\" [src]=\"job.company.urlLogo\" />\r\n  <div class=\"hures-job-content\">\r\n    <div class=\"d-flex-column\">\r\n      <h4 class=\"card-text text-uppercase\">{{ job?.title }}</h4>\r\n      <div class=\"d-flex flex-row unflexxx\">\r\n        <div class=\"d-flex flex-column hures-job-info\">\r\n          <p>{{ job?.shortDescription | limitText:39}}</p>\r\n          <span>\r\n            <i class=\"fa fa-map-marker\"></i> {{ job?.place }}</span>\r\n        </div>\r\n        <div class=\"float-right\">\r\n          <button class=\"hures-job-apply-button\" rippleEffect (click)=\"apply()\">Np n</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n<div *ngIf=\"size=='small'\">\r\n  <div class=\"hures-job-content-small\">\r\n    <div>\r\n      <p class=\"card-text text-uppercase\">{{ job?.title }}</p>\r\n      <button class=\"hures-job-apply-button\" rippleEffect (click)=\"apply()\">Chi tit</button>\r\n    </div>\r\n  </div>\r\n</div>";

/***/ }),
/* 163 */
/***/ (function(module, exports) {

module.exports = "<div *ngIf=\"isActivated\">\r\n  <div class=\"hures-overlay\">\r\n    <div class=\"hures-overlay-container\">\r\n      <ng-content></ng-content>\r\n    </div>\r\n  </div>\r\n</div>";

/***/ }),
/* 164 */
/***/ (function(module, exports) {

module.exports = "<div class=\"hures-popover-container align-middle\">\r\n    <div (click)=\"change()\" class=\"hures-popover-button\">\r\n        <ng-content select=\"[button]\" >\r\n    \r\n        </ng-content>\r\n    </div>\r\n    <div [@menuChanged]=\"state\" class=\"popover bs-popover-bottom bs-popover-bottom-docs app-popover\" #popover \r\n    (clickOutside)=\"closeIt()\">\r\n        <div class=\"popover-body\">\r\n            <ng-content select=\"[popover]\"></ng-content>\r\n        </div>\r\n    </div>\r\n</div>";

/***/ }),
/* 165 */
/***/ (function(module, exports) {

module.exports = "<div class=\"d-flex justify-content-center\">\r\n    <a *ngFor=\"let i of range(max)\" (click)=\"selectStar(i)\" > \r\n        <span><i class=\"fa\" [class.fa-star]=\"i<=rating\" [class.fa-star-o]=\"i>rating\" style=\"font-size:2em;\"\r\n            [style.color.yellow]=\"i<=rating\" [style.color.black]=\"i>rating\"></i></span>    \r\n    </a>\r\n</div>\r\n<h1 class=\"text-center\">{{ textRating[rating-1] }}</h1> ";

/***/ }),
/* 166 */
/***/ (function(module, exports) {

module.exports = "<div [@tabChanged] *ngIf=\"isActivated\" class=\"carousel-item active\" >\r\n    <ng-content></ng-content>\r\n</div>";

/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = "<ul class=\"nav justify-content-center\">\r\n    <li *ngFor=\"let tab of tabs\" class=\"nav-item\" (click)=\"selectTab(tab)\">\r\n        <a class=\"nav-link\" [class.active]=\"tab.isActivated\">{{tab.title}}</a>\r\n    </li>\r\n</ul>\r\n<div class=\"carousel slide tabbed\" [style.height.px]=\"height\">\r\n    <div class=\"carousel-inner\">\r\n        <ng-content></ng-content>\r\n    </div>\r\n</div>";

/***/ }),
/* 168 */
/***/ (function(module, exports) {

module.exports = "<div class=\"hures-waiter\" tabindex=\"-1\" role=\"dialog\">\r\n    <div id=\"loader\">\r\n        <div id=\"shadow\"></div>\r\n        <div id=\"box\"></div>\r\n    </div>\r\n</div>";

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var OpenElementStack = __webpack_require__(55),
    Tokenizer = __webpack_require__(21),
    HTML = __webpack_require__(10);


//Aliases
var $ = HTML.TAG_NAMES;

exports.assign = function (parser) {
    //NOTE: obtain Parser proto this way to avoid module circular references
    var parserProto = Object.getPrototypeOf(parser),
        treeAdapter = parser.treeAdapter,
        attachableElementLocation = null,
        lastFosterParentingLocation = null,
        currentToken = null;

    function setEndLocation(element, closingToken) {
        var loc = element.__location;

        if (!loc)
            return;

        if (!loc.startTag) {
            loc.startTag = {
                line: loc.line,
                col: loc.col,
                startOffset: loc.startOffset,
                endOffset: loc.endOffset
            };

            if (loc.attrs)
                loc.startTag.attrs = loc.attrs;
        }

        if (closingToken.location) {
            var ctLocation = closingToken.location,
                tn = treeAdapter.getTagName(element),
            // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing tag and
            // for cases like <td> <p> </td> - 'p' closes without a closing tag
                isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN &&
                                  tn === closingToken.tagName;

            if (isClosingEndTag) {
                loc.endTag = {
                    line: ctLocation.line,
                    col: ctLocation.col,
                    startOffset: ctLocation.startOffset,
                    endOffset: ctLocation.endOffset
                };
            }

            if (isClosingEndTag)
                loc.endOffset = ctLocation.endOffset;
            else
                loc.endOffset = ctLocation.startOffset;
        }

        else if (closingToken.type === Tokenizer.EOF_TOKEN)
            loc.endOffset = parser.tokenizer.preprocessor.sourcePos;
    }

    //NOTE: patch _bootstrap method
    parser._bootstrap = function (document, fragmentContext) {
        parserProto._bootstrap.call(this, document, fragmentContext);

        attachableElementLocation = null;
        lastFosterParentingLocation = null;
        currentToken = null;

        //OpenElementStack
        parser.openElements.pop = function () {
            setEndLocation(this.current, currentToken);
            OpenElementStack.prototype.pop.call(this);
        };

        parser.openElements.popAllUpToHtmlElement = function () {
            for (var i = this.stackTop; i > 0; i--)
                setEndLocation(this.items[i], currentToken);

            OpenElementStack.prototype.popAllUpToHtmlElement.call(this);
        };

        parser.openElements.remove = function (element) {
            setEndLocation(element, currentToken);
            OpenElementStack.prototype.remove.call(this, element);
        };
    };

    parser._runParsingLoop = function (scriptHandler) {
        parserProto._runParsingLoop.call(this, scriptHandler);

        // NOTE: generate location info for elements
        // that remains on open element stack
        for (var i = parser.openElements.stackTop; i >= 0; i--)
            setEndLocation(parser.openElements.items[i], currentToken);
    };


    //Token processing
    parser._processTokenInForeignContent = function (token) {
        currentToken = token;
        parserProto._processTokenInForeignContent.call(this, token);
    };

    parser._processToken = function (token) {
        currentToken = token;
        parserProto._processToken.call(this, token);

        //NOTE: <body> and <html> are never popped from the stack, so we need to updated
        //their end location explicitly.
        if (token.type === Tokenizer.END_TAG_TOKEN &&
            (token.tagName === $.HTML ||
             token.tagName === $.BODY && this.openElements.hasInScope($.BODY))) {
            for (var i = this.openElements.stackTop; i >= 0; i--) {
                var element = this.openElements.items[i];

                if (this.treeAdapter.getTagName(element) === token.tagName) {
                    setEndLocation(element, token);
                    break;
                }
            }
        }
    };


    //Doctype
    parser._setDocumentType = function (token) {
        parserProto._setDocumentType.call(this, token);

        var documentChildren = this.treeAdapter.getChildNodes(this.document),
            cnLength = documentChildren.length;

        for (var i = 0; i < cnLength; i++) {
            var node = documentChildren[i];

            if (this.treeAdapter.isDocumentTypeNode(node)) {
                node.__location = token.location;
                break;
            }
        }
    };


    //Elements
    parser._attachElementToTree = function (element) {
        //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.
        //So we will use token location stored in this methods for the element.
        element.__location = attachableElementLocation || null;
        attachableElementLocation = null;
        parserProto._attachElementToTree.call(this, element);
    };

    parser._appendElement = function (token, namespaceURI) {
        attachableElementLocation = token.location;
        parserProto._appendElement.call(this, token, namespaceURI);
    };

    parser._insertElement = function (token, namespaceURI) {
        attachableElementLocation = token.location;
        parserProto._insertElement.call(this, token, namespaceURI);
    };

    parser._insertTemplate = function (token) {
        attachableElementLocation = token.location;
        parserProto._insertTemplate.call(this, token);

        var tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);

        tmplContent.__location = null;
    };

    parser._insertFakeRootElement = function () {
        parserProto._insertFakeRootElement.call(this);
        this.openElements.current.__location = null;
    };


    //Comments
    parser._appendCommentNode = function (token, parent) {
        parserProto._appendCommentNode.call(this, token, parent);

        var children = this.treeAdapter.getChildNodes(parent),
            commentNode = children[children.length - 1];

        commentNode.__location = token.location;
    };


    //Text
    parser._findFosterParentingLocation = function () {
        //NOTE: store last foster parenting location, so we will be able to find inserted text
        //in case of foster parenting
        lastFosterParentingLocation = parserProto._findFosterParentingLocation.call(this);
        return lastFosterParentingLocation;
    };

    parser._insertCharacters = function (token) {
        parserProto._insertCharacters.call(this, token);

        var hasFosterParent = this._shouldFosterParentOnInsertion(),
            parent = hasFosterParent && lastFosterParentingLocation.parent ||
                     this.openElements.currentTmplContent ||
                     this.openElements.current,
            siblings = this.treeAdapter.getChildNodes(parent),
            textNodeIdx = hasFosterParent && lastFosterParentingLocation.beforeElement ?
            siblings.indexOf(lastFosterParentingLocation.beforeElement) - 1 :
            siblings.length - 1,
            textNode = siblings[textNodeIdx];

        //NOTE: if we have location assigned by another token, then just update end position
        if (textNode.__location)
            textNode.__location.endOffset = token.location.endOffset;

        else
            textNode.__location = token.location;
    };
};



/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var UNICODE = __webpack_require__(20);

//Aliases
var $ = UNICODE.CODE_POINTS;


exports.assign = function (tokenizer) {
    //NOTE: obtain Tokenizer proto this way to avoid module circular references
    var tokenizerProto = Object.getPrototypeOf(tokenizer),
        tokenStartOffset = -1,
        tokenCol = -1,
        tokenLine = 1,
        isEol = false,
        lineStartPos = 0,
        col = -1,
        line = 1;

    function attachLocationInfo(token) {
        token.location = {
            line: tokenLine,
            col: tokenCol,
            startOffset: tokenStartOffset,
            endOffset: -1
        };
    }

    //NOTE: patch consumption method to track line/col information
    tokenizer._consume = function () {
        var cp = tokenizerProto._consume.call(this);

        //NOTE: LF should be in the last column of the line
        if (isEol) {
            isEol = false;
            line++;
            lineStartPos = this.preprocessor.sourcePos;
        }

        if (cp === $.LINE_FEED)
            isEol = true;

        col = this.preprocessor.sourcePos - lineStartPos + 1;

        return cp;
    };

    tokenizer._unconsume = function () {
        tokenizerProto._unconsume.call(this);
        isEol = false;

        col = this.preprocessor.sourcePos - lineStartPos + 1;
    };

    //NOTE: patch token creation methods and attach location objects
    tokenizer._createStartTagToken = function () {
        tokenizerProto._createStartTagToken.call(this);
        attachLocationInfo(this.currentToken);
    };

    tokenizer._createEndTagToken = function () {
        tokenizerProto._createEndTagToken.call(this);
        attachLocationInfo(this.currentToken);
    };

    tokenizer._createCommentToken = function () {
        tokenizerProto._createCommentToken.call(this);
        attachLocationInfo(this.currentToken);
    };

    tokenizer._createDoctypeToken = function (initialName) {
        tokenizerProto._createDoctypeToken.call(this, initialName);
        attachLocationInfo(this.currentToken);
    };

    tokenizer._createCharacterToken = function (type, ch) {
        tokenizerProto._createCharacterToken.call(this, type, ch);
        attachLocationInfo(this.currentCharacterToken);
    };

    tokenizer._createAttr = function (attrNameFirstCh) {
        tokenizerProto._createAttr.call(this, attrNameFirstCh);
        this.currentAttrLocation = {
            line: line,
            col: col,
            startOffset: this.preprocessor.sourcePos,
            endOffset: -1
        };
    };

    tokenizer._leaveAttrName = function (toState) {
        tokenizerProto._leaveAttrName.call(this, toState);
        this._attachCurrentAttrLocationInfo();
    };

    tokenizer._leaveAttrValue = function (toState) {
        tokenizerProto._leaveAttrValue.call(this, toState);
        this._attachCurrentAttrLocationInfo();
    };

    tokenizer._attachCurrentAttrLocationInfo = function () {
        this.currentAttrLocation.endOffset = this.preprocessor.sourcePos;

        if (!this.currentToken.location.attrs)
            this.currentToken.location.attrs = Object.create(null);

        this.currentToken.location.attrs[this.currentAttr.name] = this.currentAttrLocation;
    };

    //NOTE: patch token emission methods to determine end location
    tokenizer._emitCurrentToken = function () {
        //NOTE: if we have pending character token make it's end location equal to the
        //current token's start location.
        if (this.currentCharacterToken)
            this.currentCharacterToken.location.endOffset = this.currentToken.location.startOffset;

        this.currentToken.location.endOffset = this.preprocessor.sourcePos + 1;
        tokenizerProto._emitCurrentToken.call(this);
    };

    tokenizer._emitCurrentCharacterToken = function () {
        //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),
        //then set it's location at the current preprocessor position.
        //We don't need to increment preprocessor position, since character token
        //emission is always forced by the start of the next character token here.
        //So, we already have advanced position.
        if (this.currentCharacterToken && this.currentCharacterToken.location.endOffset === -1)
            this.currentCharacterToken.location.endOffset = this.preprocessor.sourcePos;

        tokenizerProto._emitCurrentCharacterToken.call(this);
    };

    //NOTE: patch initial states for each mode to obtain token start position
    Object.keys(tokenizerProto.MODE)

        .map(function (modeName) {
            return tokenizerProto.MODE[modeName];
        })

        .forEach(function (state) {
            tokenizer[state] = function (cp) {
                tokenStartOffset = this.preprocessor.sourcePos;
                tokenLine = line;
                tokenCol = col;
                tokenizerProto[state].call(this, cp);
            };
        });
};


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//Const
var NOAH_ARK_CAPACITY = 3;

//List of formatting elements
var FormattingElementList = module.exports = function (treeAdapter) {
    this.length = 0;
    this.entries = [];
    this.treeAdapter = treeAdapter;
    this.bookmark = null;
};

//Entry types
FormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';
FormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';

//Noah Ark's condition
//OPTIMIZATION: at first we try to find possible candidates for exclusion using
//lightweight heuristics without thorough attributes check.
FormattingElementList.prototype._getNoahArkConditionCandidates = function (newElement) {
    var candidates = [];

    if (this.length >= NOAH_ARK_CAPACITY) {
        var neAttrsLength = this.treeAdapter.getAttrList(newElement).length,
            neTagName = this.treeAdapter.getTagName(newElement),
            neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);

        for (var i = this.length - 1; i >= 0; i--) {
            var entry = this.entries[i];

            if (entry.type === FormattingElementList.MARKER_ENTRY)
                break;

            var element = entry.element,
                elementAttrs = this.treeAdapter.getAttrList(element),
                isCandidate = this.treeAdapter.getTagName(element) === neTagName &&
                              this.treeAdapter.getNamespaceURI(element) === neNamespaceURI &&
                              elementAttrs.length === neAttrsLength;

            if (isCandidate)
                candidates.push({idx: i, attrs: elementAttrs});
        }
    }

    return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;
};

FormattingElementList.prototype._ensureNoahArkCondition = function (newElement) {
    var candidates = this._getNoahArkConditionCandidates(newElement),
        cLength = candidates.length;

    if (cLength) {
        var neAttrs = this.treeAdapter.getAttrList(newElement),
            neAttrsLength = neAttrs.length,
            neAttrsMap = Object.create(null);

        //NOTE: build attrs map for the new element so we can perform fast lookups
        for (var i = 0; i < neAttrsLength; i++) {
            var neAttr = neAttrs[i];

            neAttrsMap[neAttr.name] = neAttr.value;
        }

        for (i = 0; i < neAttrsLength; i++) {
            for (var j = 0; j < cLength; j++) {
                var cAttr = candidates[j].attrs[i];

                if (neAttrsMap[cAttr.name] !== cAttr.value) {
                    candidates.splice(j, 1);
                    cLength--;
                }

                if (candidates.length < NOAH_ARK_CAPACITY)
                    return;
            }
        }

        //NOTE: remove bottommost candidates until Noah's Ark condition will not be met
        for (i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {
            this.entries.splice(candidates[i].idx, 1);
            this.length--;
        }
    }
};

//Mutations
FormattingElementList.prototype.insertMarker = function () {
    this.entries.push({type: FormattingElementList.MARKER_ENTRY});
    this.length++;
};

FormattingElementList.prototype.pushElement = function (element, token) {
    this._ensureNoahArkCondition(element);

    this.entries.push({
        type: FormattingElementList.ELEMENT_ENTRY,
        element: element,
        token: token
    });

    this.length++;
};

FormattingElementList.prototype.insertElementAfterBookmark = function (element, token) {
    var bookmarkIdx = this.length - 1;

    for (; bookmarkIdx >= 0; bookmarkIdx--) {
        if (this.entries[bookmarkIdx] === this.bookmark)
            break;
    }

    this.entries.splice(bookmarkIdx + 1, 0, {
        type: FormattingElementList.ELEMENT_ENTRY,
        element: element,
        token: token
    });

    this.length++;
};

FormattingElementList.prototype.removeEntry = function (entry) {
    for (var i = this.length - 1; i >= 0; i--) {
        if (this.entries[i] === entry) {
            this.entries.splice(i, 1);
            this.length--;
            break;
        }
    }
};

FormattingElementList.prototype.clearToLastMarker = function () {
    while (this.length) {
        var entry = this.entries.pop();

        this.length--;

        if (entry.type === FormattingElementList.MARKER_ENTRY)
            break;
    }
};

//Search
FormattingElementList.prototype.getElementEntryInScopeWithTagName = function (tagName) {
    for (var i = this.length - 1; i >= 0; i--) {
        var entry = this.entries[i];

        if (entry.type === FormattingElementList.MARKER_ENTRY)
            return null;

        if (this.treeAdapter.getTagName(entry.element) === tagName)
            return entry;
    }

    return null;
};

FormattingElementList.prototype.getElementEntry = function (element) {
    for (var i = this.length - 1; i >= 0; i--) {
        var entry = this.entries[i];

        if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element)
            return entry;
    }

    return null;
};


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ParserStream = __webpack_require__(56),
    inherits = __webpack_require__(24).inherits,
    $ = __webpack_require__(10).TAG_NAMES;

var PlainTextConversionStream = module.exports = function (options) {
    ParserStream.call(this, options);

    // NOTE: see https://html.spec.whatwg.org/#read-text
    this.parser._insertFakeElement($.HTML);
    this.parser._insertFakeElement($.HEAD);
    this.parser.openElements.pop();
    this.parser._insertFakeElement($.BODY);
    this.parser._insertFakeElement($.PRE);
    this.parser.treeAdapter.insertText(this.parser.openElements.current, '\n');
    this.parser.switchToPlaintextParsing();
};

inherits(PlainTextConversionStream, ParserStream);


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var WritableStream = __webpack_require__(28).Writable,
    util = __webpack_require__(24);

var DevNullStream = module.exports = function () {
    WritableStream.call(this);
};

util.inherits(DevNullStream, WritableStream);

DevNullStream.prototype._write = function (chunk, encoding, cb) {
    cb();
};


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var TransformStream = __webpack_require__(28).Transform,
    DevNullStream = __webpack_require__(173),
    inherits = __webpack_require__(24).inherits,
    Tokenizer = __webpack_require__(21),
    ParserFeedbackSimulator = __webpack_require__(175),
    mergeOptions = __webpack_require__(31);

var DEFAULT_OPTIONS = {
    locationInfo: false
};

var SAXParser = module.exports = function (options) {
    TransformStream.call(this);

    this.options = mergeOptions(DEFAULT_OPTIONS, options);

    this.tokenizer = new Tokenizer(options);
    this.parserFeedbackSimulator = new ParserFeedbackSimulator(this.tokenizer);

    this.pendingText = null;
    this.currentTokenLocation = void 0;

    this.lastChunkWritten = false;
    this.stopped = false;

    // NOTE: always pipe stream to the /dev/null stream to avoid
    // `highWaterMark` hit even if we don't have consumers.
    // (see: https://github.com/inikulin/parse5/issues/97#issuecomment-171940774)
    this.pipe(new DevNullStream());
};

inherits(SAXParser, TransformStream);

//TransformStream implementation
SAXParser.prototype._transform = function (chunk, encoding, callback) {
    if (!this.stopped) {
        this.tokenizer.write(chunk.toString('utf8'), this.lastChunkWritten);
        this._runParsingLoop();
    }

    this.push(chunk);

    callback();
};

SAXParser.prototype._flush = function (callback) {
    callback();
};

SAXParser.prototype.end = function (chunk, encoding, callback) {
    this.lastChunkWritten = true;
    TransformStream.prototype.end.call(this, chunk, encoding, callback);
};

SAXParser.prototype.stop = function () {
    this.stopped = true;
};

//Internals
SAXParser.prototype._runParsingLoop = function () {
    do {
        var token = this.parserFeedbackSimulator.getNextToken();

        if (token.type === Tokenizer.HIBERNATION_TOKEN)
            break;

        if (token.type === Tokenizer.CHARACTER_TOKEN ||
            token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN ||
            token.type === Tokenizer.NULL_CHARACTER_TOKEN) {

            if (this.options.locationInfo) {
                if (this.pendingText === null)
                    this.currentTokenLocation = token.location;

                else
                    this.currentTokenLocation.endOffset = token.location.endOffset;
            }

            this.pendingText = (this.pendingText || '') + token.chars;
        }

        else {
            this._emitPendingText();
            this._handleToken(token);
        }
    } while (!this.stopped && token.type !== Tokenizer.EOF_TOKEN);
};

SAXParser.prototype._handleToken = function (token) {
    if (this.options.locationInfo)
        this.currentTokenLocation = token.location;

    if (token.type === Tokenizer.START_TAG_TOKEN)
        this.emit('startTag', token.tagName, token.attrs, token.selfClosing, this.currentTokenLocation);

    else if (token.type === Tokenizer.END_TAG_TOKEN)
        this.emit('endTag', token.tagName, this.currentTokenLocation);

    else if (token.type === Tokenizer.COMMENT_TOKEN)
        this.emit('comment', token.data, this.currentTokenLocation);

    else if (token.type === Tokenizer.DOCTYPE_TOKEN)
        this.emit('doctype', token.name, token.publicId, token.systemId, this.currentTokenLocation);
};

SAXParser.prototype._emitPendingText = function () {
    if (this.pendingText !== null) {
        this.emit('text', this.pendingText, this.currentTokenLocation);
        this.pendingText = null;
    }
};


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Tokenizer = __webpack_require__(21),
    foreignContent = __webpack_require__(53),
    UNICODE = __webpack_require__(20),
    HTML = __webpack_require__(10);


//Aliases
var $ = HTML.TAG_NAMES,
    NS = HTML.NAMESPACES;


//ParserFeedbackSimulator
//Simulates adjustment of the Tokenizer which performed by standard parser during tree construction.
var ParserFeedbackSimulator = module.exports = function (tokenizer) {
    this.tokenizer = tokenizer;

    this.namespaceStack = [];
    this.namespaceStackTop = -1;
    this._enterNamespace(NS.HTML);
};

ParserFeedbackSimulator.prototype.getNextToken = function () {
    var token = this.tokenizer.getNextToken();

    if (token.type === Tokenizer.START_TAG_TOKEN)
        this._handleStartTagToken(token);

    else if (token.type === Tokenizer.END_TAG_TOKEN)
        this._handleEndTagToken(token);

    else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN && this.inForeignContent) {
        token.type = Tokenizer.CHARACTER_TOKEN;
        token.chars = UNICODE.REPLACEMENT_CHARACTER;
    }

    else if (this.skipNextNewLine) {
        if (token.type !== Tokenizer.HIBERNATION_TOKEN)
            this.skipNextNewLine = false;

        if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === '\n') {
            if (token.chars.length === 1)
                return this.getNextToken();

            token.chars = token.chars.substr(1);
        }
    }

    return token;
};

//Namespace stack mutations
ParserFeedbackSimulator.prototype._enterNamespace = function (namespace) {
    this.namespaceStackTop++;
    this.namespaceStack.push(namespace);

    this.inForeignContent = namespace !== NS.HTML;
    this.currentNamespace = namespace;
    this.tokenizer.allowCDATA = this.inForeignContent;
};

ParserFeedbackSimulator.prototype._leaveCurrentNamespace = function () {
    this.namespaceStackTop--;
    this.namespaceStack.pop();

    this.currentNamespace = this.namespaceStack[this.namespaceStackTop];
    this.inForeignContent = this.currentNamespace !== NS.HTML;
    this.tokenizer.allowCDATA = this.inForeignContent;
};

//Token handlers
ParserFeedbackSimulator.prototype._ensureTokenizerMode = function (tn) {
    if (tn === $.TEXTAREA || tn === $.TITLE)
        this.tokenizer.state = Tokenizer.MODE.RCDATA;

    else if (tn === $.PLAINTEXT)
        this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;

    else if (tn === $.SCRIPT)
        this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;

    else if (tn === $.STYLE || tn === $.IFRAME || tn === $.XMP ||
             tn === $.NOEMBED || tn === $.NOFRAMES || tn === $.NOSCRIPT)
        this.tokenizer.state = Tokenizer.MODE.RAWTEXT;
};

ParserFeedbackSimulator.prototype._handleStartTagToken = function (token) {
    var tn = token.tagName;

    if (tn === $.SVG)
        this._enterNamespace(NS.SVG);

    else if (tn === $.MATH)
        this._enterNamespace(NS.MATHML);

    if (this.inForeignContent) {
        if (foreignContent.causesExit(token)) {
            this._leaveCurrentNamespace();
            return;
        }

        var currentNs = this.currentNamespace;

        if (currentNs === NS.MATHML)
            foreignContent.adjustTokenMathMLAttrs(token);

        else if (currentNs === NS.SVG) {
            foreignContent.adjustTokenSVGTagName(token);
            foreignContent.adjustTokenSVGAttrs(token);
        }

        foreignContent.adjustTokenXMLAttrs(token);

        tn = token.tagName;

        if (!token.selfClosing && foreignContent.isIntegrationPoint(tn, currentNs, token.attrs))
            this._enterNamespace(NS.HTML);
    }

    else {
        if (tn === $.PRE || tn === $.TEXTAREA || tn === $.LISTING)
            this.skipNextNewLine = true;

        else if (tn === $.IMAGE)
            token.tagName = $.IMG;

        this._ensureTokenizerMode(tn);
    }
};

ParserFeedbackSimulator.prototype._handleEndTagToken = function (token) {
    var tn = token.tagName;

    if (!this.inForeignContent) {
        var previousNs = this.namespaceStack[this.namespaceStackTop - 1];

        if (previousNs === NS.SVG && foreignContent.SVG_TAG_NAMES_ADJUSTMENT_MAP[tn])
            tn = foreignContent.SVG_TAG_NAMES_ADJUSTMENT_MAP[tn];

        //NOTE: check for exit from integration point
        if (foreignContent.isIntegrationPoint(tn, previousNs, token.attrs))
            this._leaveCurrentNamespace();
    }

    else if (tn === $.SVG && this.currentNamespace === NS.SVG ||
             tn === $.MATH && this.currentNamespace === NS.MATHML)
        this._leaveCurrentNamespace();

    // NOTE: adjust end tag name as well for consistency
    if (this.currentNamespace === NS.SVG)
        foreignContent.adjustTokenSVGTagName(token);
};


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ReadableStream = __webpack_require__(28).Readable,
    inherits = __webpack_require__(24).inherits,
    Serializer = __webpack_require__(57);

var SerializerStream = module.exports = function (node, options) {
    ReadableStream.call(this);

    this.serializer = new Serializer(node, options);

    Object.defineProperty(this.serializer, 'html', {
        //NOTE: To make `+=` concat operator work properly we define
        //getter which always returns empty string
        get: function () {
            return '';
        },
        set: this.push.bind(this)
    });
};

inherits(SerializerStream, ReadableStream);

//Readable stream implementation
SerializerStream.prototype._read = function () {
    this.serializer.serialize();
    this.push(null);
};


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//NOTE: this file contains auto-generated array mapped radix tree that is used for the named entity references consumption
//(details: https://github.com/inikulin/parse5/tree/master/scripts/generate_named_entity_data/README.md)
module.exports = new Uint16Array([4,52,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,106,303,412,810,1432,1701,1796,1987,2114,2360,2420,2484,3170,3251,4140,4393,4575,4610,5106,5512,5728,6117,6274,6315,6345,6427,6516,7002,7910,8733,9323,9870,10170,10631,10893,11318,11386,11467,12773,13092,14474,14922,15448,15542,16419,17666,18166,18611,19004,19095,19298,19397,4,16,69,77,97,98,99,102,103,108,109,110,111,112,114,115,116,117,140,150,158,169,176,194,199,210,216,222,226,242,256,266,283,294,108,105,103,5,198,1,59,148,1,198,80,5,38,1,59,156,1,38,99,117,116,101,5,193,1,59,167,1,193,114,101,118,101,59,1,258,4,2,105,121,182,191,114,99,5,194,1,59,189,1,194,59,1,1040,114,59,3,55349,56580,114,97,118,101,5,192,1,59,208,1,192,112,104,97,59,1,913,97,99,114,59,1,256,100,59,1,10835,4,2,103,112,232,237,111,110,59,1,260,102,59,3,55349,56632,112,108,121,70,117,110,99,116,105,111,110,59,1,8289,105,110,103,5,197,1,59,264,1,197,4,2,99,115,272,277,114,59,3,55349,56476,105,103,110,59,1,8788,105,108,100,101,5,195,1,59,292,1,195,109,108,5,196,1,59,301,1,196,4,8,97,99,101,102,111,114,115,117,321,350,354,383,388,394,400,405,4,2,99,114,327,336,107,115,108,97,115,104,59,1,8726,4,2,118,119,342,345,59,1,10983,101,100,59,1,8966,121,59,1,1041,4,3,99,114,116,362,369,379,97,117,115,101,59,1,8757,110,111,117,108,108,105,115,59,1,8492,97,59,1,914,114,59,3,55349,56581,112,102,59,3,55349,56633,101,118,101,59,1,728,99,114,59,1,8492,109,112,101,113,59,1,8782,4,14,72,79,97,99,100,101,102,104,105,108,111,114,115,117,442,447,456,504,542,547,569,573,577,616,678,784,790,796,99,121,59,1,1063,80,89,5,169,1,59,454,1,169,4,3,99,112,121,464,470,497,117,116,101,59,1,262,4,2,59,105,476,478,1,8914,116,97,108,68,105,102,102,101,114,101,110,116,105,97,108,68,59,1,8517,108,101,121,115,59,1,8493,4,4,97,101,105,111,514,520,530,535,114,111,110,59,1,268,100,105,108,5,199,1,59,528,1,199,114,99,59,1,264,110,105,110,116,59,1,8752,111,116,59,1,266,4,2,100,110,553,560,105,108,108,97,59,1,184,116,101,114,68,111,116,59,1,183,114,59,1,8493,105,59,1,935,114,99,108,101,4,4,68,77,80,84,591,596,603,609,111,116,59,1,8857,105,110,117,115,59,1,8854,108,117,115,59,1,8853,105,109,101,115,59,1,8855,111,4,2,99,115,623,646,107,119,105,115,101,67,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8754,101,67,117,114,108,121,4,2,68,81,658,671,111,117,98,108,101,81,117,111,116,101,59,1,8221,117,111,116,101,59,1,8217,4,4,108,110,112,117,688,701,736,753,111,110,4,2,59,101,696,698,1,8759,59,1,10868,4,3,103,105,116,709,717,722,114,117,101,110,116,59,1,8801,110,116,59,1,8751,111,117,114,73,110,116,101,103,114,97,108,59,1,8750,4,2,102,114,742,745,59,1,8450,111,100,117,99,116,59,1,8720,110,116,101,114,67,108,111,99,107,119,105,115,101,67,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8755,111,115,115,59,1,10799,99,114,59,3,55349,56478,112,4,2,59,67,803,805,1,8915,97,112,59,1,8781,4,11,68,74,83,90,97,99,101,102,105,111,115,834,850,855,860,865,888,903,916,921,1011,1415,4,2,59,111,840,842,1,8517,116,114,97,104,100,59,1,10513,99,121,59,1,1026,99,121,59,1,1029,99,121,59,1,1039,4,3,103,114,115,873,879,883,103,101,114,59,1,8225,114,59,1,8609,104,118,59,1,10980,4,2,97,121,894,900,114,111,110,59,1,270,59,1,1044,108,4,2,59,116,910,912,1,8711,97,59,1,916,114,59,3,55349,56583,4,2,97,102,927,998,4,2,99,109,933,992,114,105,116,105,99,97,108,4,4,65,68,71,84,950,957,978,985,99,117,116,101,59,1,180,111,4,2,116,117,964,967,59,1,729,98,108,101,65,99,117,116,101,59,1,733,114,97,118,101,59,1,96,105,108,100,101,59,1,732,111,110,100,59,1,8900,102,101,114,101,110,116,105,97,108,68,59,1,8518,4,4,112,116,117,119,1021,1026,1048,1249,102,59,3,55349,56635,4,3,59,68,69,1034,1036,1041,1,168,111,116,59,1,8412,113,117,97,108,59,1,8784,98,108,101,4,6,67,68,76,82,85,86,1065,1082,1101,1189,1211,1236,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8751,111,4,2,116,119,1089,1092,59,1,168,110,65,114,114,111,119,59,1,8659,4,2,101,111,1107,1141,102,116,4,3,65,82,84,1117,1124,1136,114,114,111,119,59,1,8656,105,103,104,116,65,114,114,111,119,59,1,8660,101,101,59,1,10980,110,103,4,2,76,82,1149,1177,101,102,116,4,2,65,82,1158,1165,114,114,111,119,59,1,10232,105,103,104,116,65,114,114,111,119,59,1,10234,105,103,104,116,65,114,114,111,119,59,1,10233,105,103,104,116,4,2,65,84,1199,1206,114,114,111,119,59,1,8658,101,101,59,1,8872,112,4,2,65,68,1218,1225,114,114,111,119,59,1,8657,111,119,110,65,114,114,111,119,59,1,8661,101,114,116,105,99,97,108,66,97,114,59,1,8741,110,4,6,65,66,76,82,84,97,1264,1292,1299,1352,1391,1408,114,114,111,119,4,3,59,66,85,1276,1278,1283,1,8595,97,114,59,1,10515,112,65,114,114,111,119,59,1,8693,114,101,118,101,59,1,785,101,102,116,4,3,82,84,86,1310,1323,1334,105,103,104,116,86,101,99,116,111,114,59,1,10576,101,101,86,101,99,116,111,114,59,1,10590,101,99,116,111,114,4,2,59,66,1345,1347,1,8637,97,114,59,1,10582,105,103,104,116,4,2,84,86,1362,1373,101,101,86,101,99,116,111,114,59,1,10591,101,99,116,111,114,4,2,59,66,1384,1386,1,8641,97,114,59,1,10583,101,101,4,2,59,65,1399,1401,1,8868,114,114,111,119,59,1,8615,114,114,111,119,59,1,8659,4,2,99,116,1421,1426,114,59,3,55349,56479,114,111,107,59,1,272,4,16,78,84,97,99,100,102,103,108,109,111,112,113,115,116,117,120,1466,1470,1478,1489,1515,1520,1525,1536,1544,1593,1609,1617,1650,1664,1668,1677,71,59,1,330,72,5,208,1,59,1476,1,208,99,117,116,101,5,201,1,59,1487,1,201,4,3,97,105,121,1497,1503,1512,114,111,110,59,1,282,114,99,5,202,1,59,1510,1,202,59,1,1069,111,116,59,1,278,114,59,3,55349,56584,114,97,118,101,5,200,1,59,1534,1,200,101,109,101,110,116,59,1,8712,4,2,97,112,1550,1555,99,114,59,1,274,116,121,4,2,83,86,1563,1576,109,97,108,108,83,113,117,97,114,101,59,1,9723,101,114,121,83,109,97,108,108,83,113,117,97,114,101,59,1,9643,4,2,103,112,1599,1604,111,110,59,1,280,102,59,3,55349,56636,115,105,108,111,110,59,1,917,117,4,2,97,105,1624,1640,108,4,2,59,84,1631,1633,1,10869,105,108,100,101,59,1,8770,108,105,98,114,105,117,109,59,1,8652,4,2,99,105,1656,1660,114,59,1,8496,109,59,1,10867,97,59,1,919,109,108,5,203,1,59,1675,1,203,4,2,105,112,1683,1689,115,116,115,59,1,8707,111,110,101,110,116,105,97,108,69,59,1,8519,4,5,99,102,105,111,115,1713,1717,1722,1762,1791,121,59,1,1060,114,59,3,55349,56585,108,108,101,100,4,2,83,86,1732,1745,109,97,108,108,83,113,117,97,114,101,59,1,9724,101,114,121,83,109,97,108,108,83,113,117,97,114,101,59,1,9642,4,3,112,114,117,1770,1775,1781,102,59,3,55349,56637,65,108,108,59,1,8704,114,105,101,114,116,114,102,59,1,8497,99,114,59,1,8497,4,12,74,84,97,98,99,100,102,103,111,114,115,116,1822,1827,1834,1848,1855,1877,1882,1887,1890,1896,1978,1984,99,121,59,1,1027,5,62,1,59,1832,1,62,109,109,97,4,2,59,100,1843,1845,1,915,59,1,988,114,101,118,101,59,1,286,4,3,101,105,121,1863,1869,1874,100,105,108,59,1,290,114,99,59,1,284,59,1,1043,111,116,59,1,288,114,59,3,55349,56586,59,1,8921,112,102,59,3,55349,56638,101,97,116,101,114,4,6,69,70,71,76,83,84,1915,1933,1944,1953,1959,1971,113,117,97,108,4,2,59,76,1925,1927,1,8805,101,115,115,59,1,8923,117,108,108,69,113,117,97,108,59,1,8807,114,101,97,116,101,114,59,1,10914,101,115,115,59,1,8823,108,97,110,116,69,113,117,97,108,59,1,10878,105,108,100,101,59,1,8819,99,114,59,3,55349,56482,59,1,8811,4,8,65,97,99,102,105,111,115,117,2005,2012,2026,2032,2036,2049,2073,2089,82,68,99,121,59,1,1066,4,2,99,116,2018,2023,101,107,59,1,711,59,1,94,105,114,99,59,1,292,114,59,1,8460,108,98,101,114,116,83,112,97,99,101,59,1,8459,4,2,112,114,2055,2059,102,59,1,8461,105,122,111,110,116,97,108,76,105,110,101,59,1,9472,4,2,99,116,2079,2083,114,59,1,8459,114,111,107,59,1,294,109,112,4,2,68,69,2097,2107,111,119,110,72,117,109,112,59,1,8782,113,117,97,108,59,1,8783,4,14,69,74,79,97,99,100,102,103,109,110,111,115,116,117,2144,2149,2155,2160,2171,2189,2194,2198,2209,2245,2307,2329,2334,2341,99,121,59,1,1045,108,105,103,59,1,306,99,121,59,1,1025,99,117,116,101,5,205,1,59,2169,1,205,4,2,105,121,2177,2186,114,99,5,206,1,59,2184,1,206,59,1,1048,111,116,59,1,304,114,59,1,8465,114,97,118,101,5,204,1,59,2207,1,204,4,3,59,97,112,2217,2219,2238,1,8465,4,2,99,103,2225,2229,114,59,1,298,105,110,97,114,121,73,59,1,8520,108,105,101,115,59,1,8658,4,2,116,118,2251,2281,4,2,59,101,2257,2259,1,8748,4,2,103,114,2265,2271,114,97,108,59,1,8747,115,101,99,116,105,111,110,59,1,8898,105,115,105,98,108,101,4,2,67,84,2293,2300,111,109,109,97,59,1,8291,105,109,101,115,59,1,8290,4,3,103,112,116,2315,2320,2325,111,110,59,1,302,102,59,3,55349,56640,97,59,1,921,99,114,59,1,8464,105,108,100,101,59,1,296,4,2,107,109,2347,2352,99,121,59,1,1030,108,5,207,1,59,2358,1,207,4,5,99,102,111,115,117,2372,2386,2391,2397,2414,4,2,105,121,2378,2383,114,99,59,1,308,59,1,1049,114,59,3,55349,56589,112,102,59,3,55349,56641,4,2,99,101,2403,2408,114,59,3,55349,56485,114,99,121,59,1,1032,107,99,121,59,1,1028,4,7,72,74,97,99,102,111,115,2436,2441,2446,2452,2467,2472,2478,99,121,59,1,1061,99,121,59,1,1036,112,112,97,59,1,922,4,2,101,121,2458,2464,100,105,108,59,1,310,59,1,1050,114,59,3,55349,56590,112,102,59,3,55349,56642,99,114,59,3,55349,56486,4,11,74,84,97,99,101,102,108,109,111,115,116,2508,2513,2520,2562,2585,2981,2986,3004,3011,3146,3167,99,121,59,1,1033,5,60,1,59,2518,1,60,4,5,99,109,110,112,114,2532,2538,2544,2548,2558,117,116,101,59,1,313,98,100,97,59,1,923,103,59,1,10218,108,97,99,101,116,114,102,59,1,8466,114,59,1,8606,4,3,97,101,121,2570,2576,2582,114,111,110,59,1,317,100,105,108,59,1,315,59,1,1051,4,2,102,115,2591,2907,116,4,10,65,67,68,70,82,84,85,86,97,114,2614,2663,2672,2728,2735,2760,2820,2870,2888,2895,4,2,110,114,2620,2633,103,108,101,66,114,97,99,107,101,116,59,1,10216,114,111,119,4,3,59,66,82,2644,2646,2651,1,8592,97,114,59,1,8676,105,103,104,116,65,114,114,111,119,59,1,8646,101,105,108,105,110,103,59,1,8968,111,4,2,117,119,2679,2692,98,108,101,66,114,97,99,107,101,116,59,1,10214,110,4,2,84,86,2699,2710,101,101,86,101,99,116,111,114,59,1,10593,101,99,116,111,114,4,2,59,66,2721,2723,1,8643,97,114,59,1,10585,108,111,111,114,59,1,8970,105,103,104,116,4,2,65,86,2745,2752,114,114,111,119,59,1,8596,101,99,116,111,114,59,1,10574,4,2,101,114,2766,2792,101,4,3,59,65,86,2775,2777,2784,1,8867,114,114,111,119,59,1,8612,101,99,116,111,114,59,1,10586,105,97,110,103,108,101,4,3,59,66,69,2806,2808,2813,1,8882,97,114,59,1,10703,113,117,97,108,59,1,8884,112,4,3,68,84,86,2829,2841,2852,111,119,110,86,101,99,116,111,114,59,1,10577,101,101,86,101,99,116,111,114,59,1,10592,101,99,116,111,114,4,2,59,66,2863,2865,1,8639,97,114,59,1,10584,101,99,116,111,114,4,2,59,66,2881,2883,1,8636,97,114,59,1,10578,114,114,111,119,59,1,8656,105,103,104,116,97,114,114,111,119,59,1,8660,115,4,6,69,70,71,76,83,84,2922,2936,2947,2956,2962,2974,113,117,97,108,71,114,101,97,116,101,114,59,1,8922,117,108,108,69,113,117,97,108,59,1,8806,114,101,97,116,101,114,59,1,8822,101,115,115,59,1,10913,108,97,110,116,69,113,117,97,108,59,1,10877,105,108,100,101,59,1,8818,114,59,3,55349,56591,4,2,59,101,2992,2994,1,8920,102,116,97,114,114,111,119,59,1,8666,105,100,111,116,59,1,319,4,3,110,112,119,3019,3110,3115,103,4,4,76,82,108,114,3030,3058,3070,3098,101,102,116,4,2,65,82,3039,3046,114,114,111,119,59,1,10229,105,103,104,116,65,114,114,111,119,59,1,10231,105,103,104,116,65,114,114,111,119,59,1,10230,101,102,116,4,2,97,114,3079,3086,114,114,111,119,59,1,10232,105,103,104,116,97,114,114,111,119,59,1,10234,105,103,104,116,97,114,114,111,119,59,1,10233,102,59,3,55349,56643,101,114,4,2,76,82,3123,3134,101,102,116,65,114,114,111,119,59,1,8601,105,103,104,116,65,114,114,111,119,59,1,8600,4,3,99,104,116,3154,3158,3161,114,59,1,8466,59,1,8624,114,111,107,59,1,321,59,1,8810,4,8,97,99,101,102,105,111,115,117,3188,3192,3196,3222,3227,3237,3243,3248,112,59,1,10501,121,59,1,1052,4,2,100,108,3202,3213,105,117,109,83,112,97,99,101,59,1,8287,108,105,110,116,114,102,59,1,8499,114,59,3,55349,56592,110,117,115,80,108,117,115,59,1,8723,112,102,59,3,55349,56644,99,114,59,1,8499,59,1,924,4,9,74,97,99,101,102,111,115,116,117,3271,3276,3283,3306,3422,3427,4120,4126,4137,99,121,59,1,1034,99,117,116,101,59,1,323,4,3,97,101,121,3291,3297,3303,114,111,110,59,1,327,100,105,108,59,1,325,59,1,1053,4,3,103,115,119,3314,3380,3415,97,116,105,118,101,4,3,77,84,86,3327,3340,3365,101,100,105,117,109,83,112,97,99,101,59,1,8203,104,105,4,2,99,110,3348,3357,107,83,112,97,99,101,59,1,8203,83,112,97,99,101,59,1,8203,101,114,121,84,104,105,110,83,112,97,99,101,59,1,8203,116,101,100,4,2,71,76,3389,3405,114,101,97,116,101,114,71,114,101,97,116,101,114,59,1,8811,101,115,115,76,101,115,115,59,1,8810,76,105,110,101,59,1,10,114,59,3,55349,56593,4,4,66,110,112,116,3437,3444,3460,3464,114,101,97,107,59,1,8288,66,114,101,97,107,105,110,103,83,112,97,99,101,59,1,160,102,59,1,8469,4,13,59,67,68,69,71,72,76,78,80,82,83,84,86,3492,3494,3517,3536,3578,3657,3685,3784,3823,3860,3915,4066,4107,1,10988,4,2,111,117,3500,3510,110,103,114,117,101,110,116,59,1,8802,112,67,97,112,59,1,8813,111,117,98,108,101,86,101,114,116,105,99,97,108,66,97,114,59,1,8742,4,3,108,113,120,3544,3552,3571,101,109,101,110,116,59,1,8713,117,97,108,4,2,59,84,3561,3563,1,8800,105,108,100,101,59,3,8770,824,105,115,116,115,59,1,8708,114,101,97,116,101,114,4,7,59,69,70,71,76,83,84,3600,3602,3609,3621,3631,3637,3650,1,8815,113,117,97,108,59,1,8817,117,108,108,69,113,117,97,108,59,3,8807,824,114,101,97,116,101,114,59,3,8811,824,101,115,115,59,1,8825,108,97,110,116,69,113,117,97,108,59,3,10878,824,105,108,100,101,59,1,8821,117,109,112,4,2,68,69,3666,3677,111,119,110,72,117,109,112,59,3,8782,824,113,117,97,108,59,3,8783,824,101,4,2,102,115,3692,3724,116,84,114,105,97,110,103,108,101,4,3,59,66,69,3709,3711,3717,1,8938,97,114,59,3,10703,824,113,117,97,108,59,1,8940,115,4,6,59,69,71,76,83,84,3739,3741,3748,3757,3764,3777,1,8814,113,117,97,108,59,1,8816,114,101,97,116,101,114,59,1,8824,101,115,115,59,3,8810,824,108,97,110,116,69,113,117,97,108,59,3,10877,824,105,108,100,101,59,1,8820,101,115,116,101,100,4,2,71,76,3795,3812,114,101,97,116,101,114,71,114,101,97,116,101,114,59,3,10914,824,101,115,115,76,101,115,115,59,3,10913,824,114,101,99,101,100,101,115,4,3,59,69,83,3838,3840,3848,1,8832,113,117,97,108,59,3,10927,824,108,97,110,116,69,113,117,97,108,59,1,8928,4,2,101,105,3866,3881,118,101,114,115,101,69,108,101,109,101,110,116,59,1,8716,103,104,116,84,114,105,97,110,103,108,101,4,3,59,66,69,3900,3902,3908,1,8939,97,114,59,3,10704,824,113,117,97,108,59,1,8941,4,2,113,117,3921,3973,117,97,114,101,83,117,4,2,98,112,3933,3952,115,101,116,4,2,59,69,3942,3945,3,8847,824,113,117,97,108,59,1,8930,101,114,115,101,116,4,2,59,69,3963,3966,3,8848,824,113,117,97,108,59,1,8931,4,3,98,99,112,3981,4000,4045,115,101,116,4,2,59,69,3990,3993,3,8834,8402,113,117,97,108,59,1,8840,99,101,101,100,115,4,4,59,69,83,84,4015,4017,4025,4037,1,8833,113,117,97,108,59,3,10928,824,108,97,110,116,69,113,117,97,108,59,1,8929,105,108,100,101,59,3,8831,824,101,114,115,101,116,4,2,59,69,4056,4059,3,8835,8402,113,117,97,108,59,1,8841,105,108,100,101,4,4,59,69,70,84,4080,4082,4089,4100,1,8769,113,117,97,108,59,1,8772,117,108,108,69,113,117,97,108,59,1,8775,105,108,100,101,59,1,8777,101,114,116,105,99,97,108,66,97,114,59,1,8740,99,114,59,3,55349,56489,105,108,100,101,5,209,1,59,4135,1,209,59,1,925,4,14,69,97,99,100,102,103,109,111,112,114,115,116,117,118,4170,4176,4187,4205,4212,4217,4228,4253,4259,4292,4295,4316,4337,4346,108,105,103,59,1,338,99,117,116,101,5,211,1,59,4185,1,211,4,2,105,121,4193,4202,114,99,5,212,1,59,4200,1,212,59,1,1054,98,108,97,99,59,1,336,114,59,3,55349,56594,114,97,118,101,5,210,1,59,4226,1,210,4,3,97,101,105,4236,4241,4246,99,114,59,1,332,103,97,59,1,937,99,114,111,110,59,1,927,112,102,59,3,55349,56646,101,110,67,117,114,108,121,4,2,68,81,4272,4285,111,117,98,108,101,81,117,111,116,101,59,1,8220,117,111,116,101,59,1,8216,59,1,10836,4,2,99,108,4301,4306,114,59,3,55349,56490,97,115,104,5,216,1,59,4314,1,216,105,4,2,108,109,4323,4332,100,101,5,213,1,59,4330,1,213,101,115,59,1,10807,109,108,5,214,1,59,4344,1,214,101,114,4,2,66,80,4354,4380,4,2,97,114,4360,4364,114,59,1,8254,97,99,4,2,101,107,4372,4375,59,1,9182,101,116,59,1,9140,97,114,101,110,116,104,101,115,105,115,59,1,9180,4,9,97,99,102,104,105,108,111,114,115,4413,4422,4426,4431,4435,4438,4448,4471,4561,114,116,105,97,108,68,59,1,8706,121,59,1,1055,114,59,3,55349,56595,105,59,1,934,59,1,928,117,115,77,105,110,117,115,59,1,177,4,2,105,112,4454,4467,110,99,97,114,101,112,108,97,110,101,59,1,8460,102,59,1,8473,4,4,59,101,105,111,4481,4483,4526,4531,1,10939,99,101,100,101,115,4,4,59,69,83,84,4498,4500,4507,4519,1,8826,113,117,97,108,59,1,10927,108,97,110,116,69,113,117,97,108,59,1,8828,105,108,100,101,59,1,8830,109,101,59,1,8243,4,2,100,112,4537,4543,117,99,116,59,1,8719,111,114,116,105,111,110,4,2,59,97,4555,4557,1,8759,108,59,1,8733,4,2,99,105,4567,4572,114,59,3,55349,56491,59,1,936,4,4,85,102,111,115,4585,4594,4599,4604,79,84,5,34,1,59,4592,1,34,114,59,3,55349,56596,112,102,59,1,8474,99,114,59,3,55349,56492,4,12,66,69,97,99,101,102,104,105,111,114,115,117,4636,4642,4650,4681,4704,4763,4767,4771,5047,5069,5081,5094,97,114,114,59,1,10512,71,5,174,1,59,4648,1,174,4,3,99,110,114,4658,4664,4668,117,116,101,59,1,340,103,59,1,10219,114,4,2,59,116,4675,4677,1,8608,108,59,1,10518,4,3,97,101,121,4689,4695,4701,114,111,110,59,1,344,100,105,108,59,1,342,59,1,1056,4,2,59,118,4710,4712,1,8476,101,114,115,101,4,2,69,85,4722,4748,4,2,108,113,4728,4736,101,109,101,110,116,59,1,8715,117,105,108,105,98,114,105,117,109,59,1,8651,112,69,113,117,105,108,105,98,114,105,117,109,59,1,10607,114,59,1,8476,111,59,1,929,103,104,116,4,8,65,67,68,70,84,85,86,97,4792,4840,4849,4905,4912,4972,5022,5040,4,2,110,114,4798,4811,103,108,101,66,114,97,99,107,101,116,59,1,10217,114,111,119,4,3,59,66,76,4822,4824,4829,1,8594,97,114,59,1,8677,101,102,116,65,114,114,111,119,59,1,8644,101,105,108,105,110,103,59,1,8969,111,4,2,117,119,4856,4869,98,108,101,66,114,97,99,107,101,116,59,1,10215,110,4,2,84,86,4876,4887,101,101,86,101,99,116,111,114,59,1,10589,101,99,116,111,114,4,2,59,66,4898,4900,1,8642,97,114,59,1,10581,108,111,111,114,59,1,8971,4,2,101,114,4918,4944,101,4,3,59,65,86,4927,4929,4936,1,8866,114,114,111,119,59,1,8614,101,99,116,111,114,59,1,10587,105,97,110,103,108,101,4,3,59,66,69,4958,4960,4965,1,8883,97,114,59,1,10704,113,117,97,108,59,1,8885,112,4,3,68,84,86,4981,4993,5004,111,119,110,86,101,99,116,111,114,59,1,10575,101,101,86,101,99,116,111,114,59,1,10588,101,99,116,111,114,4,2,59,66,5015,5017,1,8638,97,114,59,1,10580,101,99,116,111,114,4,2,59,66,5033,5035,1,8640,97,114,59,1,10579,114,114,111,119,59,1,8658,4,2,112,117,5053,5057,102,59,1,8477,110,100,73,109,112,108,105,101,115,59,1,10608,105,103,104,116,97,114,114,111,119,59,1,8667,4,2,99,104,5087,5091,114,59,1,8475,59,1,8625,108,101,68,101,108,97,121,101,100,59,1,10740,4,13,72,79,97,99,102,104,105,109,111,113,115,116,117,5134,5150,5157,5164,5198,5203,5259,5265,5277,5283,5374,5380,5385,4,2,67,99,5140,5146,72,99,121,59,1,1065,121,59,1,1064,70,84,99,121,59,1,1068,99,117,116,101,59,1,346,4,5,59,97,101,105,121,5176,5178,5184,5190,5195,1,10940,114,111,110,59,1,352,100,105,108,59,1,350,114,99,59,1,348,59,1,1057,114,59,3,55349,56598,111,114,116,4,4,68,76,82,85,5216,5227,5238,5250,111,119,110,65,114,114,111,119,59,1,8595,101,102,116,65,114,114,111,119,59,1,8592,105,103,104,116,65,114,114,111,119,59,1,8594,112,65,114,114,111,119,59,1,8593,103,109,97,59,1,931,97,108,108,67,105,114,99,108,101,59,1,8728,112,102,59,3,55349,56650,4,2,114,117,5289,5293,116,59,1,8730,97,114,101,4,4,59,73,83,85,5306,5308,5322,5367,1,9633,110,116,101,114,115,101,99,116,105,111,110,59,1,8851,117,4,2,98,112,5329,5347,115,101,116,4,2,59,69,5338,5340,1,8847,113,117,97,108,59,1,8849,101,114,115,101,116,4,2,59,69,5358,5360,1,8848,113,117,97,108,59,1,8850,110,105,111,110,59,1,8852,99,114,59,3,55349,56494,97,114,59,1,8902,4,4,98,99,109,112,5395,5420,5475,5478,4,2,59,115,5401,5403,1,8912,101,116,4,2,59,69,5411,5413,1,8912,113,117,97,108,59,1,8838,4,2,99,104,5426,5468,101,101,100,115,4,4,59,69,83,84,5440,5442,5449,5461,1,8827,113,117,97,108,59,1,10928,108,97,110,116,69,113,117,97,108,59,1,8829,105,108,100,101,59,1,8831,84,104,97,116,59,1,8715,59,1,8721,4,3,59,101,115,5486,5488,5507,1,8913,114,115,101,116,4,2,59,69,5498,5500,1,8835,113,117,97,108,59,1,8839,101,116,59,1,8913,4,11,72,82,83,97,99,102,104,105,111,114,115,5536,5546,5552,5567,5579,5602,5607,5655,5695,5701,5711,79,82,78,5,222,1,59,5544,1,222,65,68,69,59,1,8482,4,2,72,99,5558,5563,99,121,59,1,1035,121,59,1,1062,4,2,98,117,5573,5576,59,1,9,59,1,932,4,3,97,101,121,5587,5593,5599,114,111,110,59,1,356,100,105,108,59,1,354,59,1,1058,114,59,3,55349,56599,4,2,101,105,5613,5631,4,2,114,116,5619,5627,101,102,111,114,101,59,1,8756,97,59,1,920,4,2,99,110,5637,5647,107,83,112,97,99,101,59,3,8287,8202,83,112,97,99,101,59,1,8201,108,100,101,4,4,59,69,70,84,5668,5670,5677,5688,1,8764,113,117,97,108,59,1,8771,117,108,108,69,113,117,97,108,59,1,8773,105,108,100,101,59,1,8776,112,102,59,3,55349,56651,105,112,108,101,68,111,116,59,1,8411,4,2,99,116,5717,5722,114,59,3,55349,56495,114,111,107,59,1,358,4,14,97,98,99,100,102,103,109,110,111,112,114,115,116,117,5758,5789,5805,5823,5830,5835,5846,5852,5921,5937,6089,6095,6101,6108,4,2,99,114,5764,5774,117,116,101,5,218,1,59,5772,1,218,114,4,2,59,111,5781,5783,1,8607,99,105,114,59,1,10569,114,4,2,99,101,5796,5800,121,59,1,1038,118,101,59,1,364,4,2,105,121,5811,5820,114,99,5,219,1,59,5818,1,219,59,1,1059,98,108,97,99,59,1,368,114,59,3,55349,56600,114,97,118,101,5,217,1,59,5844,1,217,97,99,114,59,1,362,4,2,100,105,5858,5905,101,114,4,2,66,80,5866,5892,4,2,97,114,5872,5876,114,59,1,95,97,99,4,2,101,107,5884,5887,59,1,9183,101,116,59,1,9141,97,114,101,110,116,104,101,115,105,115,59,1,9181,111,110,4,2,59,80,5913,5915,1,8899,108,117,115,59,1,8846,4,2,103,112,5927,5932,111,110,59,1,370,102,59,3,55349,56652,4,8,65,68,69,84,97,100,112,115,5955,5985,5996,6009,6026,6033,6044,6075,114,114,111,119,4,3,59,66,68,5967,5969,5974,1,8593,97,114,59,1,10514,111,119,110,65,114,114,111,119,59,1,8645,111,119,110,65,114,114,111,119,59,1,8597,113,117,105,108,105,98,114,105,117,109,59,1,10606,101,101,4,2,59,65,6017,6019,1,8869,114,114,111,119,59,1,8613,114,114,111,119,59,1,8657,111,119,110,97,114,114,111,119,59,1,8661,101,114,4,2,76,82,6052,6063,101,102,116,65,114,114,111,119,59,1,8598,105,103,104,116,65,114,114,111,119,59,1,8599,105,4,2,59,108,6082,6084,1,978,111,110,59,1,933,105,110,103,59,1,366,99,114,59,3,55349,56496,105,108,100,101,59,1,360,109,108,5,220,1,59,6115,1,220,4,9,68,98,99,100,101,102,111,115,118,6137,6143,6148,6152,6166,6250,6255,6261,6267,97,115,104,59,1,8875,97,114,59,1,10987,121,59,1,1042,97,115,104,4,2,59,108,6161,6163,1,8873,59,1,10982,4,2,101,114,6172,6175,59,1,8897,4,3,98,116,121,6183,6188,6238,97,114,59,1,8214,4,2,59,105,6194,6196,1,8214,99,97,108,4,4,66,76,83,84,6209,6214,6220,6231,97,114,59,1,8739,105,110,101,59,1,124,101,112,97,114,97,116,111,114,59,1,10072,105,108,100,101,59,1,8768,84,104,105,110,83,112,97,99,101,59,1,8202,114,59,3,55349,56601,112,102,59,3,55349,56653,99,114,59,3,55349,56497,100,97,115,104,59,1,8874,4,5,99,101,102,111,115,6286,6292,6298,6303,6309,105,114,99,59,1,372,100,103,101,59,1,8896,114,59,3,55349,56602,112,102,59,3,55349,56654,99,114,59,3,55349,56498,4,4,102,105,111,115,6325,6330,6333,6339,114,59,3,55349,56603,59,1,926,112,102,59,3,55349,56655,99,114,59,3,55349,56499,4,9,65,73,85,97,99,102,111,115,117,6365,6370,6375,6380,6391,6405,6410,6416,6422,99,121,59,1,1071,99,121,59,1,1031,99,121,59,1,1070,99,117,116,101,5,221,1,59,6389,1,221,4,2,105,121,6397,6402,114,99,59,1,374,59,1,1067,114,59,3,55349,56604,112,102,59,3,55349,56656,99,114,59,3,55349,56500,109,108,59,1,376,4,8,72,97,99,100,101,102,111,115,6445,6450,6457,6472,6477,6501,6505,6510,99,121,59,1,1046,99,117,116,101,59,1,377,4,2,97,121,6463,6469,114,111,110,59,1,381,59,1,1047,111,116,59,1,379,4,2,114,116,6483,6497,111,87,105,100,116,104,83,112,97,99,101,59,1,8203,97,59,1,918,114,59,1,8488,112,102,59,1,8484,99,114,59,3,55349,56501,4,16,97,98,99,101,102,103,108,109,110,111,112,114,115,116,117,119,6550,6561,6568,6612,6622,6634,6645,6672,6699,6854,6870,6923,6933,6963,6974,6983,99,117,116,101,5,225,1,59,6559,1,225,114,101,118,101,59,1,259,4,6,59,69,100,105,117,121,6582,6584,6588,6591,6600,6609,1,8766,59,3,8766,819,59,1,8767,114,99,5,226,1,59,6598,1,226,116,101,5,180,1,59,6607,1,180,59,1,1072,108,105,103,5,230,1,59,6620,1,230,4,2,59,114,6628,6630,1,8289,59,3,55349,56606,114,97,118,101,5,224,1,59,6643,1,224,4,2,101,112,6651,6667,4,2,102,112,6657,6663,115,121,109,59,1,8501,104,59,1,8501,104,97,59,1,945,4,2,97,112,6678,6692,4,2,99,108,6684,6688,114,59,1,257,103,59,1,10815,5,38,1,59,6697,1,38,4,2,100,103,6705,6737,4,5,59,97,100,115,118,6717,6719,6724,6727,6734,1,8743,110,100,59,1,10837,59,1,10844,108,111,112,101,59,1,10840,59,1,10842,4,7,59,101,108,109,114,115,122,6753,6755,6758,6762,6814,6835,6848,1,8736,59,1,10660,101,59,1,8736,115,100,4,2,59,97,6770,6772,1,8737,4,8,97,98,99,100,101,102,103,104,6790,6793,6796,6799,6802,6805,6808,6811,59,1,10664,59,1,10665,59,1,10666,59,1,10667,59,1,10668,59,1,10669,59,1,10670,59,1,10671,116,4,2,59,118,6821,6823,1,8735,98,4,2,59,100,6830,6832,1,8894,59,1,10653,4,2,112,116,6841,6845,104,59,1,8738,59,1,197,97,114,114,59,1,9084,4,2,103,112,6860,6865,111,110,59,1,261,102,59,3,55349,56658,4,7,59,69,97,101,105,111,112,6886,6888,6891,6897,6900,6904,6908,1,8776,59,1,10864,99,105,114,59,1,10863,59,1,8778,100,59,1,8779,115,59,1,39,114,111,120,4,2,59,101,6917,6919,1,8776,113,59,1,8778,105,110,103,5,229,1,59,6931,1,229,4,3,99,116,121,6941,6946,6949,114,59,3,55349,56502,59,1,42,109,112,4,2,59,101,6957,6959,1,8776,113,59,1,8781,105,108,100,101,5,227,1,59,6972,1,227,109,108,5,228,1,59,6981,1,228,4,2,99,105,6989,6997,111,110,105,110,116,59,1,8755,110,116,59,1,10769,4,16,78,97,98,99,100,101,102,105,107,108,110,111,112,114,115,117,7036,7041,7119,7135,7149,7155,7219,7224,7347,7354,7463,7489,7786,7793,7814,7866,111,116,59,1,10989,4,2,99,114,7047,7094,107,4,4,99,101,112,115,7058,7064,7073,7080,111,110,103,59,1,8780,112,115,105,108,111,110,59,1,1014,114,105,109,101,59,1,8245,105,109,4,2,59,101,7088,7090,1,8765,113,59,1,8909,4,2,118,119,7100,7105,101,101,59,1,8893,101,100,4,2,59,103,7113,7115,1,8965,101,59,1,8965,114,107,4,2,59,116,7127,7129,1,9141,98,114,107,59,1,9142,4,2,111,121,7141,7146,110,103,59,1,8780,59,1,1073,113,117,111,59,1,8222,4,5,99,109,112,114,116,7167,7181,7188,7193,7199,97,117,115,4,2,59,101,7176,7178,1,8757,59,1,8757,112,116,121,118,59,1,10672,115,105,59,1,1014,110,111,117,59,1,8492,4,3,97,104,119,7207,7210,7213,59,1,946,59,1,8502,101,101,110,59,1,8812,114,59,3,55349,56607,103,4,7,99,111,115,116,117,118,119,7241,7262,7288,7305,7328,7335,7340,4,3,97,105,117,7249,7253,7258,112,59,1,8898,114,99,59,1,9711,112,59,1,8899,4,3,100,112,116,7270,7275,7281,111,116,59,1,10752,108,117,115,59,1,10753,105,109,101,115,59,1,10754,4,2,113,116,7294,7300,99,117,112,59,1,10758,97,114,59,1,9733,114,105,97,110,103,108,101,4,2,100,117,7318,7324,111,119,110,59,1,9661,112,59,1,9651,112,108,117,115,59,1,10756,101,101,59,1,8897,101,100,103,101,59,1,8896,97,114,111,119,59,1,10509,4,3,97,107,111,7362,7436,7458,4,2,99,110,7368,7432,107,4,3,108,115,116,7377,7386,7394,111,122,101,110,103,101,59,1,10731,113,117,97,114,101,59,1,9642,114,105,97,110,103,108,101,4,4,59,100,108,114,7411,7413,7419,7425,1,9652,111,119,110,59,1,9662,101,102,116,59,1,9666,105,103,104,116,59,1,9656,107,59,1,9251,4,2,49,51,7442,7454,4,2,50,52,7448,7451,59,1,9618,59,1,9617,52,59,1,9619,99,107,59,1,9608,4,2,101,111,7469,7485,4,2,59,113,7475,7478,3,61,8421,117,105,118,59,3,8801,8421,116,59,1,8976,4,4,112,116,119,120,7499,7504,7517,7523,102,59,3,55349,56659,4,2,59,116,7510,7512,1,8869,111,109,59,1,8869,116,105,101,59,1,8904,4,12,68,72,85,86,98,100,104,109,112,116,117,118,7549,7571,7597,7619,7655,7660,7682,7708,7715,7721,7728,7750,4,4,76,82,108,114,7559,7562,7565,7568,59,1,9559,59,1,9556,59,1,9558,59,1,9555,4,5,59,68,85,100,117,7583,7585,7588,7591,7594,1,9552,59,1,9574,59,1,9577,59,1,9572,59,1,9575,4,4,76,82,108,114,7607,7610,7613,7616,59,1,9565,59,1,9562,59,1,9564,59,1,9561,4,7,59,72,76,82,104,108,114,7635,7637,7640,7643,7646,7649,7652,1,9553,59,1,9580,59,1,9571,59,1,9568,59,1,9579,59,1,9570,59,1,9567,111,120,59,1,10697,4,4,76,82,108,114,7670,7673,7676,7679,59,1,9557,59,1,9554,59,1,9488,59,1,9484,4,5,59,68,85,100,117,7694,7696,7699,7702,7705,1,9472,59,1,9573,59,1,9576,59,1,9516,59,1,9524,105,110,117,115,59,1,8863,108,117,115,59,1,8862,105,109,101,115,59,1,8864,4,4,76,82,108,114,7738,7741,7744,7747,59,1,9563,59,1,9560,59,1,9496,59,1,9492,4,7,59,72,76,82,104,108,114,7766,7768,7771,7774,7777,7780,7783,1,9474,59,1,9578,59,1,9569,59,1,9566,59,1,9532,59,1,9508,59,1,9500,114,105,109,101,59,1,8245,4,2,101,118,7799,7804,118,101,59,1,728,98,97,114,5,166,1,59,7812,1,166,4,4,99,101,105,111,7824,7829,7834,7846,114,59,3,55349,56503,109,105,59,1,8271,109,4,2,59,101,7841,7843,1,8765,59,1,8909,108,4,3,59,98,104,7855,7857,7860,1,92,59,1,10693,115,117,98,59,1,10184,4,2,108,109,7872,7885,108,4,2,59,101,7879,7881,1,8226,116,59,1,8226,112,4,3,59,69,101,7894,7896,7899,1,8782,59,1,10926,4,2,59,113,7905,7907,1,8783,59,1,8783,4,15,97,99,100,101,102,104,105,108,111,114,115,116,117,119,121,7942,8021,8075,8080,8121,8126,8157,8279,8295,8430,8446,8485,8491,8707,8726,4,3,99,112,114,7950,7956,8007,117,116,101,59,1,263,4,6,59,97,98,99,100,115,7970,7972,7977,7984,7998,8003,1,8745,110,100,59,1,10820,114,99,117,112,59,1,10825,4,2,97,117,7990,7994,112,59,1,10827,112,59,1,10823,111,116,59,1,10816,59,3,8745,65024,4,2,101,111,8013,8017,116,59,1,8257,110,59,1,711,4,4,97,101,105,117,8031,8046,8056,8061,4,2,112,114,8037,8041,115,59,1,10829,111,110,59,1,269,100,105,108,5,231,1,59,8054,1,231,114,99,59,1,265,112,115,4,2,59,115,8069,8071,1,10828,109,59,1,10832,111,116,59,1,267,4,3,100,109,110,8088,8097,8104,105,108,5,184,1,59,8095,1,184,112,116,121,118,59,1,10674,116,5,162,2,59,101,8112,8114,1,162,114,100,111,116,59,1,183,114,59,3,55349,56608,4,3,99,101,105,8134,8138,8154,121,59,1,1095,99,107,4,2,59,109,8146,8148,1,10003,97,114,107,59,1,10003,59,1,967,114,4,7,59,69,99,101,102,109,115,8174,8176,8179,8258,8261,8268,8273,1,9675,59,1,10691,4,3,59,101,108,8187,8189,8193,1,710,113,59,1,8791,101,4,2,97,100,8200,8223,114,114,111,119,4,2,108,114,8210,8216,101,102,116,59,1,8634,105,103,104,116,59,1,8635,4,5,82,83,97,99,100,8235,8238,8241,8246,8252,59,1,174,59,1,9416,115,116,59,1,8859,105,114,99,59,1,8858,97,115,104,59,1,8861,59,1,8791,110,105,110,116,59,1,10768,105,100,59,1,10991,99,105,114,59,1,10690,117,98,115,4,2,59,117,8288,8290,1,9827,105,116,59,1,9827,4,4,108,109,110,112,8305,8326,8376,8400,111,110,4,2,59,101,8313,8315,1,58,4,2,59,113,8321,8323,1,8788,59,1,8788,4,2,109,112,8332,8344,97,4,2,59,116,8339,8341,1,44,59,1,64,4,3,59,102,108,8352,8354,8358,1,8705,110,59,1,8728,101,4,2,109,120,8365,8371,101,110,116,59,1,8705,101,115,59,1,8450,4,2,103,105,8382,8395,4,2,59,100,8388,8390,1,8773,111,116,59,1,10861,110,116,59,1,8750,4,3,102,114,121,8408,8412,8417,59,3,55349,56660,111,100,59,1,8720,5,169,2,59,115,8424,8426,1,169,114,59,1,8471,4,2,97,111,8436,8441,114,114,59,1,8629,115,115,59,1,10007,4,2,99,117,8452,8457,114,59,3,55349,56504,4,2,98,112,8463,8474,4,2,59,101,8469,8471,1,10959,59,1,10961,4,2,59,101,8480,8482,1,10960,59,1,10962,100,111,116,59,1,8943,4,7,100,101,108,112,114,118,119,8507,8522,8536,8550,8600,8697,8702,97,114,114,4,2,108,114,8516,8519,59,1,10552,59,1,10549,4,2,112,115,8528,8532,114,59,1,8926,99,59,1,8927,97,114,114,4,2,59,112,8545,8547,1,8630,59,1,10557,4,6,59,98,99,100,111,115,8564,8566,8573,8587,8592,8596,1,8746,114,99,97,112,59,1,10824,4,2,97,117,8579,8583,112,59,1,10822,112,59,1,10826,111,116,59,1,8845,114,59,1,10821,59,3,8746,65024,4,4,97,108,114,118,8610,8623,8663,8672,114,114,4,2,59,109,8618,8620,1,8631,59,1,10556,121,4,3,101,118,119,8632,8651,8656,113,4,2,112,115,8639,8645,114,101,99,59,1,8926,117,99,99,59,1,8927,101,101,59,1,8910,101,100,103,101,59,1,8911,101,110,5,164,1,59,8670,1,164,101,97,114,114,111,119,4,2,108,114,8684,8690,101,102,116,59,1,8630,105,103,104,116,59,1,8631,101,101,59,1,8910,101,100,59,1,8911,4,2,99,105,8713,8721,111,110,105,110,116,59,1,8754,110,116,59,1,8753,108,99,116,121,59,1,9005,4,19,65,72,97,98,99,100,101,102,104,105,106,108,111,114,115,116,117,119,122,8773,8778,8783,8821,8839,8854,8887,8914,8930,8944,9036,9041,9058,9197,9227,9258,9281,9297,9305,114,114,59,1,8659,97,114,59,1,10597,4,4,103,108,114,115,8793,8799,8805,8809,103,101,114,59,1,8224,101,116,104,59,1,8504,114,59,1,8595,104,4,2,59,118,8816,8818,1,8208,59,1,8867,4,2,107,108,8827,8834,97,114,111,119,59,1,10511,97,99,59,1,733,4,2,97,121,8845,8851,114,111,110,59,1,271,59,1,1076,4,3,59,97,111,8862,8864,8880,1,8518,4,2,103,114,8870,8876,103,101,114,59,1,8225,114,59,1,8650,116,115,101,113,59,1,10871,4,3,103,108,109,8895,8902,8907,5,176,1,59,8900,1,176,116,97,59,1,948,112,116,121,118,59,1,10673,4,2,105,114,8920,8926,115,104,116,59,1,10623,59,3,55349,56609,97,114,4,2,108,114,8938,8941,59,1,8643,59,1,8642,4,5,97,101,103,115,118,8956,8986,8989,8996,9001,109,4,3,59,111,115,8965,8967,8983,1,8900,110,100,4,2,59,115,8975,8977,1,8900,117,105,116,59,1,9830,59,1,9830,59,1,168,97,109,109,97,59,1,989,105,110,59,1,8946,4,3,59,105,111,9009,9011,9031,1,247,100,101,5,247,2,59,111,9020,9022,1,247,110,116,105,109,101,115,59,1,8903,110,120,59,1,8903,99,121,59,1,1106,99,4,2,111,114,9048,9053,114,110,59,1,8990,111,112,59,1,8973,4,5,108,112,116,117,119,9070,9076,9081,9130,9144,108,97,114,59,1,36,102,59,3,55349,56661,4,5,59,101,109,112,115,9093,9095,9109,9116,9122,1,729,113,4,2,59,100,9102,9104,1,8784,111,116,59,1,8785,105,110,117,115,59,1,8760,108,117,115,59,1,8724,113,117,97,114,101,59,1,8865,98,108,101,98,97,114,119,101,100,103,101,59,1,8966,110,4,3,97,100,104,9153,9160,9172,114,114,111,119,59,1,8595,111,119,110,97,114,114,111,119,115,59,1,8650,97,114,112,111,111,110,4,2,108,114,9184,9190,101,102,116,59,1,8643,105,103,104,116,59,1,8642,4,2,98,99,9203,9211,107,97,114,111,119,59,1,10512,4,2,111,114,9217,9222,114,110,59,1,8991,111,112,59,1,8972,4,3,99,111,116,9235,9248,9252,4,2,114,121,9241,9245,59,3,55349,56505,59,1,1109,108,59,1,10742,114,111,107,59,1,273,4,2,100,114,9264,9269,111,116,59,1,8945,105,4,2,59,102,9276,9278,1,9663,59,1,9662,4,2,97,104,9287,9292,114,114,59,1,8693,97,114,59,1,10607,97,110,103,108,101,59,1,10662,4,2,99,105,9311,9315,121,59,1,1119,103,114,97,114,114,59,1,10239,4,18,68,97,99,100,101,102,103,108,109,110,111,112,113,114,115,116,117,120,9361,9376,9398,9439,9444,9447,9462,9495,9531,9585,9598,9614,9659,9755,9771,9792,9808,9826,4,2,68,111,9367,9372,111,116,59,1,10871,116,59,1,8785,4,2,99,115,9382,9392,117,116,101,5,233,1,59,9390,1,233,116,101,114,59,1,10862,4,4,97,105,111,121,9408,9414,9430,9436,114,111,110,59,1,283,114,4,2,59,99,9421,9423,1,8790,5,234,1,59,9428,1,234,108,111,110,59,1,8789,59,1,1101,111,116,59,1,279,59,1,8519,4,2,68,114,9453,9458,111,116,59,1,8786,59,3,55349,56610,4,3,59,114,115,9470,9472,9482,1,10906,97,118,101,5,232,1,59,9480,1,232,4,2,59,100,9488,9490,1,10902,111,116,59,1,10904,4,4,59,105,108,115,9505,9507,9515,9518,1,10905,110,116,101,114,115,59,1,9191,59,1,8467,4,2,59,100,9524,9526,1,10901,111,116,59,1,10903,4,3,97,112,115,9539,9544,9564,99,114,59,1,275,116,121,4,3,59,115,118,9554,9556,9561,1,8709,101,116,59,1,8709,59,1,8709,112,4,2,49,59,9571,9583,4,2,51,52,9577,9580,59,1,8196,59,1,8197,1,8195,4,2,103,115,9591,9594,59,1,331,112,59,1,8194,4,2,103,112,9604,9609,111,110,59,1,281,102,59,3,55349,56662,4,3,97,108,115,9622,9635,9640,114,4,2,59,115,9629,9631,1,8917,108,59,1,10723,117,115,59,1,10865,105,4,3,59,108,118,9649,9651,9656,1,949,111,110,59,1,949,59,1,1013,4,4,99,115,117,118,9669,9686,9716,9747,4,2,105,111,9675,9680,114,99,59,1,8790,108,111,110,59,1,8789,4,2,105,108,9692,9696,109,59,1,8770,97,110,116,4,2,103,108,9705,9710,116,114,59,1,10902,101,115,115,59,1,10901,4,3,97,101,105,9724,9729,9734,108,115,59,1,61,115,116,59,1,8799,118,4,2,59,68,9741,9743,1,8801,68,59,1,10872,112,97,114,115,108,59,1,10725,4,2,68,97,9761,9766,111,116,59,1,8787,114,114,59,1,10609,4,3,99,100,105,9779,9783,9788,114,59,1,8495,111,116,59,1,8784,109,59,1,8770,4,2,97,104,9798,9801,59,1,951,5,240,1,59,9806,1,240,4,2,109,114,9814,9822,108,5,235,1,59,9820,1,235,111,59,1,8364,4,3,99,105,112,9834,9838,9843,108,59,1,33,115,116,59,1,8707,4,2,101,111,9849,9859,99,116,97,116,105,111,110,59,1,8496,110,101,110,116,105,97,108,101,59,1,8519,4,12,97,99,101,102,105,106,108,110,111,112,114,115,9896,9910,9914,9921,9954,9960,9967,9989,9994,10027,10036,10164,108,108,105,110,103,100,111,116,115,101,113,59,1,8786,121,59,1,1092,109,97,108,101,59,1,9792,4,3,105,108,114,9929,9935,9950,108,105,103,59,1,64259,4,2,105,108,9941,9945,103,59,1,64256,105,103,59,1,64260,59,3,55349,56611,108,105,103,59,1,64257,108,105,103,59,3,102,106,4,3,97,108,116,9975,9979,9984,116,59,1,9837,105,103,59,1,64258,110,115,59,1,9649,111,102,59,1,402,4,2,112,114,10000,10005,102,59,3,55349,56663,4,2,97,107,10011,10016,108,108,59,1,8704,4,2,59,118,10022,10024,1,8916,59,1,10969,97,114,116,105,110,116,59,1,10765,4,2,97,111,10042,10159,4,2,99,115,10048,10155,4,6,49,50,51,52,53,55,10062,10102,10114,10135,10139,10151,4,6,50,51,52,53,54,56,10076,10083,10086,10093,10096,10099,5,189,1,59,10081,1,189,59,1,8531,5,188,1,59,10091,1,188,59,1,8533,59,1,8537,59,1,8539,4,2,51,53,10108,10111,59,1,8532,59,1,8534,4,3,52,53,56,10122,10129,10132,5,190,1,59,10127,1,190,59,1,8535,59,1,8540,53,59,1,8536,4,2,54,56,10145,10148,59,1,8538,59,1,8541,56,59,1,8542,108,59,1,8260,119,110,59,1,8994,99,114,59,3,55349,56507,4,17,69,97,98,99,100,101,102,103,105,106,108,110,111,114,115,116,118,10206,10217,10247,10254,10268,10273,10358,10363,10374,10380,10385,10406,10458,10464,10470,10497,10610,4,2,59,108,10212,10214,1,8807,59,1,10892,4,3,99,109,112,10225,10231,10244,117,116,101,59,1,501,109,97,4,2,59,100,10239,10241,1,947,59,1,989,59,1,10886,114,101,118,101,59,1,287,4,2,105,121,10260,10265,114,99,59,1,285,59,1,1075,111,116,59,1,289,4,4,59,108,113,115,10283,10285,10288,10308,1,8805,59,1,8923,4,3,59,113,115,10296,10298,10301,1,8805,59,1,8807,108,97,110,116,59,1,10878,4,4,59,99,100,108,10318,10320,10324,10345,1,10878,99,59,1,10921,111,116,4,2,59,111,10332,10334,1,10880,4,2,59,108,10340,10342,1,10882,59,1,10884,4,2,59,101,10351,10354,3,8923,65024,115,59,1,10900,114,59,3,55349,56612,4,2,59,103,10369,10371,1,8811,59,1,8921,109,101,108,59,1,8503,99,121,59,1,1107,4,4,59,69,97,106,10395,10397,10400,10403,1,8823,59,1,10898,59,1,10917,59,1,10916,4,4,69,97,101,115,10416,10419,10434,10453,59,1,8809,112,4,2,59,112,10426,10428,1,10890,114,111,120,59,1,10890,4,2,59,113,10440,10442,1,10888,4,2,59,113,10448,10450,1,10888,59,1,8809,105,109,59,1,8935,112,102,59,3,55349,56664,97,118,101,59,1,96,4,2,99,105,10476,10480,114,59,1,8458,109,4,3,59,101,108,10489,10491,10494,1,8819,59,1,10894,59,1,10896,5,62,6,59,99,100,108,113,114,10512,10514,10527,10532,10538,10545,1,62,4,2,99,105,10520,10523,59,1,10919,114,59,1,10874,111,116,59,1,8919,80,97,114,59,1,10645,117,101,115,116,59,1,10876,4,5,97,100,101,108,115,10557,10574,10579,10599,10605,4,2,112,114,10563,10570,112,114,111,120,59,1,10886,114,59,1,10616,111,116,59,1,8919,113,4,2,108,113,10586,10592,101,115,115,59,1,8923,108,101,115,115,59,1,10892,101,115,115,59,1,8823,105,109,59,1,8819,4,2,101,110,10616,10626,114,116,110,101,113,113,59,3,8809,65024,69,59,3,8809,65024,4,10,65,97,98,99,101,102,107,111,115,121,10653,10658,10713,10718,10724,10760,10765,10786,10850,10875,114,114,59,1,8660,4,4,105,108,109,114,10668,10674,10678,10684,114,115,112,59,1,8202,102,59,1,189,105,108,116,59,1,8459,4,2,100,114,10690,10695,99,121,59,1,1098,4,3,59,99,119,10703,10705,10710,1,8596,105,114,59,1,10568,59,1,8621,97,114,59,1,8463,105,114,99,59,1,293,4,3,97,108,114,10732,10748,10754,114,116,115,4,2,59,117,10741,10743,1,9829,105,116,59,1,9829,108,105,112,59,1,8230,99,111,110,59,1,8889,114,59,3,55349,56613,115,4,2,101,119,10772,10779,97,114,111,119,59,1,10533,97,114,111,119,59,1,10534,4,5,97,109,111,112,114,10798,10803,10809,10839,10844,114,114,59,1,8703,116,104,116,59,1,8763,107,4,2,108,114,10816,10827,101,102,116,97,114,114,111,119,59,1,8617,105,103,104,116,97,114,114,111,119,59,1,8618,102,59,3,55349,56665,98,97,114,59,1,8213,4,3,99,108,116,10858,10863,10869,114,59,3,55349,56509,97,115,104,59,1,8463,114,111,107,59,1,295,4,2,98,112,10881,10887,117,108,108,59,1,8259,104,101,110,59,1,8208,4,15,97,99,101,102,103,105,106,109,110,111,112,113,115,116,117,10925,10936,10958,10977,10990,11001,11039,11045,11101,11192,11220,11226,11237,11285,11299,99,117,116,101,5,237,1,59,10934,1,237,4,3,59,105,121,10944,10946,10955,1,8291,114,99,5,238,1,59,10953,1,238,59,1,1080,4,2,99,120,10964,10968,121,59,1,1077,99,108,5,161,1,59,10975,1,161,4,2,102,114,10983,10986,59,1,8660,59,3,55349,56614,114,97,118,101,5,236,1,59,10999,1,236,4,4,59,105,110,111,11011,11013,11028,11034,1,8520,4,2,105,110,11019,11024,110,116,59,1,10764,116,59,1,8749,102,105,110,59,1,10716,116,97,59,1,8489,108,105,103,59,1,307,4,3,97,111,112,11053,11092,11096,4,3,99,103,116,11061,11065,11088,114,59,1,299,4,3,101,108,112,11073,11076,11082,59,1,8465,105,110,101,59,1,8464,97,114,116,59,1,8465,104,59,1,305,102,59,1,8887,101,100,59,1,437,4,5,59,99,102,111,116,11113,11115,11121,11136,11142,1,8712,97,114,101,59,1,8453,105,110,4,2,59,116,11129,11131,1,8734,105,101,59,1,10717,100,111,116,59,1,305,4,5,59,99,101,108,112,11154,11156,11161,11179,11186,1,8747,97,108,59,1,8890,4,2,103,114,11167,11173,101,114,115,59,1,8484,99,97,108,59,1,8890,97,114,104,107,59,1,10775,114,111,100,59,1,10812,4,4,99,103,112,116,11202,11206,11211,11216,121,59,1,1105,111,110,59,1,303,102,59,3,55349,56666,97,59,1,953,114,111,100,59,1,10812,117,101,115,116,5,191,1,59,11235,1,191,4,2,99,105,11243,11248,114,59,3,55349,56510,110,4,5,59,69,100,115,118,11261,11263,11266,11271,11282,1,8712,59,1,8953,111,116,59,1,8949,4,2,59,118,11277,11279,1,8948,59,1,8947,59,1,8712,4,2,59,105,11291,11293,1,8290,108,100,101,59,1,297,4,2,107,109,11305,11310,99,121,59,1,1110,108,5,239,1,59,11316,1,239,4,6,99,102,109,111,115,117,11332,11346,11351,11357,11363,11380,4,2,105,121,11338,11343,114,99,59,1,309,59,1,1081,114,59,3,55349,56615,97,116,104,59,1,567,112,102,59,3,55349,56667,4,2,99,101,11369,11374,114,59,3,55349,56511,114,99,121,59,1,1112,107,99,121,59,1,1108,4,8,97,99,102,103,104,106,111,115,11404,11418,11433,11438,11445,11450,11455,11461,112,112,97,4,2,59,118,11413,11415,1,954,59,1,1008,4,2,101,121,11424,11430,100,105,108,59,1,311,59,1,1082,114,59,3,55349,56616,114,101,101,110,59,1,312,99,121,59,1,1093,99,121,59,1,1116,112,102,59,3,55349,56668,99,114,59,3,55349,56512,4,23,65,66,69,72,97,98,99,100,101,102,103,104,106,108,109,110,111,112,114,115,116,117,118,11515,11538,11544,11555,11560,11721,11780,11818,11868,12136,12160,12171,12203,12208,12246,12275,12327,12509,12523,12569,12641,12732,12752,4,3,97,114,116,11523,11528,11532,114,114,59,1,8666,114,59,1,8656,97,105,108,59,1,10523,97,114,114,59,1,10510,4,2,59,103,11550,11552,1,8806,59,1,10891,97,114,59,1,10594,4,9,99,101,103,109,110,112,113,114,116,11580,11586,11594,11600,11606,11624,11627,11636,11694,117,116,101,59,1,314,109,112,116,121,118,59,1,10676,114,97,110,59,1,8466,98,100,97,59,1,955,103,4,3,59,100,108,11615,11617,11620,1,10216,59,1,10641,101,59,1,10216,59,1,10885,117,111,5,171,1,59,11634,1,171,114,4,8,59,98,102,104,108,112,115,116,11655,11657,11669,11673,11677,11681,11685,11690,1,8592,4,2,59,102,11663,11665,1,8676,115,59,1,10527,115,59,1,10525,107,59,1,8617,112,59,1,8619,108,59,1,10553,105,109,59,1,10611,108,59,1,8610,4,3,59,97,101,11702,11704,11709,1,10923,105,108,59,1,10521,4,2,59,115,11715,11717,1,10925,59,3,10925,65024,4,3,97,98,114,11729,11734,11739,114,114,59,1,10508,114,107,59,1,10098,4,2,97,107,11745,11758,99,4,2,101,107,11752,11755,59,1,123,59,1,91,4,2,101,115,11764,11767,59,1,10635,108,4,2,100,117,11774,11777,59,1,10639,59,1,10637,4,4,97,101,117,121,11790,11796,11811,11815,114,111,110,59,1,318,4,2,100,105,11802,11807,105,108,59,1,316,108,59,1,8968,98,59,1,123,59,1,1083,4,4,99,113,114,115,11828,11832,11845,11864,97,59,1,10550,117,111,4,2,59,114,11840,11842,1,8220,59,1,8222,4,2,100,117,11851,11857,104,97,114,59,1,10599,115,104,97,114,59,1,10571,104,59,1,8626,4,5,59,102,103,113,115,11880,11882,12008,12011,12031,1,8804,116,4,5,97,104,108,114,116,11895,11913,11935,11947,11996,114,114,111,119,4,2,59,116,11905,11907,1,8592,97,105,108,59,1,8610,97,114,112,111,111,110,4,2,100,117,11925,11931,111,119,110,59,1,8637,112,59,1,8636,101,102,116,97,114,114,111,119,115,59,1,8647,105,103,104,116,4,3,97,104,115,11959,11974,11984,114,114,111,119,4,2,59,115,11969,11971,1,8596,59,1,8646,97,114,112,111,111,110,115,59,1,8651,113,117,105,103,97,114,114,111,119,59,1,8621,104,114,101,101,116,105,109,101,115,59,1,8907,59,1,8922,4,3,59,113,115,12019,12021,12024,1,8804,59,1,8806,108,97,110,116,59,1,10877,4,5,59,99,100,103,115,12043,12045,12049,12070,12083,1,10877,99,59,1,10920,111,116,4,2,59,111,12057,12059,1,10879,4,2,59,114,12065,12067,1,10881,59,1,10883,4,2,59,101,12076,12079,3,8922,65024,115,59,1,10899,4,5,97,100,101,103,115,12095,12103,12108,12126,12131,112,112,114,111,120,59,1,10885,111,116,59,1,8918,113,4,2,103,113,12115,12120,116,114,59,1,8922,103,116,114,59,1,10891,116,114,59,1,8822,105,109,59,1,8818,4,3,105,108,114,12144,12150,12156,115,104,116,59,1,10620,111,111,114,59,1,8970,59,3,55349,56617,4,2,59,69,12166,12168,1,8822,59,1,10897,4,2,97,98,12177,12198,114,4,2,100,117,12184,12187,59,1,8637,4,2,59,108,12193,12195,1,8636,59,1,10602,108,107,59,1,9604,99,121,59,1,1113,4,5,59,97,99,104,116,12220,12222,12227,12235,12241,1,8810,114,114,59,1,8647,111,114,110,101,114,59,1,8990,97,114,100,59,1,10603,114,105,59,1,9722,4,2,105,111,12252,12258,100,111,116,59,1,320,117,115,116,4,2,59,97,12267,12269,1,9136,99,104,101,59,1,9136,4,4,69,97,101,115,12285,12288,12303,12322,59,1,8808,112,4,2,59,112,12295,12297,1,10889,114,111,120,59,1,10889,4,2,59,113,12309,12311,1,10887,4,2,59,113,12317,12319,1,10887,59,1,8808,105,109,59,1,8934,4,8,97,98,110,111,112,116,119,122,12345,12359,12364,12421,12446,12467,12474,12490,4,2,110,114,12351,12355,103,59,1,10220,114,59,1,8701,114,107,59,1,10214,103,4,3,108,109,114,12373,12401,12409,101,102,116,4,2,97,114,12382,12389,114,114,111,119,59,1,10229,105,103,104,116,97,114,114,111,119,59,1,10231,97,112,115,116,111,59,1,10236,105,103,104,116,97,114,114,111,119,59,1,10230,112,97,114,114,111,119,4,2,108,114,12433,12439,101,102,116,59,1,8619,105,103,104,116,59,1,8620,4,3,97,102,108,12454,12458,12462,114,59,1,10629,59,3,55349,56669,117,115,59,1,10797,105,109,101,115,59,1,10804,4,2,97,98,12480,12485,115,116,59,1,8727,97,114,59,1,95,4,3,59,101,102,12498,12500,12506,1,9674,110,103,101,59,1,9674,59,1,10731,97,114,4,2,59,108,12517,12519,1,40,116,59,1,10643,4,5,97,99,104,109,116,12535,12540,12548,12561,12564,114,114,59,1,8646,111,114,110,101,114,59,1,8991,97,114,4,2,59,100,12556,12558,1,8651,59,1,10605,59,1,8206,114,105,59,1,8895,4,6,97,99,104,105,113,116,12583,12589,12594,12597,12614,12635,113,117,111,59,1,8249,114,59,3,55349,56513,59,1,8624,109,4,3,59,101,103,12606,12608,12611,1,8818,59,1,10893,59,1,10895,4,2,98,117,12620,12623,59,1,91,111,4,2,59,114,12630,12632,1,8216,59,1,8218,114,111,107,59,1,322,5,60,8,59,99,100,104,105,108,113,114,12660,12662,12675,12680,12686,12692,12698,12705,1,60,4,2,99,105,12668,12671,59,1,10918,114,59,1,10873,111,116,59,1,8918,114,101,101,59,1,8907,109,101,115,59,1,8905,97,114,114,59,1,10614,117,101,115,116,59,1,10875,4,2,80,105,12711,12716,97,114,59,1,10646,4,3,59,101,102,12724,12726,12729,1,9667,59,1,8884,59,1,9666,114,4,2,100,117,12739,12746,115,104,97,114,59,1,10570,104,97,114,59,1,10598,4,2,101,110,12758,12768,114,116,110,101,113,113,59,3,8808,65024,69,59,3,8808,65024,4,14,68,97,99,100,101,102,104,105,108,110,111,112,115,117,12803,12809,12893,12908,12914,12928,12933,12937,13011,13025,13032,13049,13052,13069,68,111,116,59,1,8762,4,4,99,108,112,114,12819,12827,12849,12887,114,5,175,1,59,12825,1,175,4,2,101,116,12833,12836,59,1,9794,4,2,59,101,12842,12844,1,10016,115,101,59,1,10016,4,2,59,115,12855,12857,1,8614,116,111,4,4,59,100,108,117,12869,12871,12877,12883,1,8614,111,119,110,59,1,8615,101,102,116,59,1,8612,112,59,1,8613,107,101,114,59,1,9646,4,2,111,121,12899,12905,109,109,97,59,1,10793,59,1,1084,97,115,104,59,1,8212,97,115,117,114,101,100,97,110,103,108,101,59,1,8737,114,59,3,55349,56618,111,59,1,8487,4,3,99,100,110,12945,12954,12985,114,111,5,181,1,59,12952,1,181,4,4,59,97,99,100,12964,12966,12971,12976,1,8739,115,116,59,1,42,105,114,59,1,10992,111,116,5,183,1,59,12983,1,183,117,115,4,3,59,98,100,12995,12997,13000,1,8722,59,1,8863,4,2,59,117,13006,13008,1,8760,59,1,10794,4,2,99,100,13017,13021,112,59,1,10971,114,59,1,8230,112,108,117,115,59,1,8723,4,2,100,112,13038,13044,101,108,115,59,1,8871,102,59,3,55349,56670,59,1,8723,4,2,99,116,13058,13063,114,59,3,55349,56514,112,111,115,59,1,8766,4,3,59,108,109,13077,13079,13087,1,956,116,105,109,97,112,59,1,8888,97,112,59,1,8888,4,24,71,76,82,86,97,98,99,100,101,102,103,104,105,106,108,109,111,112,114,115,116,117,118,119,13142,13165,13217,13229,13247,13330,13359,13414,13420,13508,13513,13579,13602,13626,13631,13762,13767,13855,13936,13995,14214,14285,14312,14432,4,2,103,116,13148,13152,59,3,8921,824,4,2,59,118,13158,13161,3,8811,8402,59,3,8811,824,4,3,101,108,116,13173,13200,13204,102,116,4,2,97,114,13181,13188,114,114,111,119,59,1,8653,105,103,104,116,97,114,114,111,119,59,1,8654,59,3,8920,824,4,2,59,118,13210,13213,3,8810,8402,59,3,8810,824,105,103,104,116,97,114,114,111,119,59,1,8655,4,2,68,100,13235,13241,97,115,104,59,1,8879,97,115,104,59,1,8878,4,5,98,99,110,112,116,13259,13264,13270,13275,13308,108,97,59,1,8711,117,116,101,59,1,324,103,59,3,8736,8402,4,5,59,69,105,111,112,13287,13289,13293,13298,13302,1,8777,59,3,10864,824,100,59,3,8779,824,115,59,1,329,114,111,120,59,1,8777,117,114,4,2,59,97,13316,13318,1,9838,108,4,2,59,115,13325,13327,1,9838,59,1,8469,4,2,115,117,13336,13344,112,5,160,1,59,13342,1,160,109,112,4,2,59,101,13352,13355,3,8782,824,59,3,8783,824,4,5,97,101,111,117,121,13371,13385,13391,13407,13411,4,2,112,114,13377,13380,59,1,10819,111,110,59,1,328,100,105,108,59,1,326,110,103,4,2,59,100,13399,13401,1,8775,111,116,59,3,10861,824,112,59,1,10818,59,1,1085,97,115,104,59,1,8211,4,7,59,65,97,100,113,115,120,13436,13438,13443,13466,13472,13478,13494,1,8800,114,114,59,1,8663,114,4,2,104,114,13450,13454,107,59,1,10532,4,2,59,111,13460,13462,1,8599,119,59,1,8599,111,116,59,3,8784,824,117,105,118,59,1,8802,4,2,101,105,13484,13489,97,114,59,1,10536,109,59,3,8770,824,105,115,116,4,2,59,115,13503,13505,1,8708,59,1,8708,114,59,3,55349,56619,4,4,69,101,115,116,13523,13527,13563,13568,59,3,8807,824,4,3,59,113,115,13535,13537,13559,1,8817,4,3,59,113,115,13545,13547,13551,1,8817,59,3,8807,824,108,97,110,116,59,3,10878,824,59,3,10878,824,105,109,59,1,8821,4,2,59,114,13574,13576,1,8815,59,1,8815,4,3,65,97,112,13587,13592,13597,114,114,59,1,8654,114,114,59,1,8622,97,114,59,1,10994,4,3,59,115,118,13610,13612,13623,1,8715,4,2,59,100,13618,13620,1,8956,59,1,8954,59,1,8715,99,121,59,1,1114,4,7,65,69,97,100,101,115,116,13647,13652,13656,13661,13665,13737,13742,114,114,59,1,8653,59,3,8806,824,114,114,59,1,8602,114,59,1,8229,4,4,59,102,113,115,13675,13677,13703,13725,1,8816,116,4,2,97,114,13684,13691,114,114,111,119,59,1,8602,105,103,104,116,97,114,114,111,119,59,1,8622,4,3,59,113,115,13711,13713,13717,1,8816,59,3,8806,824,108,97,110,116,59,3,10877,824,4,2,59,115,13731,13734,3,10877,824,59,1,8814,105,109,59,1,8820,4,2,59,114,13748,13750,1,8814,105,4,2,59,101,13757,13759,1,8938,59,1,8940,105,100,59,1,8740,4,2,112,116,13773,13778,102,59,3,55349,56671,5,172,3,59,105,110,13787,13789,13829,1,172,110,4,4,59,69,100,118,13800,13802,13806,13812,1,8713,59,3,8953,824,111,116,59,3,8949,824,4,3,97,98,99,13820,13823,13826,59,1,8713,59,1,8951,59,1,8950,105,4,2,59,118,13836,13838,1,8716,4,3,97,98,99,13846,13849,13852,59,1,8716,59,1,8958,59,1,8957,4,3,97,111,114,13863,13892,13899,114,4,4,59,97,115,116,13874,13876,13883,13888,1,8742,108,108,101,108,59,1,8742,108,59,3,11005,8421,59,3,8706,824,108,105,110,116,59,1,10772,4,3,59,99,101,13907,13909,13914,1,8832,117,101,59,1,8928,4,2,59,99,13920,13923,3,10927,824,4,2,59,101,13929,13931,1,8832,113,59,3,10927,824,4,4,65,97,105,116,13946,13951,13971,13982,114,114,59,1,8655,114,114,4,3,59,99,119,13961,13963,13967,1,8603,59,3,10547,824,59,3,8605,824,103,104,116,97,114,114,111,119,59,1,8603,114,105,4,2,59,101,13990,13992,1,8939,59,1,8941,4,7,99,104,105,109,112,113,117,14011,14036,14060,14080,14085,14090,14106,4,4,59,99,101,114,14021,14023,14028,14032,1,8833,117,101,59,1,8929,59,3,10928,824,59,3,55349,56515,111,114,116,4,2,109,112,14045,14050,105,100,59,1,8740,97,114,97,108,108,101,108,59,1,8742,109,4,2,59,101,14067,14069,1,8769,4,2,59,113,14075,14077,1,8772,59,1,8772,105,100,59,1,8740,97,114,59,1,8742,115,117,4,2,98,112,14098,14102,101,59,1,8930,101,59,1,8931,4,3,98,99,112,14114,14157,14171,4,4,59,69,101,115,14124,14126,14130,14133,1,8836,59,3,10949,824,59,1,8840,101,116,4,2,59,101,14141,14144,3,8834,8402,113,4,2,59,113,14151,14153,1,8840,59,3,10949,824,99,4,2,59,101,14164,14166,1,8833,113,59,3,10928,824,4,4,59,69,101,115,14181,14183,14187,14190,1,8837,59,3,10950,824,59,1,8841,101,116,4,2,59,101,14198,14201,3,8835,8402,113,4,2,59,113,14208,14210,1,8841,59,3,10950,824,4,4,103,105,108,114,14224,14228,14238,14242,108,59,1,8825,108,100,101,5,241,1,59,14236,1,241,103,59,1,8824,105,97,110,103,108,101,4,2,108,114,14254,14269,101,102,116,4,2,59,101,14263,14265,1,8938,113,59,1,8940,105,103,104,116,4,2,59,101,14279,14281,1,8939,113,59,1,8941,4,2,59,109,14291,14293,1,957,4,3,59,101,115,14301,14303,14308,1,35,114,111,59,1,8470,112,59,1,8199,4,9,68,72,97,100,103,105,108,114,115,14332,14338,14344,14349,14355,14369,14376,14408,14426,97,115,104,59,1,8877,97,114,114,59,1,10500,112,59,3,8781,8402,97,115,104,59,1,8876,4,2,101,116,14361,14365,59,3,8805,8402,59,3,62,8402,110,102,105,110,59,1,10718,4,3,65,101,116,14384,14389,14393,114,114,59,1,10498,59,3,8804,8402,4,2,59,114,14399,14402,3,60,8402,105,101,59,3,8884,8402,4,2,65,116,14414,14419,114,114,59,1,10499,114,105,101,59,3,8885,8402,105,109,59,3,8764,8402,4,3,65,97,110,14440,14445,14468,114,114,59,1,8662,114,4,2,104,114,14452,14456,107,59,1,10531,4,2,59,111,14462,14464,1,8598,119,59,1,8598,101,97,114,59,1,10535,4,18,83,97,99,100,101,102,103,104,105,108,109,111,112,114,115,116,117,118,14512,14515,14535,14560,14597,14603,14618,14643,14657,14662,14701,14741,14747,14769,14851,14877,14907,14916,59,1,9416,4,2,99,115,14521,14531,117,116,101,5,243,1,59,14529,1,243,116,59,1,8859,4,2,105,121,14541,14557,114,4,2,59,99,14548,14550,1,8858,5,244,1,59,14555,1,244,59,1,1086,4,5,97,98,105,111,115,14572,14577,14583,14587,14591,115,104,59,1,8861,108,97,99,59,1,337,118,59,1,10808,116,59,1,8857,111,108,100,59,1,10684,108,105,103,59,1,339,4,2,99,114,14609,14614,105,114,59,1,10687,59,3,55349,56620,4,3,111,114,116,14626,14630,14640,110,59,1,731,97,118,101,5,242,1,59,14638,1,242,59,1,10689,4,2,98,109,14649,14654,97,114,59,1,10677,59,1,937,110,116,59,1,8750,4,4,97,99,105,116,14672,14677,14693,14698,114,114,59,1,8634,4,2,105,114,14683,14687,114,59,1,10686,111,115,115,59,1,10683,110,101,59,1,8254,59,1,10688,4,3,97,101,105,14709,14714,14719,99,114,59,1,333,103,97,59,1,969,4,3,99,100,110,14727,14733,14736,114,111,110,59,1,959,59,1,10678,117,115,59,1,8854,112,102,59,3,55349,56672,4,3,97,101,108,14755,14759,14764,114,59,1,10679,114,112,59,1,10681,117,115,59,1,8853,4,7,59,97,100,105,111,115,118,14785,14787,14792,14831,14837,14841,14848,1,8744,114,114,59,1,8635,4,4,59,101,102,109,14802,14804,14817,14824,1,10845,114,4,2,59,111,14811,14813,1,8500,102,59,1,8500,5,170,1,59,14822,1,170,5,186,1,59,14829,1,186,103,111,102,59,1,8886,114,59,1,10838,108,111,112,101,59,1,10839,59,1,10843,4,3,99,108,111,14859,14863,14873,114,59,1,8500,97,115,104,5,248,1,59,14871,1,248,108,59,1,8856,105,4,2,108,109,14884,14893,100,101,5,245,1,59,14891,1,245,101,115,4,2,59,97,14901,14903,1,8855,115,59,1,10806,109,108,5,246,1,59,14914,1,246,98,97,114,59,1,9021,4,12,97,99,101,102,104,105,108,109,111,114,115,117,14948,14992,14996,15033,15038,15068,15090,15189,15192,15222,15427,15441,114,4,4,59,97,115,116,14959,14961,14976,14989,1,8741,5,182,2,59,108,14968,14970,1,182,108,101,108,59,1,8741,4,2,105,108,14982,14986,109,59,1,10995,59,1,11005,59,1,8706,121,59,1,1087,114,4,5,99,105,109,112,116,15009,15014,15019,15024,15027,110,116,59,1,37,111,100,59,1,46,105,108,59,1,8240,59,1,8869,101,110,107,59,1,8241,114,59,3,55349,56621,4,3,105,109,111,15046,15057,15063,4,2,59,118,15052,15054,1,966,59,1,981,109,97,116,59,1,8499,110,101,59,1,9742,4,3,59,116,118,15076,15078,15087,1,960,99,104,102,111,114,107,59,1,8916,59,1,982,4,2,97,117,15096,15119,110,4,2,99,107,15103,15115,107,4,2,59,104,15110,15112,1,8463,59,1,8462,118,59,1,8463,115,4,9,59,97,98,99,100,101,109,115,116,15140,15142,15148,15151,15156,15168,15171,15179,15184,1,43,99,105,114,59,1,10787,59,1,8862,105,114,59,1,10786,4,2,111,117,15162,15165,59,1,8724,59,1,10789,59,1,10866,110,5,177,1,59,15177,1,177,105,109,59,1,10790,119,111,59,1,10791,59,1,177,4,3,105,112,117,15200,15208,15213,110,116,105,110,116,59,1,10773,102,59,3,55349,56673,110,100,5,163,1,59,15220,1,163,4,10,59,69,97,99,101,105,110,111,115,117,15244,15246,15249,15253,15258,15334,15347,15367,15416,15421,1,8826,59,1,10931,112,59,1,10935,117,101,59,1,8828,4,2,59,99,15264,15266,1,10927,4,6,59,97,99,101,110,115,15280,15282,15290,15299,15303,15329,1,8826,112,112,114,111,120,59,1,10935,117,114,108,121,101,113,59,1,8828,113,59,1,10927,4,3,97,101,115,15311,15319,15324,112,112,114,111,120,59,1,10937,113,113,59,1,10933,105,109,59,1,8936,105,109,59,1,8830,109,101,4,2,59,115,15342,15344,1,8242,59,1,8473,4,3,69,97,115,15355,15358,15362,59,1,10933,112,59,1,10937,105,109,59,1,8936,4,3,100,102,112,15375,15378,15404,59,1,8719,4,3,97,108,115,15386,15392,15398,108,97,114,59,1,9006,105,110,101,59,1,8978,117,114,102,59,1,8979,4,2,59,116,15410,15412,1,8733,111,59,1,8733,105,109,59,1,8830,114,101,108,59,1,8880,4,2,99,105,15433,15438,114,59,3,55349,56517,59,1,968,110,99,115,112,59,1,8200,4,6,102,105,111,112,115,117,15462,15467,15472,15478,15485,15491,114,59,3,55349,56622,110,116,59,1,10764,112,102,59,3,55349,56674,114,105,109,101,59,1,8279,99,114,59,3,55349,56518,4,3,97,101,111,15499,15520,15534,116,4,2,101,105,15506,15515,114,110,105,111,110,115,59,1,8461,110,116,59,1,10774,115,116,4,2,59,101,15528,15530,1,63,113,59,1,8799,116,5,34,1,59,15540,1,34,4,21,65,66,72,97,98,99,100,101,102,104,105,108,109,110,111,112,114,115,116,117,120,15586,15609,15615,15620,15796,15855,15893,15931,15977,16001,16039,16183,16204,16222,16228,16285,16312,16318,16363,16408,16416,4,3,97,114,116,15594,15599,15603,114,114,59,1,8667,114,59,1,8658,97,105,108,59,1,10524,97,114,114,59,1,10511,97,114,59,1,10596,4,7,99,100,101,110,113,114,116,15636,15651,15656,15664,15687,15696,15770,4,2,101,117,15642,15646,59,3,8765,817,116,101,59,1,341,105,99,59,1,8730,109,112,116,121,118,59,1,10675,103,4,4,59,100,101,108,15675,15677,15680,15683,1,10217,59,1,10642,59,1,10661,101,59,1,10217,117,111,5,187,1,59,15694,1,187,114,4,11,59,97,98,99,102,104,108,112,115,116,119,15721,15723,15727,15739,15742,15746,15750,15754,15758,15763,15767,1,8594,112,59,1,10613,4,2,59,102,15733,15735,1,8677,115,59,1,10528,59,1,10547,115,59,1,10526,107,59,1,8618,112,59,1,8620,108,59,1,10565,105,109,59,1,10612,108,59,1,8611,59,1,8605,4,2,97,105,15776,15781,105,108,59,1,10522,111,4,2,59,110,15788,15790,1,8758,97,108,115,59,1,8474,4,3,97,98,114,15804,15809,15814,114,114,59,1,10509,114,107,59,1,10099,4,2,97,107,15820,15833,99,4,2,101,107,15827,15830,59,1,125,59,1,93,4,2,101,115,15839,15842,59,1,10636,108,4,2,100,117,15849,15852,59,1,10638,59,1,10640,4,4,97,101,117,121,15865,15871,15886,15890,114,111,110,59,1,345,4,2,100,105,15877,15882,105,108,59,1,343,108,59,1,8969,98,59,1,125,59,1,1088,4,4,99,108,113,115,15903,15907,15914,15927,97,59,1,10551,100,104,97,114,59,1,10601,117,111,4,2,59,114,15922,15924,1,8221,59,1,8221,104,59,1,8627,4,3,97,99,103,15939,15966,15970,108,4,4,59,105,112,115,15950,15952,15957,15963,1,8476,110,101,59,1,8475,97,114,116,59,1,8476,59,1,8477,116,59,1,9645,5,174,1,59,15975,1,174,4,3,105,108,114,15985,15991,15997,115,104,116,59,1,10621,111,111,114,59,1,8971,59,3,55349,56623,4,2,97,111,16007,16028,114,4,2,100,117,16014,16017,59,1,8641,4,2,59,108,16023,16025,1,8640,59,1,10604,4,2,59,118,16034,16036,1,961,59,1,1009,4,3,103,110,115,16047,16167,16171,104,116,4,6,97,104,108,114,115,116,16063,16081,16103,16130,16143,16155,114,114,111,119,4,2,59,116,16073,16075,1,8594,97,105,108,59,1,8611,97,114,112,111,111,110,4,2,100,117,16093,16099,111,119,110,59,1,8641,112,59,1,8640,101,102,116,4,2,97,104,16112,16120,114,114,111,119,115,59,1,8644,97,114,112,111,111,110,115,59,1,8652,105,103,104,116,97,114,114,111,119,115,59,1,8649,113,117,105,103,97,114,114,111,119,59,1,8605,104,114,101,101,116,105,109,101,115,59,1,8908,103,59,1,730,105,110,103,100,111,116,115,101,113,59,1,8787,4,3,97,104,109,16191,16196,16201,114,114,59,1,8644,97,114,59,1,8652,59,1,8207,111,117,115,116,4,2,59,97,16214,16216,1,9137,99,104,101,59,1,9137,109,105,100,59,1,10990,4,4,97,98,112,116,16238,16252,16257,16278,4,2,110,114,16244,16248,103,59,1,10221,114,59,1,8702,114,107,59,1,10215,4,3,97,102,108,16265,16269,16273,114,59,1,10630,59,3,55349,56675,117,115,59,1,10798,105,109,101,115,59,1,10805,4,2,97,112,16291,16304,114,4,2,59,103,16298,16300,1,41,116,59,1,10644,111,108,105,110,116,59,1,10770,97,114,114,59,1,8649,4,4,97,99,104,113,16328,16334,16339,16342,113,117,111,59,1,8250,114,59,3,55349,56519,59,1,8625,4,2,98,117,16348,16351,59,1,93,111,4,2,59,114,16358,16360,1,8217,59,1,8217,4,3,104,105,114,16371,16377,16383,114,101,101,59,1,8908,109,101,115,59,1,8906,105,4,4,59,101,102,108,16394,16396,16399,16402,1,9657,59,1,8885,59,1,9656,116,114,105,59,1,10702,108,117,104,97,114,59,1,10600,59,1,8478,4,19,97,98,99,100,101,102,104,105,108,109,111,112,113,114,115,116,117,119,122,16459,16466,16472,16572,16590,16672,16687,16746,16844,16850,16924,16963,16988,17115,17121,17154,17206,17614,17656,99,117,116,101,59,1,347,113,117,111,59,1,8218,4,10,59,69,97,99,101,105,110,112,115,121,16494,16496,16499,16513,16518,16531,16536,16556,16564,16569,1,8827,59,1,10932,4,2,112,114,16505,16508,59,1,10936,111,110,59,1,353,117,101,59,1,8829,4,2,59,100,16524,16526,1,10928,105,108,59,1,351,114,99,59,1,349,4,3,69,97,115,16544,16547,16551,59,1,10934,112,59,1,10938,105,109,59,1,8937,111,108,105,110,116,59,1,10771,105,109,59,1,8831,59,1,1089,111,116,4,3,59,98,101,16582,16584,16587,1,8901,59,1,8865,59,1,10854,4,7,65,97,99,109,115,116,120,16606,16611,16634,16642,16646,16652,16668,114,114,59,1,8664,114,4,2,104,114,16618,16622,107,59,1,10533,4,2,59,111,16628,16630,1,8600,119,59,1,8600,116,5,167,1,59,16640,1,167,105,59,1,59,119,97,114,59,1,10537,109,4,2,105,110,16659,16665,110,117,115,59,1,8726,59,1,8726,116,59,1,10038,114,4,2,59,111,16679,16682,3,55349,56624,119,110,59,1,8994,4,4,97,99,111,121,16697,16702,16716,16739,114,112,59,1,9839,4,2,104,121,16708,16713,99,121,59,1,1097,59,1,1096,114,116,4,2,109,112,16724,16729,105,100,59,1,8739,97,114,97,108,108,101,108,59,1,8741,5,173,1,59,16744,1,173,4,2,103,109,16752,16770,109,97,4,3,59,102,118,16762,16764,16767,1,963,59,1,962,59,1,962,4,8,59,100,101,103,108,110,112,114,16788,16790,16795,16806,16817,16828,16832,16838,1,8764,111,116,59,1,10858,4,2,59,113,16801,16803,1,8771,59,1,8771,4,2,59,69,16812,16814,1,10910,59,1,10912,4,2,59,69,16823,16825,1,10909,59,1,10911,101,59,1,8774,108,117,115,59,1,10788,97,114,114,59,1,10610,97,114,114,59,1,8592,4,4,97,101,105,116,16860,16883,16891,16904,4,2,108,115,16866,16878,108,115,101,116,109,105,110,117,115,59,1,8726,104,112,59,1,10803,112,97,114,115,108,59,1,10724,4,2,100,108,16897,16900,59,1,8739,101,59,1,8995,4,2,59,101,16910,16912,1,10922,4,2,59,115,16918,16920,1,10924,59,3,10924,65024,4,3,102,108,112,16932,16938,16958,116,99,121,59,1,1100,4,2,59,98,16944,16946,1,47,4,2,59,97,16952,16954,1,10692,114,59,1,9023,102,59,3,55349,56676,97,4,2,100,114,16970,16985,101,115,4,2,59,117,16978,16980,1,9824,105,116,59,1,9824,59,1,8741,4,3,99,115,117,16996,17028,17089,4,2,97,117,17002,17015,112,4,2,59,115,17009,17011,1,8851,59,3,8851,65024,112,4,2,59,115,17022,17024,1,8852,59,3,8852,65024,117,4,2,98,112,17035,17062,4,3,59,101,115,17043,17045,17048,1,8847,59,1,8849,101,116,4,2,59,101,17056,17058,1,8847,113,59,1,8849,4,3,59,101,115,17070,17072,17075,1,8848,59,1,8850,101,116,4,2,59,101,17083,17085,1,8848,113,59,1,8850,4,3,59,97,102,17097,17099,17112,1,9633,114,4,2,101,102,17106,17109,59,1,9633,59,1,9642,59,1,9642,97,114,114,59,1,8594,4,4,99,101,109,116,17131,17136,17142,17148,114,59,3,55349,56520,116,109,110,59,1,8726,105,108,101,59,1,8995,97,114,102,59,1,8902,4,2,97,114,17160,17172,114,4,2,59,102,17167,17169,1,9734,59,1,9733,4,2,97,110,17178,17202,105,103,104,116,4,2,101,112,17188,17197,112,115,105,108,111,110,59,1,1013,104,105,59,1,981,115,59,1,175,4,5,98,99,109,110,112,17218,17351,17420,17423,17427,4,9,59,69,100,101,109,110,112,114,115,17238,17240,17243,17248,17261,17267,17279,17285,17291,1,8834,59,1,10949,111,116,59,1,10941,4,2,59,100,17254,17256,1,8838,111,116,59,1,10947,117,108,116,59,1,10945,4,2,69,101,17273,17276,59,1,10955,59,1,8842,108,117,115,59,1,10943,97,114,114,59,1,10617,4,3,101,105,117,17299,17335,17339,116,4,3,59,101,110,17308,17310,17322,1,8834,113,4,2,59,113,17317,17319,1,8838,59,1,10949,101,113,4,2,59,113,17330,17332,1,8842,59,1,10955,109,59,1,10951,4,2,98,112,17345,17348,59,1,10965,59,1,10963,99,4,6,59,97,99,101,110,115,17366,17368,17376,17385,17389,17415,1,8827,112,112,114,111,120,59,1,10936,117,114,108,121,101,113,59,1,8829,113,59,1,10928,4,3,97,101,115,17397,17405,17410,112,112,114,111,120,59,1,10938,113,113,59,1,10934,105,109,59,1,8937,105,109,59,1,8831,59,1,8721,103,59,1,9834,4,13,49,50,51,59,69,100,101,104,108,109,110,112,115,17455,17462,17469,17476,17478,17481,17496,17509,17524,17530,17536,17548,17554,5,185,1,59,17460,1,185,5,178,1,59,17467,1,178,5,179,1,59,17474,1,179,1,8835,59,1,10950,4,2,111,115,17487,17491,116,59,1,10942,117,98,59,1,10968,4,2,59,100,17502,17504,1,8839,111,116,59,1,10948,115,4,2,111,117,17516,17520,108,59,1,10185,98,59,1,10967,97,114,114,59,1,10619,117,108,116,59,1,10946,4,2,69,101,17542,17545,59,1,10956,59,1,8843,108,117,115,59,1,10944,4,3,101,105,117,17562,17598,17602,116,4,3,59,101,110,17571,17573,17585,1,8835,113,4,2,59,113,17580,17582,1,8839,59,1,10950,101,113,4,2,59,113,17593,17595,1,8843,59,1,10956,109,59,1,10952,4,2,98,112,17608,17611,59,1,10964,59,1,10966,4,3,65,97,110,17622,17627,17650,114,114,59,1,8665,114,4,2,104,114,17634,17638,107,59,1,10534,4,2,59,111,17644,17646,1,8601,119,59,1,8601,119,97,114,59,1,10538,108,105,103,5,223,1,59,17664,1,223,4,13,97,98,99,100,101,102,104,105,111,112,114,115,119,17694,17709,17714,17737,17742,17749,17754,17860,17905,17957,17964,18090,18122,4,2,114,117,17700,17706,103,101,116,59,1,8982,59,1,964,114,107,59,1,9140,4,3,97,101,121,17722,17728,17734,114,111,110,59,1,357,100,105,108,59,1,355,59,1,1090,111,116,59,1,8411,108,114,101,99,59,1,8981,114,59,3,55349,56625,4,4,101,105,107,111,17764,17805,17836,17851,4,2,114,116,17770,17786,101,4,2,52,102,17777,17780,59,1,8756,111,114,101,59,1,8756,97,4,3,59,115,118,17795,17797,17802,1,952,121,109,59,1,977,59,1,977,4,2,99,110,17811,17831,107,4,2,97,115,17818,17826,112,112,114,111,120,59,1,8776,105,109,59,1,8764,115,112,59,1,8201,4,2,97,115,17842,17846,112,59,1,8776,105,109,59,1,8764,114,110,5,254,1,59,17858,1,254,4,3,108,109,110,17868,17873,17901,100,101,59,1,732,101,115,5,215,3,59,98,100,17884,17886,17898,1,215,4,2,59,97,17892,17894,1,8864,114,59,1,10801,59,1,10800,116,59,1,8749,4,3,101,112,115,17913,17917,17953,97,59,1,10536,4,4,59,98,99,102,17927,17929,17934,17939,1,8868,111,116,59,1,9014,105,114,59,1,10993,4,2,59,111,17945,17948,3,55349,56677,114,107,59,1,10970,97,59,1,10537,114,105,109,101,59,1,8244,4,3,97,105,112,17972,17977,18082,100,101,59,1,8482,4,7,97,100,101,109,112,115,116,17993,18051,18056,18059,18066,18072,18076,110,103,108,101,4,5,59,100,108,113,114,18009,18011,18017,18032,18035,1,9653,111,119,110,59,1,9663,101,102,116,4,2,59,101,18026,18028,1,9667,113,59,1,8884,59,1,8796,105,103,104,116,4,2,59,101,18045,18047,1,9657,113,59,1,8885,111,116,59,1,9708,59,1,8796,105,110,117,115,59,1,10810,108,117,115,59,1,10809,98,59,1,10701,105,109,101,59,1,10811,101,122,105,117,109,59,1,9186,4,3,99,104,116,18098,18111,18116,4,2,114,121,18104,18108,59,3,55349,56521,59,1,1094,99,121,59,1,1115,114,111,107,59,1,359,4,2,105,111,18128,18133,120,116,59,1,8812,104,101,97,100,4,2,108,114,18143,18154,101,102,116,97,114,114,111,119,59,1,8606,105,103,104,116,97,114,114,111,119,59,1,8608,4,18,65,72,97,98,99,100,102,103,104,108,109,111,112,114,115,116,117,119,18204,18209,18214,18234,18250,18268,18292,18308,18319,18343,18379,18397,18413,18504,18547,18553,18584,18603,114,114,59,1,8657,97,114,59,1,10595,4,2,99,114,18220,18230,117,116,101,5,250,1,59,18228,1,250,114,59,1,8593,114,4,2,99,101,18241,18245,121,59,1,1118,118,101,59,1,365,4,2,105,121,18256,18265,114,99,5,251,1,59,18263,1,251,59,1,1091,4,3,97,98,104,18276,18281,18287,114,114,59,1,8645,108,97,99,59,1,369,97,114,59,1,10606,4,2,105,114,18298,18304,115,104,116,59,1,10622,59,3,55349,56626,114,97,118,101,5,249,1,59,18317,1,249,4,2,97,98,18325,18338,114,4,2,108,114,18332,18335,59,1,8639,59,1,8638,108,107,59,1,9600,4,2,99,116,18349,18374,4,2,111,114,18355,18369,114,110,4,2,59,101,18363,18365,1,8988,114,59,1,8988,111,112,59,1,8975,114,105,59,1,9720,4,2,97,108,18385,18390,99,114,59,1,363,5,168,1,59,18395,1,168,4,2,103,112,18403,18408,111,110,59,1,371,102,59,3,55349,56678,4,6,97,100,104,108,115,117,18427,18434,18445,18470,18475,18494,114,114,111,119,59,1,8593,111,119,110,97,114,114,111,119,59,1,8597,97,114,112,111,111,110,4,2,108,114,18457,18463,101,102,116,59,1,8639,105,103,104,116,59,1,8638,117,115,59,1,8846,105,4,3,59,104,108,18484,18486,18489,1,965,59,1,978,111,110,59,1,965,112,97,114,114,111,119,115,59,1,8648,4,3,99,105,116,18512,18537,18542,4,2,111,114,18518,18532,114,110,4,2,59,101,18526,18528,1,8989,114,59,1,8989,111,112,59,1,8974,110,103,59,1,367,114,105,59,1,9721,99,114,59,3,55349,56522,4,3,100,105,114,18561,18566,18572,111,116,59,1,8944,108,100,101,59,1,361,105,4,2,59,102,18579,18581,1,9653,59,1,9652,4,2,97,109,18590,18595,114,114,59,1,8648,108,5,252,1,59,18601,1,252,97,110,103,108,101,59,1,10663,4,15,65,66,68,97,99,100,101,102,108,110,111,112,114,115,122,18643,18648,18661,18667,18847,18851,18857,18904,18909,18915,18931,18937,18943,18949,18996,114,114,59,1,8661,97,114,4,2,59,118,18656,18658,1,10984,59,1,10985,97,115,104,59,1,8872,4,2,110,114,18673,18679,103,114,116,59,1,10652,4,7,101,107,110,112,114,115,116,18695,18704,18711,18720,18742,18754,18810,112,115,105,108,111,110,59,1,1013,97,112,112,97,59,1,1008,111,116,104,105,110,103,59,1,8709,4,3,104,105,114,18728,18732,18735,105,59,1,981,59,1,982,111,112,116,111,59,1,8733,4,2,59,104,18748,18750,1,8597,111,59,1,1009,4,2,105,117,18760,18766,103,109,97,59,1,962,4,2,98,112,18772,18791,115,101,116,110,101,113,4,2,59,113,18784,18787,3,8842,65024,59,3,10955,65024,115,101,116,110,101,113,4,2,59,113,18803,18806,3,8843,65024,59,3,10956,65024,4,2,104,114,18816,18822,101,116,97,59,1,977,105,97,110,103,108,101,4,2,108,114,18834,18840,101,102,116,59,1,8882,105,103,104,116,59,1,8883,121,59,1,1074,97,115,104,59,1,8866,4,3,101,108,114,18865,18884,18890,4,3,59,98,101,18873,18875,18880,1,8744,97,114,59,1,8891,113,59,1,8794,108,105,112,59,1,8942,4,2,98,116,18896,18901,97,114,59,1,124,59,1,124,114,59,3,55349,56627,116,114,105,59,1,8882,115,117,4,2,98,112,18923,18927,59,3,8834,8402,59,3,8835,8402,112,102,59,3,55349,56679,114,111,112,59,1,8733,116,114,105,59,1,8883,4,2,99,117,18955,18960,114,59,3,55349,56523,4,2,98,112,18966,18981,110,4,2,69,101,18973,18977,59,3,10955,65024,59,3,8842,65024,110,4,2,69,101,18988,18992,59,3,10956,65024,59,3,8843,65024,105,103,122,97,103,59,1,10650,4,7,99,101,102,111,112,114,115,19020,19026,19061,19066,19072,19075,19089,105,114,99,59,1,373,4,2,100,105,19032,19055,4,2,98,103,19038,19043,97,114,59,1,10847,101,4,2,59,113,19050,19052,1,8743,59,1,8793,101,114,112,59,1,8472,114,59,3,55349,56628,112,102,59,3,55349,56680,59,1,8472,4,2,59,101,19081,19083,1,8768,97,116,104,59,1,8768,99,114,59,3,55349,56524,4,14,99,100,102,104,105,108,109,110,111,114,115,117,118,119,19125,19146,19152,19157,19173,19176,19192,19197,19202,19236,19252,19269,19286,19291,4,3,97,105,117,19133,19137,19142,112,59,1,8898,114,99,59,1,9711,112,59,1,8899,116,114,105,59,1,9661,114,59,3,55349,56629,4,2,65,97,19163,19168,114,114,59,1,10234,114,114,59,1,10231,59,1,958,4,2,65,97,19182,19187,114,114,59,1,10232,114,114,59,1,10229,97,112,59,1,10236,105,115,59,1,8955,4,3,100,112,116,19210,19215,19230,111,116,59,1,10752,4,2,102,108,19221,19225,59,3,55349,56681,117,115,59,1,10753,105,109,101,59,1,10754,4,2,65,97,19242,19247,114,114,59,1,10233,114,114,59,1,10230,4,2,99,113,19258,19263,114,59,3,55349,56525,99,117,112,59,1,10758,4,2,112,116,19275,19281,108,117,115,59,1,10756,114,105,59,1,9651,101,101,59,1,8897,101,100,103,101,59,1,8896,4,8,97,99,101,102,105,111,115,117,19316,19335,19349,19357,19362,19367,19373,19379,99,4,2,117,121,19323,19332,116,101,5,253,1,59,19330,1,253,59,1,1103,4,2,105,121,19341,19346,114,99,59,1,375,59,1,1099,110,5,165,1,59,19355,1,165,114,59,3,55349,56630,99,121,59,1,1111,112,102,59,3,55349,56682,99,114,59,3,55349,56526,4,2,99,109,19385,19389,121,59,1,1102,108,5,255,1,59,19395,1,255,4,10,97,99,100,101,102,104,105,111,115,119,19419,19426,19441,19446,19462,19467,19472,19480,19486,19492,99,117,116,101,59,1,378,4,2,97,121,19432,19438,114,111,110,59,1,382,59,1,1079,111,116,59,1,380,4,2,101,116,19452,19458,116,114,102,59,1,8488,97,59,1,950,114,59,3,55349,56631,99,121,59,1,1078,103,114,97,114,114,59,1,8669,112,102,59,3,55349,56683,99,114,59,3,55349,56527,4,2,106,110,19498,19501,59,1,8205,106,59,1,8204]);

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var UNICODE = __webpack_require__(20);

//Aliases
var $ = UNICODE.CODE_POINTS;

//Utils

//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline
//this functions if they will be situated in another module due to context switch.
//Always perform inlining check before modifying this functions ('node --trace-inlining').
function isSurrogatePair(cp1, cp2) {
    return cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF;
}

function getSurrogatePairCodePoint(cp1, cp2) {
    return (cp1 - 0xD800) * 0x400 + 0x2400 + cp2;
}


//Const
var DEFAULT_BUFFER_WATERLINE = 1 << 16;


//Preprocessor
//NOTE: HTML input preprocessing
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)
var Preprocessor = module.exports = function () {
    this.html = null;

    this.pos = -1;
    this.lastGapPos = -1;
    this.lastCharPos = -1;
    this.droppedBufferSize = 0;

    this.gapStack = [];

    this.skipNextNewLine = false;

    this.lastChunkWritten = false;
    this.endOfChunkHit = false;
    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
};

Object.defineProperty(Preprocessor.prototype, 'sourcePos', {
    get: function () {
        return this.droppedBufferSize + this.pos;
    }
});

Preprocessor.prototype.dropParsedChunk = function () {
    if (this.pos > this.bufferWaterline) {
        this.lastCharPos -= this.pos;
        this.droppedBufferSize += this.pos;
        this.html = this.html.substring(this.pos);
        this.pos = 0;
        this.lastGapPos = -1;
        this.gapStack = [];
    }
};

Preprocessor.prototype._addGap = function () {
    this.gapStack.push(this.lastGapPos);
    this.lastGapPos = this.pos;
};

Preprocessor.prototype._processHighRangeCodePoint = function (cp) {
    //NOTE: try to peek a surrogate pair
    if (this.pos !== this.lastCharPos) {
        var nextCp = this.html.charCodeAt(this.pos + 1);

        if (isSurrogatePair(cp, nextCp)) {
            //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.
            this.pos++;
            cp = getSurrogatePairCodePoint(cp, nextCp);

            //NOTE: add gap that should be avoided during retreat
            this._addGap();
        }
    }

    // NOTE: we've hit the end of chunk, stop processing at this point
    else if (!this.lastChunkWritten) {
        this.endOfChunkHit = true;
        return $.EOF;
    }

    return cp;
};

Preprocessor.prototype.write = function (chunk, isLastChunk) {
    if (this.html)
        this.html += chunk;

    else
        this.html = chunk;

    this.lastCharPos = this.html.length - 1;
    this.endOfChunkHit = false;
    this.lastChunkWritten = isLastChunk;
};

Preprocessor.prototype.insertHtmlAtCurrentPos = function (chunk) {
    this.html = this.html.substring(0, this.pos + 1) +
                chunk +
                this.html.substring(this.pos + 1, this.html.length);

    this.lastCharPos = this.html.length - 1;
    this.endOfChunkHit = false;
};


Preprocessor.prototype.advance = function () {
    this.pos++;

    if (this.pos > this.lastCharPos) {
        if (!this.lastChunkWritten)
            this.endOfChunkHit = true;

        return $.EOF;
    }

    var cp = this.html.charCodeAt(this.pos);

    //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character
    //must be ignored.
    if (this.skipNextNewLine && cp === $.LINE_FEED) {
        this.skipNextNewLine = false;
        this._addGap();
        return this.advance();
    }

    //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters
    if (cp === $.CARRIAGE_RETURN) {
        this.skipNextNewLine = true;
        return $.LINE_FEED;
    }

    this.skipNextNewLine = false;

    //OPTIMIZATION: first perform check if the code point in the allowed range that covers most common
    //HTML input (e.g. ASCII codes) to avoid performance-cost operations for high-range code points.
    return cp >= 0xD800 ? this._processHighRangeCodePoint(cp) : cp;
};

Preprocessor.prototype.retreat = function () {
    if (this.pos === this.lastGapPos) {
        this.lastGapPos = this.gapStack.pop();
        this.pos--;
    }

    this.pos--;
};



/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var doctype = __webpack_require__(30),
    DOCUMENT_MODE = __webpack_require__(10).DOCUMENT_MODE;


//Conversion tables for DOM Level1 structure emulation
var nodeTypes = {
    element: 1,
    text: 3,
    cdata: 4,
    comment: 8
};

var nodePropertyShorthands = {
    tagName: 'name',
    childNodes: 'children',
    parentNode: 'parent',
    previousSibling: 'prev',
    nextSibling: 'next',
    nodeValue: 'data'
};

//Node
var Node = function (props) {
    for (var key in props) {
        if (props.hasOwnProperty(key))
            this[key] = props[key];
    }
};

Node.prototype = {
    get firstChild() {
        var children = this.children;

        return children && children[0] || null;
    },

    get lastChild() {
        var children = this.children;

        return children && children[children.length - 1] || null;
    },

    get nodeType() {
        return nodeTypes[this.type] || nodeTypes.element;
    }
};

Object.keys(nodePropertyShorthands).forEach(function (key) {
    var shorthand = nodePropertyShorthands[key];

    Object.defineProperty(Node.prototype, key, {
        get: function () {
            return this[shorthand] || null;
        },
        set: function (val) {
            this[shorthand] = val;
            return val;
        }
    });
});


//Node construction
exports.createDocument = function () {
    return new Node({
        type: 'root',
        name: 'root',
        parent: null,
        prev: null,
        next: null,
        children: [],
        'x-mode': DOCUMENT_MODE.NO_QUIRKS
    });
};

exports.createDocumentFragment = function () {
    return new Node({
        type: 'root',
        name: 'root',
        parent: null,
        prev: null,
        next: null,
        children: []
    });
};

exports.createElement = function (tagName, namespaceURI, attrs) {
    var attribs = Object.create(null),
        attribsNamespace = Object.create(null),
        attribsPrefix = Object.create(null);

    for (var i = 0; i < attrs.length; i++) {
        var attrName = attrs[i].name;

        attribs[attrName] = attrs[i].value;
        attribsNamespace[attrName] = attrs[i].namespace;
        attribsPrefix[attrName] = attrs[i].prefix;
    }

    return new Node({
        type: tagName === 'script' || tagName === 'style' ? tagName : 'tag',
        name: tagName,
        namespace: namespaceURI,
        attribs: attribs,
        'x-attribsNamespace': attribsNamespace,
        'x-attribsPrefix': attribsPrefix,
        children: [],
        parent: null,
        prev: null,
        next: null
    });
};

exports.createCommentNode = function (data) {
    return new Node({
        type: 'comment',
        data: data,
        parent: null,
        prev: null,
        next: null
    });
};

var createTextNode = function (value) {
    return new Node({
        type: 'text',
        data: value,
        parent: null,
        prev: null,
        next: null
    });
};


//Tree mutation
var appendChild = exports.appendChild = function (parentNode, newNode) {
    var prev = parentNode.children[parentNode.children.length - 1];

    if (prev) {
        prev.next = newNode;
        newNode.prev = prev;
    }

    parentNode.children.push(newNode);
    newNode.parent = parentNode;
};

var insertBefore = exports.insertBefore = function (parentNode, newNode, referenceNode) {
    var insertionIdx = parentNode.children.indexOf(referenceNode),
        prev = referenceNode.prev;

    if (prev) {
        prev.next = newNode;
        newNode.prev = prev;
    }

    referenceNode.prev = newNode;
    newNode.next = referenceNode;

    parentNode.children.splice(insertionIdx, 0, newNode);
    newNode.parent = parentNode;
};

exports.setTemplateContent = function (templateElement, contentElement) {
    appendChild(templateElement, contentElement);
};

exports.getTemplateContent = function (templateElement) {
    return templateElement.children[0];
};

exports.setDocumentType = function (document, name, publicId, systemId) {
    var data = doctype.serializeContent(name, publicId, systemId),
        doctypeNode = null;

    for (var i = 0; i < document.children.length; i++) {
        if (document.children[i].type === 'directive' && document.children[i].name === '!doctype') {
            doctypeNode = document.children[i];
            break;
        }
    }

    if (doctypeNode) {
        doctypeNode.data = data;
        doctypeNode['x-name'] = name;
        doctypeNode['x-publicId'] = publicId;
        doctypeNode['x-systemId'] = systemId;
    }

    else {
        appendChild(document, new Node({
            type: 'directive',
            name: '!doctype',
            data: data,
            'x-name': name,
            'x-publicId': publicId,
            'x-systemId': systemId
        }));
    }

};

exports.setDocumentMode = function (document, mode) {
    document['x-mode'] = mode;
};

exports.getDocumentMode = function (document) {
    return document['x-mode'];
};

exports.detachNode = function (node) {
    if (node.parent) {
        var idx = node.parent.children.indexOf(node),
            prev = node.prev,
            next = node.next;

        node.prev = null;
        node.next = null;

        if (prev)
            prev.next = next;

        if (next)
            next.prev = prev;

        node.parent.children.splice(idx, 1);
        node.parent = null;
    }
};

exports.insertText = function (parentNode, text) {
    var lastChild = parentNode.children[parentNode.children.length - 1];

    if (lastChild && lastChild.type === 'text')
        lastChild.data += text;
    else
        appendChild(parentNode, createTextNode(text));
};

exports.insertTextBefore = function (parentNode, text, referenceNode) {
    var prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];

    if (prevNode && prevNode.type === 'text')
        prevNode.data += text;
    else
        insertBefore(parentNode, createTextNode(text), referenceNode);
};

exports.adoptAttributes = function (recipient, attrs) {
    for (var i = 0; i < attrs.length; i++) {
        var attrName = attrs[i].name;

        if (typeof recipient.attribs[attrName] === 'undefined') {
            recipient.attribs[attrName] = attrs[i].value;
            recipient['x-attribsNamespace'][attrName] = attrs[i].namespace;
            recipient['x-attribsPrefix'][attrName] = attrs[i].prefix;
        }
    }
};


//Tree traversing
exports.getFirstChild = function (node) {
    return node.children[0];
};

exports.getChildNodes = function (node) {
    return node.children;
};

exports.getParentNode = function (node) {
    return node.parent;
};

exports.getAttrList = function (element) {
    var attrList = [];

    for (var name in element.attribs) {
        attrList.push({
            name: name,
            value: element.attribs[name],
            namespace: element['x-attribsNamespace'][name],
            prefix: element['x-attribsPrefix'][name]
        });
    }

    return attrList;
};


//Node data
exports.getTagName = function (element) {
    return element.name;
};

exports.getNamespaceURI = function (element) {
    return element.namespace;
};

exports.getTextNodeContent = function (textNode) {
    return textNode.data;
};

exports.getCommentNodeContent = function (commentNode) {
    return commentNode.data;
};

exports.getDocumentTypeNodeName = function (doctypeNode) {
    return doctypeNode['x-name'];
};

exports.getDocumentTypeNodePublicId = function (doctypeNode) {
    return doctypeNode['x-publicId'];
};

exports.getDocumentTypeNodeSystemId = function (doctypeNode) {
    return doctypeNode['x-systemId'];
};


//Node types
exports.isTextNode = function (node) {
    return node.type === 'text';
};

exports.isCommentNode = function (node) {
    return node.type === 'comment';
};

exports.isDocumentTypeNode = function (node) {
    return node.type === 'directive' && node.name === '!doctype';
};

exports.isElementNode = function (node) {
    return !!node.attribs;
};


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(6);
var Subscription_1 = __webpack_require__(14);
/**
 * @class AsyncSubject<T>
 */
var AsyncSubject = (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        _super.apply(this, arguments);
        this.value = null;
        this.hasNext = false;
        this.hasCompleted = false;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject_1.Subject));
exports.AsyncSubject = AsyncSubject;
//# sourceMappingURL=AsyncSubject.js.map

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
    return Scheduler;
}());
exports.Scheduler = Scheduler;
//# sourceMappingURL=Scheduler.js.map

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(5);
var defer_1 = __webpack_require__(187);
Observable_1.Observable.defer = defer_1.defer;
//# sourceMappingURL=defer.js.map

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(5);
var fromPromise_1 = __webpack_require__(295);
Observable_1.Observable.fromPromise = fromPromise_1.fromPromise;
//# sourceMappingURL=fromPromise.js.map

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(5);
var mergeMap_1 = __webpack_require__(303);
Observable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;
Observable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;
//# sourceMappingURL=mergeMap.js.map

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(5);
var subscribeToResult_1 = __webpack_require__(4);
var OuterSubscriber_1 = __webpack_require__(3);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var DeferObservable = (function (_super) {
    __extends(DeferObservable, _super);
    function DeferObservable(observableFactory) {
        _super.call(this);
        this.observableFactory = observableFactory;
    }
    /**
     * Creates an Observable that, on subscribe, calls an Observable factory to
     * make an Observable for each new Observer.
     *
     * <span class="informal">Creates the Observable lazily, that is, only when it
     * is subscribed.
     * </span>
     *
     * <img src="./img/defer.png" width="100%">
     *
     * `defer` allows you to create the Observable only when the Observer
     * subscribes, and create a fresh Observable for each Observer. It waits until
     * an Observer subscribes to it, and then it generates an Observable,
     * typically with an Observable factory function. It does this afresh for each
     * subscriber, so although each subscriber may think it is subscribing to the
     * same Observable, in fact each subscriber gets its own individual
     * Observable.
     *
     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
     * var clicksOrInterval = Rx.Observable.defer(function () {
     *   if (Math.random() > 0.5) {
     *     return Rx.Observable.fromEvent(document, 'click');
     *   } else {
     *     return Rx.Observable.interval(1000);
     *   }
     * });
     * clicksOrInterval.subscribe(x => console.log(x));
     *
     * // Results in the following behavior:
     * // If the result of Math.random() is greater than 0.5 it will listen
     * // for clicks anywhere on the "document"; when document is clicked it
     * // will log a MouseEvent object to the console. If the result is less
     * // than 0.5 it will emit ascending numbers, one every second(1000ms).
     *
     * @see {@link create}
     *
     * @param {function(): SubscribableOrPromise} observableFactory The Observable
     * factory function to invoke for each Observer that subscribes to the output
     * Observable. May also return a Promise, which will be converted on the fly
     * to an Observable.
     * @return {Observable} An Observable whose Observers' subscriptions trigger
     * an invocation of the given Observable factory function.
     * @static true
     * @name defer
     * @owner Observable
     */
    DeferObservable.create = function (observableFactory) {
        return new DeferObservable(observableFactory);
    };
    DeferObservable.prototype._subscribe = function (subscriber) {
        return new DeferSubscriber(subscriber, this.observableFactory);
    };
    return DeferObservable;
}(Observable_1.Observable));
exports.DeferObservable = DeferObservable;
var DeferSubscriber = (function (_super) {
    __extends(DeferSubscriber, _super);
    function DeferSubscriber(destination, factory) {
        _super.call(this, destination);
        this.factory = factory;
        this.tryDefer();
    }
    DeferSubscriber.prototype.tryDefer = function () {
        try {
            this._callFactory();
        }
        catch (err) {
            this._error(err);
        }
    };
    DeferSubscriber.prototype._callFactory = function () {
        var result = this.factory();
        if (result) {
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return DeferSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=DeferObservable.js.map

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = __webpack_require__(71);
var Observable_1 = __webpack_require__(5);
var async_1 = __webpack_require__(7);
var isScheduler_1 = __webpack_require__(22);
var isDate_1 = __webpack_require__(25);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = (function (_super) {
    __extends(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) { dueTime = 0; }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        }
        else if (isScheduler_1.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async_1.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ?
            (+dueTime - this.scheduler.now()) :
            dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) { initialDelay = 0; }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state) {
        var index = state.index, period = state.period, subscriber = state.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        }
        else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        action.schedule(state, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1.Observable));
exports.TimerObservable = TimerObservable;
//# sourceMappingURL=TimerObservable.js.map

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DeferObservable_1 = __webpack_require__(185);
exports.defer = DeferObservable_1.DeferObservable.create;
//# sourceMappingURL=defer.js.map

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1 = __webpack_require__(17);
var ArrayObservable_1 = __webpack_require__(26);
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    // if the only argument is an array, it was most likely called with
    // `race([obs1, obs2, ...])`
    if (observables.length === 1) {
        if (isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());
}
exports.race = race;
var RaceOperator = (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
exports.RaceOperator = RaceOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RaceSubscriber = (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        _super.call(this, destination);
        this.hasFirst = false;
        this.observables = [];
        this.subscriptions = [];
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.RaceSubscriber = RaceSubscriber;
//# sourceMappingURL=race.js.map

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var TimerObservable_1 = __webpack_require__(186);
exports.timer = TimerObservable_1.TimerObservable.create;
//# sourceMappingURL=timer.js.map

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(5);
// HACK: this is here for backward compatability
// TODO(benlesh): remove this in v6.
exports.toPromise = Observable_1.Observable.prototype.toPromise;
//# sourceMappingURL=toPromise.js.map

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var async_1 = __webpack_require__(7);
var audit_1 = __webpack_require__(62);
var timer_1 = __webpack_require__(189);
/**
 * Ignores source values for `duration` milliseconds, then emits the most recent
 * value from the source Observable, then repeats this process.
 *
 * <span class="informal">When it sees a source values, it ignores that plus
 * the next ones for `duration` milliseconds, and then it emits the most recent
 * value from the source.</span>
 *
 * <img src="./img/auditTime.png" width="100%">
 *
 * `auditTime` is similar to `throttleTime`, but emits the last value from the
 * silenced time window, instead of the first value. `auditTime` emits the most
 * recent value from the source Observable on the output Observable as soon as
 * its internal timer becomes disabled, and ignores source values while the
 * timer is enabled. Initially, the timer is disabled. As soon as the first
 * source value arrives, the timer is enabled. After `duration` milliseconds (or
 * the time unit determined internally by the optional `scheduler`) has passed,
 * the timer is disabled, then the most recent source value is emitted on the
 * output Observable, and this process repeats for the next source value.
 * Optionally takes a {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.auditTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} duration Time to wait before emitting the most recent source
 * value, measured in milliseconds or the time unit determined internally
 * by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the rate-limiting behavior.
 * @return {Observable<T>} An Observable that performs rate-limiting of
 * emissions from the source Observable.
 * @method auditTime
 * @owner Observable
 */
function auditTime(duration, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });
}
exports.auditTime = auditTime;
//# sourceMappingURL=auditTime.js.map

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/**
 * Buffers the source Observable values until `closingNotifier` emits.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when another Observable emits.</span>
 *
 * <img src="./img/buffer.png" width="100%">
 *
 * Buffers the incoming Observable values until the given `closingNotifier`
 * Observable emits a value, at which point it emits the buffer on the output
 * Observable and starts a new buffer internally, awaiting the next time
 * `closingNotifier` emits.
 *
 * @example <caption>On every click, emit array of most recent interval events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var buffered = interval.buffer(clicks);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link window}
 *
 * @param {Observable<any>} closingNotifier An Observable that signals the
 * buffer to be emitted on the output Observable.
 * @return {Observable<T[]>} An Observable of buffers, which are arrays of
 * values.
 * @method buffer
 * @owner Observable
 */
function buffer(closingNotifier) {
    return function bufferOperatorFunction(source) {
        return source.lift(new BufferOperator(closingNotifier));
    };
}
exports.buffer = buffer;
var BufferOperator = (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferSubscriber = (function (_super) {
    __extends(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        _super.call(this, destination);
        this.buffer = [];
        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=buffer.js.map

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
/**
 * Buffers the source Observable values until the size hits the maximum
 * `bufferSize` given.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when its size reaches `bufferSize`.</span>
 *
 * <img src="./img/bufferCount.png" width="100%">
 *
 * Buffers a number of values from the source Observable by `bufferSize` then
 * emits the buffer and clears it, and starts a new buffer each
 * `startBufferEvery` values. If `startBufferEvery` is not provided or is
 * `null`, then new buffers are started immediately at the start of the source
 * and when each buffer closes and is emitted.
 *
 * @example <caption>Emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>On every click, emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2, 1);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link pairwise}
 * @see {@link windowCount}
 *
 * @param {number} bufferSize The maximum size of the buffer emitted.
 * @param {number} [startBufferEvery] Interval at which to start a new buffer.
 * For example if `startBufferEvery` is `2`, then a new buffer will be started
 * on every other value from the source. A new buffer is started at the
 * beginning of the source by default.
 * @return {Observable<T[]>} An Observable of arrays of buffered values.
 * @method bufferCount
 * @owner Observable
 */
function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) { startBufferEvery = null; }
    return function bufferCountOperatorFunction(source) {
        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
    };
}
exports.bufferCount = bufferCount;
var BufferCountOperator = (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
            this.subscriberClass = BufferCountSubscriber;
        }
        else {
            this.subscriberClass = BufferSkipCountSubscriber;
        }
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferCountSubscriber = (function (_super) {
    __extends(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        _super.call(this, destination);
        this.bufferSize = bufferSize;
        this.buffer = [];
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber_1.Subscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferSkipCountSubscriber = (function (_super) {
    __extends(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        _super.call(this, destination);
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        this.buffers = [];
        this.count = 0;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=bufferCount.js.map

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(7);
var Subscriber_1 = __webpack_require__(2);
var isScheduler_1 = __webpack_require__(22);
/* tslint:enable:max-line-length */
/**
 * Buffers the source Observable values for a specific time period.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * those arrays periodically in time.</span>
 *
 * <img src="./img/bufferTime.png" width="100%">
 *
 * Buffers values from the source for a specific time duration `bufferTimeSpan`.
 * Unless the optional argument `bufferCreationInterval` is given, it emits and
 * resets the buffer every `bufferTimeSpan` milliseconds. If
 * `bufferCreationInterval` is given, this operator opens the buffer every
 * `bufferCreationInterval` milliseconds and closes (emits and resets) the
 * buffer every `bufferTimeSpan` milliseconds. When the optional argument
 * `maxBufferSize` is specified, the buffer will be closed either after
 * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.
 *
 * @example <caption>Every second, emit an array of the recent click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferTime(1000);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferTime(2000, 5000);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link windowTime}
 *
 * @param {number} bufferTimeSpan The amount of time to fill each buffer array.
 * @param {number} [bufferCreationInterval] The interval at which to start new
 * buffers.
 * @param {number} [maxBufferSize] The maximum buffer size.
 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
 * intervals that determine buffer boundaries.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferTime
 * @owner Observable
 */
function bufferTime(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = async_1.async;
    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length >= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) {
        maxBufferSize = arguments[2];
    }
    return function bufferTimeOperatorFunction(source) {
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
    };
}
exports.bufferTime = bufferTime;
var BufferTimeOperator = (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferTimeSubscriber = (function (_super) {
    __extends(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        _super.call(this, destination);
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
        this.contexts = [];
        var context = this.openContext();
        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };
            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context = contexts[i];
            var buffer = context.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context = contexts.shift();
            destination.next(context.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}
//# sourceMappingURL=bufferTime.js.map

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(14);
var subscribeToResult_1 = __webpack_require__(4);
var OuterSubscriber_1 = __webpack_require__(3);
/**
 * Buffers the source Observable values starting from an emission from
 * `openings` and ending when the output of `closingSelector` emits.
 *
 * <span class="informal">Collects values from the past as an array. Starts
 * collecting only when `opening` emits, and calls the `closingSelector`
 * function to get an Observable that tells when to close the buffer.</span>
 *
 * <img src="./img/bufferToggle.png" width="100%">
 *
 * Buffers values from the source by opening the buffer via signals from an
 * Observable provided to `openings`, and closing and sending the buffers when
 * a Subscribable or Promise returned by the `closingSelector` function emits.
 *
 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var openings = Rx.Observable.interval(1000);
 * var buffered = clicks.bufferToggle(openings, i =>
 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferWhen}
 * @see {@link windowToggle}
 *
 * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new
 * buffers.
 * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes
 * the value emitted by the `openings` observable and returns a Subscribable or Promise,
 * which, when it emits, signals that the associated buffer should be emitted
 * and cleared.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferToggle
 * @owner Observable
 */
function bufferToggle(openings, closingSelector) {
    return function bufferToggleOperatorFunction(source) {
        return source.lift(new BufferToggleOperator(openings, closingSelector));
    };
}
exports.bufferToggle = bufferToggle;
var BufferToggleOperator = (function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferToggleSubscriber = (function (_super) {
    __extends(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        _super.call(this, destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.contexts = [];
        this.add(subscribeToResult_1.subscribeToResult(this, openings));
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context = contexts.shift();
            context.subscription.unsubscribe();
            context.buffer = null;
            context.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context = contexts.shift();
            this.destination.next(context.buffer);
            context.subscription.unsubscribe();
            context.buffer = null;
            context.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription_1.Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=bufferToggle.js.map

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(14);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(9);
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/**
 * Buffers the source Observable values, using a factory function of closing
 * Observables to determine when to close, emit, and reset the buffer.
 *
 * <span class="informal">Collects values from the past as an array. When it
 * starts collecting values, it calls a function that returns an Observable that
 * tells when to close the buffer and restart collecting.</span>
 *
 * <img src="./img/bufferWhen.png" width="100%">
 *
 * Opens a buffer immediately, then closes the buffer when the observable
 * returned by calling `closingSelector` function emits a value. When it closes
 * the buffer, it immediately opens a new buffer and repeats the process.
 *
 * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferWhen(() =>
 *   Rx.Observable.interval(1000 + Math.random() * 4000)
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link windowWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals buffer closure.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferWhen
 * @owner Observable
 */
function bufferWhen(closingSelector) {
    return function (source) {
        return source.lift(new BufferWhenOperator(closingSelector));
    };
}
exports.bufferWhen = bufferWhen;
var BufferWhenOperator = (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferWhenSubscriber = (function (_super) {
    __extends(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        _super.call(this, destination);
        this.closingSelector = closingSelector;
        this.subscribing = false;
        this.openBuffer();
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = null;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject_1.errorObject) {
            this.error(errorObject_1.errorObject.e);
        }
        else {
            closingSubscription = new Subscription_1.Subscription();
            this.closingSubscription = closingSubscription;
            this.add(closingSubscription);
            this.subscribing = true;
            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
            this.subscribing = false;
        }
    };
    return BufferWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=bufferWhen.js.map

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var combineLatest_1 = __webpack_require__(63);
function combineAll(project) {
    return function (source) { return source.lift(new combineLatest_1.CombineLatestOperator(project)); };
}
exports.combineAll = combineAll;
//# sourceMappingURL=combineAll.js.map

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var concat_1 = __webpack_require__(34);
var concat_2 = __webpack_require__(34);
exports.concatStatic = concat_2.concat;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };
}
exports.concat = concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var concatMap_1 = __webpack_require__(80);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in a serialized fashion on the output Observable.
 *
 * <span class="informal">It's like {@link concatMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/concatMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. Each new `innerObservable`
 * instance emitted on the output Observable is concatenated with the previous
 * `innerObservable` instance.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
 * set to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link mergeMapTo}
 * @see {@link switchMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An observable of values merged together by joining the
 * passed observable with itself, one after the other, for each value emitted
 * from the source.
 * @method concatMapTo
 * @owner Observable
 */
function concatMapTo(innerObservable, resultSelector) {
    return concatMap_1.concatMap(function () { return innerObservable; }, resultSelector);
}
exports.concatMapTo = concatMapTo;
//# sourceMappingURL=concatMapTo.js.map

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
/**
 * Counts the number of emissions on the source and emits that number when the
 * source completes.
 *
 * <span class="informal">Tells how many values were emitted, when the source
 * completes.</span>
 *
 * <img src="./img/count.png" width="100%">
 *
 * `count` transforms an Observable that emits values into an Observable that
 * emits a single value that represents the number of values emitted by the
 * source Observable. If the source Observable terminates with an error, `count`
 * will pass this error notification along without emitting a value first. If
 * the source Observable does not terminate at all, `count` will neither emit
 * a value nor terminate. This operator takes an optional `predicate` function
 * as argument, in which case the output emission will represent the number of
 * source values that matched `true` with the `predicate`.
 *
 * @example <caption>Counts how many seconds have passed before the first click happened</caption>
 * var seconds = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var secondsBeforeClick = seconds.takeUntil(clicks);
 * var result = secondsBeforeClick.count();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>
 * var numbers = Rx.Observable.range(1, 7);
 * var result = numbers.count(i => i % 2 === 1);
 * result.subscribe(x => console.log(x));
 *
 * // Results in:
 * // 4
 *
 * @see {@link max}
 * @see {@link min}
 * @see {@link reduce}
 *
 * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A
 * boolean function to select what values are to be counted. It is provided with
 * arguments of:
 * - `value`: the value from the source Observable.
 * - `index`: the (zero-based) "index" of the value from the source Observable.
 * - `source`: the source Observable instance itself.
 * @return {Observable} An Observable of one number that represents the count as
 * described above.
 * @method count
 * @owner Observable
 */
function count(predicate) {
    return function (source) { return source.lift(new CountOperator(predicate, source)); };
}
exports.count = count;
var CountOperator = (function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CountSubscriber = (function (_super) {
    __extends(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.count = 0;
        this.index = 0;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=count.js.map

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/**
 * Emits a value from the source Observable only after a particular time span
 * determined by another Observable has passed without another source emission.
 *
 * <span class="informal">It's like {@link debounceTime}, but the time span of
 * emission silence is determined by a second Observable.</span>
 *
 * <img src="./img/debounce.png" width="100%">
 *
 * `debounce` delays values emitted by the source Observable, but drops previous
 * pending delayed emissions if a new value arrives on the source Observable.
 * This operator keeps track of the most recent value from the source
 * Observable, and spawns a duration Observable by calling the
 * `durationSelector` function. The value is emitted only when the duration
 * Observable emits a value or completes, and if no other value was emitted on
 * the source Observable since the duration Observable was spawned. If a new
 * value appears before the duration Observable emits, the previous value will
 * be dropped and will not be emitted on the output Observable.
 *
 * Like {@link debounceTime}, this is a rate-limiting operator, and also a
 * delay-like operator since output emissions do not necessarily occur at the
 * same time as they did on the source Observable.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounce(() => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 * @see {@link throttle}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the timeout
 * duration for each source value, returned as an Observable or a Promise.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified duration Observable returned by
 * `durationSelector`, and may drop some values if they occur too frequently.
 * @method debounce
 * @owner Observable
 */
function debounce(durationSelector) {
    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };
}
exports.debounce = debounce;
var DebounceOperator = (function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceSubscriber = (function (_super) {
    __extends(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        _super.call(this, destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
        this.durationSubscription = null;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = subscribeToResult_1.subscribeToResult(this, duration);
        if (!subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = null;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = null;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=debounce.js.map

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var async_1 = __webpack_require__(7);
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}
//# sourceMappingURL=debounceTime.js.map

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(7);
var isDate_1 = __webpack_require__(25);
var Subscriber_1 = __webpack_require__(2);
var Notification_1 = __webpack_require__(75);
/**
 * Delays the emission of items from the source Observable by a given timeout or
 * until a given Date.
 *
 * <span class="informal">Time shifts each item by some specified amount of
 * milliseconds.</span>
 *
 * <img src="./img/delay.png" width="100%">
 *
 * If the delay argument is a Number, this operator time shifts the source
 * Observable by that amount of time expressed in milliseconds. The relative
 * time intervals between the values are preserved.
 *
 * If the delay argument is a Date, this operator time shifts the start of the
 * Observable execution until the given date occurs.
 *
 * @example <caption>Delay each click by one second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @example <caption>Delay all clicks until a future date happens</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var date = new Date('March 15, 2050 12:00:00'); // in the future
 * var delayedClicks = clicks.delay(date); // click emitted only after that date
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 *
 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
 * a `Date` until which the emission of the source items is delayed.
 * @param {Scheduler} [scheduler=async] The IScheduler to use for
 * managing the timers that handle the time-shift for each item.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified timeout or Date.
 * @method delay
 * @owner Observable
 */
function delay(delay, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
exports.delay = delay;
var DelayOperator = (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelaySubscriber = (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        _super.call(this, destination);
        this.delay = delay;
        this.scheduler = scheduler;
        this.queue = [];
        this.active = false;
        this.errored = false;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1.Notification.createComplete());
    };
    return DelaySubscriber;
}(Subscriber_1.Subscriber));
var DelayMessage = (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());
//# sourceMappingURL=delay.js.map

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var Observable_1 = __webpack_require__(5);
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/**
 * Delays the emission of items from the source Observable by a given time span
 * determined by the emissions of another Observable.
 *
 * <span class="informal">It's like {@link delay}, but the time span of the
 * delay duration is determined by a second Observable.</span>
 *
 * <img src="./img/delayWhen.png" width="100%">
 *
 * `delayWhen` time shifts each emitted value from the source Observable by a
 * time span determined by another Observable. When the source emits a value,
 * the `delayDurationSelector` function is called with the source value as
 * argument, and should return an Observable, called the "duration" Observable.
 * The source value is emitted on the output Observable only when the duration
 * Observable emits a value or completes.
 *
 * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which
 * is an Observable. When `subscriptionDelay` emits its first value or
 * completes, the source Observable is subscribed to and starts behaving like
 * described in the previous paragraph. If `subscriptionDelay` is not provided,
 * `delayWhen` will subscribe to the source Observable as soon as the output
 * Observable is subscribed.
 *
 * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delayWhen(event =>
 *   Rx.Observable.interval(Math.random() * 5000)
 * );
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounce}
 * @see {@link delay}
 *
 * @param {function(value: T): Observable} delayDurationSelector A function that
 * returns an Observable for each value emitted by the source Observable, which
 * is then used to delay the emission of that item on the output Observable
 * until the Observable returned from this function emits a value.
 * @param {Observable} subscriptionDelay An Observable that triggers the
 * subscription to the source Observable once it emits any value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by an amount of time specified by the Observable returned by
 * `delayDurationSelector`.
 * @method delayWhen
 * @owner Observable
 */
function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        return function (source) {
            return new SubscriptionDelayObservable(source, subscriptionDelay)
                .lift(new DelayWhenOperator(delayDurationSelector));
        };
    }
    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };
}
exports.delayWhen = delayWhen;
var DelayWhenOperator = (function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelayWhenSubscriber = (function (_super) {
    __extends(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        _super.call(this, destination);
        this.delayDurationSelector = delayDurationSelector;
        this.completed = false;
        this.delayNotifierSubscriptions = [];
        this.values = [];
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        try {
            var delayNotifier = this.delayDurationSelector(value);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        var value = null;
        if (subscriptionIdx !== -1) {
            value = this.values[subscriptionIdx];
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
            this.values.splice(subscriptionIdx, 1);
        }
        return value;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            this.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
        this.values.push(value);
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubscriptionDelayObservable = (function (_super) {
    __extends(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        _super.call(this);
        this.source = source;
        this.subscriptionDelay = subscriptionDelay;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable_1.Observable));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubscriptionDelaySubscriber = (function (_super) {
    __extends(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        _super.call(this);
        this.parent = parent;
        this.source = source;
        this.sourceSubscribed = false;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=delayWhen.js.map

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
/**
 * Converts an Observable of {@link Notification} objects into the emissions
 * that they represent.
 *
 * <span class="informal">Unwraps {@link Notification} objects as actual `next`,
 * `error` and `complete` emissions. The opposite of {@link materialize}.</span>
 *
 * <img src="./img/dematerialize.png" width="100%">
 *
 * `dematerialize` is assumed to operate an Observable that only emits
 * {@link Notification} objects as `next` emissions, and does not emit any
 * `error`. Such Observable is the output of a `materialize` operation. Those
 * notifications are then unwrapped using the metadata they contain, and emitted
 * as `next`, `error`, and `complete` on the output Observable.
 *
 * Use this operator in conjunction with {@link materialize}.
 *
 * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>
 * var notifA = new Rx.Notification('N', 'A');
 * var notifB = new Rx.Notification('N', 'B');
 * var notifE = new Rx.Notification('E', void 0,
 *   new TypeError('x.toUpperCase is not a function')
 * );
 * var materialized = Rx.Observable.of(notifA, notifB, notifE);
 * var upperCase = materialized.dematerialize();
 * upperCase.subscribe(x => console.log(x), e => console.error(e));
 *
 * // Results in:
 * // A
 * // B
 * // TypeError: x.toUpperCase is not a function
 *
 * @see {@link Notification}
 * @see {@link materialize}
 *
 * @return {Observable} An Observable that emits items and notifications
 * embedded in Notification objects emitted by the source Observable.
 * @method dematerialize
 * @owner Observable
 */
function dematerialize() {
    return function dematerializeOperatorFunction(source) {
        return source.lift(new DeMaterializeOperator());
    };
}
exports.dematerialize = dematerialize;
var DeMaterializeOperator = (function () {
    function DeMaterializeOperator() {
    }
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DeMaterializeSubscriber = (function (_super) {
    __extends(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        _super.call(this, destination);
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=dematerialize.js.map

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
var Set_1 = __webpack_require__(271);
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
 *
 * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will
 * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the
 * source observable directly with an equality check against previous values.
 *
 * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.
 *
 * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
 * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`
 * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
 * that the internal `Set` can be "flushed", basically clearing it of values.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
 *   .distinct()
 *   .subscribe(x => console.log(x)); // 1, 2, 3, 4
 *
 * @example <caption>An example using a keySelector function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     .distinct((p: Person) => p.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 *
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [keySelector] Optional function to select which value you want to check as distinct.
 * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinct
 * @owner Observable
 */
function distinct(keySelector, flushes) {
    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };
}
exports.distinct = distinct;
var DistinctOperator = (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctSubscriber = (function (_super) {
    __extends(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.values = new Set_1.Set();
        if (flushes) {
            this.add(subscribeToResult_1.subscribeToResult(this, flushes));
        }
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.DistinctSubscriber = DistinctSubscriber;
//# sourceMappingURL=distinct.js.map

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var distinctUntilChanged_1 = __webpack_require__(64);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
 * using a property accessed by using the key provided to check if the two items are distinct.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>An example comparing the name of persons</caption>
 *
 *  interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'},
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilKeyChanged('name')
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @example <caption>An example comparing the first letters of the name</caption>
 *
 * interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo1'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo2'},
 *     { age: 6, name: 'Foo3'})
 *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo1' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo2' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 *
 * @param {string} key String key for object property lookup on each item.
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.
 * @method distinctUntilKeyChanged
 * @owner Observable
 */
function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
}
exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
//# sourceMappingURL=distinctUntilKeyChanged.js.map

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var ArgumentOutOfRangeError_1 = __webpack_require__(38);
/**
 * Emits the single value at the specified `index` in a sequence of emissions
 * from the source Observable.
 *
 * <span class="informal">Emits only the i-th value, then completes.</span>
 *
 * <img src="./img/elementAt.png" width="100%">
 *
 * `elementAt` returns an Observable that emits the item at the specified
 * `index` in the source Observable, or a default value if that `index` is out
 * of range and the `default` argument is provided. If the `default` argument is
 * not given and the `index` is out of range, the output Observable will emit an
 * `ArgumentOutOfRangeError` error.
 *
 * @example <caption>Emit only the third click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.elementAt(2);
 * result.subscribe(x => console.log(x));
 *
 * // Results in:
 * // click 1 = nothing
 * // click 2 = nothing
 * // click 3 = MouseEvent object logged to console
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link skip}
 * @see {@link single}
 * @see {@link take}
 *
 * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the
 * Observable has completed before emitting the i-th `next` notification.
 *
 * @param {number} index Is the number `i` for the i-th source emission that has
 * happened since the subscription, starting from the number `0`.
 * @param {T} [defaultValue] The default value returned for missing indices.
 * @return {Observable} An Observable that emits a single item, if it is found.
 * Otherwise, will emit the default value if given. If not, then emits an error.
 * @method elementAt
 * @owner Observable
 */
function elementAt(index, defaultValue) {
    return function (source) { return source.lift(new ElementAtOperator(index, defaultValue)); };
}
exports.elementAt = elementAt;
var ElementAtOperator = (function () {
    function ElementAtOperator(index, defaultValue) {
        this.index = index;
        this.defaultValue = defaultValue;
        if (index < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    ElementAtOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));
    };
    return ElementAtOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ElementAtSubscriber = (function (_super) {
    __extends(ElementAtSubscriber, _super);
    function ElementAtSubscriber(destination, index, defaultValue) {
        _super.call(this, destination);
        this.index = index;
        this.defaultValue = defaultValue;
    }
    ElementAtSubscriber.prototype._next = function (x) {
        if (this.index-- === 0) {
            this.destination.next(x);
            this.destination.complete();
        }
    };
    ElementAtSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index >= 0) {
            if (typeof this.defaultValue !== 'undefined') {
                destination.next(this.defaultValue);
            }
            else {
                destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);
            }
        }
        destination.complete();
    };
    return ElementAtSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=elementAt.js.map

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/**
 * Converts a higher-order Observable into a first-order Observable by dropping
 * inner Observables while the previous inner Observable has not yet completed.
 *
 * <span class="informal">Flattens an Observable-of-Observables by dropping the
 * next inner Observables while the current inner is still executing.</span>
 *
 * <img src="./img/exhaust.png" width="100%">
 *
 * `exhaust` subscribes to an Observable that emits Observables, also known as a
 * higher-order Observable. Each time it observes one of these emitted inner
 * Observables, the output Observable begins emitting the items emitted by that
 * inner Observable. So far, it behaves like {@link mergeAll}. However,
 * `exhaust` ignores every new inner Observable if the previous Observable has
 * not yet completed. Once that one completes, it will accept and flatten the
 * next inner Observable and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));
 * var result = higherOrder.exhaust();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link switch}
 * @see {@link mergeAll}
 * @see {@link exhaustMap}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable that takes a source of Observables and propagates the first observable
 * exclusively until it completes before subscribing to the next.
 * @method exhaust
 * @owner Observable
 */
function exhaust() {
    return function (source) { return source.lift(new SwitchFirstOperator()); };
}
exports.exhaust = exhaust;
var SwitchFirstOperator = (function () {
    function SwitchFirstOperator() {
    }
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstSubscriber = (function (_super) {
    __extends(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        _super.call(this, destination);
        this.hasCompleted = false;
        this.hasSubscription = false;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(subscribeToResult_1.subscribeToResult(this, value));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=exhaust.js.map

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable only if the previous projected Observable has completed.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link exhaust}.</span>
 *
 * <img src="./img/exhaustMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. When it projects a source value to
 * an Observable, the output Observable begins emitting the items emitted by
 * that projected Observable. However, `exhaustMap` ignores every new projected
 * Observable if the previous projected Observable has not yet completed. Once
 * that one completes, it will accept and flatten the next projected Observable
 * and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaust}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable containing projected Observables
 * of each item of the source, ignoring projected Observables that start before
 * their preceding Observable has completed.
 * @method exhaustMap
 * @owner Observable
 */
function exhaustMap(project, resultSelector) {
    return function (source) { return source.lift(new SwitchFirstMapOperator(project, resultSelector)); };
}
exports.exhaustMap = exhaustMap;
var SwitchFirstMapOperator = (function () {
    function SwitchFirstMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchFirstMapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstMapSubscriber = (function (_super) {
    __extends(SwitchFirstMapSubscriber, _super);
    function SwitchFirstMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.hasSubscription = false;
        this.hasCompleted = false;
        this.index = 0;
    }
    SwitchFirstMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {
        var index = this.index++;
        var destination = this.destination;
        try {
            var result = this.project(value, index);
            this.hasSubscription = true;
            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
        }
        catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        try {
            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
            destination.next(result);
        }
        catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=exhaustMap.js.map

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(9);
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/* tslint:enable:max-line-length */
/**
 * Recursively projects each source value to an Observable which is merged in
 * the output Observable.
 *
 * <span class="informal">It's similar to {@link mergeMap}, but applies the
 * projection function to every source value as well as every output value.
 * It's recursive.</span>
 *
 * <img src="./img/expand.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger. *Expand* will re-emit on the output
 * Observable every source value. Then, each output value is given to the
 * `project` function which returns an inner Observable to be merged on the
 * output Observable. Those output values resulting from the projection are also
 * given to the `project` function to produce new output values. This is how
 * *expand* behaves recursively.
 *
 * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var powersOfTwo = clicks
 *   .mapTo(1)
 *   .expand(x => Rx.Observable.of(2 * x).delay(1000))
 *   .take(10);
 * powersOfTwo.subscribe(x => console.log(x));
 *
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 *
 * @param {function(value: T, index: number) => Observable} project A function
 * that, when applied to an item emitted by the source or the output Observable,
 * returns an Observable.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
 * each projected inner Observable.
 * @return {Observable} An Observable that emits the source values and also
 * result of applying the projection function to each value emitted on the
 * output Observable and and merging the results of the Observables obtained
 * from this transformation.
 * @method expand
 * @owner Observable
 */
function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (scheduler === void 0) { scheduler = undefined; }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };
}
exports.expand = expand;
var ExpandOperator = (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());
exports.ExpandOperator = ExpandOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ExpandSubscriber = (function (_super) {
    __extends(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        _super.call(this, destination);
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
        this.index = 0;
        this.active = 0;
        this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            this.buffer = [];
        }
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            var result = tryCatch_1.tryCatch(this.project)(value, index);
            if (result === errorObject_1.errorObject) {
                destination.error(errorObject_1.errorObject.e);
            }
            else if (!this.scheduler) {
                this.subscribeToProjection(result, value, index);
            }
            else {
                var state = { subscriber: this, result: result, value: value, index: index };
                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.ExpandSubscriber = ExpandSubscriber;
//# sourceMappingURL=expand.js.map

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var Subscription_1 = __webpack_require__(14);
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback Function to be called when source terminates.
 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
exports.finalize = finalize;
var FinallyOperator = (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FinallySubscriber = (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        _super.call(this, destination);
        this.add(new Subscription_1.Subscription(callback));
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=finalize.js.map

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var find_1 = __webpack_require__(65);
/**
 * Emits only the index of the first value emitted by the source Observable that
 * meets some condition.
 *
 * <span class="informal">It's like {@link find}, but emits the index of the
 * found value, not the value itself.</span>
 *
 * <img src="./img/findIndex.png" width="100%">
 *
 * `findIndex` searches for the first item in the source Observable that matches
 * the specified condition embodied by the `predicate`, and returns the
 * (zero-based) index of the first occurrence in the source. Unlike
 * {@link first}, the `predicate` is required in `findIndex`, and does not emit
 * an error if a valid value is not found.
 *
 * @example <caption>Emit the index of first click that happens on a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link find}
 * @see {@link first}
 * @see {@link take}
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
 * A function called with each item to test for condition matching.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of the index of the first item that
 * matches the condition.
 * @method find
 * @owner Observable
 */
function findIndex(predicate, thisArg) {
    return function (source) { return source.lift(new find_1.FindValueOperator(predicate, source, true, thisArg)); };
}
exports.findIndex = findIndex;
//# sourceMappingURL=findIndex.js.map

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var Subscription_1 = __webpack_require__(14);
var Observable_1 = __webpack_require__(5);
var Subject_1 = __webpack_require__(6);
var Map_1 = __webpack_require__(269);
var FastMap_1 = __webpack_require__(268);
/* tslint:enable:max-line-length */
/**
 * Groups the items emitted by an Observable according to a specified criterion,
 * and emits these grouped items as `GroupedObservables`, one
 * {@link GroupedObservable} per group.
 *
 * <img src="./img/groupBy.png" width="100%">
 *
 * @example <caption>Group objects by id and return as array</caption>
 * Observable.of<Obj>({id: 1, name: 'aze1'},
 *                    {id: 2, name: 'sf2'},
 *                    {id: 2, name: 'dg2'},
 *                    {id: 1, name: 'erg1'},
 *                    {id: 1, name: 'df1'},
 *                    {id: 2, name: 'sfqfb2'},
 *                    {id: 3, name: 'qfs3'},
 *                    {id: 2, name: 'qsgqsfg2'}
 *     )
 *     .groupBy(p => p.id)
 *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))
 *     .subscribe(p => console.log(p));
 *
 * // displays:
 * // [ { id: 1, name: 'aze1' },
 * //   { id: 1, name: 'erg1' },
 * //   { id: 1, name: 'df1' } ]
 * //
 * // [ { id: 2, name: 'sf2' },
 * //   { id: 2, name: 'dg2' },
 * //   { id: 2, name: 'sfqfb2' },
 * //   { id: 2, name: 'qsgqsfg2' } ]
 * //
 * // [ { id: 3, name: 'qfs3' } ]
 *
 * @example <caption>Pivot data on the id field</caption>
 * Observable.of<Obj>({id: 1, name: 'aze1'},
 *                    {id: 2, name: 'sf2'},
 *                    {id: 2, name: 'dg2'},
 *                    {id: 1, name: 'erg1'},
 *                    {id: 1, name: 'df1'},
 *                    {id: 2, name: 'sfqfb2'},
 *                    {id: 3, name: 'qfs1'},
 *                    {id: 2, name: 'qsgqsfg2'}
 *                   )
 *     .groupBy(p => p.id, p => p.name)
 *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], ["" + group$.key]))
 *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))
 *     .subscribe(p => console.log(p));
 *
 * // displays:
 * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }
 * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }
 * // { id: 3, values: [ 'qfs1' ] }
 *
 * @param {function(value: T): K} keySelector A function that extracts the key
 * for each item.
 * @param {function(value: T): R} [elementSelector] A function that extracts the
 * return element for each item.
 * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
 * A function that returns an Observable to determine how long each group should
 * exist.
 * @return {Observable<GroupedObservable<K,R>>} An Observable that emits
 * GroupedObservables, each of which corresponds to a unique key value and each
 * of which emits those items from the source Observable that share that key
 * value.
 * @method groupBy
 * @owner Observable
 */
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function (source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
}
exports.groupBy = groupBy;
var GroupByOperator = (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupBySubscriber = (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
        this.groups = null;
        this.attemptedToUnsubscribe = false;
        this.count = 0;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber_1.Subscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupDurationSubscriber = (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        _super.call(this, group);
        this.key = key;
        this.group = group;
        this.parent = parent;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber_1.Subscriber));
/**
 * An Observable representing values belonging to the same group represented by
 * a common key. The values emitted by a GroupedObservable come from the source
 * Observable. The common key is available as the field `key` on a
 * GroupedObservable instance.
 *
 * @class GroupedObservable<K, T>
 */
var GroupedObservable = (function (_super) {
    __extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        _super.call(this);
        this.key = key;
        this.groupSubject = groupSubject;
        this.refCountSubscription = refCountSubscription;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable_1.Observable));
exports.GroupedObservable = GroupedObservable;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerRefCountSubscription = (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        _super.call(this);
        this.parent = parent;
        parent.count++;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription_1.Subscription));
//# sourceMappingURL=groupBy.js.map

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var noop_1 = __webpack_require__(314);
/**
 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
 *
 * <img src="./img/ignoreElements.png" width="100%">
 *
 * @return {Observable} An empty Observable that only calls `complete`
 * or `error`, based on which one is called by the source Observable.
 * @method ignoreElements
 * @owner Observable
 */
function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
exports.ignoreElements = ignoreElements;
var IgnoreElementsOperator = (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IgnoreElementsSubscriber = (function (_super) {
    __extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        _super.apply(this, arguments);
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
        noop_1.noop();
    };
    return IgnoreElementsSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=ignoreElements.js.map

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
function isEmpty() {
    return function (source) { return source.lift(new IsEmptyOperator()); };
}
exports.isEmpty = isEmpty;
var IsEmptyOperator = (function () {
    function IsEmptyOperator() {
    }
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IsEmptySubscriber = (function (_super) {
    __extends(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        _super.call(this, destination);
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=isEmpty.js.map

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
/**
 * Emits the given constant value on the output Observable every time the source
 * Observable emits a value.
 *
 * <span class="informal">Like {@link map}, but it maps every source value to
 * the same output value every time.</span>
 *
 * <img src="./img/mapTo.png" width="100%">
 *
 * Takes a constant `value` as argument, and emits that whenever the source
 * Observable emits a value. In other words, ignores the actual source value,
 * and simply uses the emission moment to know when to emit the given `value`.
 *
 * @example <caption>Map every click to the string 'Hi'</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var greetings = clicks.mapTo('Hi');
 * greetings.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {any} value The value to map each source value to.
 * @return {Observable} An Observable that emits the given `value` every time
 * the source Observable emits something.
 * @method mapTo
 * @owner Observable
 */
function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
exports.mapTo = mapTo;
var MapToOperator = (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapToSubscriber = (function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        _super.call(this, destination);
        this.value = value;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=mapTo.js.map

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var Notification_1 = __webpack_require__(75);
/**
 * Represents all of the notifications from the source Observable as `next`
 * emissions marked with their original types within {@link Notification}
 * objects.
 *
 * <span class="informal">Wraps `next`, `error` and `complete` emissions in
 * {@link Notification} objects, emitted as `next` on the output Observable.
 * </span>
 *
 * <img src="./img/materialize.png" width="100%">
 *
 * `materialize` returns an Observable that emits a `next` notification for each
 * `next`, `error`, or `complete` emission of the source Observable. When the
 * source Observable emits `complete`, the output Observable will emit `next` as
 * a Notification of type "complete", and then it will emit `complete` as well.
 * When the source Observable emits `error`, the output will emit `next` as a
 * Notification of type "error", and then `complete`.
 *
 * This operator is useful for producing metadata of the source Observable, to
 * be consumed as `next` emissions. Use it in conjunction with
 * {@link dematerialize}.
 *
 * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>
 * var letters = Rx.Observable.of('a', 'b', 13, 'd');
 * var upperCase = letters.map(x => x.toUpperCase());
 * var materialized = upperCase.materialize();
 * materialized.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - Notification {kind: "N", value: "A", error: undefined, hasValue: true}
 * // - Notification {kind: "N", value: "B", error: undefined, hasValue: true}
 * // - Notification {kind: "E", value: undefined, error: TypeError:
 * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x
 * //   [as project] (http://1, hasValue: false}
 *
 * @see {@link Notification}
 * @see {@link dematerialize}
 *
 * @return {Observable<Notification<T>>} An Observable that emits
 * {@link Notification} objects that wrap the original emissions from the source
 * Observable with metadata.
 * @method materialize
 * @owner Observable
 */
function materialize() {
    return function materializeOperatorFunction(source) {
        return source.lift(new MaterializeOperator());
    };
}
exports.materialize = materialize;
var MaterializeOperator = (function () {
    function MaterializeOperator() {
    }
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MaterializeSubscriber = (function (_super) {
    __extends(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        _super.call(this, destination);
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification_1.Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=materialize.js.map

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var reduce_1 = __webpack_require__(27);
/**
 * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
 * and when source Observable completes it emits a single item: the item with the largest value.
 *
 * <img src="./img/max.png" width="100%">
 *
 * @example <caption>Get the maximal value of a series of numbers</caption>
 * Rx.Observable.of(5, 4, 7, 2, 8)
 *   .max()
 *   .subscribe(x => console.log(x)); // -> 8
 *
 * @example <caption>Use a comparer function to get the maximal item</caption>
 * interface Person {
 *   age: number,
 *   name: string
 * }
 * Observable.of<Person>({age: 7, name: 'Foo'},
 *                       {age: 5, name: 'Bar'},
 *                       {age: 9, name: 'Beer'})
 *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)
 *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'
 * }
 *
 * @see {@link min}
 *
 * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
 * value of two items.
 * @return {Observable} An Observable that emits item with the largest value.
 * @method max
 * @owner Observable
 */
function max(comparer) {
    var max = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
        : function (x, y) { return x > y ? x : y; };
    return reduce_1.reduce(max);
}
exports.max = max;
//# sourceMappingURL=max.js.map

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var merge_1 = __webpack_require__(76);
var merge_2 = __webpack_require__(76);
exports.mergeStatic = merge_2.merge;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (either the source or an
 * Observable given as argument), and simply forwards (without doing any
 * transformation) all the values from all the input Observables to the output
 * Observable. The output Observable only completes once all input Observables
 * have completed. Any error delivered by an input Observable will be immediately
 * emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = clicks.merge(timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = timer1.merge(timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {ObservableInput} other An input Observable to merge with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} An Observable that emits items that are the result of
 * every input Observable.
 * @method merge
 * @owner Observable
 */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };
}
exports.merge = merge;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in the output Observable.
 *
 * <span class="informal">It's like {@link mergeMap}, but maps each value always
 * to the same inner Observable.</span>
 *
 * <img src="./img/mergeMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then merges those resulting Observables into one
 * single Observable, which is the output Observable.
 *
 * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 * @see {@link switchMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable.
 * @method mergeMapTo
 * @owner Observable
 */
function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return function (source) { return source.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent)); };
}
exports.mergeMapTo = mergeMapTo;
// TODO: Figure out correct signature here: an Operator<Observable<T>, R>
//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>
var MergeMapToOperator = (function () {
    function MergeMapToOperator(ish, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.ish = ish;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapToOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));
    };
    return MergeMapToOperator;
}());
exports.MergeMapToOperator = MergeMapToOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapToSubscriber = (function (_super) {
    __extends(MergeMapToSubscriber, _super);
    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        _super.call(this, destination);
        this.ish = ish;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapToSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var resultSelector = this.resultSelector;
            var index = this.index++;
            var ish = this.ish;
            var destination = this.destination;
            this.active++;
            this._innerSub(ish, destination, resultSelector, value, index);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapToSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    MergeMapToSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapToSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeMapToSubscriber = MergeMapToSubscriber;
//# sourceMappingURL=mergeMapTo.js.map

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(9);
var subscribeToResult_1 = __webpack_require__(4);
var OuterSubscriber_1 = __webpack_require__(3);
/**
 * Applies an accumulator function over the source Observable where the
 * accumulator function itself returns an Observable, then each intermediate
 * Observable returned is merged into the output Observable.
 *
 * <span class="informal">It's like {@link scan}, but the Observables returned
 * by the accumulator are merged into the outer Observable.</span>
 *
 * @example <caption>Count the number of click events</caption>
 * const click$ = Rx.Observable.fromEvent(document, 'click');
 * const one$ = click$.mapTo(1);
 * const seed = 0;
 * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);
 * count$.subscribe(x => console.log(x));
 *
 * // Results:
 * 1
 * 2
 * 3
 * 4
 * // ...and so on for each click
 *
 * @param {function(acc: R, value: T): Observable<R>} accumulator
 * The accumulator function called on each source value.
 * @param seed The initial accumulation value.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of
 * input Observables being subscribed to concurrently.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method mergeScan
 * @owner Observable
 */
function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };
}
exports.mergeScan = mergeScan;
var MergeScanOperator = (function () {
    function MergeScanOperator(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}());
exports.MergeScanOperator = MergeScanOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeScanSubscriber = (function (_super) {
    __extends(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this.acc = acc;
        this.concurrent = concurrent;
        this.hasValue = false;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);
            var destination = this.destination;
            if (ish === errorObject_1.errorObject) {
                destination.error(errorObject_1.errorObject.e);
            }
            else {
                this.active++;
                this._innerSub(ish, value, index);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeScanSubscriber = MergeScanSubscriber;
//# sourceMappingURL=mergeScan.js.map

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var reduce_1 = __webpack_require__(27);
/**
 * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
 * and when source Observable completes it emits a single item: the item with the smallest value.
 *
 * <img src="./img/min.png" width="100%">
 *
 * @example <caption>Get the minimal value of a series of numbers</caption>
 * Rx.Observable.of(5, 4, 7, 2, 8)
 *   .min()
 *   .subscribe(x => console.log(x)); // -> 2
 *
 * @example <caption>Use a comparer function to get the minimal item</caption>
 * interface Person {
 *   age: number,
 *   name: string
 * }
 * Observable.of<Person>({age: 7, name: 'Foo'},
 *                       {age: 5, name: 'Bar'},
 *                       {age: 9, name: 'Beer'})
 *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)
 *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'
 * }
 *
 * @see {@link max}
 *
 * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
 * value of two items.
 * @return {Observable<R>} An Observable that emits item with the smallest value.
 * @method min
 * @owner Observable
 */
function min(comparer) {
    var min = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
        : function (x, y) { return x < y ? x : y; };
    return reduce_1.reduce(min);
}
exports.min = min;
//# sourceMappingURL=min.js.map

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var FromObservable_1 = __webpack_require__(299);
var isArray_1 = __webpack_require__(17);
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/* tslint:enable:max-line-length */
/**
 * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one
 * that was passed.
 *
 * <span class="informal">Execute series of Observables no matter what, even if it means swallowing errors.</span>
 *
 * <img src="./img/onErrorResumeNext.png" width="100%">
 *
 * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as
 * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same
 * as the source.
 *
 * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.
 * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`
 * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting
 * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another
 * Observable in provided series, no matter if previous Observable completed or ended with an error. This will
 * be happening until there is no more Observables left in the series, at which point returned Observable will
 * complete - even if the last subscribed stream ended with an error.
 *
 * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive
 * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable
 * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with
 * an error.
 *
 * Note that you do not get any access to errors emitted by the Observables. In particular do not
 * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take
 * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.
 *
 *
 * @example <caption>Subscribe to the next Observable after map fails</caption>
 * Rx.Observable.of(1, 2, 3, 0)
 *   .map(x => {
 *       if (x === 0) { throw Error(); }
         return 10 / x;
 *   })
 *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))
 *   .subscribe(
 *     val => console.log(val),
 *     err => console.log(err),          // Will never be called.
 *     () => console.log('that\'s it!')
 *   );
 *
 * // Logs:
 * // 10
 * // 5
 * // 3.3333333333333335
 * // 1
 * // 2
 * // 3
 * // "that's it!"
 *
 * @see {@link concat}
 * @see {@link catch}
 *
 * @param {...ObservableInput} observables Observables passed either directly or as an array.
 * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes
 * to the next passed Observable and so on, until it completes or runs out of Observables.
 * @method onErrorResumeNext
 * @owner Observable
 */
function onErrorResumeNext() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i - 0] = arguments[_i];
    }
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };
}
exports.onErrorResumeNext = onErrorResumeNext;
/* tslint:enable:max-line-length */
function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i - 0] = arguments[_i];
    }
    var source = null;
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));
}
exports.onErrorResumeNextStatic = onErrorResumeNextStatic;
var OnErrorResumeNextOperator = (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = (function (_super) {
    __extends(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        _super.call(this, destination);
        this.destination = destination;
        this.nextSources = nextSources;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (next) {
            this.add(subscribeToResult_1.subscribeToResult(this, next));
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=onErrorResumeNext.js.map

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
exports.pairwise = pairwise;
var PairwiseOperator = (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var PairwiseSubscriber = (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        _super.call(this, destination);
        this.hasPrev = false;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=pairwise.js.map

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var not_1 = __webpack_require__(273);
var filter_1 = __webpack_require__(81);
/**
 * Splits the source Observable into two, one with values that satisfy a
 * predicate, and another with values that don't satisfy the predicate.
 *
 * <span class="informal">It's like {@link filter}, but returns two Observables:
 * one like the output of {@link filter}, and the other with values that did not
 * pass the condition.</span>
 *
 * <img src="./img/partition.png" width="100%">
 *
 * `partition` outputs an array with two Observables that partition the values
 * from the source Observable through the given `predicate` function. The first
 * Observable in that array emits source values for which the predicate argument
 * returns true. The second Observable emits source values for which the
 * predicate returns false. The first behaves like {@link filter} and the second
 * behaves like {@link filter} with the predicate negated.
 *
 * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');
 * var clicksOnDivs = parts[0];
 * var clicksElsewhere = parts[1];
 * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));
 * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));
 *
 * @see {@link filter}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted on the first Observable in the returned array, if
 * `false` the value is emitted on the second Observable in the array. The
 * `index` parameter is the number `i` for the i-th source emission that has
 * happened since the subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {[Observable<T>, Observable<T>]} An array with two Observables: one
 * with values that passed the predicate, and another with values that did not
 * pass the predicate.
 * @method partition
 * @owner Observable
 */
function partition(predicate, thisArg) {
    return function (source) { return [
        filter_1.filter(predicate, thisArg)(source),
        filter_1.filter(not_1.not(predicate, thisArg))(source)
    ]; };
}
exports.partition = partition;
//# sourceMappingURL=partition.js.map

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var map_1 = __webpack_require__(37);
/**
 * Maps each source value (an object) to its specified nested property.
 *
 * <span class="informal">Like {@link map}, but meant only for picking one of
 * the nested properties of every emitted object.</span>
 *
 * <img src="./img/pluck.png" width="100%">
 *
 * Given a list of strings describing a path to an object property, retrieves
 * the value of a specified nested property from all values in the source
 * Observable. If a property can't be resolved, it will return `undefined` for
 * that value.
 *
 * @example <caption>Map every click to the tagName of the clicked target element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var tagNames = clicks.pluck('target', 'tagName');
 * tagNames.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {...string} properties The nested properties to pluck from each source
 * value (an object).
 * @return {Observable} A new Observable of property values from the source values.
 * @method pluck
 * @owner Observable
 */
function pluck() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i - 0] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return function (source) { return map_1.map(plucker(properties, length))(source); };
}
exports.pluck = pluck;
function plucker(props, length) {
    var mapper = function (x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
            var p = currentProp[props[i]];
            if (typeof p !== 'undefined') {
                currentProp = p;
            }
            else {
                return undefined;
            }
        }
        return currentProp;
    };
    return mapper;
}
//# sourceMappingURL=pluck.js.map

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Subject_1 = __webpack_require__(6);
var multicast_1 = __webpack_require__(23);
/* tslint:enable:max-line-length */
/**
 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
 * before it begins emitting items to those Observers that have subscribed to it.
 *
 * <img src="./img/publish.png" width="100%">
 *
 * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
 * as needed, without causing multiple subscriptions to the source sequence.
 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
 * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
 * @method publish
 * @owner Observable
 */
function publish(selector) {
    return selector ?
        multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :
        multicast_1.multicast(new Subject_1.Subject());
}
exports.publish = publish;
//# sourceMappingURL=publish.js.map

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var BehaviorSubject_1 = __webpack_require__(104);
var multicast_1 = __webpack_require__(23);
/**
 * @param value
 * @return {ConnectableObservable<T>}
 * @method publishBehavior
 * @owner Observable
 */
function publishBehavior(value) {
    return function (source) { return multicast_1.multicast(new BehaviorSubject_1.BehaviorSubject(value))(source); };
}
exports.publishBehavior = publishBehavior;
//# sourceMappingURL=publishBehavior.js.map

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var AsyncSubject_1 = __webpack_require__(180);
var multicast_1 = __webpack_require__(23);
function publishLast() {
    return function (source) { return multicast_1.multicast(new AsyncSubject_1.AsyncSubject())(source); };
}
exports.publishLast = publishLast;
//# sourceMappingURL=publishLast.js.map

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ReplaySubject_1 = __webpack_require__(58);
var multicast_1 = __webpack_require__(23);
/* tslint:enable:max-line-length */
function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
        scheduler = selectorOrScheduler;
    }
    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
    var subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
    return function (source) { return multicast_1.multicast(function () { return subject; }, selector)(source); };
}
exports.publishReplay = publishReplay;
//# sourceMappingURL=publishReplay.js.map

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray_1 = __webpack_require__(17);
var race_1 = __webpack_require__(188);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that mirrors the first source Observable to emit an item
 * from the combination of this Observable and supplied Observables.
 * @param {...Observables} ...observables Sources used to race for which Observable emits first.
 * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.
 * @method race
 * @owner Observable
 */
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return function raceOperatorFunction(source) {
        // if the only argument is an array, it was most likely called with
        // `pair([obs1, obs2, ...])`
        if (observables.length === 1 && isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));
    };
}
exports.race = race;
//# sourceMappingURL=race.js.map

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var EmptyObservable_1 = __webpack_require__(36);
/**
 * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.
 *
 * <img src="./img/repeat.png" width="100%">
 *
 * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield
 * an empty Observable.
 * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most
 * count times.
 * @method repeat
 * @owner Observable
 */
function repeat(count) {
    if (count === void 0) { count = -1; }
    return function (source) {
        if (count === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else if (count < 0) {
            return source.lift(new RepeatOperator(-1, source));
        }
        else {
            return source.lift(new RepeatOperator(count - 1, source));
        }
    };
}
exports.repeat = repeat;
var RepeatOperator = (function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RepeatSubscriber = (function (_super) {
    __extends(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        _super.call(this, destination);
        this.count = count;
        this.source = source;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=repeat.js.map

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(6);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(9);
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/**
 * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source
 * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable
 * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise
 * this method will resubscribe to the source Observable.
 *
 * <img src="./img/repeatWhen.png" width="100%">
 *
 * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with
 * which a user can `complete` or `error`, aborting the repetition.
 * @return {Observable} The source Observable modified with repeat logic.
 * @method repeatWhen
 * @owner Observable
 */
function repeatWhen(notifier) {
    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };
}
exports.repeatWhen = repeatWhen;
var RepeatWhenOperator = (function () {
    function RepeatWhenOperator(notifier) {
        this.notifier = notifier;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RepeatWhenSubscriber = (function (_super) {
    __extends(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
        this.sourceIsBeingSubscribedTo = true;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            else if (this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next();
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
        this.notifications = null;
        this.retries = null;
        this.retriesSubscription = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this.notifications = notifications;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new Subject_1.Subject();
        var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);
        if (retries === errorObject_1.errorObject) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
    };
    return RepeatWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=repeatWhen.js.map

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
 * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given
 * as a number parameter) rather than propagating the `error` call.
 *
 * <img src="./img/retry.png" width="100%">
 *
 * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
 * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
 * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
 * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
 * @param {number} count - Number of retry attempts before failing.
 * @return {Observable} The source Observable modified with the retry logic.
 * @method retry
 * @owner Observable
 */
function retry(count) {
    if (count === void 0) { count = -1; }
    return function (source) { return source.lift(new RetryOperator(count, source)); };
}
exports.retry = retry;
var RetryOperator = (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetrySubscriber = (function (_super) {
    __extends(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        _super.call(this, destination);
        this.count = count;
        this.source = source;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=retry.js.map

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(6);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(9);
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
 * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.
 * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child
 * subscription. Otherwise this method will resubscribe to the source Observable.
 *
 * <img src="./img/retryWhen.png" width="100%">
 *
 * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a
 * user can `complete` or `error`, aborting the retry.
 * @return {Observable} The source Observable modified with retry logic.
 * @method retryWhen
 * @owner Observable
 */
function retryWhen(notifier) {
    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };
}
exports.retryWhen = retryWhen;
var RetryWhenOperator = (function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetryWhenSubscriber = (function (_super) {
    __extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject_1.Subject();
                retries = tryCatch_1.tryCatch(this.notifier)(errors);
                if (retries === errorObject_1.errorObject) {
                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);
                }
                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
            }
            else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
        this.errors = null;
        this.retries = null;
        this.retriesSubscription = null;
        this._unsubscribeAndRecycle();
        this.errors = errors;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=retryWhen.js.map

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/**
 * Emits the most recently emitted value from the source Observable whenever
 * another Observable, the `notifier`, emits.
 *
 * <span class="informal">It's like {@link sampleTime}, but samples whenever
 * the `notifier` Observable emits something.</span>
 *
 * <img src="./img/sample.png" width="100%">
 *
 * Whenever the `notifier` Observable emits a value or completes, `sample`
 * looks at the source Observable and emits whichever value it has most recently
 * emitted since the previous sampling, unless the source has not emitted
 * anything since the previous sampling. The `notifier` is subscribed to as soon
 * as the output Observable is subscribed.
 *
 * @example <caption>On every click, sample the most recent "seconds" timer</caption>
 * var seconds = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = seconds.sample(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {Observable<any>} notifier The Observable to use for sampling the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the results of sampling the
 * values emitted by the source Observable whenever the notifier Observable
 * emits value or completes.
 * @method sample
 * @owner Observable
 */
function sample(notifier) {
    return function (source) { return source.lift(new SampleOperator(notifier)); };
}
exports.sample = sample;
var SampleOperator = (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));
        return subscription;
    };
    return SampleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SampleSubscriber = (function (_super) {
    __extends(SampleSubscriber, _super);
    function SampleSubscriber() {
        _super.apply(this, arguments);
        this.hasValue = false;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=sample.js.map

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var async_1 = __webpack_require__(7);
/**
 * Emits the most recently emitted value from the source Observable within
 * periodic time intervals.
 *
 * <span class="informal">Samples the source Observable at periodic time
 * intervals, emitting what it samples.</span>
 *
 * <img src="./img/sampleTime.png" width="100%">
 *
 * `sampleTime` periodically looks at the source Observable and emits whichever
 * value it has most recently emitted since the previous sampling, unless the
 * source has not emitted anything since the previous sampling. The sampling
 * happens periodically in time every `period` milliseconds (or the time unit
 * defined by the optional `scheduler` argument). The sampling starts as soon as
 * the output Observable is subscribed.
 *
 * @example <caption>Every second, emit the most recent click at most once</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.sampleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {number} period The sampling period expressed in milliseconds or the
 * time unit determined internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the sampling.
 * @return {Observable<T>} An Observable that emits the results of sampling the
 * values emitted by the source Observable at the specified time interval.
 * @method sampleTime
 * @owner Observable
 */
function sampleTime(period, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };
}
exports.sampleTime = sampleTime;
var SampleTimeOperator = (function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SampleTimeSubscriber = (function (_super) {
    __extends(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        _super.call(this, destination);
        this.period = period;
        this.scheduler = scheduler;
        this.hasValue = false;
        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}
//# sourceMappingURL=sampleTime.js.map

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(9);
/**
 * Compares all values of two observables in sequence using an optional comparor function
 * and returns an observable of a single boolean value representing whether or not the two sequences
 * are equal.
 *
 * <span class="informal">Checks to see of all values emitted by both observables are equal, in order.</span>
 *
 * <img src="./img/sequenceEqual.png" width="100%">
 *
 * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either
 * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom
 * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the
 * observables completes, the operator will wait for the other observable to complete; If the other
 * observable emits before completing, the returned observable will emit `false` and complete. If one observable never
 * completes or emits after the other complets, the returned observable will never complete.
 *
 * @example <caption>figure out if the Konami code matches</caption>
 * var code = Rx.Observable.from([
 *  "ArrowUp",
 *  "ArrowUp",
 *  "ArrowDown",
 *  "ArrowDown",
 *  "ArrowLeft",
 *  "ArrowRight",
 *  "ArrowLeft",
 *  "ArrowRight",
 *  "KeyB",
 *  "KeyA",
 *  "Enter" // no start key, clearly.
 * ]);
 *
 * var keys = Rx.Observable.fromEvent(document, 'keyup')
 *  .map(e => e.code);
 * var matches = keys.bufferCount(11, 1)
 *  .mergeMap(
 *    last11 =>
 *      Rx.Observable.from(last11)
 *        .sequenceEqual(code)
 *   );
 * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));
 *
 * @see {@link combineLatest}
 * @see {@link zip}
 * @see {@link withLatestFrom}
 *
 * @param {Observable} compareTo The observable sequence to compare the source sequence to.
 * @param {function} [comparor] An optional function to compare each value pair
 * @return {Observable} An Observable of a single boolean value representing whether or not
 * the values emitted by both observables were equal in sequence.
 * @method sequenceEqual
 * @owner Observable
 */
function sequenceEqual(compareTo, comparor) {
    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparor)); };
}
exports.sequenceEqual = sequenceEqual;
var SequenceEqualOperator = (function () {
    function SequenceEqualOperator(compareTo, comparor) {
        this.compareTo = compareTo;
        this.comparor = comparor;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));
    };
    return SequenceEqualOperator;
}());
exports.SequenceEqualOperator = SequenceEqualOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SequenceEqualSubscriber = (function (_super) {
    __extends(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparor) {
        _super.call(this, destination);
        this.compareTo = compareTo;
        this.comparor = comparor;
        this._a = [];
        this._b = [];
        this._oneComplete = false;
        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            if (comparor) {
                areEqual = tryCatch_1.tryCatch(comparor)(a, b);
                if (areEqual === errorObject_1.errorObject) {
                    this.destination.error(errorObject_1.errorObject.e);
                }
            }
            else {
                areEqual = a === b;
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber_1.Subscriber));
exports.SequenceEqualSubscriber = SequenceEqualSubscriber;
var SequenceEqualCompareToSubscriber = (function (_super) {
    __extends(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        _super.call(this, destination);
        this.parent = parent;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent._complete();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=sequenceEqual.js.map

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ReplaySubject_1 = __webpack_require__(58);
/**
 * @method shareReplay
 * @owner Observable
 */
function shareReplay(bufferSize, windowTime, scheduler) {
    return function (source) { return source.lift(shareReplayOperator(bufferSize, windowTime, scheduler)); };
}
exports.shareReplay = shareReplay;
function shareReplayOperator(bufferSize, windowTime, scheduler) {
    var subject;
    var refCount = 0;
    var subscription;
    var hasError = false;
    var isComplete = false;
    return function shareReplayOperation(source) {
        refCount++;
        if (!subject || hasError) {
            hasError = false;
            subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
            subscription = source.subscribe({
                next: function (value) { subject.next(value); },
                error: function (err) {
                    hasError = true;
                    subject.error(err);
                },
                complete: function () {
                    isComplete = true;
                    subject.complete();
                },
            });
        }
        var innerSub = subject.subscribe(this);
        return function () {
            refCount--;
            innerSub.unsubscribe();
            if (subscription && refCount === 0 && isComplete) {
                subscription.unsubscribe();
            }
        };
    };
}
;
//# sourceMappingURL=shareReplay.js.map

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var EmptyError_1 = __webpack_require__(292);
/**
 * Returns an Observable that emits the single item emitted by the source Observable that matches a specified
 * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no
 * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.
 *
 * <img src="./img/single.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.
 * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches
 * the predicate.
 .
 * @method single
 * @owner Observable
 */
function single(predicate) {
    return function (source) { return source.lift(new SingleOperator(predicate, source)); };
}
exports.single = single;
var SingleOperator = (function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SingleSubscriber = (function (_super) {
    __extends(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.seenValue = false;
        this.index = 0;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return SingleSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=single.js.map

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
/**
 * Returns an Observable that skips the first `count` items emitted by the source Observable.
 *
 * <img src="./img/skip.png" width="100%">
 *
 * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
 * @return {Observable} An Observable that skips values emitted by the source Observable.
 *
 * @method skip
 * @owner Observable
 */
function skip(count) {
    return function (source) { return source.lift(new SkipOperator(count)); };
}
exports.skip = skip;
var SkipOperator = (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipSubscriber = (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=skip.js.map

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var ArgumentOutOfRangeError_1 = __webpack_require__(38);
/**
 * Skip the last `count` values emitted by the source Observable.
 *
 * <img src="./img/skipLast.png" width="100%">
 *
 * `skipLast` returns an Observable that accumulates a queue with a length
 * enough to store the first `count` values. As more values are received,
 * values are taken from the front of the queue and produced on the result
 * sequence. This causes values to be delayed.
 *
 * @example <caption>Skip the last 2 values of an Observable with many values</caption>
 * var many = Rx.Observable.range(1, 5);
 * var skipLastTwo = many.skipLast(2);
 * skipLastTwo.subscribe(x => console.log(x));
 *
 * // Results in:
 * // 1 2 3
 *
 * @see {@link skip}
 * @see {@link skipUntil}
 * @see {@link skipWhile}
 * @see {@link take}
 *
 * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws
 * ArgumentOutOrRangeError if `i < 0`.
 *
 * @param {number} count Number of elements to skip from the end of the source Observable.
 * @returns {Observable<T>} An Observable that skips the last count values
 * emitted by the source Observable.
 * @method skipLast
 * @owner Observable
 */
function skipLast(count) {
    return function (source) { return source.lift(new SkipLastOperator(count)); };
}
exports.skipLast = skipLast;
var SkipLastOperator = (function () {
    function SkipLastOperator(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    SkipLastOperator.prototype.call = function (subscriber, source) {
        if (this._skipCount === 0) {
            // If we don't want to skip any values then just subscribe
            // to Subscriber without any further logic.
            return source.subscribe(new Subscriber_1.Subscriber(subscriber));
        }
        else {
            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
    };
    return SkipLastOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipLastSubscriber = (function (_super) {
    __extends(SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        _super.call(this, destination);
        this._skipCount = _skipCount;
        this._count = 0;
        this._ring = new Array(_skipCount);
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=skipLast.js.map

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/**
 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
 *
 * <img src="./img/skipUntil.png" width="100%">
 *
 * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to
 * be mirrored by the resulting Observable.
 * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits
 * an item, then emits the remaining items.
 * @method skipUntil
 * @owner Observable
 */
function skipUntil(notifier) {
    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
}
exports.skipUntil = skipUntil;
var SkipUntilOperator = (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));
    };
    return SkipUntilOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipUntilSubscriber = (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.hasValue = false;
        this.isInnerStopped = false;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype._complete = function () {
        if (this.isInnerStopped) {
            _super.prototype._complete.call(this);
        }
        else {
            this.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
        this.isInnerStopped = true;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    return SkipUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=skipUntil.js.map

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
/**
 * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
 * true, but emits all further source items as soon as the condition becomes false.
 *
 * <img src="./img/skipWhile.png" width="100%">
 *
 * @param {Function} predicate - A function to test each item emitted from the source Observable.
 * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the
 * specified predicate becomes false.
 * @method skipWhile
 * @owner Observable
 */
function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
exports.skipWhile = skipWhile;
var SkipWhileOperator = (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipWhileSubscriber = (function (_super) {
    __extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.skipping = true;
        this.index = 0;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=skipWhile.js.map

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayObservable_1 = __webpack_require__(26);
var ScalarObservable_1 = __webpack_require__(294);
var EmptyObservable_1 = __webpack_require__(36);
var concat_1 = __webpack_require__(34);
var isScheduler_1 = __webpack_require__(22);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments before it begins to emit
 * items emitted by the source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {...T} values - Items you want the modified Observable to emit first.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    return function (source) {
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len === 1) {
            return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);
        }
        else if (len > 1) {
            return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);
        }
        else {
            return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);
        }
    };
}
exports.startWith = startWith;
//# sourceMappingURL=startWith.js.map

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var switchMap_1 = __webpack_require__(41);
var identity_1 = __webpack_require__(313);
function switchAll() {
    return switchMap_1.switchMap(identity_1.identity);
}
exports.switchAll = switchAll;
//# sourceMappingURL=switchAll.js.map

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is flattened multiple
 * times with {@link switch} in the output Observable.
 *
 * <span class="informal">It's like {@link switchMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/switchMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. The output Observables
 * emits values only from the most recently emitted instance of
 * `innerObservable`.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link switch}
 * @see {@link switchMap}
 * @see {@link mergeMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable, and taking only the values
 * from the most recently projected inner Observable.
 * @method switchMapTo
 * @owner Observable
 */
function switchMapTo(innerObservable, resultSelector) {
    return function (source) { return source.lift(new SwitchMapToOperator(innerObservable, resultSelector)); };
}
exports.switchMapTo = switchMapTo;
var SwitchMapToOperator = (function () {
    function SwitchMapToOperator(observable, resultSelector) {
        this.observable = observable;
        this.resultSelector = resultSelector;
    }
    SwitchMapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));
    };
    return SwitchMapToOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapToSubscriber = (function (_super) {
    __extends(SwitchMapToSubscriber, _super);
    function SwitchMapToSubscriber(destination, inner, resultSelector) {
        _super.call(this, destination);
        this.inner = inner;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapToSubscriber.prototype._next = function (value) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));
    };
    SwitchMapToSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    return SwitchMapToSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=switchMapTo.js.map

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var ArgumentOutOfRangeError_1 = __webpack_require__(38);
var EmptyObservable_1 = __webpack_require__(36);
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
function take(count) {
    return function (source) {
        if (count === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
exports.take = take;
var TakeOperator = (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeSubscriber = (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=take.js.map

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value or a complete notification, the output Observable stops
 * mirroring the source Observable and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
    };
    return TakeUntilOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=takeUntil.js.map

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
/**
 * Emits values emitted by the source Observable so long as each value satisfies
 * the given `predicate`, and then completes as soon as this `predicate` is not
 * satisfied.
 *
 * <span class="informal">Takes values from the source only while they pass the
 * condition given. When the first value does not satisfy, it completes.</span>
 *
 * <img src="./img/takeWhile.png" width="100%">
 *
 * `takeWhile` subscribes and begins mirroring the source Observable. Each value
 * emitted on the source is given to the `predicate` function which returns a
 * boolean, representing a condition to be satisfied by the source values. The
 * output Observable emits the source values until such time as the `predicate`
 * returns false, at which point `takeWhile` stops mirroring the source
 * Observable and completes the output Observable.
 *
 * @example <caption>Emit click events only while the clientX property is greater than 200</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.takeWhile(ev => ev.clientX > 200);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates a value emitted by the source Observable and returns a boolean.
 * Also takes the (zero-based) index as the second argument.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable so long as each value satisfies the condition defined by the
 * `predicate`, then completes.
 * @method takeWhile
 * @owner Observable
 */
function takeWhile(predicate) {
    return function (source) { return source.lift(new TakeWhileOperator(predicate)); };
}
exports.takeWhile = takeWhile;
var TakeWhileOperator = (function () {
    function TakeWhileOperator(predicate) {
        this.predicate = predicate;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));
    };
    return TakeWhileOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeWhileSubscriber = (function (_super) {
    __extends(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.index = 0;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=takeWhile.js.map

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var async_1 = __webpack_require__(7);
var throttle_1 = __webpack_require__(66);
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for `duration` milliseconds, then repeats this process.
 *
 * <span class="informal">Lets a value pass, then ignores source values for the
 * next `duration` milliseconds.</span>
 *
 * <img src="./img/throttleTime.png" width="100%">
 *
 * `throttleTime` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled. After `duration` milliseconds (or the time unit determined
 * internally by the optional `scheduler`) has passed, the timer is disabled,
 * and this process repeats for the next source value. Optionally takes a
 * {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {number} duration Time to wait before emitting another value after
 * emitting the last value, measured in milliseconds or the time unit determined
 * internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the throttling.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttleTime
 * @owner Observable
 */
function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
exports.throttleTime = throttleTime;
var ThrottleTimeOperator = (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ThrottleTimeSubscriber = (function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        _super.call(this, destination);
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
        this._hasTrailingValue = false;
        this._trailingValue = null;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}
//# sourceMappingURL=throttleTime.js.map

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var async_1 = __webpack_require__(7);
function timeInterval(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new TimeIntervalOperator(scheduler)); };
}
exports.timeInterval = timeInterval;
var TimeInterval = (function () {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}());
exports.TimeInterval = TimeInterval;
;
var TimeIntervalOperator = (function () {
    function TimeIntervalOperator(scheduler) {
        this.scheduler = scheduler;
    }
    TimeIntervalOperator.prototype.call = function (observer, source) {
        return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));
    };
    return TimeIntervalOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeIntervalSubscriber = (function (_super) {
    __extends(TimeIntervalSubscriber, _super);
    function TimeIntervalSubscriber(destination, scheduler) {
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.lastTime = 0;
        this.lastTime = scheduler.now();
    }
    TimeIntervalSubscriber.prototype._next = function (value) {
        var now = this.scheduler.now();
        var span = now - this.lastTime;
        this.lastTime = now;
        this.destination.next(new TimeInterval(value, span));
    };
    return TimeIntervalSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=timeInterval.js.map

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(7);
var isDate_1 = __webpack_require__(25);
var Subscriber_1 = __webpack_require__(2);
var TimeoutError_1 = __webpack_require__(272);
/**
 *
 * Errors if Observable does not emit a value in given time span.
 *
 * <span class="informal">Timeouts on Observable that doesn't emit values fast enough.</span>
 *
 * <img src="./img/timeout.png" width="100%">
 *
 * `timeout` operator accepts as an argument either a number or a Date.
 *
 * If number was provided, it returns an Observable that behaves like a source
 * Observable, unless there is a period of time where there is no value emitted.
 * So if you provide `100` as argument and first value comes after 50ms from
 * the moment of subscription, this value will be simply re-emitted by the resulting
 * Observable. If however after that 100ms passes without a second value being emitted,
 * stream will end with an error and source Observable will be unsubscribed.
 * These checks are performed throughout whole lifecycle of Observable - from the moment
 * it was subscribed to, until it completes or errors itself. Thus every value must be
 * emitted within specified period since previous value.
 *
 * If provided argument was Date, returned Observable behaves differently. It throws
 * if Observable did not complete before provided Date. This means that periods between
 * emission of particular values do not matter in this case. If Observable did not complete
 * before provided Date, source Observable will be unsubscribed. Other than that, resulting
 * stream behaves just as source Observable.
 *
 * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)
 * when returned Observable will check if source stream emitted value or completed.
 *
 * @example <caption>Check if ticks are emitted within certain timespan</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(1100) // Let's use bigger timespan to be safe,
 *                       // since `interval` might fire a bit later then scheduled.
 * .subscribe(
 *     value => console.log(value), // Will emit numbers just as regular `interval` would.
 *     err => console.log(err) // Will never be called.
 * );
 *
 * seconds.timeout(900).subscribe(
 *     value => console.log(value), // Will never be called.
 *     err => console.log(err) // Will emit error before even first value is emitted,
 *                             // since it did not arrive within 900ms period.
 * );
 *
 * @example <caption>Use Date to check if Observable completed</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(new Date("December 17, 2020 03:24:00"))
 * .subscribe(
 *     value => console.log(value), // Will emit values as regular `interval` would
 *                                  // until December 17, 2020 at 03:24:00.
 *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,
 *                             // since Observable did not complete by then.
 * );
 *
 * @see {@link timeoutWith}
 *
 * @param {number|Date} due Number specifying period within which Observable must emit values
 *                          or Date specifying before when Observable should complete
 * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
 * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.
 * @method timeout
 * @owner Observable
 */
function timeout(due, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteTimeout = isDate_1.isDate(due);
    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
    return function (source) { return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError())); };
}
exports.timeout = timeout;
var TimeoutOperator = (function () {
    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
    }
    TimeoutOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));
    };
    return TimeoutOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutSubscriber = (function (_super) {
    __extends(TimeoutSubscriber, _super);
    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {
        _super.call(this, destination);
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
        this.action = null;
        this.scheduleTimeout();
    }
    TimeoutSubscriber.dispatchTimeout = function (subscriber) {
        subscriber.error(subscriber.errorInstance);
    };
    TimeoutSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            // Recycle the action if we've already scheduled one. All the production
            // Scheduler Actions mutate their state/delay time and return themeselves.
            // VirtualActions are immutable, so they create and return a clone. In this
            // case, we need to set the action reference to the most recent VirtualAction,
            // to ensure that's the one we clone from next time.
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.errorInstance = null;
    };
    return TimeoutSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=timeout.js.map

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(7);
var isDate_1 = __webpack_require__(25);
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/* tslint:enable:max-line-length */
/**
 *
 * Errors if Observable does not emit a value in given time span, in case of which
 * subscribes to the second Observable.
 *
 * <span class="informal">It's a version of `timeout` operator that let's you specify fallback Observable.</span>
 *
 * <img src="./img/timeoutWith.png" width="100%">
 *
 * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,
 * still accepting as a first argument either a number or a Date, which control - respectively -
 * when values of source Observable should be emitted or when it should complete.
 *
 * The only difference is that it accepts a second, required parameter. This parameter
 * should be an Observable which will be subscribed when source Observable fails any timeout check.
 * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting
 * values from second Observable. Note that this fallback Observable is not checked for timeouts
 * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second
 * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that
 * stream completes, it completes as well.
 *
 * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided
 * here - as a third, optional parameter. It still is used to schedule timeout checks and -
 * as a consequence - when second Observable will be subscribed, since subscription happens
 * immediately after failing check.
 *
 * @example <caption>Add fallback observable</caption>
 * const seconds = Rx.Observable.interval(1000);
 * const minutes = Rx.Observable.interval(60 * 1000);
 *
 * seconds.timeoutWith(900, minutes)
 *     .subscribe(
 *         value => console.log(value), // After 900ms, will start emitting `minutes`,
 *                                      // since first value of `seconds` will not arrive fast enough.
 *         err => console.log(err) // Would be called after 900ms in case of `timeout`,
 *                                 // but here will never be called.
 *     );
 *
 * @param {number|Date} due Number specifying period within which Observable must emit values
 *                          or Date specifying before when Observable should complete
 * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.
 * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
 * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable
 *                          passed as a second parameter.
 * @method timeoutWith
 * @owner Observable
 */
function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) {
        var absoluteTimeout = isDate_1.isDate(due);
        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
    };
}
exports.timeoutWith = timeoutWith;
var TimeoutWithOperator = (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutWithSubscriber = (function (_super) {
    __extends(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        _super.call(this, destination);
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
        this.action = null;
        this.scheduleTimeout();
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            // Recycle the action if we've already scheduled one. All the production
            // Scheduler Actions mutate their state/delay time and return themeselves.
            // VirtualActions are immutable, so they create and return a clone. In this
            // case, we need to set the action reference to the most recent VirtualAction,
            // to ensure that's the one we clone from next time.
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=timeoutWith.js.map

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var async_1 = __webpack_require__(7);
var map_1 = __webpack_require__(37);
/**
 * @param scheduler
 * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}
 * @method timestamp
 * @owner Observable
 */
function timestamp(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return map_1.map(function (value) { return new Timestamp(value, scheduler.now()); });
    // return (source: Observable<T>) => source.lift(new TimestampOperator(scheduler));
}
exports.timestamp = timestamp;
var Timestamp = (function () {
    function Timestamp(value, timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
    return Timestamp;
}());
exports.Timestamp = Timestamp;
;
//# sourceMappingURL=timestamp.js.map

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var reduce_1 = __webpack_require__(27);
function toArrayReducer(arr, item, index) {
    arr.push(item);
    return arr;
}
function toArray() {
    return reduce_1.reduce(toArrayReducer, []);
}
exports.toArray = toArray;
//# sourceMappingURL=toArray.js.map

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(2);
var Subject_1 = __webpack_require__(6);
/**
 * Branch out the source Observable values as a nested Observable with each
 * nested Observable emitting at most `windowSize` values.
 *
 * <span class="informal">It's like {@link bufferCount}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowCount.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows every `startWindowEvery`
 * items, each containing no more than `windowSize` items. When the source
 * Observable completes or encounters an error, the output Observable emits
 * the current window and propagates the notification from the source
 * Observable. If `startWindowEvery` is not provided, then new windows are
 * started immediately at the start of the source and when each window completes
 * with size `windowSize`.
 *
 * @example <caption>Ignore every 3rd click event, starting from the first one</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowCount(3)
 *   .map(win => win.skip(1)) // skip first of every 3 clicks
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Ignore every 3rd click event, starting from the third one</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowCount(2, 3)
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link bufferCount}
 *
 * @param {number} windowSize The maximum number of values emitted by each
 * window.
 * @param {number} [startWindowEvery] Interval at which to start a new window.
 * For example if `startWindowEvery` is `2`, then a new window will be started
 * on every other value from the source. A new window is started at the
 * beginning of the source by default.
 * @return {Observable<Observable<T>>} An Observable of windows, which in turn
 * are Observable of values.
 * @method windowCount
 * @owner Observable
 */
function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) { startWindowEvery = 0; }
    return function windowCountOperatorFunction(source) {
        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
    };
}
exports.windowCount = windowCount;
var WindowCountOperator = (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowCountSubscriber = (function (_super) {
    __extends(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        _super.call(this, destination);
        this.destination = destination;
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
        this.windows = [new Subject_1.Subject()];
        this.count = 0;
        destination.next(this.windows[0]);
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject_1.Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=windowCount.js.map

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(6);
var async_1 = __webpack_require__(7);
var Subscriber_1 = __webpack_require__(2);
var isNumeric_1 = __webpack_require__(71);
var isScheduler_1 = __webpack_require__(22);
function windowTime(windowTimeSpan) {
    var scheduler = async_1.async;
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if (isScheduler_1.isScheduler(arguments[3])) {
        scheduler = arguments[3];
    }
    if (isScheduler_1.isScheduler(arguments[2])) {
        scheduler = arguments[2];
    }
    else if (isNumeric_1.isNumeric(arguments[2])) {
        maxWindowSize = arguments[2];
    }
    if (isScheduler_1.isScheduler(arguments[1])) {
        scheduler = arguments[1];
    }
    else if (isNumeric_1.isNumeric(arguments[1])) {
        windowCreationInterval = arguments[1];
    }
    return function windowTimeOperatorFunction(source) {
        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
    };
}
exports.windowTime = windowTime;
var WindowTimeOperator = (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = (function (_super) {
    __extends(CountedSubject, _super);
    function CountedSubject() {
        _super.apply(this, arguments);
        this._numberOfNextedValues = 0;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject_1.Subject));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowTimeSubscriber = (function (_super) {
    __extends(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        _super.call(this, destination);
        this.destination = destination;
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
        this.windows = [];
        var window = this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };
            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: this, window: window, windowTimeSpan: windowTimeSpan };
            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}
//# sourceMappingURL=windowTime.js.map

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(6);
var Subscription_1 = __webpack_require__(14);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(9);
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/**
 * Branch out the source Observable values as a nested Observable starting from
 * an emission from `openings` and ending when the output of `closingSelector`
 * emits.
 *
 * <span class="informal">It's like {@link bufferToggle}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowToggle.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows that contain those items
 * emitted by the source Observable between the time when the `openings`
 * Observable emits an item and when the Observable returned by
 * `closingSelector` emits an item.
 *
 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var openings = Rx.Observable.interval(1000);
 * var result = clicks.windowToggle(openings, i =>
 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
 * ).mergeAll();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowWhen}
 * @see {@link bufferToggle}
 *
 * @param {Observable<O>} openings An observable of notifications to start new
 * windows.
 * @param {function(value: O): Observable} closingSelector A function that takes
 * the value emitted by the `openings` observable and returns an Observable,
 * which, when it emits (either `next` or `complete`), signals that the
 * associated window should complete.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowToggle
 * @owner Observable
 */
function windowToggle(openings, closingSelector) {
    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };
}
exports.windowToggle = windowToggle;
var WindowToggleOperator = (function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowToggleSubscriber = (function (_super) {
    __extends(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        _super.call(this, destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.contexts = [];
        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.error(err);
                context.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.complete();
                context.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.unsubscribe();
                context.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingSelector = this.closingSelector;
            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);
            if (closingNotifier === errorObject_1.errorObject) {
                return this.error(errorObject_1.errorObject.e);
            }
            else {
                var window_1 = new Subject_1.Subject();
                var subscription = new Subscription_1.Subscription();
                var context = { window: window_1, subscription: subscription };
                this.contexts.push(context);
                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
                if (innerSubscription.closed) {
                    this.closeWindow(this.contexts.length - 1);
                }
                else {
                    innerSubscription.context = context;
                    subscription.add(innerSubscription);
                }
                this.destination.next(window_1);
            }
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=windowToggle.js.map

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(6);
var tryCatch_1 = __webpack_require__(8);
var errorObject_1 = __webpack_require__(9);
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/**
 * Branch out the source Observable values as a nested Observable using a
 * factory function of closing Observables to determine when to start a new
 * window.
 *
 * <span class="informal">It's like {@link bufferWhen}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowWhen.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping windows.
 * It emits the current window and opens a new one whenever the Observable
 * produced by the specified `closingSelector` function emits an item. The first
 * window is opened immediately when subscribing to the output Observable.
 *
 * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks
 *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link bufferWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals (on either `next` or
 * `complete`) when to close the previous window and start a new one.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowWhen
 * @owner Observable
 */
function windowWhen(closingSelector) {
    return function windowWhenOperatorFunction(source) {
        return source.lift(new WindowOperator(closingSelector));
    };
}
exports.windowWhen = windowWhen;
var WindowOperator = (function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
    };
    return WindowOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowSubscriber = (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        _super.call(this, destination);
        this.destination = destination;
        this.closingSelector = closingSelector;
        this.openWindow();
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) { innerSub = null; }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject_1.Subject();
        this.destination.next(window);
        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject_1.errorObject) {
            var err = errorObject_1.errorObject.e;
            this.destination.error(err);
            this.window.error(err);
        }
        else {
            this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));
        }
    };
    return WindowSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=windowWhen.js.map

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(3);
var subscribeToResult_1 = __webpack_require__(4);
/* tslint:enable:max-line-length */
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * <img src="./img/withLatestFrom.png" width="100%">
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var result = clicks.withLatestFrom(timer);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
exports.withLatestFrom = withLatestFrom;
var WithLatestFromOperator = (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WithLatestFromSubscriber = (function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        _super.call(this, destination);
        this.observables = observables;
        this.project = project;
        this.toRespond = [];
        var len = observables.length;
        this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
        }
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=withLatestFrom.js.map

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var zip_1 = __webpack_require__(68);
function zipAll(project) {
    return function (source) { return source.lift(new zip_1.ZipOperator(project)); };
}
exports.zipAll = zipAll;
//# sourceMappingURL=zipAll.js.map

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(14);
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
exports.Action = Action;
//# sourceMappingURL=Action.js.map

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncAction_1 = __webpack_require__(69);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var QueueAction = (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Otherwise flush the scheduler starting with this action.
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
exports.QueueAction = QueueAction;
//# sourceMappingURL=QueueAction.js.map

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncScheduler_1 = __webpack_require__(70);
var QueueScheduler = (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        _super.apply(this, arguments);
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.QueueScheduler = QueueScheduler;
//# sourceMappingURL=QueueScheduler.js.map

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var QueueAction_1 = __webpack_require__(265);
var QueueScheduler_1 = __webpack_require__(266);
/**
 *
 * Queue Scheduler
 *
 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
 *
 * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
 *
 * When used without delay, it schedules given task synchronously - executes it right when
 * it is scheduled. However when called recursively, that is when inside the scheduled task,
 * another task is scheduled with queue scheduler, instead of executing immediately as well,
 * that task will be put on a queue and wait for current one to finish.
 *
 * This means that when you execute task with `queue` scheduler, you are sure it will end
 * before any other task scheduled with that scheduler will start.
 *
 * @examples <caption>Schedule recursively first, then do something</caption>
 *
 * Rx.Scheduler.queue.schedule(() => {
 *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
 *
 *   console.log('first');
 * });
 *
 * // Logs:
 * // "first"
 * // "second"
 *
 *
 * @example <caption>Reschedule itself recursively</caption>
 *
 * Rx.Scheduler.queue.schedule(function(state) {
 *   if (state !== 0) {
 *     console.log('before', state);
 *     this.schedule(state - 1); // `this` references currently executing Action,
 *                               // which we reschedule with new state
 *     console.log('after', state);
 *   }
 * }, 0, 3);
 *
 * // In scheduler that runs recursively, you would expect:
 * // "before", 3
 * // "before", 2
 * // "before", 1
 * // "after", 1
 * // "after", 2
 * // "after", 3
 *
 * // But with queue it logs:
 * // "before", 3
 * // "after", 3
 * // "before", 2
 * // "after", 2
 * // "before", 1
 * // "after", 1
 *
 *
 * @static true
 * @name queue
 * @owner Scheduler
 */
exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
//# sourceMappingURL=queue.js.map

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var FastMap = (function () {
    function FastMap() {
        this.values = {};
    }
    FastMap.prototype.delete = function (key) {
        this.values[key] = null;
        return true;
    };
    FastMap.prototype.set = function (key, value) {
        this.values[key] = value;
        return this;
    };
    FastMap.prototype.get = function (key) {
        return this.values[key];
    };
    FastMap.prototype.forEach = function (cb, thisArg) {
        var values = this.values;
        for (var key in values) {
            if (values.hasOwnProperty(key) && values[key] !== null) {
                cb.call(thisArg, values[key], key);
            }
        }
    };
    FastMap.prototype.clear = function () {
        this.values = {};
    };
    return FastMap;
}());
exports.FastMap = FastMap;
//# sourceMappingURL=FastMap.js.map

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(35);
var MapPolyfill_1 = __webpack_require__(270);
exports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();
//# sourceMappingURL=Map.js.map

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var MapPolyfill = (function () {
    function MapPolyfill() {
        this.size = 0;
        this._values = [];
        this._keys = [];
    }
    MapPolyfill.prototype.get = function (key) {
        var i = this._keys.indexOf(key);
        return i === -1 ? undefined : this._values[i];
    };
    MapPolyfill.prototype.set = function (key, value) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
            this._keys.push(key);
            this._values.push(value);
            this.size++;
        }
        else {
            this._values[i] = value;
        }
        return this;
    };
    MapPolyfill.prototype.delete = function (key) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
            return false;
        }
        this._values.splice(i, 1);
        this._keys.splice(i, 1);
        this.size--;
        return true;
    };
    MapPolyfill.prototype.clear = function () {
        this._keys.length = 0;
        this._values.length = 0;
        this.size = 0;
    };
    MapPolyfill.prototype.forEach = function (cb, thisArg) {
        for (var i = 0; i < this.size; i++) {
            cb.call(thisArg, this._values[i], this._keys[i]);
        }
    };
    return MapPolyfill;
}());
exports.MapPolyfill = MapPolyfill;
//# sourceMappingURL=MapPolyfill.js.map

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(35);
function minimalSetImpl() {
    // THIS IS NOT a full impl of Set, this is just the minimum
    // bits of functionality we need for this library.
    return (function () {
        function MinimalSet() {
            this._values = [];
        }
        MinimalSet.prototype.add = function (value) {
            if (!this.has(value)) {
                this._values.push(value);
            }
        };
        MinimalSet.prototype.has = function (value) {
            return this._values.indexOf(value) !== -1;
        };
        Object.defineProperty(MinimalSet.prototype, "size", {
            get: function () {
                return this._values.length;
            },
            enumerable: true,
            configurable: true
        });
        MinimalSet.prototype.clear = function () {
            this._values.length = 0;
        };
        return MinimalSet;
    }());
}
exports.minimalSetImpl = minimalSetImpl;
exports.Set = root_1.root.Set || minimalSetImpl();
//# sourceMappingURL=Set.js.map

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when duetime elapses.
 *
 * @see {@link timeout}
 *
 * @class TimeoutError
 */
var TimeoutError = (function (_super) {
    __extends(TimeoutError, _super);
    function TimeoutError() {
        var err = _super.call(this, 'Timeout has occurred');
        this.name = err.name = 'TimeoutError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return TimeoutError;
}(Error));
exports.TimeoutError = TimeoutError;
//# sourceMappingURL=TimeoutError.js.map

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function not(pred, thisArg) {
    function notPred() {
        return !(notPred.pred.apply(notPred.thisArg, arguments));
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}
exports.not = not;
//# sourceMappingURL=not.js.map

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(136);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(137);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(138);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(139);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(140);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(141);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(142);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(143);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(144);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(145);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(146);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(147);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(148);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(149);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (exports) { factory(createExporter(root, createExporter(exports))); }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [0, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator];
        return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
});

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.2
(function() {
  var InvalidStateError, NetworkError, ProgressEvent, SecurityError, SyntaxError, XMLHttpRequest, XMLHttpRequestEventTarget, XMLHttpRequestUpload, http, https, os, url,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLHttpRequestEventTarget = (function() {
    function XMLHttpRequestEventTarget() {
      this.onloadstart = null;
      this.onprogress = null;
      this.onabort = null;
      this.onerror = null;
      this.onload = null;
      this.ontimeout = null;
      this.onloadend = null;
      this._listeners = {};
    }

    XMLHttpRequestEventTarget.prototype.onloadstart = null;

    XMLHttpRequestEventTarget.prototype.onprogress = null;

    XMLHttpRequestEventTarget.prototype.onabort = null;

    XMLHttpRequestEventTarget.prototype.onerror = null;

    XMLHttpRequestEventTarget.prototype.onload = null;

    XMLHttpRequestEventTarget.prototype.ontimeout = null;

    XMLHttpRequestEventTarget.prototype.onloadend = null;

    XMLHttpRequestEventTarget.prototype.addEventListener = function(eventType, listener) {
      var base;
      eventType = eventType.toLowerCase();
      (base = this._listeners)[eventType] || (base[eventType] = []);
      this._listeners[eventType].push(listener);
      return void 0;
    };

    XMLHttpRequestEventTarget.prototype.removeEventListener = function(eventType, listener) {
      var index;
      eventType = eventType.toLowerCase();
      if (this._listeners[eventType]) {
        index = this._listeners[eventType].indexOf(listener);
        if (index !== -1) {
          this._listeners[eventType].splice(index, 1);
        }
      }
      return void 0;
    };

    XMLHttpRequestEventTarget.prototype.dispatchEvent = function(event) {
      var eventType, j, len, listener, listeners;
      event.currentTarget = event.target = this;
      eventType = event.type;
      if (listeners = this._listeners[eventType]) {
        for (j = 0, len = listeners.length; j < len; j++) {
          listener = listeners[j];
          listener.call(this, event);
        }
      }
      if (listener = this["on" + eventType]) {
        listener.call(this, event);
      }
      return void 0;
    };

    return XMLHttpRequestEventTarget;

  })();

  http = __webpack_require__(315);

  https = __webpack_require__(316);

  os = __webpack_require__(317);

  url = __webpack_require__(83);

  XMLHttpRequest = (function(superClass) {
    extend(XMLHttpRequest, superClass);

    function XMLHttpRequest(options) {
      XMLHttpRequest.__super__.constructor.call(this);
      this.onreadystatechange = null;
      this._anonymous = options && options.anon;
      this.readyState = XMLHttpRequest.UNSENT;
      this.response = null;
      this.responseText = '';
      this.responseType = '';
      this.responseURL = '';
      this.status = 0;
      this.statusText = '';
      this.timeout = 0;
      this.upload = new XMLHttpRequestUpload(this);
      this._method = null;
      this._url = null;
      this._sync = false;
      this._headers = null;
      this._loweredHeaders = null;
      this._mimeOverride = null;
      this._request = null;
      this._response = null;
      this._responseParts = null;
      this._responseHeaders = null;
      this._aborting = null;
      this._error = null;
      this._loadedBytes = 0;
      this._totalBytes = 0;
      this._lengthComputable = false;
    }

    XMLHttpRequest.prototype.onreadystatechange = null;

    XMLHttpRequest.prototype.readyState = null;

    XMLHttpRequest.prototype.response = null;

    XMLHttpRequest.prototype.responseText = null;

    XMLHttpRequest.prototype.responseType = null;

    XMLHttpRequest.prototype.status = null;

    XMLHttpRequest.prototype.timeout = null;

    XMLHttpRequest.prototype.upload = null;

    XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
      var xhrUrl;
      method = method.toUpperCase();
      if (method in this._restrictedMethods) {
        throw new SecurityError("HTTP method " + method + " is not allowed in XHR");
      }
      xhrUrl = this._parseUrl(url);
      if (async === void 0) {
        async = true;
      }
      switch (this.readyState) {
        case XMLHttpRequest.UNSENT:
        case XMLHttpRequest.OPENED:
        case XMLHttpRequest.DONE:
          null;
          break;
        case XMLHttpRequest.HEADERS_RECEIVED:
        case XMLHttpRequest.LOADING:
          null;
      }
      this._method = method;
      this._url = xhrUrl;
      this._sync = !async;
      this._headers = {};
      this._loweredHeaders = {};
      this._mimeOverride = null;
      this._setReadyState(XMLHttpRequest.OPENED);
      this._request = null;
      this._response = null;
      this.status = 0;
      this.statusText = '';
      this._responseParts = [];
      this._responseHeaders = null;
      this._loadedBytes = 0;
      this._totalBytes = 0;
      this._lengthComputable = false;
      return void 0;
    };

    XMLHttpRequest.prototype.setRequestHeader = function(name, value) {
      var loweredName;
      if (this.readyState !== XMLHttpRequest.OPENED) {
        throw new InvalidStateError("XHR readyState must be OPENED");
      }
      loweredName = name.toLowerCase();
      if (this._restrictedHeaders[loweredName] || /^sec\-/.test(loweredName) || /^proxy-/.test(loweredName)) {
        console.warn("Refused to set unsafe header \"" + name + "\"");
        return void 0;
      }
      value = value.toString();
      if (loweredName in this._loweredHeaders) {
        name = this._loweredHeaders[loweredName];
        this._headers[name] = this._headers[name] + ', ' + value;
      } else {
        this._loweredHeaders[loweredName] = name;
        this._headers[name] = value;
      }
      return void 0;
    };

    XMLHttpRequest.prototype.send = function(data) {
      if (this.readyState !== XMLHttpRequest.OPENED) {
        throw new InvalidStateError("XHR readyState must be OPENED");
      }
      if (this._request) {
        throw new InvalidStateError("send() already called");
      }
      switch (this._url.protocol) {
        case 'file:':
          this._sendFile(data);
          break;
        case 'http:':
        case 'https:':
          this._sendHttp(data);
          break;
        default:
          throw new NetworkError("Unsupported protocol " + this._url.protocol);
      }
      return void 0;
    };

    XMLHttpRequest.prototype.abort = function() {
      if (!this._request) {
        return;
      }
      this._request.abort();
      this._setError();
      this._dispatchProgress('abort');
      this._dispatchProgress('loadend');
      return void 0;
    };

    XMLHttpRequest.prototype.getResponseHeader = function(name) {
      var loweredName;
      if (!this._responseHeaders) {
        return null;
      }
      loweredName = name.toLowerCase();
      if (loweredName in this._responseHeaders) {
        return this._responseHeaders[loweredName];
      } else {
        return null;
      }
    };

    XMLHttpRequest.prototype.getAllResponseHeaders = function() {
      var lines, name, value;
      if (!this._responseHeaders) {
        return '';
      }
      lines = (function() {
        var ref, results;
        ref = this._responseHeaders;
        results = [];
        for (name in ref) {
          value = ref[name];
          results.push(name + ": " + value);
        }
        return results;
      }).call(this);
      return lines.join("\r\n");
    };

    XMLHttpRequest.prototype.overrideMimeType = function(newMimeType) {
      if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {
        throw new InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
      }
      this._mimeOverride = newMimeType.toLowerCase();
      return void 0;
    };

    XMLHttpRequest.prototype.nodejsSet = function(options) {
      var baseUrl, parsedUrl;
      if ('httpAgent' in options) {
        this.nodejsHttpAgent = options.httpAgent;
      }
      if ('httpsAgent' in options) {
        this.nodejsHttpsAgent = options.httpsAgent;
      }
      if ('baseUrl' in options) {
        baseUrl = options.baseUrl;
        if (baseUrl !== null) {
          parsedUrl = url.parse(baseUrl, false, true);
          if (!parsedUrl.protocol) {
            throw new SyntaxError("baseUrl must be an absolute URL");
          }
        }
        this.nodejsBaseUrl = baseUrl;
      }
      return void 0;
    };

    XMLHttpRequest.nodejsSet = function(options) {
      XMLHttpRequest.prototype.nodejsSet(options);
      return void 0;
    };

    XMLHttpRequest.prototype.UNSENT = 0;

    XMLHttpRequest.UNSENT = 0;

    XMLHttpRequest.prototype.OPENED = 1;

    XMLHttpRequest.OPENED = 1;

    XMLHttpRequest.prototype.HEADERS_RECEIVED = 2;

    XMLHttpRequest.HEADERS_RECEIVED = 2;

    XMLHttpRequest.prototype.LOADING = 3;

    XMLHttpRequest.LOADING = 3;

    XMLHttpRequest.prototype.DONE = 4;

    XMLHttpRequest.DONE = 4;

    XMLHttpRequest.prototype.nodejsHttpAgent = http.globalAgent;

    XMLHttpRequest.prototype.nodejsHttpsAgent = https.globalAgent;

    XMLHttpRequest.prototype.nodejsBaseUrl = null;

    XMLHttpRequest.prototype._restrictedMethods = {
      CONNECT: true,
      TRACE: true,
      TRACK: true
    };

    XMLHttpRequest.prototype._restrictedHeaders = {
      'accept-charset': true,
      'accept-encoding': true,
      'access-control-request-headers': true,
      'access-control-request-method': true,
      connection: true,
      'content-length': true,
      cookie: true,
      cookie2: true,
      date: true,
      dnt: true,
      expect: true,
      host: true,
      'keep-alive': true,
      origin: true,
      referer: true,
      te: true,
      trailer: true,
      'transfer-encoding': true,
      upgrade: true,
      'user-agent': true,
      via: true
    };

    XMLHttpRequest.prototype._privateHeaders = {
      'set-cookie': true,
      'set-cookie2': true
    };

    XMLHttpRequest.prototype._userAgent = ("Mozilla/5.0 (" + (os.type()) + " " + (os.arch()) + ") ") + ("node.js/" + process.versions.node + " v8/" + process.versions.v8);

    XMLHttpRequest.prototype._setReadyState = function(newReadyState) {
      var event;
      this.readyState = newReadyState;
      event = new ProgressEvent('readystatechange');
      this.dispatchEvent(event);
      return void 0;
    };

    XMLHttpRequest.prototype._sendFile = function() {
      if (this._url.method !== 'GET') {
        throw new NetworkError('The file protocol only supports GET');
      }
      throw new Error("Protocol file: not implemented");
    };

    XMLHttpRequest.prototype._sendHttp = function(data) {
      if (this._sync) {
        throw new Error("Synchronous XHR processing not implemented");
      }
      if ((data != null) && (this._method === 'GET' || this._method === 'HEAD')) {
        console.warn("Discarding entity body for " + this._method + " requests");
        data = null;
      } else {
        data || (data = '');
      }
      this.upload._setData(data);
      this._finalizeHeaders();
      this._sendHxxpRequest();
      return void 0;
    };

    XMLHttpRequest.prototype._sendHxxpRequest = function() {
      var agent, hxxp, request;
      if (this._url.protocol === 'http:') {
        hxxp = http;
        agent = this.nodejsHttpAgent;
      } else {
        hxxp = https;
        agent = this.nodejsHttpsAgent;
      }
      request = hxxp.request({
        hostname: this._url.hostname,
        port: this._url.port,
        path: this._url.path,
        auth: this._url.auth,
        method: this._method,
        headers: this._headers,
        agent: agent
      });
      this._request = request;
      if (this.timeout) {
        request.setTimeout(this.timeout, (function(_this) {
          return function() {
            return _this._onHttpTimeout(request);
          };
        })(this));
      }
      request.on('response', (function(_this) {
        return function(response) {
          return _this._onHttpResponse(request, response);
        };
      })(this));
      request.on('error', (function(_this) {
        return function(error) {
          return _this._onHttpRequestError(request, error);
        };
      })(this));
      this.upload._startUpload(request);
      if (this._request === request) {
        this._dispatchProgress('loadstart');
      }
      return void 0;
    };

    XMLHttpRequest.prototype._finalizeHeaders = function() {
      this._headers['Connection'] = 'keep-alive';
      this._headers['Host'] = this._url.host;
      if (this._anonymous) {
        this._headers['Referer'] = 'about:blank';
      }
      this._headers['User-Agent'] = this._userAgent;
      this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
      return void 0;
    };

    XMLHttpRequest.prototype._onHttpResponse = function(request, response) {
      var lengthString;
      if (this._request !== request) {
        return;
      }
      switch (response.statusCode) {
        case 301:
        case 302:
        case 303:
        case 307:
        case 308:
          this._url = this._parseUrl(response.headers['location']);
          this._method = 'GET';
          if ('content-type' in this._loweredHeaders) {
            delete this._headers[this._loweredHeaders['content-type']];
            delete this._loweredHeaders['content-type'];
          }
          if ('Content-Type' in this._headers) {
            delete this._headers['Content-Type'];
          }
          delete this._headers['Content-Length'];
          this.upload._reset();
          this._finalizeHeaders();
          this._sendHxxpRequest();
          return;
      }
      this._response = response;
      this._response.on('data', (function(_this) {
        return function(data) {
          return _this._onHttpResponseData(response, data);
        };
      })(this));
      this._response.on('end', (function(_this) {
        return function() {
          return _this._onHttpResponseEnd(response);
        };
      })(this));
      this._response.on('close', (function(_this) {
        return function() {
          return _this._onHttpResponseClose(response);
        };
      })(this));
      this.responseURL = this._url.href.split('#')[0];
      this.status = this._response.statusCode;
      this.statusText = http.STATUS_CODES[this.status];
      this._parseResponseHeaders(response);
      if (lengthString = this._responseHeaders['content-length']) {
        this._totalBytes = parseInt(lengthString);
        this._lengthComputable = true;
      } else {
        this._lengthComputable = false;
      }
      return this._setReadyState(XMLHttpRequest.HEADERS_RECEIVED);
    };

    XMLHttpRequest.prototype._onHttpResponseData = function(response, data) {
      if (this._response !== response) {
        return;
      }
      this._responseParts.push(data);
      this._loadedBytes += data.length;
      if (this.readyState !== XMLHttpRequest.LOADING) {
        this._setReadyState(XMLHttpRequest.LOADING);
      }
      return this._dispatchProgress('progress');
    };

    XMLHttpRequest.prototype._onHttpResponseEnd = function(response) {
      if (this._response !== response) {
        return;
      }
      this._parseResponse();
      this._request = null;
      this._response = null;
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('load');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._onHttpResponseClose = function(response) {
      var request;
      if (this._response !== response) {
        return;
      }
      request = this._request;
      this._setError();
      request.abort();
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('error');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._onHttpTimeout = function(request) {
      if (this._request !== request) {
        return;
      }
      this._setError();
      request.abort();
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('timeout');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._onHttpRequestError = function(request, error) {
      if (this._request !== request) {
        return;
      }
      this._setError();
      request.abort();
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('error');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._dispatchProgress = function(eventType) {
      var event;
      event = new ProgressEvent(eventType);
      event.lengthComputable = this._lengthComputable;
      event.loaded = this._loadedBytes;
      event.total = this._totalBytes;
      this.dispatchEvent(event);
      return void 0;
    };

    XMLHttpRequest.prototype._setError = function() {
      this._request = null;
      this._response = null;
      this._responseHeaders = null;
      this._responseParts = null;
      return void 0;
    };

    XMLHttpRequest.prototype._parseUrl = function(urlString) {
      var absoluteUrlString, index, password, user, xhrUrl;
      if (this.nodejsBaseUrl === null) {
        absoluteUrlString = urlString;
      } else {
        absoluteUrlString = url.resolve(this.nodejsBaseUrl, urlString);
      }
      xhrUrl = url.parse(absoluteUrlString, false, true);
      xhrUrl.hash = null;
      if (xhrUrl.auth && ((typeof user !== "undefined" && user !== null) || (typeof password !== "undefined" && password !== null))) {
        index = xhrUrl.auth.indexOf(':');
        if (index === -1) {
          if (!user) {
            user = xhrUrl.auth;
          }
        } else {
          if (!user) {
            user = xhrUrl.substring(0, index);
          }
          if (!password) {
            password = xhrUrl.substring(index + 1);
          }
        }
      }
      if (user || password) {
        xhrUrl.auth = user + ":" + password;
      }
      return xhrUrl;
    };

    XMLHttpRequest.prototype._parseResponseHeaders = function(response) {
      var loweredName, name, ref, value;
      this._responseHeaders = {};
      ref = response.headers;
      for (name in ref) {
        value = ref[name];
        loweredName = name.toLowerCase();
        if (this._privateHeaders[loweredName]) {
          continue;
        }
        if (this._mimeOverride !== null && loweredName === 'content-type') {
          value = this._mimeOverride;
        }
        this._responseHeaders[loweredName] = value;
      }
      if (this._mimeOverride !== null && !('content-type' in this._responseHeaders)) {
        this._responseHeaders['content-type'] = this._mimeOverride;
      }
      return void 0;
    };

    XMLHttpRequest.prototype._parseResponse = function() {
      var arrayBuffer, buffer, i, j, jsonError, ref, view;
      if (Buffer.concat) {
        buffer = Buffer.concat(this._responseParts);
      } else {
        buffer = this._concatBuffers(this._responseParts);
      }
      this._responseParts = null;
      switch (this.responseType) {
        case 'text':
          this._parseTextResponse(buffer);
          break;
        case 'json':
          this.responseText = null;
          try {
            this.response = JSON.parse(buffer.toString('utf-8'));
          } catch (error1) {
            jsonError = error1;
            this.response = null;
          }
          break;
        case 'buffer':
          this.responseText = null;
          this.response = buffer;
          break;
        case 'arraybuffer':
          this.responseText = null;
          arrayBuffer = new ArrayBuffer(buffer.length);
          view = new Uint8Array(arrayBuffer);
          for (i = j = 0, ref = buffer.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            view[i] = buffer[i];
          }
          this.response = arrayBuffer;
          break;
        default:
          this._parseTextResponse(buffer);
      }
      return void 0;
    };

    XMLHttpRequest.prototype._parseTextResponse = function(buffer) {
      var e;
      try {
        this.responseText = buffer.toString(this._parseResponseEncoding());
      } catch (error1) {
        e = error1;
        this.responseText = buffer.toString('binary');
      }
      this.response = this.responseText;
      return void 0;
    };

    XMLHttpRequest.prototype._parseResponseEncoding = function() {
      var contentType, encoding, match;
      encoding = null;
      if (contentType = this._responseHeaders['content-type']) {
        if (match = /\;\s*charset\=(.*)$/.exec(contentType)) {
          return match[1];
        }
      }
      return 'utf-8';
    };

    XMLHttpRequest.prototype._concatBuffers = function(buffers) {
      var buffer, j, k, len, len1, length, target;
      if (buffers.length === 0) {
        return new Buffer(0);
      }
      if (buffers.length === 1) {
        return buffers[0];
      }
      length = 0;
      for (j = 0, len = buffers.length; j < len; j++) {
        buffer = buffers[j];
        length += buffer.length;
      }
      target = new Buffer(length);
      length = 0;
      for (k = 0, len1 = buffers.length; k < len1; k++) {
        buffer = buffers[k];
        buffer.copy(target, length);
        length += buffer.length;
      }
      return target;
    };

    return XMLHttpRequest;

  })(XMLHttpRequestEventTarget);

  module.exports = XMLHttpRequest;

  XMLHttpRequest.XMLHttpRequest = XMLHttpRequest;

  SecurityError = (function(superClass) {
    extend(SecurityError, superClass);

    function SecurityError() {
      SecurityError.__super__.constructor.apply(this, arguments);
    }

    return SecurityError;

  })(Error);

  XMLHttpRequest.SecurityError = SecurityError;

  InvalidStateError = (function(superClass) {
    extend(InvalidStateError, superClass);

    function InvalidStateError() {
      InvalidStateError.__super__.constructor.apply(this, arguments);
    }

    return InvalidStateError;

  })(Error);

  InvalidStateError = (function(superClass) {
    extend(InvalidStateError, superClass);

    function InvalidStateError() {
      return InvalidStateError.__super__.constructor.apply(this, arguments);
    }

    return InvalidStateError;

  })(Error);

  XMLHttpRequest.InvalidStateError = InvalidStateError;

  NetworkError = (function(superClass) {
    extend(NetworkError, superClass);

    function NetworkError() {
      NetworkError.__super__.constructor.apply(this, arguments);
    }

    return NetworkError;

  })(Error);

  XMLHttpRequest.SyntaxError = SyntaxError;

  SyntaxError = (function(superClass) {
    extend(SyntaxError, superClass);

    function SyntaxError() {
      SyntaxError.__super__.constructor.apply(this, arguments);
    }

    return SyntaxError;

  })(Error);

  ProgressEvent = (function() {
    function ProgressEvent(type) {
      this.type = type;
      this.target = null;
      this.currentTarget = null;
      this.lengthComputable = false;
      this.loaded = 0;
      this.total = 0;
    }

    ProgressEvent.prototype.bubbles = false;

    ProgressEvent.prototype.cancelable = false;

    ProgressEvent.prototype.target = null;

    ProgressEvent.prototype.loaded = null;

    ProgressEvent.prototype.lengthComputable = null;

    ProgressEvent.prototype.total = null;

    return ProgressEvent;

  })();

  XMLHttpRequest.ProgressEvent = ProgressEvent;

  XMLHttpRequestUpload = (function(superClass) {
    extend(XMLHttpRequestUpload, superClass);

    function XMLHttpRequestUpload(request) {
      XMLHttpRequestUpload.__super__.constructor.call(this);
      this._request = request;
      this._reset();
    }

    XMLHttpRequestUpload.prototype._reset = function() {
      this._contentType = null;
      this._body = null;
      return void 0;
    };

    XMLHttpRequestUpload.prototype._setData = function(data) {
      var body, i, j, k, offset, ref, ref1, view;
      if (typeof data === 'undefined' || data === null) {
        return;
      }
      if (typeof data === 'string') {
        if (data.length !== 0) {
          this._contentType = 'text/plain;charset=UTF-8';
        }
        this._body = new Buffer(data, 'utf8');
      } else if (Buffer.isBuffer(data)) {
        this._body = data;
      } else if (data instanceof ArrayBuffer) {
        body = new Buffer(data.byteLength);
        view = new Uint8Array(data);
        for (i = j = 0, ref = data.byteLength; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          body[i] = view[i];
        }
        this._body = body;
      } else if (data.buffer && data.buffer instanceof ArrayBuffer) {
        body = new Buffer(data.byteLength);
        offset = data.byteOffset;
        view = new Uint8Array(data.buffer);
        for (i = k = 0, ref1 = data.byteLength; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
          body[i] = view[i + offset];
        }
        this._body = body;
      } else {
        throw new Error("Unsupported send() data " + data);
      }
      return void 0;
    };

    XMLHttpRequestUpload.prototype._finalizeHeaders = function(headers, loweredHeaders) {
      if (this._contentType) {
        if (!('content-type' in loweredHeaders)) {
          headers['Content-Type'] = this._contentType;
        }
      }
      if (this._body) {
        headers['Content-Length'] = this._body.length.toString();
      }
      return void 0;
    };

    XMLHttpRequestUpload.prototype._startUpload = function(request) {
      if (this._body) {
        request.write(this._body);
      }
      request.end();
      return void 0;
    };

    return XMLHttpRequestUpload;

  })(XMLHttpRequestEventTarget);

  XMLHttpRequest.XMLHttpRequestUpload = XMLHttpRequestUpload;

}).call(this);


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(12);

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(14);

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(17);

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(21);

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(27);

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(28);

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(30);

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(31);

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(60);

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(64);

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(67);

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(70);

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(72);

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(78);

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(80);

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(81);

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(84);

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(85);

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(87);

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(88);

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(93);

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(94);

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(95);

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(98);

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(99);

/***/ }),
/* 315 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 316 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 317 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ })
/******/ ])));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZjIxMWQ4OWE0N2RmODViYjQwNTYiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiLi92ZW5kb3JcIiIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvYnVuZGxlcy9jb3JlLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL1N1YnNjcmliZXIuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9PdXRlclN1YnNjcmliZXIuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL3N1YnNjcmliZVRvUmVzdWx0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvT2JzZXJ2YWJsZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL1N1YmplY3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy8uL34vcnhqcy9zY2hlZHVsZXIvYXN5bmMuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvdHJ5Q2F0Y2guanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL2Vycm9yT2JqZWN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlNS9saWIvY29tbW9uL2h0bWwuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vYnVuZGxlcy9jb21tb24udW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9zZXJ2aWNlcy9iYWNrZW5kL2NvbW1vbi1odHRwLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9yb3V0ZXIvYnVuZGxlcy9yb3V0ZXIudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvU3Vic2NyaXB0aW9uLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9zZXJ2aWNlcy9zZXJ2aWNlLnZhcmlhYmxlcy50cyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnVuZGxlcy9hbmltYXRpb25zLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNBcnJheS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9odHRwL2J1bmRsZXMvaHR0cC51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItand0L2FuZ3VsYXIyLWp3dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlNS9saWIvY29tbW9uL3VuaWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZTUvbGliL3Rva2VuaXplci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc1NjaGVkdWxlci5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9tdWx0aWNhc3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9leHRlcm5hbCBcInV0aWxcIiIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9pc0RhdGUuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3JlZHVjZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwic3RyZWFtXCIiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2VydmljZXMvZnJvbnRlbmQvYWxlcnQuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlNS9saWIvY29tbW9uL2RvY3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZTUvbGliL2NvbW1vbi9tZXJnZV9vcHRpb25zLmpzIiwid2VicGFjazovLy8uL34vcGFyc2U1L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlNS9saWIvdHJlZV9hZGFwdGVycy9kZWZhdWx0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL2NvbmNhdC5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9yb290LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvbWFwLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvci5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9wbGF0Zm9ybS1zZXJ2ZXIvYnVuZGxlcy9wbGF0Zm9ybS1zZXJ2ZXIudW1kLmpzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3NlcnZpY2VzL2Zyb250ZW5kL2xvYWRpbmcuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL3N3aXRjaE1hcC5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZmlsdGVyLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnVuZGxlcy9hbmltYXRpb25zLWJyb3dzZXIudW1kLmpzIiwid2VicGFjazovLy8uL34vQGFuZ3VsYXIvY29tbW9uL2J1bmRsZXMvY29tbW9uLWh0dHAudW1kLmpzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvYXBwL2FwcC5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9hcHAvZW5kLXVzZXIvZXJyb3IvZXJyb3IuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL2RpcmVjdGl2ZXMvZGlyZWN0aXZlLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9waXBlcy9waXBlLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9zZXJ2aWNlcy9iYWNrZW5kL2xvY2FsLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2VydmljZXMvZnJvbnRlbmQvZGF0YS5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2Ryb3Bkb3duL2Ryb3Bkb3duLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS90YWJiZWQvdGFiYmVkLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlNS9saWIvY29tbW9uL2ZvcmVpZ25fY29udGVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlNS9saWIvcGFyc2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcGFyc2U1L2xpYi9wYXJzZXIvb3Blbl9lbGVtZW50X3N0YWNrLmpzIiwid2VicGFjazovLy8uL34vcGFyc2U1L2xpYi9wYXJzZXIvcGFyc2VyX3N0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlNS9saWIvc2VyaWFsaXplci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvUmVwbGF5U3ViamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2NhdGNoLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvbWFwLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2hhcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9hdWRpdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL2NvbWJpbmVMYXRlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9kaXN0aW5jdFVudGlsQ2hhbmdlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy90aHJvdHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL3dpbmRvdy5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL3ppcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc2NoZWR1bGVyL0FzeW5jQWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9zY2hlZHVsZXIvQXN5bmNTY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3V0aWwvaXNOdW1lcmljLmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvbWVyZ2VNYXAuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9tYXAuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9idW5kbGVzL3BsYXRmb3JtLWJyb3dzZXIudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvTm90aWZpY2F0aW9uLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9tZXJnZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvb2YuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9maXJzdC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9jb25jYXRBbGwuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvY29uY2F0TWFwLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL2ZpbHRlci5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9vYnNlcnZlT24uanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9leHRlcm5hbCBcInVybFwiIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvYXBwLnNlcnZlci5tb2R1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWZsZWN0LW1ldGFkYXRhL1JlZmxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9maXJzdC5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2FzcG5ldC1wcmVyZW5kZXJpbmcvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvem9uZS5qcy9kaXN0L3pvbmUtbm9kZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9mb3Jtcy9idW5kbGVzL2Zvcm1zLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2hhcmVkLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9zZXJ2aWNlcy9iYWNrZW5kL2F1dGguc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3NlcnZpY2VzL2Zyb250ZW5kL2NvbmZpcm0uc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9zZXJ2aWNlcy9iYWNrZW5kL2pvYi5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3NlcnZpY2VzL2JhY2tlbmQvZXZlbnQuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9zZXJ2aWNlcy9iYWNrZW5kL2pvYi1ncm91cC5zZXJ2aWNlLnRzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL192YXJpYWJsZXMudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZ3VhcmRzL2FkbWluLmd1YXJkLnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3NlcnZpY2VzL2JhY2tlbmQvcHJvZmlsZS5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3NlcnZpY2VzL2JhY2tlbmQvcm9sZS5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3NlcnZpY2VzL2JhY2tlbmQvd29yay10eXBlLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy90YXAuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL0JlaGF2aW9yU3ViamVjdC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2VydmljZXMvYmFja2VuZC9jb21wYW55LnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvdWkubW9kdWxlLnRzIiwid2VicGFjazovLy8uL34vQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9idW5kbGVzL3BsYXRmb3JtLWJyb3dzZXItYW5pbWF0aW9ucy51bWQuanMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9hcHAucm91dGVyLnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvYXBwLnNoYXJlZC5tb2R1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9hcHAvZW5kLXVzZXIvaG9tZS9jb21wb25lbnRzL2pvYnMtY29udGFpbmVyL2pvYnMtY29udGFpbmVyLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9kaXJlY3RpdmVzL2NsaWNrT3V0c2lkZS5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZGlyZWN0aXZlcy9ob3ZlckVmZmVjdC5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZGlyZWN0aXZlcy9yaXBwbGUuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL2d1YXJkcy9hdXRoLmd1YXJkLnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL2d1YXJkcy9jb21wYW55Lmd1YXJkLnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL2d1YXJkcy9ndWFyZC5tb2R1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZ3VhcmRzL3N0dWRlbnQuZ3VhcmQudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvcGlwZXMvbGltaXQtdGV4dC5waXBlLnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3NlcnZpY2VzL2Zyb250ZW5kL3Byb2dyZXNzLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2VydmljZXMvc2VydmljZS5tb2R1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvYWN0aW9uLW1lbnUvYWN0aW9uLWl0ZW0vYWN0aW9uLWl0ZW0uY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2FjdGlvbi1tZW51L2FjdGlvbi1tZW51LmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9ibG9nL2Jsb2cuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2NhcmQvY2FyZC5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvY2Fyb3VzZWwtbGlzdC9jYXJvdXNlbC1saXN0LmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9kcm9wZG93bi9kcm9wZG93bkl0ZW0vZHJvcGRvd25JdGVtLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9leHBhbnNpYmxlLWNhcmQvZXhwYW5zaWJsZS1jYXJkLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9ncm91cC9ncm91cC5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvam9iL2pvYi5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvb3ZlcmxheS9vdmVybGF5LmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9wb3BvdmVyL3BvcG92ZXIuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL3JhdGluZy9yYXRpbmcuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL3RhYmJlZC90YWIvdGFiLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS93YWl0ZXIvd2FpdGVyLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYm9vdC5zZXJ2ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9hcHAvYXBwLmNvbXBvbmVudC5jc3MiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9hcHAvZW5kLXVzZXIvaG9tZS9jb21wb25lbnRzL2pvYnMtY29udGFpbmVyL2pvYnMtY29udGFpbmVyLmNvbXBvbmVudC5zY3NzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2FjdGlvbi1tZW51L2FjdGlvbi1pdGVtL2FjdGlvbi1pdGVtLmNvbXBvbmVudC5zY3NzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2FjdGlvbi1tZW51L2FjdGlvbi1tZW51LmNvbXBvbmVudC5zY3NzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2Jsb2cvYmxvZy5jb21wb25lbnQuc2NzcyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9jYXJkL2NhcmQuY29tcG9uZW50LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvY2Fyb3VzZWwtbGlzdC9jYXJvdXNlbC1saXN0LmNvbXBvbmVudC5zY3NzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2Ryb3Bkb3duL2Ryb3Bkb3duLmNvbXBvbmVudC5zY3NzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2V4cGFuc2libGUtY2FyZC9leHBhbnNpYmxlLWNhcmQuY29tcG9uZW50LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvZ3JvdXAvZ3JvdXAuY29tcG9uZW50LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvam9iL2pvYi5jb21wb25lbnQuc2NzcyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9vdmVybGF5L292ZXJsYXkuY29tcG9uZW50LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvcG9wb3Zlci9wb3BvdmVyLmNvbXBvbmVudC5zY3NzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL3dhaXRlci93YWl0ZXIuY29tcG9uZW50LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9hcHAvYXBwLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvYXBwL2VuZC11c2VyL2Vycm9yL2Vycm9yLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvYXBwL2VuZC11c2VyL2hvbWUvY29tcG9uZW50cy9qb2JzLWNvbnRhaW5lci9qb2JzLWNvbnRhaW5lci5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9hY3Rpb24tbWVudS9hY3Rpb24taXRlbS9hY3Rpb24taXRlbS5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9hY3Rpb24tbWVudS9hY3Rpb24tbWVudS5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9ibG9nL2Jsb2cuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvY2FyZC9jYXJkLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2Nhcm91c2VsLWxpc3QvY2Fyb3VzZWwtbGlzdC5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9kcm9wZG93bi9kcm9wZG93bi5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9kcm9wZG93bi9kcm9wZG93bkl0ZW0vZHJvcGRvd25JdGVtLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2V4cGFuc2libGUtY2FyZC9leHBhbnNpYmxlLWNhcmQuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvZ3JvdXAvZ3JvdXAuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvam9iL2pvYi5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9vdmVybGF5L292ZXJsYXkuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvcG9wb3Zlci9wb3BvdmVyLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL3JhdGluZy9yYXRpbmcuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvdGFiYmVkL3RhYi90YWIuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvdGFiYmVkL3RhYmJlZC5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS93YWl0ZXIvd2FpdGVyLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL34vcGFyc2U1L2xpYi9sb2NhdGlvbl9pbmZvL3BhcnNlcl9taXhpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlNS9saWIvbG9jYXRpb25faW5mby90b2tlbml6ZXJfbWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZTUvbGliL3BhcnNlci9mb3JtYXR0aW5nX2VsZW1lbnRfbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlNS9saWIvcGFyc2VyL3BsYWluX3RleHRfY29udmVyc2lvbl9zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZTUvbGliL3NheC9kZXZfbnVsbF9zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZTUvbGliL3NheC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlNS9saWIvc2F4L3BhcnNlcl9mZWVkYmFja19zaW11bGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZTUvbGliL3NlcmlhbGl6ZXIvc2VyaWFsaXplcl9zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZTUvbGliL3Rva2VuaXplci9uYW1lZF9lbnRpdHlfZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlNS9saWIvdG9rZW5pemVyL3ByZXByb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlNS9saWIvdHJlZV9hZGFwdGVycy9odG1scGFyc2VyMi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvQXN5bmNTdWJqZWN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9TY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2RlZmVyLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL21lcmdlTWFwLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL0RlZmVyT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9UaW1lck9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvZGVmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvcmFjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS90aW1lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvYXVkaXRUaW1lLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvYnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvYnVmZmVyQ291bnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9idWZmZXJUaW1lLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvYnVmZmVyVG9nZ2xlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvYnVmZmVyV2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL2NvbWJpbmVBbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9jb25jYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9jb25jYXRNYXBUby5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL2NvdW50LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9kZWJvdW5jZVRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9kZWxheS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL2RlbGF5V2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL2RlbWF0ZXJpYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9kaXN0aW5jdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvZWxlbWVudEF0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvZXhoYXVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL2V4aGF1c3RNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9leHBhbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9maW5hbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL2ZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL2dyb3VwQnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9pZ25vcmVFbGVtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL2lzRW1wdHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9tYXBUby5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL21hdGVyaWFsaXplLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvbWF4LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9tZXJnZU1hcFRvLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvbWVyZ2VTY2FuLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvbWluLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvb25FcnJvclJlc3VtZU5leHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9wYWlyd2lzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL3BhcnRpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL3BsdWNrLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvcHVibGlzaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL3B1Ymxpc2hCZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL3B1Ymxpc2hMYXN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvcHVibGlzaFJlcGxheS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL3JhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9yZXBlYXRXaGVuLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvcmV0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9yZXRyeVdoZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9zYW1wbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy9zYW1wbGVUaW1lLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvc2VxdWVuY2VFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL3NoYXJlUmVwbGF5LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvc2luZ2xlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvc2tpcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL3NraXBMYXN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvc2tpcFVudGlsLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvc2tpcFdoaWxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvc3RhcnRXaXRoLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvc3dpdGNoQWxsLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvc3dpdGNoTWFwVG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy90YWtlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvdGFrZVVudGlsLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvdGFrZVdoaWxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvdGhyb3R0bGVUaW1lLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvdGltZUludGVydmFsLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvdGltZW91dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL3RpbWVvdXRXaXRoLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvdGltZXN0YW1wLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvdG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL3dpbmRvd0NvdW50LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvcnMvd2luZG93VGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL3dpbmRvd1RvZ2dsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL3dpbmRvd1doZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9ycy93aXRoTGF0ZXN0RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3JzL3ppcEFsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc2NoZWR1bGVyL0FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc2NoZWR1bGVyL1F1ZXVlQWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9zY2hlZHVsZXIvUXVldWVTY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NjaGVkdWxlci9xdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9GYXN0TWFwLmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL01hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9NYXBQb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9TZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3V0aWwvVGltZW91dEVycm9yLmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL25vdC5qcyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2FwcC9hcHAuY29tcG9uZW50LmNzcz85ODE3Iiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvYXBwL2VuZC11c2VyL2hvbWUvY29tcG9uZW50cy9qb2JzLWNvbnRhaW5lci9qb2JzLWNvbnRhaW5lci5jb21wb25lbnQuc2Nzcz8xM2YzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2FjdGlvbi1tZW51L2FjdGlvbi1pdGVtL2FjdGlvbi1pdGVtLmNvbXBvbmVudC5zY3NzPzIzNWYiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvYWN0aW9uLW1lbnUvYWN0aW9uLW1lbnUuY29tcG9uZW50LnNjc3M/ZDFiNyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9ibG9nL2Jsb2cuY29tcG9uZW50LnNjc3M/MWUyMSIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9jYXJkL2NhcmQuY29tcG9uZW50LnNjc3M/NzRlZiIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9jYXJvdXNlbC1saXN0L2Nhcm91c2VsLWxpc3QuY29tcG9uZW50LnNjc3M/NjVmZiIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9kcm9wZG93bi9kcm9wZG93bi5jb21wb25lbnQuc2Nzcz8wYjBjIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2V4cGFuc2libGUtY2FyZC9leHBhbnNpYmxlLWNhcmQuY29tcG9uZW50LnNjc3M/ZDBhMCIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9ncm91cC9ncm91cC5jb21wb25lbnQuc2Nzcz84MWE0Iiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2pvYi9qb2IuY29tcG9uZW50LnNjc3M/NjVlMiIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9vdmVybGF5L292ZXJsYXkuY29tcG9uZW50LnNjc3M/MGZjYyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9wb3BvdmVyL3BvcG92ZXIuY29tcG9uZW50LnNjc3M/OTJhZSIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS93YWl0ZXIvd2FpdGVyLmNvbXBvbmVudC5zY3NzPzBjMDgiLCJ3ZWJwYWNrOi8vLy4vfi90c2xpYi90c2xpYi5qcyIsIndlYnBhY2s6Ly8vLi9+L3hocjIvbGliL3hocjIuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9tZXJnZUFsbC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL3N5bWJvbC9pdGVyYXRvci5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvRW1wdHlFcnJvci5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9idW5kbGVzL2NvbXBpbGVyLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvU2NhbGFyT2JzZXJ2YWJsZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvZnJvbVByb21pc2UuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvcmVmQ291bnQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvU3ViamVjdFN1YnNjcmlwdGlvbi5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvRnJvbU9ic2VydmFibGUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL2Zyb20uanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9jYXRjaC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2NvbmNhdE1hcC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL21lcmdlTWFwLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3Ivc2hhcmUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvY2F0Y2hFcnJvci5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9kZWZhdWx0SWZFbXB0eS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9ldmVyeS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9maXJzdC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9sYXN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3NjYW4uanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvc2hhcmUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvdGFrZUxhc3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL2lkZW50aXR5LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9ub29wLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiaHR0cHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJvc1wiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBMkMsY0FBYzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBYztBQUNkLFlBQUk7QUFDSjs7QUFFQTtBQUNBOzs7Ozs7O0FDNUZBLHFDOzs7Ozs7QUNBQSw2Qzs7Ozs7O0FDQUEsNkM7Ozs7OztBQ0FBLDhDOzs7Ozs7QUNBQSw4Qzs7Ozs7O0FDQUEsNkM7Ozs7OztBQ0FBLDZDOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7O0FDOUNBLCtDOzs7Ozs7QUNBQSw4Qzs7Ozs7OztBQ0FBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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O0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQ0FBbUMsdURBQXVEO0FBQzFGO0FBQ0E7QUFDQSxtQ0FBbUMsMERBQTBEO0FBQzdGO0FBQ0E7QUFDQSxtQ0FBbUMseURBQXlEO0FBQzVGO0FBQ0E7QUFDQSxtQ0FBbUMsMERBQTBEO0FBQzdGO0FBQ0E7QUFDQSxtQ0FBbUMsMkRBQTJEO0FBQzlGO0FBQ0E7QUFDQSxtQ0FBbUMsd0RBQXdEO0FBQzNGO0FBQ0E7QUFDQSxtQ0FBbUMsMkRBQTJEO0FBQzlGO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEO0FBQ0E7QUFDQSxtQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBaUQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0M7Ozs7Ozs7QUN6V0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxnQ0FBZ0M7QUFDOUM7O0FBRUE7QUFDQSw4QkFBOEIsa0NBQWtDOztBQUVoRTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSw0QkFBNEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQzNKQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLO0FBQ0w7Ozs7Ozs7O0FDWkE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLGdDQUFnQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNuUUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBELFFBQVE7QUFDbEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxRQUFRO0FBQ2pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLCtCQUErQjtBQUN6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLE9BQU87QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMscUNBQXFDO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHFDQUFxQztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNsd0ZBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMVlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUMxRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsK0JBQStCLElBQUk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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a0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsd0NBQXdDO0FBQ3hDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx3Q0FBd0M7QUFDeEMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsd0NBQXdDO0FBQ3hDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHdDQUF3QztBQUN4QywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsd0NBQXdDO0FBQ3hDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUJBQXVCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDBCQUEwQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDO3VCQUNwSCxHQUFHLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUM7dUJBQzNILEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDO3VCQUMxSSxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDLElBQUksR0FBRyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQzt1QkFDckksR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUM7dUJBQ3ZJLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQ2xK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O0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQzFOQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7Ozs7Ozs7O0FDbkpBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFFBQVE7QUFDN0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLDRCQUE0QjtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQzs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEMsMkJBQTJCLGFBQWE7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsNEJBQTRCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix5Q0FBeUM7QUFDaEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxrQkFBa0I7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDdEtBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNuQkE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ2JBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hKQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0JBOztBQUVBO0FBQ0E7QUFDQSxrd3ZFOzs7Ozs7O0FDSkE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7QUN6SkE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqVkE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdDOzs7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxREFBcUQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0I7Ozs7Ozs7QUNUQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7Ozs7Ozs7O0FDTkE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7Ozs7OztBQ05BOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7Ozs7Ozs7QUNOQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7Ozs7Ozs7O0FDTkE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7Ozs7OztBQ05BOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7Ozs7Ozs7QUNOQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7Ozs7Ozs7O0FDTkE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7Ozs7OztBQ05BOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7Ozs7Ozs7QUNOQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7Ozs7Ozs7O0FDTkE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7Ozs7OztBQ05BOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7Ozs7Ozs7QUNOQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7Ozs7Ozs7O0FDTkE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBeUQsd0RBQXdELEVBQUU7QUFBQTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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dC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgY2h1bmtzXG4gXHQvLyBcIjBcIiBtZWFucyBcImFscmVhZHkgbG9hZGVkXCJcbiBcdHZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG4gXHRcdDEwOiAwXG4gXHR9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cbiBcdC8vIFRoaXMgZmlsZSBjb250YWlucyBvbmx5IHRoZSBlbnRyeSBjaHVuay5cbiBcdC8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5lID0gZnVuY3Rpb24gcmVxdWlyZUVuc3VyZShjaHVua0lkKSB7XG4gXHRcdC8vIFwiMFwiIGlzIHRoZSBzaWduYWwgZm9yIFwiYWxyZWFkeSBsb2FkZWRcIlxuIFx0XHRpZihpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gIT09IDApIHtcbiBcdFx0XHR2YXIgY2h1bmsgPSByZXF1aXJlKFwiLi9cIiArIGNodW5rSWQgKyBcIi5qc1wiKTtcbiBcdFx0XHR2YXIgbW9yZU1vZHVsZXMgPSBjaHVuay5tb2R1bGVzLCBjaHVua0lkcyA9IGNodW5rLmlkcztcbiBcdFx0XHRmb3IodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG4gXHRcdFx0XHRtb2R1bGVzW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHR9XG4gXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNodW5rSWRzLmxlbmd0aDsgaSsrKVxuIFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRzW2ldXSA9IDA7XG4gXHRcdH1cbiBcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuIFx0fTtcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcImRpc3QvXCI7XG5cbiBcdC8vIHVuY2F0Y2hlZCBlcnJvciBoYW5kbGVyIGZvciB3ZWJwYWNrIHJ1bnRpbWVcbiBcdF9fd2VicGFja19yZXF1aXJlX18ub2UgPSBmdW5jdGlvbihlcnIpIHtcbiBcdFx0cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiBcdFx0XHR0aHJvdyBlcnI7IC8vIGNhdGNoIHRoaXMgZXJyb3IgYnkgdXNpbmcgU3lzdGVtLmltcG9ydCgpLmNhdGNoKClcbiBcdFx0fSk7XG4gXHR9O1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEzNSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZjIxMWQ4OWE0N2RmODViYjQwNTYiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3ZlbmRvclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIi4vdmVuZG9yXCJcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL2J1bmRsZXMvY29yZS51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSgxKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9TdWJzY3JpYmVyLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoMTApO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL091dGVyU3Vic2NyaWJlci5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDE5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL3N1YnNjcmliZVRvUmVzdWx0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoMCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvT2JzZXJ2YWJsZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL1N1YmplY3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBBc3luY0FjdGlvbl8xID0gcmVxdWlyZSgnLi9Bc3luY0FjdGlvbicpO1xudmFyIEFzeW5jU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuL0FzeW5jU2NoZWR1bGVyJyk7XG4vKipcbiAqXG4gKiBBc3luYyBTY2hlZHVsZXJcbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+U2NoZWR1bGUgdGFzayBhcyBpZiB5b3UgdXNlZCBzZXRUaW1lb3V0KHRhc2ssIGR1cmF0aW9uKTwvc3Bhbj5cbiAqXG4gKiBgYXN5bmNgIHNjaGVkdWxlciBzY2hlZHVsZXMgdGFza3MgYXN5bmNocm9ub3VzbHksIGJ5IHB1dHRpbmcgdGhlbSBvbiB0aGUgSmF2YVNjcmlwdFxuICogZXZlbnQgbG9vcCBxdWV1ZS4gSXQgaXMgYmVzdCB1c2VkIHRvIGRlbGF5IHRhc2tzIGluIHRpbWUgb3IgdG8gc2NoZWR1bGUgdGFza3MgcmVwZWF0aW5nXG4gKiBpbiBpbnRlcnZhbHMuXG4gKlxuICogSWYgeW91IGp1c3Qgd2FudCB0byBcImRlZmVyXCIgdGFzaywgdGhhdCBpcyB0byBwZXJmb3JtIGl0IHJpZ2h0IGFmdGVyIGN1cnJlbnRseVxuICogZXhlY3V0aW5nIHN5bmNocm9ub3VzIGNvZGUgZW5kcyAoY29tbW9ubHkgYWNoaWV2ZWQgYnkgYHNldFRpbWVvdXQoZGVmZXJyZWRUYXNrLCAwKWApLFxuICogYmV0dGVyIGNob2ljZSB3aWxsIGJlIHRoZSB7QGxpbmsgYXNhcH0gc2NoZWR1bGVyLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlVzZSBhc3luYyBzY2hlZHVsZXIgdG8gZGVsYXkgdGFzazwvY2FwdGlvbj5cbiAqIGNvbnN0IHRhc2sgPSAoKSA9PiBjb25zb2xlLmxvZygnaXQgd29ya3MhJyk7XG4gKlxuICogUnguU2NoZWR1bGVyLmFzeW5jLnNjaGVkdWxlKHRhc2ssIDIwMDApO1xuICpcbiAqIC8vIEFmdGVyIDIgc2Vjb25kcyBsb2dzOlxuICogLy8gXCJpdCB3b3JrcyFcIlxuICpcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2UgYXN5bmMgc2NoZWR1bGVyIHRvIHJlcGVhdCB0YXNrIGluIGludGVydmFsczwvY2FwdGlvbj5cbiAqIGZ1bmN0aW9uIHRhc2soc3RhdGUpIHtcbiAqICAgY29uc29sZS5sb2coc3RhdGUpO1xuICogICB0aGlzLnNjaGVkdWxlKHN0YXRlICsgMSwgMTAwMCk7IC8vIGB0aGlzYCByZWZlcmVuY2VzIGN1cnJlbnRseSBleGVjdXRpbmcgQWN0aW9uLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdlIHJlc2NoZWR1bGUgd2l0aCBuZXcgc3RhdGUgYW5kIGRlbGF5XG4gKiB9XG4gKlxuICogUnguU2NoZWR1bGVyLmFzeW5jLnNjaGVkdWxlKHRhc2ssIDMwMDAsIDApO1xuICpcbiAqIC8vIExvZ3M6XG4gKiAvLyAwIGFmdGVyIDNzXG4gKiAvLyAxIGFmdGVyIDRzXG4gKiAvLyAyIGFmdGVyIDVzXG4gKiAvLyAzIGFmdGVyIDZzXG4gKlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBhc3luY1xuICogQG93bmVyIFNjaGVkdWxlclxuICovXG5leHBvcnRzLmFzeW5jID0gbmV3IEFzeW5jU2NoZWR1bGVyXzEuQXN5bmNTY2hlZHVsZXIoQXN5bmNBY3Rpb25fMS5Bc3luY0FjdGlvbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9zY2hlZHVsZXIvYXN5bmMuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDEwMSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC90cnlDYXRjaC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDMyKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL2Vycm9yT2JqZWN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTlMgPSBleHBvcnRzLk5BTUVTUEFDRVMgPSB7XG4gICAgSFRNTDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLFxuICAgIE1BVEhNTDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnLFxuICAgIFNWRzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICBYTElOSzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICAgIFhNTDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsXG4gICAgWE1MTlM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLydcbn07XG5cbmV4cG9ydHMuQVRUUlMgPSB7XG4gICAgVFlQRTogJ3R5cGUnLFxuICAgIEFDVElPTjogJ2FjdGlvbicsXG4gICAgRU5DT0RJTkc6ICdlbmNvZGluZycsXG4gICAgUFJPTVBUOiAncHJvbXB0JyxcbiAgICBOQU1FOiAnbmFtZScsXG4gICAgQ09MT1I6ICdjb2xvcicsXG4gICAgRkFDRTogJ2ZhY2UnLFxuICAgIFNJWkU6ICdzaXplJ1xufTtcblxuZXhwb3J0cy5ET0NVTUVOVF9NT0RFID0ge1xuICAgIE5PX1FVSVJLUzogJ25vLXF1aXJrcycsXG4gICAgUVVJUktTOiAncXVpcmtzJyxcbiAgICBMSU1JVEVEX1FVSVJLUzogJ2xpbWl0ZWQtcXVpcmtzJ1xufTtcblxudmFyICQgPSBleHBvcnRzLlRBR19OQU1FUyA9IHtcbiAgICBBOiAnYScsXG4gICAgQUREUkVTUzogJ2FkZHJlc3MnLFxuICAgIEFOTk9UQVRJT05fWE1MOiAnYW5ub3RhdGlvbi14bWwnLFxuICAgIEFQUExFVDogJ2FwcGxldCcsXG4gICAgQVJFQTogJ2FyZWEnLFxuICAgIEFSVElDTEU6ICdhcnRpY2xlJyxcbiAgICBBU0lERTogJ2FzaWRlJyxcblxuICAgIEI6ICdiJyxcbiAgICBCQVNFOiAnYmFzZScsXG4gICAgQkFTRUZPTlQ6ICdiYXNlZm9udCcsXG4gICAgQkdTT1VORDogJ2Jnc291bmQnLFxuICAgIEJJRzogJ2JpZycsXG4gICAgQkxPQ0tRVU9URTogJ2Jsb2NrcXVvdGUnLFxuICAgIEJPRFk6ICdib2R5JyxcbiAgICBCUjogJ2JyJyxcbiAgICBCVVRUT046ICdidXR0b24nLFxuXG4gICAgQ0FQVElPTjogJ2NhcHRpb24nLFxuICAgIENFTlRFUjogJ2NlbnRlcicsXG4gICAgQ09ERTogJ2NvZGUnLFxuICAgIENPTDogJ2NvbCcsXG4gICAgQ09MR1JPVVA6ICdjb2xncm91cCcsXG5cbiAgICBERDogJ2RkJyxcbiAgICBERVNDOiAnZGVzYycsXG4gICAgREVUQUlMUzogJ2RldGFpbHMnLFxuICAgIERJQUxPRzogJ2RpYWxvZycsXG4gICAgRElSOiAnZGlyJyxcbiAgICBESVY6ICdkaXYnLFxuICAgIERMOiAnZGwnLFxuICAgIERUOiAnZHQnLFxuXG4gICAgRU06ICdlbScsXG4gICAgRU1CRUQ6ICdlbWJlZCcsXG5cbiAgICBGSUVMRFNFVDogJ2ZpZWxkc2V0JyxcbiAgICBGSUdDQVBUSU9OOiAnZmlnY2FwdGlvbicsXG4gICAgRklHVVJFOiAnZmlndXJlJyxcbiAgICBGT05UOiAnZm9udCcsXG4gICAgRk9PVEVSOiAnZm9vdGVyJyxcbiAgICBGT1JFSUdOX09CSkVDVDogJ2ZvcmVpZ25PYmplY3QnLFxuICAgIEZPUk06ICdmb3JtJyxcbiAgICBGUkFNRTogJ2ZyYW1lJyxcbiAgICBGUkFNRVNFVDogJ2ZyYW1lc2V0JyxcblxuICAgIEgxOiAnaDEnLFxuICAgIEgyOiAnaDInLFxuICAgIEgzOiAnaDMnLFxuICAgIEg0OiAnaDQnLFxuICAgIEg1OiAnaDUnLFxuICAgIEg2OiAnaDYnLFxuICAgIEhFQUQ6ICdoZWFkJyxcbiAgICBIRUFERVI6ICdoZWFkZXInLFxuICAgIEhHUk9VUDogJ2hncm91cCcsXG4gICAgSFI6ICdocicsXG4gICAgSFRNTDogJ2h0bWwnLFxuXG4gICAgSTogJ2knLFxuICAgIElNRzogJ2ltZycsXG4gICAgSU1BR0U6ICdpbWFnZScsXG4gICAgSU5QVVQ6ICdpbnB1dCcsXG4gICAgSUZSQU1FOiAnaWZyYW1lJyxcblxuICAgIEtFWUdFTjogJ2tleWdlbicsXG5cbiAgICBMQUJFTDogJ2xhYmVsJyxcbiAgICBMSTogJ2xpJyxcbiAgICBMSU5LOiAnbGluaycsXG4gICAgTElTVElORzogJ2xpc3RpbmcnLFxuXG4gICAgTUFJTjogJ21haW4nLFxuICAgIE1BTElHTk1BUks6ICdtYWxpZ25tYXJrJyxcbiAgICBNQVJRVUVFOiAnbWFycXVlZScsXG4gICAgTUFUSDogJ21hdGgnLFxuICAgIE1FTlU6ICdtZW51JyxcbiAgICBNRU5VSVRFTTogJ21lbnVpdGVtJyxcbiAgICBNRVRBOiAnbWV0YScsXG4gICAgTUdMWVBIOiAnbWdseXBoJyxcbiAgICBNSTogJ21pJyxcbiAgICBNTzogJ21vJyxcbiAgICBNTjogJ21uJyxcbiAgICBNUzogJ21zJyxcbiAgICBNVEVYVDogJ210ZXh0JyxcblxuICAgIE5BVjogJ25hdicsXG4gICAgTk9CUjogJ25vYnInLFxuICAgIE5PRlJBTUVTOiAnbm9mcmFtZXMnLFxuICAgIE5PRU1CRUQ6ICdub2VtYmVkJyxcbiAgICBOT1NDUklQVDogJ25vc2NyaXB0JyxcblxuICAgIE9CSkVDVDogJ29iamVjdCcsXG4gICAgT0w6ICdvbCcsXG4gICAgT1BUR1JPVVA6ICdvcHRncm91cCcsXG4gICAgT1BUSU9OOiAnb3B0aW9uJyxcblxuICAgIFA6ICdwJyxcbiAgICBQQVJBTTogJ3BhcmFtJyxcbiAgICBQTEFJTlRFWFQ6ICdwbGFpbnRleHQnLFxuICAgIFBSRTogJ3ByZScsXG5cbiAgICBSQjogJ3JiJyxcbiAgICBSUDogJ3JwJyxcbiAgICBSVDogJ3J0JyxcbiAgICBSVEM6ICdydGMnLFxuICAgIFJVQlk6ICdydWJ5JyxcblxuICAgIFM6ICdzJyxcbiAgICBTQ1JJUFQ6ICdzY3JpcHQnLFxuICAgIFNFQ1RJT046ICdzZWN0aW9uJyxcbiAgICBTRUxFQ1Q6ICdzZWxlY3QnLFxuICAgIFNPVVJDRTogJ3NvdXJjZScsXG4gICAgU01BTEw6ICdzbWFsbCcsXG4gICAgU1BBTjogJ3NwYW4nLFxuICAgIFNUUklLRTogJ3N0cmlrZScsXG4gICAgU1RST05HOiAnc3Ryb25nJyxcbiAgICBTVFlMRTogJ3N0eWxlJyxcbiAgICBTVUI6ICdzdWInLFxuICAgIFNVTU1BUlk6ICdzdW1tYXJ5JyxcbiAgICBTVVA6ICdzdXAnLFxuXG4gICAgVEFCTEU6ICd0YWJsZScsXG4gICAgVEJPRFk6ICd0Ym9keScsXG4gICAgVEVNUExBVEU6ICd0ZW1wbGF0ZScsXG4gICAgVEVYVEFSRUE6ICd0ZXh0YXJlYScsXG4gICAgVEZPT1Q6ICd0Zm9vdCcsXG4gICAgVEQ6ICd0ZCcsXG4gICAgVEg6ICd0aCcsXG4gICAgVEhFQUQ6ICd0aGVhZCcsXG4gICAgVElUTEU6ICd0aXRsZScsXG4gICAgVFI6ICd0cicsXG4gICAgVFJBQ0s6ICd0cmFjaycsXG4gICAgVFQ6ICd0dCcsXG5cbiAgICBVOiAndScsXG4gICAgVUw6ICd1bCcsXG5cbiAgICBTVkc6ICdzdmcnLFxuXG4gICAgVkFSOiAndmFyJyxcblxuICAgIFdCUjogJ3dicicsXG5cbiAgICBYTVA6ICd4bXAnXG59O1xuXG52YXIgU1BFQ0lBTF9FTEVNRU5UUyA9IGV4cG9ydHMuU1BFQ0lBTF9FTEVNRU5UUyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLkFERFJFU1NdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5BUFBMRVRdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5BUkVBXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuQVJUSUNMRV0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLkFTSURFXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuQkFTRV0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLkJBU0VGT05UXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuQkdTT1VORF0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLkJMT0NLUVVPVEVdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5CT0RZXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuQlJdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5CVVRUT05dID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5DQVBUSU9OXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuQ0VOVEVSXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuQ09MXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuQ09MR1JPVVBdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5ERF0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLkRFVEFJTFNdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5ESVJdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5ESVZdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5ETF0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLkRUXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuRU1CRURdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5GSUVMRFNFVF0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLkZJR0NBUFRJT05dID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5GSUdVUkVdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5GT09URVJdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5GT1JNXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuRlJBTUVdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5GUkFNRVNFVF0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLkgxXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuSDJdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5IM10gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLkg0XSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuSDVdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5INl0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLkhFQURdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5IRUFERVJdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5IR1JPVVBdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5IUl0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLkhUTUxdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5JRlJBTUVdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5JTUddID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5JTlBVVF0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLkxJXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuTElOS10gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLkxJU1RJTkddID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5NQUlOXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuTUFSUVVFRV0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLk1FTlVdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5NRVRBXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuTkFWXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuTk9FTUJFRF0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLk5PRlJBTUVTXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuTk9TQ1JJUFRdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5PQkpFQ1RdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5PTF0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLlBdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5QQVJBTV0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLlBMQUlOVEVYVF0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLlBSRV0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLlNDUklQVF0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLlNFQ1RJT05dID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5TRUxFQ1RdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5TT1VSQ0VdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5TVFlMRV0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLlNVTU1BUlldID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5UQUJMRV0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLlRCT0RZXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuVERdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5URU1QTEFURV0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLlRFWFRBUkVBXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuVEZPT1RdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5USF0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLlRIRUFEXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuVElUTEVdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5UUl0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5IVE1MXVskLlRSQUNLXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLkhUTUxdWyQuVUxdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5XQlJdID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuSFRNTF1bJC5YTVBdID0gdHJ1ZTtcblxuU1BFQ0lBTF9FTEVNRU5UU1tOUy5NQVRITUxdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuTUFUSE1MXVskLk1JXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLk1BVEhNTF1bJC5NT10gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5NQVRITUxdWyQuTU5dID0gdHJ1ZTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuTUFUSE1MXVskLk1TXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLk1BVEhNTF1bJC5NVEVYVF0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5NQVRITUxdWyQuQU5OT1RBVElPTl9YTUxdID0gdHJ1ZTtcblxuU1BFQ0lBTF9FTEVNRU5UU1tOUy5TVkddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblNQRUNJQUxfRUxFTUVOVFNbTlMuU1ZHXVskLlRJVExFXSA9IHRydWU7XG5TUEVDSUFMX0VMRU1FTlRTW05TLlNWR11bJC5GT1JFSUdOX09CSkVDVF0gPSB0cnVlO1xuU1BFQ0lBTF9FTEVNRU5UU1tOUy5TVkddWyQuREVTQ10gPSB0cnVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlNS9saWIvY29tbW9uL2h0bWwuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg2KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL2J1bmRsZXMvY29tbW9uLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGNhdGNoRXJyb3IgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xyXG5pbXBvcnQgeyBMb2FkaW5nU2VydmljZSB9IGZyb20gJy4uL2Zyb250ZW5kL2xvYWRpbmcuc2VydmljZSc7XHJcbmltcG9ydCB7IEFsZXJ0U2VydmljZSB9IGZyb20gJy4uL2Zyb250ZW5kL2FsZXJ0LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBIdHRwLCBIZWFkZXJzLCBSZXNwb25zZSB9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xyXG5pbXBvcnQgeyBzaGFyZSB9IGZyb20gJ3J4anMvb3BlcmF0b3Ivc2hhcmUnO1xyXG5pbXBvcnQgeyBvZiB9IGZyb20gXCJyeGpzL29ic2VydmFibGUvb2ZcIjtcclxuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tYXAnO1xyXG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL2NhdGNoJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIENvbW1vbkh0dHBTZXJ2aWNlPFQ+e1xyXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGh0dHA6IEh0dHAsIHByb3RlY3RlZCBsb2FkaW5nU3ZjOiBMb2FkaW5nU2VydmljZSwgcHJvdGVjdGVkIGFsZXJ0U3ZjOiBBbGVydFNlcnZpY2UpIHsgfVxyXG4gICAgcHJvdGVjdGVkIGV4dHJhY3RkYXRhKHJlczogUmVzcG9uc2UpIHtcclxuICAgICAgICBsZXQgYm9keSA9IHJlcy5qc29uKCk7XHJcbiAgICAgICAgcmV0dXJuIGJvZHkgfHwge307XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgY3JlYXRlSGVhZGVyKCk6IEhlYWRlcnMge1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xyXG4gICAgICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcclxuICAgICAgICByZXR1cm4gaGVhZGVycztcclxuICAgIH1cclxuICAgIGdldHM8VD4odXJsOiBzdHJpbmcsIGhlYWRlcnM/OiBIZWFkZXJzKTogT2JzZXJ2YWJsZTxUW10+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdTdmMuc2hvd0xvYWRpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh0dHAuZ2V0KHVybCwgeyBoZWFkZXJzOiBoZWFkZXJzIHx8IHRoaXMuY3JlYXRlSGVhZGVyKCkgfSlcclxuICAgICAgICAgICAgICAgIC5tYXAodGhpcy5leHRyYWN0ZGF0YSkuY2F0Y2goZXJyID0+IFtdKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlPFRbXT4oc3ViID0+IHN1Yi5uZXh0KCkpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1N2Yy5zaG93TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldDxUPih1cmw6IHN0cmluZywgaWQ/OiBudW1iZXIsIGhlYWRlcnM/OiBIZWFkZXJzKTogT2JzZXJ2YWJsZTxUPiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3ZjLnNob3dMb2FkaW5nKHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5odHRwLmdldCh1cmwgKyAoXCIvXCIrIGlkIS50b1N0cmluZygpKXx8XCJcIiwgeyBoZWFkZXJzOiBoZWFkZXJzIHx8IHRoaXMuY3JlYXRlSGVhZGVyKCkgfSlcclxuICAgICAgICAgICAgICAgIC5tYXAodGhpcy5leHRyYWN0ZGF0YSkuY2F0Y2goZXJyID0+IG5ldyBPYnNlcnZhYmxlPFQ+KHN1YiA9PiBzdWIubmV4dCgpKSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZTxUPihzdWIgPT4gc3ViLm5leHQoKSk7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3ZjLnNob3dMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwb3N0KHVybDogc3RyaW5nLCBib2R5OiBhbnksIGhlYWRlcnM/OiBIZWFkZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5wb3N0KHVybCwgSlNPTi5zdHJpbmdpZnkoYm9keSksIHsgaGVhZGVyczogaGVhZGVycyB8fCB0aGlzLmNyZWF0ZUhlYWRlcigpIH0pXHJcbiAgICAgICAgICAgIC5tYXAodGhpcy5leHRyYWN0ZGF0YSkuY2F0Y2goZXJyID0+IFtdKTtcclxuICAgIH1cclxuICAgIHB1dCh1cmw6IHN0cmluZywgaWQ6IG51bWJlciwgYm9keTogYW55LCBoZWFkZXJzPzogSGVhZGVycykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAucHV0KHVybCArIGlkLnRvU3RyaW5nKCksIEpTT04uc3RyaW5naWZ5KGJvZHkpLCB7IGhlYWRlcnM6IGhlYWRlcnMgfHwgdGhpcy5jcmVhdGVIZWFkZXIoKSB9KVxyXG4gICAgICAgICAgICAubWFwKHRoaXMuZXh0cmFjdGRhdGEpLmNhdGNoKGVyciA9PiBbXSk7XHJcbiAgICB9XHJcbiAgICBkZWxldGUodXJsOiBzdHJpbmcsIGlkOiBudW1iZXIsIGhlYWRlcnM/OiBIZWFkZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5kZWxldGUodXJsICsgaWQudG9TdHJpbmcoKSwgeyBoZWFkZXJzOiBoZWFkZXJzIHx8IHRoaXMuY3JlYXRlSGVhZGVyKCkgfSlcclxuICAgICAgICAgICAgLm1hcCh0aGlzLmV4dHJhY3RkYXRhKS5jYXRjaChlcnIgPT4gW10pO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2VydmljZXMvYmFja2VuZC9jb21tb24taHR0cC5zZXJ2aWNlLnRzIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoNDMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9yb3V0ZXIvYnVuZGxlcy9yb3V0ZXIudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL1N1YnNjcmlwdGlvbi5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJleHBvcnQgY29uc3QgVVJMID0ge1xyXG4gICAgQkFTRV9VUkw6IFwiL2FwaVwiLFxyXG4gICAgSk9CX1VSTDogXCIvYXBpL2pvYnNcIixcclxuICAgIEVWRU5UX1VSTDogXCIvYXBpL2V2ZW50c1wiLFxyXG4gICAgUFJPRklMRV9VUkw6XCIvYXBpL3Byb2ZpbGVzXCIsXHJcbiAgICBKT0JfR1JPVVBfVVJMOlwiL2FwaS9qb2ItZ3JvdXBzXCIsXHJcbiAgICBST0xFX1VSTDpcIi9hcGkvcm9sZXNcIixcclxuICAgIFdPUktUWVBFX1VSTDpcIi9hcGkvd29yay10eXBlc1wiLFxyXG4gICAgQ09NUEFOWV9VUkw6XCIvYXBpL2NvbXBhbmllc1wiXHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9zZXJ2aWNlcy9zZXJ2aWNlLnZhcmlhYmxlcy50cyIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDM5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvYW5pbWF0aW9ucy9idW5kbGVzL2FuaW1hdGlvbnMudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDE4KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzQXJyYXkuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoNDEpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9odHRwL2J1bmRsZXMvaHR0cC51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbnZhciBodHRwXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvaHR0cFwiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKFwicnhqcy9PYnNlcnZhYmxlXCIpO1xucmVxdWlyZShcInJ4anMvYWRkL29ic2VydmFibGUvZnJvbVByb21pc2VcIik7XG5yZXF1aXJlKFwicnhqcy9hZGQvb2JzZXJ2YWJsZS9kZWZlclwiKTtcbnJlcXVpcmUoXCJyeGpzL2FkZC9vcGVyYXRvci9tZXJnZU1hcFwiKTtcbnZhciBBdXRoQ29uZmlnQ29uc3RzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRoQ29uZmlnQ29uc3RzKCkge1xuICAgIH1cbiAgICByZXR1cm4gQXV0aENvbmZpZ0NvbnN0cztcbn0oKSk7XG5BdXRoQ29uZmlnQ29uc3RzLkRFRkFVTFRfVE9LRU5fTkFNRSA9ICd0b2tlbic7XG5BdXRoQ29uZmlnQ29uc3RzLkRFRkFVTFRfSEVBREVSX05BTUUgPSAnQXV0aG9yaXphdGlvbic7XG5BdXRoQ29uZmlnQ29uc3RzLkhFQURFUl9QUkVGSVhfQkVBUkVSID0gJ0JlYXJlciAnO1xuZXhwb3J0cy5BdXRoQ29uZmlnQ29uc3RzID0gQXV0aENvbmZpZ0NvbnN0cztcbnZhciBBdXRoQ29uZmlnRGVmYXVsdHMgPSB7XG4gICAgaGVhZGVyTmFtZTogQXV0aENvbmZpZ0NvbnN0cy5ERUZBVUxUX0hFQURFUl9OQU1FLFxuICAgIGhlYWRlclByZWZpeDogbnVsbCxcbiAgICB0b2tlbk5hbWU6IEF1dGhDb25maWdDb25zdHMuREVGQVVMVF9UT0tFTl9OQU1FLFxuICAgIHRva2VuR2V0dGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShBdXRoQ29uZmlnRGVmYXVsdHMudG9rZW5OYW1lKTsgfSxcbiAgICBub0p3dEVycm9yOiBmYWxzZSxcbiAgICBub0NsaWVudENoZWNrOiBmYWxzZSxcbiAgICBnbG9iYWxIZWFkZXJzOiBbXSxcbiAgICBub1Rva2VuU2NoZW1lOiBmYWxzZVxufTtcbi8qKlxuICogU2V0cyB1cCB0aGUgYXV0aGVudGljYXRpb24gY29uZmlndXJhdGlvbi5cbiAqL1xudmFyIEF1dGhDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1dGhDb25maWcoY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gb2JqZWN0QXNzaWduKHt9LCBBdXRoQ29uZmlnRGVmYXVsdHMsIGNvbmZpZyk7XG4gICAgICAgIGlmICh0aGlzLl9jb25maWcuaGVhZGVyUHJlZml4KSB7XG4gICAgICAgICAgICB0aGlzLl9jb25maWcuaGVhZGVyUHJlZml4ICs9ICcgJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9jb25maWcubm9Ub2tlblNjaGVtZSkge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLmhlYWRlclByZWZpeCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLmhlYWRlclByZWZpeCA9IEF1dGhDb25maWdDb25zdHMuSEVBREVSX1BSRUZJWF9CRUFSRVI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy50b2tlbk5hbWUgJiYgIWNvbmZpZy50b2tlbkdldHRlcikge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLnRva2VuR2V0dGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oY29uZmlnLnRva2VuTmFtZSk7IH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXV0aENvbmZpZy5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xuICAgIH07XG4gICAgcmV0dXJuIEF1dGhDb25maWc7XG59KCkpO1xuZXhwb3J0cy5BdXRoQ29uZmlnID0gQXV0aENvbmZpZztcbnZhciBBdXRoSHR0cEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXV0aEh0dHBFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBdXRoSHR0cEVycm9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBBdXRoSHR0cEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5BdXRoSHR0cEVycm9yID0gQXV0aEh0dHBFcnJvcjtcbi8qKlxuICogQWxsb3dzIGZvciBleHBsaWNpdCBhdXRoZW50aWNhdGVkIEhUVFAgcmVxdWVzdHMuXG4gKi9cbnZhciBBdXRoSHR0cCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXV0aEh0dHAob3B0aW9ucywgaHR0cCwgZGVmT3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmh0dHAgPSBodHRwO1xuICAgICAgICB0aGlzLmRlZk9wdHMgPSBkZWZPcHRzO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IG9wdGlvbnMuZ2V0Q29uZmlnKCk7XG4gICAgICAgIHRoaXMudG9rZW5TdHJlYW0gPSBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoZnVuY3Rpb24gKG9icykge1xuICAgICAgICAgICAgb2JzLm5leHQoX3RoaXMuY29uZmlnLnRva2VuR2V0dGVyKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgQXV0aEh0dHAucHJvdG90eXBlLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIChwcm92aWRlZE9wdHMsIGRlZmF1bHRPcHRzKSB7XG4gICAgICAgIHZhciBuZXdPcHRpb25zID0gZGVmYXVsdE9wdHMgfHwgbmV3IGh0dHBfMS5SZXF1ZXN0T3B0aW9ucygpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZ2xvYmFsSGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5zZXRHbG9iYWxIZWFkZXJzKHRoaXMuY29uZmlnLmdsb2JhbEhlYWRlcnMsIHByb3ZpZGVkT3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3T3B0aW9ucyA9IG5ld09wdGlvbnMubWVyZ2UobmV3IGh0dHBfMS5SZXF1ZXN0T3B0aW9ucyhwcm92aWRlZE9wdHMpKTtcbiAgICAgICAgcmV0dXJuIG5ld09wdGlvbnM7XG4gICAgfTtcbiAgICBBdXRoSHR0cC5wcm90b3R5cGUucmVxdWVzdEhlbHBlciA9IGZ1bmN0aW9uIChyZXF1ZXN0QXJncywgYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBuZXcgaHR0cF8xLlJlcXVlc3RPcHRpb25zKHJlcXVlc3RBcmdzKTtcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5tZXJnZShhZGRpdGlvbmFsT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChuZXcgaHR0cF8xLlJlcXVlc3QodGhpcy5tZXJnZU9wdGlvbnMob3B0aW9ucywgdGhpcy5kZWZPcHRzKSkpO1xuICAgIH07XG4gICAgQXV0aEh0dHAucHJvdG90eXBlLnJlcXVlc3RXaXRoVG9rZW4gPSBmdW5jdGlvbiAocmVxLCB0b2tlbikge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLm5vQ2xpZW50Q2hlY2sgJiYgIXRva2VuTm90RXhwaXJlZCh1bmRlZmluZWQsIHRva2VuKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5ub0p3dEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9icy5lcnJvcihuZXcgQXV0aEh0dHBFcnJvcignTm8gSldUIHByZXNlbnQgb3IgaGFzIGV4cGlyZWQnKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXEuaGVhZGVycy5zZXQodGhpcy5jb25maWcuaGVhZGVyTmFtZSwgdGhpcy5jb25maWcuaGVhZGVyUHJlZml4ICsgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAucmVxdWVzdChyZXEpO1xuICAgIH07XG4gICAgQXV0aEh0dHAucHJvdG90eXBlLnNldEdsb2JhbEhlYWRlcnMgPSBmdW5jdGlvbiAoaGVhZGVycywgcmVxdWVzdCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QuaGVhZGVycykge1xuICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzID0gbmV3IGh0dHBfMS5IZWFkZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBPYmplY3Qua2V5cyhoZWFkZXIpWzBdO1xuICAgICAgICAgICAgdmFyIGhlYWRlclZhbHVlID0gaGVhZGVyW2tleV07XG4gICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KGtleSwgaGVhZGVyVmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEF1dGhIdHRwLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwsIG9wdGlvbnMpOyAvLyBSZWN1cnNpb246IHRyYW5zZm9ybSB1cmwgZnJvbSBTdHJpbmcgdG8gUmVxdWVzdFxuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UgaWYgKCAhIHVybCBpbnN0YW5jZW9mIFJlcXVlc3QgKSB7XG4gICAgICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdXJsIHN0cmluZyBvciBSZXF1ZXN0IGluc3RhbmNlLicpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGZyb20gdGhpcyBwb2ludCB1cmwgaXMgYWx3YXlzIGFuIGluc3RhbmNlIG9mIFJlcXVlc3Q7XG4gICAgICAgIHZhciByZXEgPSB1cmw7XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbGQgb2JzZXJ2YWJsZSBhbmQgbG9hZCB0aGUgdG9rZW4ganVzdCBpbiB0aW1lXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBfdGhpcy5jb25maWcudG9rZW5HZXR0ZXIoKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuZnJvbVByb21pc2UodG9rZW4pLm1lcmdlTWFwKGZ1bmN0aW9uIChqd3RUb2tlbikgeyByZXR1cm4gX3RoaXMucmVxdWVzdFdpdGhUb2tlbihyZXEsIGp3dFRva2VuKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVxdWVzdFdpdGhUb2tlbihyZXEsIHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBdXRoSHR0cC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0SGVscGVyKHsgYm9keTogJycsIG1ldGhvZDogaHR0cF8xLlJlcXVlc3RNZXRob2QuR2V0LCB1cmw6IHVybCB9LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIEF1dGhIdHRwLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKHVybCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0SGVscGVyKHsgYm9keTogYm9keSwgbWV0aG9kOiBodHRwXzEuUmVxdWVzdE1ldGhvZC5Qb3N0LCB1cmw6IHVybCB9LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIEF1dGhIdHRwLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAodXJsLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RIZWxwZXIoeyBib2R5OiBib2R5LCBtZXRob2Q6IGh0dHBfMS5SZXF1ZXN0TWV0aG9kLlB1dCwgdXJsOiB1cmwgfSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBBdXRoSHR0cC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0SGVscGVyKHsgYm9keTogJycsIG1ldGhvZDogaHR0cF8xLlJlcXVlc3RNZXRob2QuRGVsZXRlLCB1cmw6IHVybCB9LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIEF1dGhIdHRwLnByb3RvdHlwZS5wYXRjaCA9IGZ1bmN0aW9uICh1cmwsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEhlbHBlcih7IGJvZHk6IGJvZHksIG1ldGhvZDogaHR0cF8xLlJlcXVlc3RNZXRob2QuUGF0Y2gsIHVybDogdXJsIH0sIG9wdGlvbnMpO1xuICAgIH07XG4gICAgQXV0aEh0dHAucHJvdG90eXBlLmhlYWQgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RIZWxwZXIoeyBib2R5OiAnJywgbWV0aG9kOiBodHRwXzEuUmVxdWVzdE1ldGhvZC5IZWFkLCB1cmw6IHVybCB9LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIEF1dGhIdHRwLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0SGVscGVyKHsgYm9keTogJycsIG1ldGhvZDogaHR0cF8xLlJlcXVlc3RNZXRob2QuT3B0aW9ucywgdXJsOiB1cmwgfSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gQXV0aEh0dHA7XG59KCkpO1xuQXV0aEh0dHAgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXV0aENvbmZpZywgaHR0cF8xLkh0dHAsIGh0dHBfMS5SZXF1ZXN0T3B0aW9uc10pXG5dLCBBdXRoSHR0cCk7XG5leHBvcnRzLkF1dGhIdHRwID0gQXV0aEh0dHA7XG4vKipcbiAqIEhlbHBlciBjbGFzcyB0byBkZWNvZGUgYW5kIGZpbmQgSldUIGV4cGlyYXRpb24uXG4gKi9cbnZhciBKd3RIZWxwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEp3dEhlbHBlcigpIHtcbiAgICB9XG4gICAgSnd0SGVscGVyLnByb3RvdHlwZS51cmxCYXNlNjREZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBzdHIucmVwbGFjZSgvLS9nLCAnKycpLnJlcGxhY2UoL18vZywgJy8nKTtcbiAgICAgICAgc3dpdGNoIChvdXRwdXQubGVuZ3RoICUgNCkge1xuICAgICAgICAgICAgY2FzZSAwOiB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJz09JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSAnPSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0lsbGVnYWwgYmFzZTY0dXJsIHN0cmluZyEnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmI2NERlY29kZVVuaWNvZGUob3V0cHV0KTtcbiAgICB9O1xuICAgIC8vIGNyZWRpdHMgZm9yIGRlY29kZXIgZ29lcyB0byBodHRwczovL2dpdGh1Yi5jb20vYXRrXG4gICAgSnd0SGVscGVyLnByb3RvdHlwZS5iNjRkZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG4gICAgICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICAgICAgc3RyID0gU3RyaW5nKHN0cikucmVwbGFjZSgvPSskLywgJycpO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCAlIDQgPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2F0b2InIGZhaWxlZDogVGhlIHN0cmluZyB0byBiZSBkZWNvZGVkIGlzIG5vdCBjb3JyZWN0bHkgZW5jb2RlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJzXG4gICAgICAgIHZhciBiYyA9IDAsIGJzID0gdm9pZCAwLCBidWZmZXIgPSB2b2lkIDAsIGlkeCA9IDA7IFxuICAgICAgICAvLyBnZXQgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgYnVmZmVyID0gc3RyLmNoYXJBdChpZHgrKyk7IFxuICAgICAgICAvLyBjaGFyYWN0ZXIgZm91bmQgaW4gdGFibGU/IGluaXRpYWxpemUgYml0IHN0b3JhZ2UgYW5kIGFkZCBpdHMgYXNjaWkgdmFsdWU7XG4gICAgICAgIH5idWZmZXIgJiYgKGJzID0gYmMgJSA0ID8gYnMgKiA2NCArIGJ1ZmZlciA6IGJ1ZmZlcixcbiAgICAgICAgICAgIC8vIGFuZCBpZiBub3QgZmlyc3Qgb2YgZWFjaCA0IGNoYXJhY3RlcnMsXG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBmaXJzdCA4IGJpdHMgdG8gb25lIGFzY2lpIGNoYXJhY3RlclxuICAgICAgICAgICAgYmMrKyAlIDQpID8gb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1ICYgYnMgPj4gKC0yICogYmMgJiA2KSkgOiAwKSB7XG4gICAgICAgICAgICAvLyB0cnkgdG8gZmluZCBjaGFyYWN0ZXIgaW4gdGFibGUgKDAtNjMsIG5vdCBmb3VuZCA9PiAtMSlcbiAgICAgICAgICAgIGJ1ZmZlciA9IGNoYXJzLmluZGV4T2YoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL1dpbmRvd0Jhc2U2NC9CYXNlNjRfZW5jb2RpbmdfYW5kX2RlY29kaW5nI1RoZV9Vbmljb2RlX1Byb2JsZW1cbiAgICBKd3RIZWxwZXIucHJvdG90eXBlLmI2NERlY29kZVVuaWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHRoaXMuYjY0ZGVjb2RlKHN0ciksIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gJyUnICsgKCcwMCcgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICAgIH0pLmpvaW4oJycpKTtcbiAgICB9O1xuICAgIEp3dEhlbHBlci5wcm90b3R5cGUuZGVjb2RlVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKV1QgbXVzdCBoYXZlIDMgcGFydHMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVjb2RlZCA9IHRoaXMudXJsQmFzZTY0RGVjb2RlKHBhcnRzWzFdKTtcbiAgICAgICAgaWYgKCFkZWNvZGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWNvZGUgdGhlIHRva2VuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gICAgfTtcbiAgICBKd3RIZWxwZXIucHJvdG90eXBlLmdldFRva2VuRXhwaXJhdGlvbkRhdGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIGRlY29kZWQ7XG4gICAgICAgIGRlY29kZWQgPSB0aGlzLmRlY29kZVRva2VuKHRva2VuKTtcbiAgICAgICAgaWYgKCFkZWNvZGVkLmhhc093blByb3BlcnR5KCdleHAnKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKTsgLy8gVGhlIDAgaGVyZSBpcyB0aGUga2V5LCB3aGljaCBzZXRzIHRoZSBkYXRlIHRvIHRoZSBlcG9jaFxuICAgICAgICBkYXRlLnNldFVUQ1NlY29uZHMoZGVjb2RlZC5leHApO1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9O1xuICAgIEp3dEhlbHBlci5wcm90b3R5cGUuaXNUb2tlbkV4cGlyZWQgPSBmdW5jdGlvbiAodG9rZW4sIG9mZnNldFNlY29uZHMpIHtcbiAgICAgICAgdmFyIGRhdGUgPSB0aGlzLmdldFRva2VuRXhwaXJhdGlvbkRhdGUodG9rZW4pO1xuICAgICAgICBvZmZzZXRTZWNvbmRzID0gb2Zmc2V0U2Vjb25kcyB8fCAwO1xuICAgICAgICBpZiAoZGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG9rZW4gZXhwaXJlZD9cbiAgICAgICAgcmV0dXJuICEoZGF0ZS52YWx1ZU9mKCkgPiAobmV3IERhdGUoKS52YWx1ZU9mKCkgKyAob2Zmc2V0U2Vjb25kcyAqIDEwMDApKSk7XG4gICAgfTtcbiAgICByZXR1cm4gSnd0SGVscGVyO1xufSgpKTtcbmV4cG9ydHMuSnd0SGVscGVyID0gSnd0SGVscGVyO1xuLyoqXG4gKiBDaGVja3MgZm9yIHByZXNlbmNlIG9mIHRva2VuIGFuZCB0aGF0IHRva2VuIGhhc24ndCBleHBpcmVkLlxuICogRm9yIHVzZSB3aXRoIHRoZSBAQ2FuQWN0aXZhdGUgcm91dGVyIGRlY29yYXRvciBhbmQgTmdJZlxuICovXG5mdW5jdGlvbiB0b2tlbk5vdEV4cGlyZWQodG9rZW5OYW1lLCBqd3QpIHtcbiAgICBpZiAodG9rZW5OYW1lID09PSB2b2lkIDApIHsgdG9rZW5OYW1lID0gQXV0aENvbmZpZ0NvbnN0cy5ERUZBVUxUX1RPS0VOX05BTUU7IH1cbiAgICB2YXIgdG9rZW4gPSBqd3QgfHwgbG9jYWxTdG9yYWdlLmdldEl0ZW0odG9rZW5OYW1lKTtcbiAgICB2YXIgand0SGVscGVyID0gbmV3IEp3dEhlbHBlcigpO1xuICAgIHJldHVybiB0b2tlbiAhPSBudWxsICYmICFqd3RIZWxwZXIuaXNUb2tlbkV4cGlyZWQodG9rZW4pO1xufVxuZXhwb3J0cy50b2tlbk5vdEV4cGlyZWQgPSB0b2tlbk5vdEV4cGlyZWQ7XG5leHBvcnRzLkFVVEhfUFJPVklERVJTID0gW1xuICAgIHtcbiAgICAgICAgcHJvdmlkZTogQXV0aEh0dHAsXG4gICAgICAgIGRlcHM6IFtodHRwXzEuSHR0cCwgaHR0cF8xLlJlcXVlc3RPcHRpb25zXSxcbiAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKGh0dHAsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXV0aEh0dHAobmV3IEF1dGhDb25maWcoKSwgaHR0cCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5dO1xuZnVuY3Rpb24gcHJvdmlkZUF1dGgoY29uZmlnKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZTogQXV0aEh0dHAsXG4gICAgICAgICAgICBkZXBzOiBbaHR0cF8xLkh0dHAsIGh0dHBfMS5SZXF1ZXN0T3B0aW9uc10sXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAoaHR0cCwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXV0aEh0dHAobmV3IEF1dGhDb25maWcoY29uZmlnKSwgaHR0cCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdO1xufVxuZXhwb3J0cy5wcm92aWRlQXV0aCA9IHByb3ZpZGVBdXRoO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuICAgIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdCh2YWwpO1xufVxuZnVuY3Rpb24gb2JqZWN0QXNzaWduKHRhcmdldCkge1xuICAgIHZhciBzb3VyY2UgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBzb3VyY2VbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG4gICAgdmFyIHN5bWJvbHM7XG4gICAgZm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICB0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0bztcbn1cbi8qKlxuICogTW9kdWxlIGZvciBhbmd1bGFyMi1qd3RcbiAqIEBleHBlcmltZW50YWxcbiAqL1xudmFyIEF1dGhNb2R1bGUgPSBBdXRoTW9kdWxlXzEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1dGhNb2R1bGUocGFyZW50TW9kdWxlKSB7XG4gICAgICAgIGlmIChwYXJlbnRNb2R1bGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aE1vZHVsZSBpcyBhbHJlYWR5IGxvYWRlZC4gSW1wb3J0IGl0IGluIHRoZSBBcHBNb2R1bGUgb25seScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEF1dGhNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBBdXRoTW9kdWxlXzEsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEF1dGhDb25maWcsIHVzZVZhbHVlOiBjb25maWcgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEF1dGhNb2R1bGU7XG59KCkpO1xuQXV0aE1vZHVsZSA9IEF1dGhNb2R1bGVfMSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtodHRwXzEuSHR0cE1vZHVsZV0sXG4gICAgICAgIHByb3ZpZGVyczogW0F1dGhIdHRwLCBKd3RIZWxwZXJdXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBjb3JlXzEuT3B0aW9uYWwoKSksIF9fcGFyYW0oMCwgY29yZV8xLlNraXBTZWxmKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXV0aE1vZHVsZV0pXG5dLCBBdXRoTW9kdWxlKTtcbmV4cG9ydHMuQXV0aE1vZHVsZSA9IEF1dGhNb2R1bGU7XG52YXIgQXV0aE1vZHVsZV8xO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5ndWxhcjItand0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1qd3QvYW5ndWxhcjItand0LmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLlJFUExBQ0VNRU5UX0NIQVJBQ1RFUiA9ICdcXHVGRkZEJztcblxuZXhwb3J0cy5DT0RFX1BPSU5UUyA9IHtcbiAgICBFT0Y6IC0xLFxuICAgIE5VTEw6IDB4MDAsXG4gICAgVEFCVUxBVElPTjogMHgwOSxcbiAgICBDQVJSSUFHRV9SRVRVUk46IDB4MEQsXG4gICAgTElORV9GRUVEOiAweDBBLFxuICAgIEZPUk1fRkVFRDogMHgwQyxcbiAgICBTUEFDRTogMHgyMCxcbiAgICBFWENMQU1BVElPTl9NQVJLOiAweDIxLFxuICAgIFFVT1RBVElPTl9NQVJLOiAweDIyLFxuICAgIE5VTUJFUl9TSUdOOiAweDIzLFxuICAgIEFNUEVSU0FORDogMHgyNixcbiAgICBBUE9TVFJPUEhFOiAweDI3LFxuICAgIEhZUEhFTl9NSU5VUzogMHgyRCxcbiAgICBTT0xJRFVTOiAweDJGLFxuICAgIERJR0lUXzA6IDB4MzAsXG4gICAgRElHSVRfOTogMHgzOSxcbiAgICBTRU1JQ09MT046IDB4M0IsXG4gICAgTEVTU19USEFOX1NJR046IDB4M0MsXG4gICAgRVFVQUxTX1NJR046IDB4M0QsXG4gICAgR1JFQVRFUl9USEFOX1NJR046IDB4M0UsXG4gICAgUVVFU1RJT05fTUFSSzogMHgzRixcbiAgICBMQVRJTl9DQVBJVEFMX0E6IDB4NDEsXG4gICAgTEFUSU5fQ0FQSVRBTF9GOiAweDQ2LFxuICAgIExBVElOX0NBUElUQUxfWDogMHg1OCxcbiAgICBMQVRJTl9DQVBJVEFMX1o6IDB4NUEsXG4gICAgR1JBVkVfQUNDRU5UOiAweDYwLFxuICAgIExBVElOX1NNQUxMX0E6IDB4NjEsXG4gICAgTEFUSU5fU01BTExfRjogMHg2NixcbiAgICBMQVRJTl9TTUFMTF9YOiAweDc4LFxuICAgIExBVElOX1NNQUxMX1o6IDB4N0EsXG4gICAgUkVQTEFDRU1FTlRfQ0hBUkFDVEVSOiAweEZGRkRcbn07XG5cbmV4cG9ydHMuQ09ERV9QT0lOVF9TRVFVRU5DRVMgPSB7XG4gICAgREFTSF9EQVNIX1NUUklORzogWzB4MkQsIDB4MkRdLCAvLy0tXG4gICAgRE9DVFlQRV9TVFJJTkc6IFsweDQ0LCAweDRGLCAweDQzLCAweDU0LCAweDU5LCAweDUwLCAweDQ1XSwgLy9ET0NUWVBFXG4gICAgQ0RBVEFfU1RBUlRfU1RSSU5HOiBbMHg1QiwgMHg0MywgMHg0NCwgMHg0MSwgMHg1NCwgMHg0MSwgMHg1Ql0sIC8vW0NEQVRBW1xuICAgIENEQVRBX0VORF9TVFJJTkc6IFsweDVELCAweDVELCAweDNFXSwgLy9dXT5cbiAgICBTQ1JJUFRfU1RSSU5HOiBbMHg3MywgMHg2MywgMHg3MiwgMHg2OSwgMHg3MCwgMHg3NF0sIC8vc2NyaXB0XG4gICAgUFVCTElDX1NUUklORzogWzB4NTAsIDB4NTUsIDB4NDIsIDB4NEMsIDB4NDksIDB4NDNdLCAvL1BVQkxJQ1xuICAgIFNZU1RFTV9TVFJJTkc6IFsweDUzLCAweDU5LCAweDUzLCAweDU0LCAweDQ1LCAweDREXSAvL1NZU1RFTVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZTUvbGliL2NvbW1vbi91bmljb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJlcHJvY2Vzc29yID0gcmVxdWlyZSgnLi9wcmVwcm9jZXNzb3InKSxcbiAgICBsb2NhdGlvbkluZm9NaXhpbiA9IHJlcXVpcmUoJy4uL2xvY2F0aW9uX2luZm8vdG9rZW5pemVyX21peGluJyksXG4gICAgVU5JQ09ERSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91bmljb2RlJyksXG4gICAgbmVUcmVlID0gcmVxdWlyZSgnLi9uYW1lZF9lbnRpdHlfZGF0YScpO1xuXG4vL0FsaWFzZXNcbnZhciAkID0gVU5JQ09ERS5DT0RFX1BPSU5UUyxcbiAgICAkJCA9IFVOSUNPREUuQ09ERV9QT0lOVF9TRVFVRU5DRVM7XG5cbi8vUmVwbGFjZW1lbnQgY29kZSBwb2ludHMgZm9yIG51bWVyaWMgZW50aXRpZXNcbnZhciBOVU1FUklDX0VOVElUWV9SRVBMQUNFTUVOVFMgPSB7XG4gICAgMHgwMDogMHhGRkZELCAweDBEOiAweDAwMEQsIDB4ODA6IDB4MjBBQywgMHg4MTogMHgwMDgxLCAweDgyOiAweDIwMUEsIDB4ODM6IDB4MDE5MiwgMHg4NDogMHgyMDFFLFxuICAgIDB4ODU6IDB4MjAyNiwgMHg4NjogMHgyMDIwLCAweDg3OiAweDIwMjEsIDB4ODg6IDB4MDJDNiwgMHg4OTogMHgyMDMwLCAweDhBOiAweDAxNjAsIDB4OEI6IDB4MjAzOSxcbiAgICAweDhDOiAweDAxNTIsIDB4OEQ6IDB4MDA4RCwgMHg4RTogMHgwMTdELCAweDhGOiAweDAwOEYsIDB4OTA6IDB4MDA5MCwgMHg5MTogMHgyMDE4LCAweDkyOiAweDIwMTksXG4gICAgMHg5MzogMHgyMDFDLCAweDk0OiAweDIwMUQsIDB4OTU6IDB4MjAyMiwgMHg5NjogMHgyMDEzLCAweDk3OiAweDIwMTQsIDB4OTg6IDB4MDJEQywgMHg5OTogMHgyMTIyLFxuICAgIDB4OUE6IDB4MDE2MSwgMHg5QjogMHgyMDNBLCAweDlDOiAweDAxNTMsIDB4OUQ6IDB4MDA5RCwgMHg5RTogMHgwMTdFLCAweDlGOiAweDAxNzhcbn07XG5cbi8vIE5hbWVkIGVudGl0eSB0cmVlIGZsYWdzXG52YXIgSEFTX0RBVEFfRkxBRyA9IDEgPDwgMDtcbnZhciBEQVRBX0RVUExFVF9GTEFHID0gMSA8PCAxO1xudmFyIEhBU19CUkFOQ0hFU19GTEFHID0gMSA8PCAyO1xudmFyIE1BWF9CUkFOQ0hfTUFSS0VSX1ZBTFVFID0gSEFTX0RBVEFfRkxBRyB8IERBVEFfRFVQTEVUX0ZMQUcgfCBIQVNfQlJBTkNIRVNfRkxBRztcblxuXG4vL1N0YXRlc1xudmFyIERBVEFfU1RBVEUgPSAnREFUQV9TVEFURScsXG4gICAgQ0hBUkFDVEVSX1JFRkVSRU5DRV9JTl9EQVRBX1NUQVRFID0gJ0NIQVJBQ1RFUl9SRUZFUkVOQ0VfSU5fREFUQV9TVEFURScsXG4gICAgUkNEQVRBX1NUQVRFID0gJ1JDREFUQV9TVEFURScsXG4gICAgQ0hBUkFDVEVSX1JFRkVSRU5DRV9JTl9SQ0RBVEFfU1RBVEUgPSAnQ0hBUkFDVEVSX1JFRkVSRU5DRV9JTl9SQ0RBVEFfU1RBVEUnLFxuICAgIFJBV1RFWFRfU1RBVEUgPSAnUkFXVEVYVF9TVEFURScsXG4gICAgU0NSSVBUX0RBVEFfU1RBVEUgPSAnU0NSSVBUX0RBVEFfU1RBVEUnLFxuICAgIFBMQUlOVEVYVF9TVEFURSA9ICdQTEFJTlRFWFRfU1RBVEUnLFxuICAgIFRBR19PUEVOX1NUQVRFID0gJ1RBR19PUEVOX1NUQVRFJyxcbiAgICBFTkRfVEFHX09QRU5fU1RBVEUgPSAnRU5EX1RBR19PUEVOX1NUQVRFJyxcbiAgICBUQUdfTkFNRV9TVEFURSA9ICdUQUdfTkFNRV9TVEFURScsXG4gICAgUkNEQVRBX0xFU1NfVEhBTl9TSUdOX1NUQVRFID0gJ1JDREFUQV9MRVNTX1RIQU5fU0lHTl9TVEFURScsXG4gICAgUkNEQVRBX0VORF9UQUdfT1BFTl9TVEFURSA9ICdSQ0RBVEFfRU5EX1RBR19PUEVOX1NUQVRFJyxcbiAgICBSQ0RBVEFfRU5EX1RBR19OQU1FX1NUQVRFID0gJ1JDREFUQV9FTkRfVEFHX05BTUVfU1RBVEUnLFxuICAgIFJBV1RFWFRfTEVTU19USEFOX1NJR05fU1RBVEUgPSAnUkFXVEVYVF9MRVNTX1RIQU5fU0lHTl9TVEFURScsXG4gICAgUkFXVEVYVF9FTkRfVEFHX09QRU5fU1RBVEUgPSAnUkFXVEVYVF9FTkRfVEFHX09QRU5fU1RBVEUnLFxuICAgIFJBV1RFWFRfRU5EX1RBR19OQU1FX1NUQVRFID0gJ1JBV1RFWFRfRU5EX1RBR19OQU1FX1NUQVRFJyxcbiAgICBTQ1JJUFRfREFUQV9MRVNTX1RIQU5fU0lHTl9TVEFURSA9ICdTQ1JJUFRfREFUQV9MRVNTX1RIQU5fU0lHTl9TVEFURScsXG4gICAgU0NSSVBUX0RBVEFfRU5EX1RBR19PUEVOX1NUQVRFID0gJ1NDUklQVF9EQVRBX0VORF9UQUdfT1BFTl9TVEFURScsXG4gICAgU0NSSVBUX0RBVEFfRU5EX1RBR19OQU1FX1NUQVRFID0gJ1NDUklQVF9EQVRBX0VORF9UQUdfTkFNRV9TVEFURScsXG4gICAgU0NSSVBUX0RBVEFfRVNDQVBFX1NUQVJUX1NUQVRFID0gJ1NDUklQVF9EQVRBX0VTQ0FQRV9TVEFSVF9TVEFURScsXG4gICAgU0NSSVBUX0RBVEFfRVNDQVBFX1NUQVJUX0RBU0hfU1RBVEUgPSAnU0NSSVBUX0RBVEFfRVNDQVBFX1NUQVJUX0RBU0hfU1RBVEUnLFxuICAgIFNDUklQVF9EQVRBX0VTQ0FQRURfU1RBVEUgPSAnU0NSSVBUX0RBVEFfRVNDQVBFRF9TVEFURScsXG4gICAgU0NSSVBUX0RBVEFfRVNDQVBFRF9EQVNIX1NUQVRFID0gJ1NDUklQVF9EQVRBX0VTQ0FQRURfREFTSF9TVEFURScsXG4gICAgU0NSSVBUX0RBVEFfRVNDQVBFRF9EQVNIX0RBU0hfU1RBVEUgPSAnU0NSSVBUX0RBVEFfRVNDQVBFRF9EQVNIX0RBU0hfU1RBVEUnLFxuICAgIFNDUklQVF9EQVRBX0VTQ0FQRURfTEVTU19USEFOX1NJR05fU1RBVEUgPSAnU0NSSVBUX0RBVEFfRVNDQVBFRF9MRVNTX1RIQU5fU0lHTl9TVEFURScsXG4gICAgU0NSSVBUX0RBVEFfRVNDQVBFRF9FTkRfVEFHX09QRU5fU1RBVEUgPSAnU0NSSVBUX0RBVEFfRVNDQVBFRF9FTkRfVEFHX09QRU5fU1RBVEUnLFxuICAgIFNDUklQVF9EQVRBX0VTQ0FQRURfRU5EX1RBR19OQU1FX1NUQVRFID0gJ1NDUklQVF9EQVRBX0VTQ0FQRURfRU5EX1RBR19OQU1FX1NUQVRFJyxcbiAgICBTQ1JJUFRfREFUQV9ET1VCTEVfRVNDQVBFX1NUQVJUX1NUQVRFID0gJ1NDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVfU1RBUlRfU1RBVEUnLFxuICAgIFNDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX1NUQVRFID0gJ1NDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX1NUQVRFJyxcbiAgICBTQ1JJUFRfREFUQV9ET1VCTEVfRVNDQVBFRF9EQVNIX1NUQVRFID0gJ1NDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX0RBU0hfU1RBVEUnLFxuICAgIFNDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX0RBU0hfREFTSF9TVEFURSA9ICdTQ1JJUFRfREFUQV9ET1VCTEVfRVNDQVBFRF9EQVNIX0RBU0hfU1RBVEUnLFxuICAgIFNDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX0xFU1NfVEhBTl9TSUdOX1NUQVRFID0gJ1NDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX0xFU1NfVEhBTl9TSUdOX1NUQVRFJyxcbiAgICBTQ1JJUFRfREFUQV9ET1VCTEVfRVNDQVBFX0VORF9TVEFURSA9ICdTQ1JJUFRfREFUQV9ET1VCTEVfRVNDQVBFX0VORF9TVEFURScsXG4gICAgQkVGT1JFX0FUVFJJQlVURV9OQU1FX1NUQVRFID0gJ0JFRk9SRV9BVFRSSUJVVEVfTkFNRV9TVEFURScsXG4gICAgQVRUUklCVVRFX05BTUVfU1RBVEUgPSAnQVRUUklCVVRFX05BTUVfU1RBVEUnLFxuICAgIEFGVEVSX0FUVFJJQlVURV9OQU1FX1NUQVRFID0gJ0FGVEVSX0FUVFJJQlVURV9OQU1FX1NUQVRFJyxcbiAgICBCRUZPUkVfQVRUUklCVVRFX1ZBTFVFX1NUQVRFID0gJ0JFRk9SRV9BVFRSSUJVVEVfVkFMVUVfU1RBVEUnLFxuICAgIEFUVFJJQlVURV9WQUxVRV9ET1VCTEVfUVVPVEVEX1NUQVRFID0gJ0FUVFJJQlVURV9WQUxVRV9ET1VCTEVfUVVPVEVEX1NUQVRFJyxcbiAgICBBVFRSSUJVVEVfVkFMVUVfU0lOR0xFX1FVT1RFRF9TVEFURSA9ICdBVFRSSUJVVEVfVkFMVUVfU0lOR0xFX1FVT1RFRF9TVEFURScsXG4gICAgQVRUUklCVVRFX1ZBTFVFX1VOUVVPVEVEX1NUQVRFID0gJ0FUVFJJQlVURV9WQUxVRV9VTlFVT1RFRF9TVEFURScsXG4gICAgQ0hBUkFDVEVSX1JFRkVSRU5DRV9JTl9BVFRSSUJVVEVfVkFMVUVfU1RBVEUgPSAnQ0hBUkFDVEVSX1JFRkVSRU5DRV9JTl9BVFRSSUJVVEVfVkFMVUVfU1RBVEUnLFxuICAgIEFGVEVSX0FUVFJJQlVURV9WQUxVRV9RVU9URURfU1RBVEUgPSAnQUZURVJfQVRUUklCVVRFX1ZBTFVFX1FVT1RFRF9TVEFURScsXG4gICAgU0VMRl9DTE9TSU5HX1NUQVJUX1RBR19TVEFURSA9ICdTRUxGX0NMT1NJTkdfU1RBUlRfVEFHX1NUQVRFJyxcbiAgICBCT0dVU19DT01NRU5UX1NUQVRFID0gJ0JPR1VTX0NPTU1FTlRfU1RBVEUnLFxuICAgIEJPR1VTX0NPTU1FTlRfU1RBVEVfQ09OVElOVUFUSU9OID0gJ0JPR1VTX0NPTU1FTlRfU1RBVEVfQ09OVElOVUFUSU9OJyxcbiAgICBNQVJLVVBfREVDTEFSQVRJT05fT1BFTl9TVEFURSA9ICdNQVJLVVBfREVDTEFSQVRJT05fT1BFTl9TVEFURScsXG4gICAgQ09NTUVOVF9TVEFSVF9TVEFURSA9ICdDT01NRU5UX1NUQVJUX1NUQVRFJyxcbiAgICBDT01NRU5UX1NUQVJUX0RBU0hfU1RBVEUgPSAnQ09NTUVOVF9TVEFSVF9EQVNIX1NUQVRFJyxcbiAgICBDT01NRU5UX1NUQVRFID0gJ0NPTU1FTlRfU1RBVEUnLFxuICAgIENPTU1FTlRfRU5EX0RBU0hfU1RBVEUgPSAnQ09NTUVOVF9FTkRfREFTSF9TVEFURScsXG4gICAgQ09NTUVOVF9FTkRfU1RBVEUgPSAnQ09NTUVOVF9FTkRfU1RBVEUnLFxuICAgIENPTU1FTlRfRU5EX0JBTkdfU1RBVEUgPSAnQ09NTUVOVF9FTkRfQkFOR19TVEFURScsXG4gICAgRE9DVFlQRV9TVEFURSA9ICdET0NUWVBFX1NUQVRFJyxcbiAgICBET0NUWVBFX05BTUVfU1RBVEUgPSAnRE9DVFlQRV9OQU1FX1NUQVRFJyxcbiAgICBBRlRFUl9ET0NUWVBFX05BTUVfU1RBVEUgPSAnQUZURVJfRE9DVFlQRV9OQU1FX1NUQVRFJyxcbiAgICBCRUZPUkVfRE9DVFlQRV9QVUJMSUNfSURFTlRJRklFUl9TVEFURSA9ICdCRUZPUkVfRE9DVFlQRV9QVUJMSUNfSURFTlRJRklFUl9TVEFURScsXG4gICAgRE9DVFlQRV9QVUJMSUNfSURFTlRJRklFUl9ET1VCTEVfUVVPVEVEX1NUQVRFID0gJ0RPQ1RZUEVfUFVCTElDX0lERU5USUZJRVJfRE9VQkxFX1FVT1RFRF9TVEFURScsXG4gICAgRE9DVFlQRV9QVUJMSUNfSURFTlRJRklFUl9TSU5HTEVfUVVPVEVEX1NUQVRFID0gJ0RPQ1RZUEVfUFVCTElDX0lERU5USUZJRVJfU0lOR0xFX1FVT1RFRF9TVEFURScsXG4gICAgQkVUV0VFTl9ET0NUWVBFX1BVQkxJQ19BTkRfU1lTVEVNX0lERU5USUZJRVJTX1NUQVRFID0gJ0JFVFdFRU5fRE9DVFlQRV9QVUJMSUNfQU5EX1NZU1RFTV9JREVOVElGSUVSU19TVEFURScsXG4gICAgQkVGT1JFX0RPQ1RZUEVfU1lTVEVNX0lERU5USUZJRVJfU1RBVEUgPSAnQkVGT1JFX0RPQ1RZUEVfU1lTVEVNX0lERU5USUZJRVJfU1RBVEUnLFxuICAgIERPQ1RZUEVfU1lTVEVNX0lERU5USUZJRVJfRE9VQkxFX1FVT1RFRF9TVEFURSA9ICdET0NUWVBFX1NZU1RFTV9JREVOVElGSUVSX0RPVUJMRV9RVU9URURfU1RBVEUnLFxuICAgIERPQ1RZUEVfU1lTVEVNX0lERU5USUZJRVJfU0lOR0xFX1FVT1RFRF9TVEFURSA9ICdET0NUWVBFX1NZU1RFTV9JREVOVElGSUVSX1NJTkdMRV9RVU9URURfU1RBVEUnLFxuICAgIEFGVEVSX0RPQ1RZUEVfU1lTVEVNX0lERU5USUZJRVJfU1RBVEUgPSAnQUZURVJfRE9DVFlQRV9TWVNURU1fSURFTlRJRklFUl9TVEFURScsXG4gICAgQk9HVVNfRE9DVFlQRV9TVEFURSA9ICdCT0dVU19ET0NUWVBFX1NUQVRFJyxcbiAgICBDREFUQV9TRUNUSU9OX1NUQVRFID0gJ0NEQVRBX1NFQ1RJT05fU1RBVEUnO1xuXG4vL1V0aWxzXG5cbi8vT1BUSU1JWkFUSU9OOiB0aGVzZSB1dGlsaXR5IGZ1bmN0aW9ucyBzaG91bGQgbm90IGJlIG1vdmVkIG91dCBvZiB0aGlzIG1vZHVsZS4gVjggQ3JhbmtzaGFmdCB3aWxsIG5vdCBpbmxpbmVcbi8vdGhpcyBmdW5jdGlvbnMgaWYgdGhleSB3aWxsIGJlIHNpdHVhdGVkIGluIGFub3RoZXIgbW9kdWxlIGR1ZSB0byBjb250ZXh0IHN3aXRjaC5cbi8vQWx3YXlzIHBlcmZvcm0gaW5saW5pbmcgY2hlY2sgYmVmb3JlIG1vZGlmeWluZyB0aGlzIGZ1bmN0aW9ucyAoJ25vZGUgLS10cmFjZS1pbmxpbmluZycpLlxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNwKSB7XG4gICAgcmV0dXJuIGNwID09PSAkLlNQQUNFIHx8IGNwID09PSAkLkxJTkVfRkVFRCB8fCBjcCA9PT0gJC5UQUJVTEFUSU9OIHx8IGNwID09PSAkLkZPUk1fRkVFRDtcbn1cblxuZnVuY3Rpb24gaXNBc2NpaURpZ2l0KGNwKSB7XG4gICAgcmV0dXJuIGNwID49ICQuRElHSVRfMCAmJiBjcCA8PSAkLkRJR0lUXzk7XG59XG5cbmZ1bmN0aW9uIGlzQXNjaWlVcHBlcihjcCkge1xuICAgIHJldHVybiBjcCA+PSAkLkxBVElOX0NBUElUQUxfQSAmJiBjcCA8PSAkLkxBVElOX0NBUElUQUxfWjtcbn1cblxuZnVuY3Rpb24gaXNBc2NpaUxvd2VyKGNwKSB7XG4gICAgcmV0dXJuIGNwID49ICQuTEFUSU5fU01BTExfQSAmJiBjcCA8PSAkLkxBVElOX1NNQUxMX1o7XG59XG5cbmZ1bmN0aW9uIGlzQXNjaWlMZXR0ZXIoY3ApIHtcbiAgICByZXR1cm4gaXNBc2NpaUxvd2VyKGNwKSB8fCBpc0FzY2lpVXBwZXIoY3ApO1xufVxuXG5mdW5jdGlvbiBpc0FzY2lpQWxwaGFOdW1lcmljKGNwKSB7XG4gICAgcmV0dXJuIGlzQXNjaWlMZXR0ZXIoY3ApIHx8IGlzQXNjaWlEaWdpdChjcCk7XG59XG5cbmZ1bmN0aW9uIGlzRGlnaXQoY3AsIGlzSGV4KSB7XG4gICAgcmV0dXJuIGlzQXNjaWlEaWdpdChjcCkgfHwgaXNIZXggJiYgKGNwID49ICQuTEFUSU5fQ0FQSVRBTF9BICYmIGNwIDw9ICQuTEFUSU5fQ0FQSVRBTF9GIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwID49ICQuTEFUSU5fU01BTExfQSAmJiBjcCA8PSAkLkxBVElOX1NNQUxMX0YpO1xufVxuXG5mdW5jdGlvbiBpc1Jlc2VydmVkQ29kZVBvaW50KGNwKSB7XG4gICAgcmV0dXJuIGNwID49IDB4RDgwMCAmJiBjcCA8PSAweERGRkYgfHwgY3AgPiAweDEwRkZGRjtcbn1cblxuZnVuY3Rpb24gdG9Bc2NpaUxvd2VyQ29kZVBvaW50KGNwKSB7XG4gICAgcmV0dXJuIGNwICsgMHgwMDIwO1xufVxuXG4vL05PVEU6IFN0cmluZy5mcm9tQ2hhckNvZGUoKSBmdW5jdGlvbiBjYW4gaGFuZGxlIG9ubHkgY2hhcmFjdGVycyBmcm9tIEJNUCBzdWJzZXQuXG4vL1NvLCB3ZSBuZWVkIHRvIHdvcmthcm91bmQgdGhpcyBtYW51YWxseS5cbi8vKHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZnJvbUNoYXJDb2RlI0dldHRpbmdfaXRfdG9fd29ya193aXRoX2hpZ2hlcl92YWx1ZXMpXG5mdW5jdGlvbiB0b0NoYXIoY3ApIHtcbiAgICBpZiAoY3AgPD0gMHhGRkZGKVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjcCk7XG5cbiAgICBjcCAtPSAweDEwMDAwO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNwID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEQzAwIHwgY3AgJiAweDNGRik7XG59XG5cbmZ1bmN0aW9uIHRvQXNjaWlMb3dlckNoYXIoY3ApIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0b0FzY2lpTG93ZXJDb2RlUG9pbnQoY3ApKTtcbn1cblxuZnVuY3Rpb24gZmluZE5hbWVkRW50aXR5VHJlZUJyYW5jaChub2RlSXgsIGNwKSB7XG4gICAgdmFyIGJyYW5jaENvdW50ID0gbmVUcmVlWysrbm9kZUl4XSxcbiAgICAgICAgbG8gPSArK25vZGVJeCxcbiAgICAgICAgaGkgPSBsbyArIGJyYW5jaENvdW50IC0gMTtcblxuICAgIHdoaWxlIChsbyA8PSBoaSkge1xuICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMSxcbiAgICAgICAgICAgIG1pZENwID0gbmVUcmVlW21pZF07XG5cbiAgICAgICAgaWYgKG1pZENwIDwgY3ApXG4gICAgICAgICAgICBsbyA9IG1pZCArIDE7XG5cbiAgICAgICAgZWxzZSBpZiAobWlkQ3AgPiBjcClcbiAgICAgICAgICAgIGhpID0gbWlkIC0gMTtcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmVUcmVlW21pZCArIGJyYW5jaENvdW50XTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG59XG5cblxuLy9Ub2tlbml6ZXJcbnZhciBUb2tlbml6ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5wcmVwcm9jZXNzb3IgPSBuZXcgUHJlcHJvY2Vzc29yKCk7XG5cbiAgICB0aGlzLnRva2VuUXVldWUgPSBbXTtcblxuICAgIHRoaXMuYWxsb3dDREFUQSA9IGZhbHNlO1xuXG4gICAgdGhpcy5zdGF0ZSA9IERBVEFfU1RBVEU7XG4gICAgdGhpcy5yZXR1cm5TdGF0ZSA9ICcnO1xuXG4gICAgdGhpcy50ZW1wQnVmZiA9IFtdO1xuICAgIHRoaXMuYWRkaXRpb25hbEFsbG93ZWRDcCA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RTdGFydFRhZ05hbWUgPSAnJztcblxuICAgIHRoaXMuY29uc3VtZWRBZnRlclNuYXBzaG90ID0gLTE7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcblxuICAgIHRoaXMuY3VycmVudENoYXJhY3RlclRva2VuID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUb2tlbiA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50QXR0ciA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxvY2F0aW9uSW5mbylcbiAgICAgICAgbG9jYXRpb25JbmZvTWl4aW4uYXNzaWduKHRoaXMpO1xufTtcblxuLy9Ub2tlbiB0eXBlc1xuVG9rZW5pemVyLkNIQVJBQ1RFUl9UT0tFTiA9ICdDSEFSQUNURVJfVE9LRU4nO1xuVG9rZW5pemVyLk5VTExfQ0hBUkFDVEVSX1RPS0VOID0gJ05VTExfQ0hBUkFDVEVSX1RPS0VOJztcblRva2VuaXplci5XSElURVNQQUNFX0NIQVJBQ1RFUl9UT0tFTiA9ICdXSElURVNQQUNFX0NIQVJBQ1RFUl9UT0tFTic7XG5Ub2tlbml6ZXIuU1RBUlRfVEFHX1RPS0VOID0gJ1NUQVJUX1RBR19UT0tFTic7XG5Ub2tlbml6ZXIuRU5EX1RBR19UT0tFTiA9ICdFTkRfVEFHX1RPS0VOJztcblRva2VuaXplci5DT01NRU5UX1RPS0VOID0gJ0NPTU1FTlRfVE9LRU4nO1xuVG9rZW5pemVyLkRPQ1RZUEVfVE9LRU4gPSAnRE9DVFlQRV9UT0tFTic7XG5Ub2tlbml6ZXIuRU9GX1RPS0VOID0gJ0VPRl9UT0tFTic7XG5Ub2tlbml6ZXIuSElCRVJOQVRJT05fVE9LRU4gPSAnSElCRVJOQVRJT05fVE9LRU4nO1xuXG4vL1Rva2VuaXplciBpbml0aWFsIHN0YXRlcyBmb3IgZGlmZmVyZW50IG1vZGVzXG5Ub2tlbml6ZXIuTU9ERSA9IFRva2VuaXplci5wcm90b3R5cGUuTU9ERSA9IHtcbiAgICBEQVRBOiBEQVRBX1NUQVRFLFxuICAgIFJDREFUQTogUkNEQVRBX1NUQVRFLFxuICAgIFJBV1RFWFQ6IFJBV1RFWFRfU1RBVEUsXG4gICAgU0NSSVBUX0RBVEE6IFNDUklQVF9EQVRBX1NUQVRFLFxuICAgIFBMQUlOVEVYVDogUExBSU5URVhUX1NUQVRFXG59O1xuXG4vL1N0YXRpY1xuVG9rZW5pemVyLmdldFRva2VuQXR0ciA9IGZ1bmN0aW9uICh0b2tlbiwgYXR0ck5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gdG9rZW4uYXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHRva2VuLmF0dHJzW2ldLm5hbWUgPT09IGF0dHJOYW1lKVxuICAgICAgICAgICAgcmV0dXJuIHRva2VuLmF0dHJzW2ldLnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuLy9BUElcblRva2VuaXplci5wcm90b3R5cGUuZ2V0TmV4dFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlICghdGhpcy50b2tlblF1ZXVlLmxlbmd0aCAmJiB0aGlzLmFjdGl2ZSkge1xuICAgICAgICB0aGlzLl9oaWJlcm5hdGlvblNuYXBzaG90KCk7XG5cbiAgICAgICAgdmFyIGNwID0gdGhpcy5fY29uc3VtZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fZW5zdXJlSGliZXJuYXRpb24oKSlcbiAgICAgICAgICAgIHRoaXNbdGhpcy5zdGF0ZV0oY3ApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRva2VuUXVldWUuc2hpZnQoKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGlzTGFzdENodW5rKSB7XG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMucHJlcHJvY2Vzc29yLndyaXRlKGNodW5rLCBpc0xhc3RDaHVuayk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLmluc2VydEh0bWxBdEN1cnJlbnRQb3MgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5wcmVwcm9jZXNzb3IuaW5zZXJ0SHRtbEF0Q3VycmVudFBvcyhjaHVuayk7XG59O1xuXG4vL0hpYmVybmF0aW9uXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9oaWJlcm5hdGlvblNuYXBzaG90ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29uc3VtZWRBZnRlclNuYXBzaG90ID0gMDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2Vuc3VyZUhpYmVybmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnByZXByb2Nlc3Nvci5lbmRPZkNodW5rSGl0KSB7XG4gICAgICAgIGZvciAoOyB0aGlzLmNvbnN1bWVkQWZ0ZXJTbmFwc2hvdCA+IDA7IHRoaXMuY29uc3VtZWRBZnRlclNuYXBzaG90LS0pXG4gICAgICAgICAgICB0aGlzLnByZXByb2Nlc3Nvci5yZXRyZWF0KCk7XG5cbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b2tlblF1ZXVlLnB1c2goe3R5cGU6IFRva2VuaXplci5ISUJFUk5BVElPTl9UT0tFTn0pO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblxuLy9Db25zdW1wdGlvblxuVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbnN1bWVkQWZ0ZXJTbmFwc2hvdCsrO1xuICAgIHJldHVybiB0aGlzLnByZXByb2Nlc3Nvci5hZHZhbmNlKCk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl91bmNvbnN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb25zdW1lZEFmdGVyU25hcHNob3QtLTtcbiAgICB0aGlzLnByZXByb2Nlc3Nvci5yZXRyZWF0KCk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl91bmNvbnN1bWVTZXZlcmFsID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgd2hpbGUgKGNvdW50LS0pXG4gICAgICAgIHRoaXMuX3VuY29uc3VtZSgpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVjb25zdW1lSW5TdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLl91bmNvbnN1bWUoKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVTdWJzZXF1ZW50SWZNYXRjaCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBzdGFydENwLCBjYXNlU2Vuc2l0aXZlKSB7XG4gICAgdmFyIGNvbnN1bWVkQ291bnQgPSAwLFxuICAgICAgICBpc01hdGNoID0gdHJ1ZSxcbiAgICAgICAgcGF0dGVybkxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoLFxuICAgICAgICBwYXR0ZXJuUG9zID0gMCxcbiAgICAgICAgY3AgPSBzdGFydENwLFxuICAgICAgICBwYXR0ZXJuQ3AgPSB2b2lkIDA7XG5cbiAgICBmb3IgKDsgcGF0dGVyblBvcyA8IHBhdHRlcm5MZW5ndGg7IHBhdHRlcm5Qb3MrKykge1xuICAgICAgICBpZiAocGF0dGVyblBvcyA+IDApIHtcbiAgICAgICAgICAgIGNwID0gdGhpcy5fY29uc3VtZSgpO1xuICAgICAgICAgICAgY29uc3VtZWRDb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNwID09PSAkLkVPRikge1xuICAgICAgICAgICAgaXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwYXR0ZXJuQ3AgPSBwYXR0ZXJuW3BhdHRlcm5Qb3NdO1xuXG4gICAgICAgIGlmIChjcCAhPT0gcGF0dGVybkNwICYmIChjYXNlU2Vuc2l0aXZlIHx8IGNwICE9PSB0b0FzY2lpTG93ZXJDb2RlUG9pbnQocGF0dGVybkNwKSkpIHtcbiAgICAgICAgICAgIGlzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc01hdGNoKVxuICAgICAgICB0aGlzLl91bmNvbnN1bWVTZXZlcmFsKGNvbnN1bWVkQ291bnQpO1xuXG4gICAgcmV0dXJuIGlzTWF0Y2g7XG59O1xuXG4vL0xvb2thaGVhZFxuVG9rZW5pemVyLnByb3RvdHlwZS5fbG9va2FoZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjcCA9IHRoaXMuX2NvbnN1bWUoKTtcblxuICAgIHRoaXMuX3VuY29uc3VtZSgpO1xuXG4gICAgcmV0dXJuIGNwO1xufTtcblxuLy9UZW1wIGJ1ZmZlclxuVG9rZW5pemVyLnByb3RvdHlwZS5pc1RlbXBCdWZmZXJFcXVhbFRvU2NyaXB0U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRlbXBCdWZmLmxlbmd0aCAhPT0gJCQuU0NSSVBUX1NUUklORy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50ZW1wQnVmZi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy50ZW1wQnVmZltpXSAhPT0gJCQuU0NSSVBUX1NUUklOR1tpXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vVG9rZW4gY3JlYXRpb25cblRva2VuaXplci5wcm90b3R5cGUuX2NyZWF0ZVN0YXJ0VGFnVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdXJyZW50VG9rZW4gPSB7XG4gICAgICAgIHR5cGU6IFRva2VuaXplci5TVEFSVF9UQUdfVE9LRU4sXG4gICAgICAgIHRhZ05hbWU6ICcnLFxuICAgICAgICBzZWxmQ2xvc2luZzogZmFsc2UsXG4gICAgICAgIGF0dHJzOiBbXVxuICAgIH07XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9jcmVhdGVFbmRUYWdUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmN1cnJlbnRUb2tlbiA9IHtcbiAgICAgICAgdHlwZTogVG9rZW5pemVyLkVORF9UQUdfVE9LRU4sXG4gICAgICAgIHRhZ05hbWU6ICcnLFxuICAgICAgICBhdHRyczogW11cbiAgICB9O1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fY3JlYXRlQ29tbWVudFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY3VycmVudFRva2VuID0ge1xuICAgICAgICB0eXBlOiBUb2tlbml6ZXIuQ09NTUVOVF9UT0tFTixcbiAgICAgICAgZGF0YTogJydcbiAgICB9O1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fY3JlYXRlRG9jdHlwZVRva2VuID0gZnVuY3Rpb24gKGluaXRpYWxOYW1lKSB7XG4gICAgdGhpcy5jdXJyZW50VG9rZW4gPSB7XG4gICAgICAgIHR5cGU6IFRva2VuaXplci5ET0NUWVBFX1RPS0VOLFxuICAgICAgICBuYW1lOiBpbml0aWFsTmFtZSxcbiAgICAgICAgZm9yY2VRdWlya3M6IGZhbHNlLFxuICAgICAgICBwdWJsaWNJZDogbnVsbCxcbiAgICAgICAgc3lzdGVtSWQ6IG51bGxcbiAgICB9O1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fY3JlYXRlQ2hhcmFjdGVyVG9rZW4gPSBmdW5jdGlvbiAodHlwZSwgY2gpIHtcbiAgICB0aGlzLmN1cnJlbnRDaGFyYWN0ZXJUb2tlbiA9IHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgY2hhcnM6IGNoXG4gICAgfTtcbn07XG5cbi8vVGFnIGF0dHJpYnV0ZXNcblRva2VuaXplci5wcm90b3R5cGUuX2NyZWF0ZUF0dHIgPSBmdW5jdGlvbiAoYXR0ck5hbWVGaXJzdENoKSB7XG4gICAgdGhpcy5jdXJyZW50QXR0ciA9IHtcbiAgICAgICAgbmFtZTogYXR0ck5hbWVGaXJzdENoLFxuICAgICAgICB2YWx1ZTogJydcbiAgICB9O1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNEdXBsaWNhdGVBdHRyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUb2tlbml6ZXIuZ2V0VG9rZW5BdHRyKHRoaXMuY3VycmVudFRva2VuLCB0aGlzLmN1cnJlbnRBdHRyLm5hbWUpICE9PSBudWxsO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fbGVhdmVBdHRyTmFtZSA9IGZ1bmN0aW9uICh0b1N0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHRvU3RhdGU7XG5cbiAgICBpZiAoIXRoaXMuX2lzRHVwbGljYXRlQXR0cigpKVxuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5hdHRycy5wdXNoKHRoaXMuY3VycmVudEF0dHIpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fbGVhdmVBdHRyVmFsdWUgPSBmdW5jdGlvbiAodG9TdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSB0b1N0YXRlO1xufTtcblxuLy9BcHByb3ByaWF0ZSBlbmQgdGFnIHRva2VuXG4vLyhzZWU6IGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3Rva2VuaXphdGlvbi5odG1sI2FwcHJvcHJpYXRlLWVuZC10YWctdG9rZW4pXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc0FwcHJvcHJpYXRlRW5kVGFnVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGFzdFN0YXJ0VGFnTmFtZSA9PT0gdGhpcy5jdXJyZW50VG9rZW4udGFnTmFtZTtcbn07XG5cbi8vVG9rZW4gZW1pc3Npb25cblRva2VuaXplci5wcm90b3R5cGUuX2VtaXRDdXJyZW50VG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZW1pdEN1cnJlbnRDaGFyYWN0ZXJUb2tlbigpO1xuXG4gICAgLy9OT1RFOiBzdG9yZSBlbWl0ZWQgc3RhcnQgdGFnJ3MgdGFnTmFtZSB0byBkZXRlcm1pbmUgaXMgdGhlIGZvbGxvd2luZyBlbmQgdGFnIHRva2VuIGlzIGFwcHJvcHJpYXRlLlxuICAgIGlmICh0aGlzLmN1cnJlbnRUb2tlbi50eXBlID09PSBUb2tlbml6ZXIuU1RBUlRfVEFHX1RPS0VOKVxuICAgICAgICB0aGlzLmxhc3RTdGFydFRhZ05hbWUgPSB0aGlzLmN1cnJlbnRUb2tlbi50YWdOYW1lO1xuXG4gICAgdGhpcy50b2tlblF1ZXVlLnB1c2godGhpcy5jdXJyZW50VG9rZW4pO1xuICAgIHRoaXMuY3VycmVudFRva2VuID0gbnVsbDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2VtaXRDdXJyZW50Q2hhcmFjdGVyVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudENoYXJhY3RlclRva2VuKSB7XG4gICAgICAgIHRoaXMudG9rZW5RdWV1ZS5wdXNoKHRoaXMuY3VycmVudENoYXJhY3RlclRva2VuKTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2hhcmFjdGVyVG9rZW4gPSBudWxsO1xuICAgIH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2VtaXRFT0ZUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9lbWl0Q3VycmVudENoYXJhY3RlclRva2VuKCk7XG4gICAgdGhpcy50b2tlblF1ZXVlLnB1c2goe3R5cGU6IFRva2VuaXplci5FT0ZfVE9LRU59KTtcbn07XG5cbi8vQ2hhcmFjdGVycyBlbWlzc2lvblxuXG4vL09QVElNSVpBVElPTjogc3BlY2lmaWNhdGlvbiB1c2VzIG9ubHkgb25lIHR5cGUgb2YgY2hhcmFjdGVyIHRva2VucyAob25lIHRva2VuIHBlciBjaGFyYWN0ZXIpLlxuLy9UaGlzIGNhdXNlcyBhIGh1Z2UgbWVtb3J5IG92ZXJoZWFkIGFuZCBhIGxvdCBvZiB1bm5lY2Vzc2FyeSBwYXJzZXIgbG9vcHMuIHBhcnNlNSB1c2VzIDMgZ3JvdXBzIG9mIGNoYXJhY3RlcnMuXG4vL0lmIHdlIGhhdmUgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIHRoYXQgYmVsb25nIHRvIHRoZSBzYW1lIGdyb3VwLCBwYXJzZXIgY2FuIHByb2Nlc3MgaXRcbi8vYXMgYSBzaW5nbGUgc29saWQgY2hhcmFjdGVyIHRva2VuLlxuLy9TbywgdGhlcmUgYXJlIDMgdHlwZXMgb2YgY2hhcmFjdGVyIHRva2VucyBpbiBwYXJzZTU6XG4vLzEpTlVMTF9DSEFSQUNURVJfVE9LRU4gLSBcXHUwMDAwLWNoYXJhY3RlciBzZXF1ZW5jZXMgKGUuZy4gJ1xcdTAwMDBcXHUwMDAwXFx1MDAwMCcpXG4vLzIpV0hJVEVTUEFDRV9DSEFSQUNURVJfVE9LRU4gLSBhbnkgd2hpdGVzcGFjZS9uZXctbGluZSBjaGFyYWN0ZXIgc2VxdWVuY2VzIChlLmcuICdcXG4gIFxcclxcdCAgIFxcZicpXG4vLzMpQ0hBUkFDVEVSX1RPS0VOIC0gYW55IGNoYXJhY3RlciBzZXF1ZW5jZSB3aGljaCBkb24ndCBiZWxvbmcgdG8gZ3JvdXBzIDEgYW5kIDIgKGUuZy4gJ2FiY2RlZjEyMzRAQCMkJV4nKVxuVG9rZW5pemVyLnByb3RvdHlwZS5fYXBwZW5kQ2hhclRvQ3VycmVudENoYXJhY3RlclRva2VuID0gZnVuY3Rpb24gKHR5cGUsIGNoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudENoYXJhY3RlclRva2VuICYmIHRoaXMuY3VycmVudENoYXJhY3RlclRva2VuLnR5cGUgIT09IHR5cGUpXG4gICAgICAgIHRoaXMuX2VtaXRDdXJyZW50Q2hhcmFjdGVyVG9rZW4oKTtcblxuICAgIGlmICh0aGlzLmN1cnJlbnRDaGFyYWN0ZXJUb2tlbilcbiAgICAgICAgdGhpcy5jdXJyZW50Q2hhcmFjdGVyVG9rZW4uY2hhcnMgKz0gY2g7XG5cbiAgICBlbHNlXG4gICAgICAgIHRoaXMuX2NyZWF0ZUNoYXJhY3RlclRva2VuKHR5cGUsIGNoKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2VtaXRDb2RlUG9pbnQgPSBmdW5jdGlvbiAoY3ApIHtcbiAgICB2YXIgdHlwZSA9IFRva2VuaXplci5DSEFSQUNURVJfVE9LRU47XG5cbiAgICBpZiAoaXNXaGl0ZXNwYWNlKGNwKSlcbiAgICAgICAgdHlwZSA9IFRva2VuaXplci5XSElURVNQQUNFX0NIQVJBQ1RFUl9UT0tFTjtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLk5VTEwpXG4gICAgICAgIHR5cGUgPSBUb2tlbml6ZXIuTlVMTF9DSEFSQUNURVJfVE9LRU47XG5cbiAgICB0aGlzLl9hcHBlbmRDaGFyVG9DdXJyZW50Q2hhcmFjdGVyVG9rZW4odHlwZSwgdG9DaGFyKGNwKSk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9lbWl0U2V2ZXJhbENvZGVQb2ludHMgPSBmdW5jdGlvbiAoY29kZVBvaW50cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZVBvaW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgdGhpcy5fZW1pdENvZGVQb2ludChjb2RlUG9pbnRzW2ldKTtcbn07XG5cbi8vTk9URTogdXNlZCB0aGVuIHdlIGVtaXQgY2hhcmFjdGVyIGV4cGxpY2l0bHkuIFRoaXMgaXMgYWx3YXlzIGEgbm9uLXdoaXRlc3BhY2UgYW5kIGEgbm9uLW51bGwgY2hhcmFjdGVyLlxuLy9TbyB3ZSBjYW4gYXZvaWQgYWRkaXRpb25hbCBjaGVja3MgaGVyZS5cblRva2VuaXplci5wcm90b3R5cGUuX2VtaXRDaGFyID0gZnVuY3Rpb24gKGNoKSB7XG4gICAgdGhpcy5fYXBwZW5kQ2hhclRvQ3VycmVudENoYXJhY3RlclRva2VuKFRva2VuaXplci5DSEFSQUNURVJfVE9LRU4sIGNoKTtcbn07XG5cbi8vQ2hhcmFjdGVyIHJlZmVyZW5jZSB0b2tlbml6YXRpb25cblRva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVOdW1lcmljRW50aXR5ID0gZnVuY3Rpb24gKGlzSGV4KSB7XG4gICAgdmFyIGRpZ2l0cyA9ICcnLFxuICAgICAgICBuZXh0Q3AgPSB2b2lkIDA7XG5cbiAgICBkbyB7XG4gICAgICAgIGRpZ2l0cyArPSB0b0NoYXIodGhpcy5fY29uc3VtZSgpKTtcbiAgICAgICAgbmV4dENwID0gdGhpcy5fbG9va2FoZWFkKCk7XG4gICAgfSB3aGlsZSAobmV4dENwICE9PSAkLkVPRiAmJiBpc0RpZ2l0KG5leHRDcCwgaXNIZXgpKTtcblxuICAgIGlmICh0aGlzLl9sb29rYWhlYWQoKSA9PT0gJC5TRU1JQ09MT04pXG4gICAgICAgIHRoaXMuX2NvbnN1bWUoKTtcblxuICAgIHZhciByZWZlcmVuY2VkQ3AgPSBwYXJzZUludChkaWdpdHMsIGlzSGV4ID8gMTYgOiAxMCksXG4gICAgICAgIHJlcGxhY2VtZW50ID0gTlVNRVJJQ19FTlRJVFlfUkVQTEFDRU1FTlRTW3JlZmVyZW5jZWRDcF07XG5cbiAgICBpZiAocmVwbGFjZW1lbnQpXG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcblxuICAgIGlmIChpc1Jlc2VydmVkQ29kZVBvaW50KHJlZmVyZW5jZWRDcCkpXG4gICAgICAgIHJldHVybiAkLlJFUExBQ0VNRU5UX0NIQVJBQ1RFUjtcblxuICAgIHJldHVybiByZWZlcmVuY2VkQ3A7XG59O1xuXG4vLyBOT1RFOiBmb3IgdGhlIGRldGFpbHMgb24gdGhpcyBhbGdvcml0aG0gc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vaW5pa3VsaW4vcGFyc2U1L3RyZWUvbWFzdGVyL3NjcmlwdHMvZ2VuZXJhdGVfbmFtZWRfZW50aXR5X2RhdGEvUkVBRE1FLm1kXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lTmFtZWRFbnRpdHkgPSBmdW5jdGlvbiAoaW5BdHRyKSB7XG4gICAgdmFyIHJlZmVyZW5jZWRDb2RlUG9pbnRzID0gbnVsbCxcbiAgICAgICAgcmVmZXJlbmNlU2l6ZSA9IDAsXG4gICAgICAgIGNwID0gbnVsbCxcbiAgICAgICAgY29uc3VtZWRDb3VudCA9IDAsXG4gICAgICAgIHNlbWljb2xvblRlcm1pbmF0ZWQgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpID4gLTE7KSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmVUcmVlW2ldLFxuICAgICAgICAgICAgaW5Ob2RlID0gY3VycmVudCA8IE1BWF9CUkFOQ0hfTUFSS0VSX1ZBTFVFLFxuICAgICAgICAgICAgbm9kZVdpdGhEYXRhID0gaW5Ob2RlICYmIGN1cnJlbnQgJiBIQVNfREFUQV9GTEFHO1xuXG4gICAgICAgIGlmIChub2RlV2l0aERhdGEpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZWRDb2RlUG9pbnRzID0gY3VycmVudCAmIERBVEFfRFVQTEVUX0ZMQUcgPyBbbmVUcmVlWysraV0sIG5lVHJlZVsrK2ldXSA6IFtuZVRyZWVbKytpXV07XG4gICAgICAgICAgICByZWZlcmVuY2VTaXplID0gY29uc3VtZWRDb3VudDtcblxuICAgICAgICAgICAgaWYgKGNwID09PSAkLlNFTUlDT0xPTikge1xuICAgICAgICAgICAgICAgIHNlbWljb2xvblRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3AgPSB0aGlzLl9jb25zdW1lKCk7XG4gICAgICAgIGNvbnN1bWVkQ291bnQrKztcblxuICAgICAgICBpZiAoY3AgPT09ICQuRU9GKVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgaWYgKGluTm9kZSlcbiAgICAgICAgICAgIGkgPSBjdXJyZW50ICYgSEFTX0JSQU5DSEVTX0ZMQUcgPyBmaW5kTmFtZWRFbnRpdHlUcmVlQnJhbmNoKGksIGNwKSA6IC0xO1xuXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGkgPSBjcCA9PT0gY3VycmVudCA/ICsraSA6IC0xO1xuICAgIH1cblxuXG4gICAgaWYgKHJlZmVyZW5jZWRDb2RlUG9pbnRzKSB7XG4gICAgICAgIGlmICghc2VtaWNvbG9uVGVybWluYXRlZCkge1xuICAgICAgICAgICAgLy9OT1RFOiB1bmNvbnN1bWUgZXhjZXNzIChlLmcuICdpdCcgaW4gJyZub3RpdCcpXG4gICAgICAgICAgICB0aGlzLl91bmNvbnN1bWVTZXZlcmFsKGNvbnN1bWVkQ291bnQgLSByZWZlcmVuY2VTaXplKTtcblxuICAgICAgICAgICAgLy9OT1RFOiBJZiB0aGUgY2hhcmFjdGVyIHJlZmVyZW5jZSBpcyBiZWluZyBjb25zdW1lZCBhcyBwYXJ0IG9mIGFuIGF0dHJpYnV0ZSBhbmQgdGhlIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICAvL2lzIGVpdGhlciBhIFUrMDAzRCBFUVVBTFMgU0lHTiBjaGFyYWN0ZXIgKD0pIG9yIGFuIGFscGhhbnVtZXJpYyBBU0NJSSBjaGFyYWN0ZXIsIHRoZW4sIGZvciBoaXN0b3JpY2FsXG4gICAgICAgICAgICAvL3JlYXNvbnMsIGFsbCB0aGUgY2hhcmFjdGVycyB0aGF0IHdlcmUgbWF0Y2hlZCBhZnRlciB0aGUgVSswMDI2IEFNUEVSU0FORCBjaGFyYWN0ZXIgKCYpIG11c3QgYmVcbiAgICAgICAgICAgIC8vdW5jb25zdW1lZCwgYW5kIG5vdGhpbmcgaXMgcmV0dXJuZWQuXG4gICAgICAgICAgICAvL0hvd2V2ZXIsIGlmIHRoaXMgbmV4dCBjaGFyYWN0ZXIgaXMgaW4gZmFjdCBhIFUrMDAzRCBFUVVBTFMgU0lHTiBjaGFyYWN0ZXIgKD0pLCB0aGVuIHRoaXMgaXMgYVxuICAgICAgICAgICAgLy9wYXJzZSBlcnJvciwgYmVjYXVzZSBzb21lIGxlZ2FjeSB1c2VyIGFnZW50cyB3aWxsIG1pc2ludGVycHJldCB0aGUgbWFya3VwIGluIHRob3NlIGNhc2VzLlxuICAgICAgICAgICAgLy8oc2VlOiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90b2tlbml6YXRpb24uaHRtbCN0b2tlbml6aW5nLWNoYXJhY3Rlci1yZWZlcmVuY2VzKVxuICAgICAgICAgICAgaWYgKGluQXR0cikge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0Q3AgPSB0aGlzLl9sb29rYWhlYWQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q3AgPT09ICQuRVFVQUxTX1NJR04gfHwgaXNBc2NpaUFscGhhTnVtZXJpYyhuZXh0Q3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VuY29uc3VtZVNldmVyYWwocmVmZXJlbmNlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWZlcmVuY2VkQ29kZVBvaW50cztcbiAgICB9XG5cbiAgICB0aGlzLl91bmNvbnN1bWVTZXZlcmFsKGNvbnN1bWVkQ291bnQpO1xuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lQ2hhcmFjdGVyUmVmZXJlbmNlID0gZnVuY3Rpb24gKHN0YXJ0Q3AsIGluQXR0cikge1xuICAgIGlmIChpc1doaXRlc3BhY2Uoc3RhcnRDcCkgfHwgc3RhcnRDcCA9PT0gJC5HUkVBVEVSX1RIQU5fU0lHTiB8fFxuICAgICAgICBzdGFydENwID09PSAkLkFNUEVSU0FORCB8fCBzdGFydENwID09PSB0aGlzLmFkZGl0aW9uYWxBbGxvd2VkQ3AgfHwgc3RhcnRDcCA9PT0gJC5FT0YpIHtcbiAgICAgICAgLy9OT1RFOiBub3QgYSBjaGFyYWN0ZXIgcmVmZXJlbmNlLiBObyBjaGFyYWN0ZXJzIGFyZSBjb25zdW1lZCwgYW5kIG5vdGhpbmcgaXMgcmV0dXJuZWQuXG4gICAgICAgIHRoaXMuX3VuY29uc3VtZSgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRDcCA9PT0gJC5OVU1CRVJfU0lHTikge1xuICAgICAgICAvL05PVEU6IHdlIGhhdmUgYSBudW1lcmljIGVudGl0eSBjYW5kaWRhdGUsIG5vdyB3ZSBzaG91bGQgZGV0ZXJtaW5lIGlmIGl0J3MgaGV4IG9yIGRlY2ltYWxcbiAgICAgICAgdmFyIGlzSGV4ID0gZmFsc2UsXG4gICAgICAgICAgICBuZXh0Q3AgPSB0aGlzLl9sb29rYWhlYWQoKTtcblxuICAgICAgICBpZiAobmV4dENwID09PSAkLkxBVElOX1NNQUxMX1ggfHwgbmV4dENwID09PSAkLkxBVElOX0NBUElUQUxfWCkge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZSgpO1xuICAgICAgICAgICAgaXNIZXggPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dENwID0gdGhpcy5fbG9va2FoZWFkKCk7XG5cbiAgICAgICAgLy9OT1RFOiBpZiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBkaWdpdCB0aGlzIGlzIGEgbnVtZXJpYyBlbnRpdHkgZm9yIHN1cmUsIHNvIHdlIGNvbnN1bWUgaXRcbiAgICAgICAgaWYgKG5leHRDcCAhPT0gJC5FT0YgJiYgaXNEaWdpdChuZXh0Q3AsIGlzSGV4KSlcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5fY29uc3VtZU51bWVyaWNFbnRpdHkoaXNIZXgpXTtcblxuICAgICAgICAvL05PVEU6IG90aGVyd2lzZSB0aGlzIGlzIGEgYm9ndXMgbnVtYmVyIGVudGl0eSBhbmQgYSBwYXJzZSBlcnJvci4gVW5jb25zdW1lIHRoZSBudW1iZXIgc2lnblxuICAgICAgICAvL2FuZCB0aGUgJ3gnLWNoYXJhY3RlciBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgdGhpcy5fdW5jb25zdW1lU2V2ZXJhbChpc0hleCA/IDIgOiAxKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fdW5jb25zdW1lKCk7XG5cbiAgICByZXR1cm4gdGhpcy5fY29uc3VtZU5hbWVkRW50aXR5KGluQXR0cik7XG59O1xuXG4vL1N0YXRlIG1hY2hpbmVcbnZhciBfID0gVG9rZW5pemVyLnByb3RvdHlwZTtcblxuLy8xMi4yLjQuMSBEYXRhIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tEQVRBX1NUQVRFXSA9IGZ1bmN0aW9uIGRhdGFTdGF0ZShjcCkge1xuICAgIHRoaXMucHJlcHJvY2Vzc29yLmRyb3BQYXJzZWRDaHVuaygpO1xuXG4gICAgaWYgKGNwID09PSAkLkFNUEVSU0FORClcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQVJBQ1RFUl9SRUZFUkVOQ0VfSU5fREFUQV9TVEFURTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkxFU1NfVEhBTl9TSUdOKVxuICAgICAgICB0aGlzLnN0YXRlID0gVEFHX09QRU5fU1RBVEU7XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5OVUxMKVxuICAgICAgICB0aGlzLl9lbWl0Q29kZVBvaW50KGNwKTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkVPRilcbiAgICAgICAgdGhpcy5fZW1pdEVPRlRva2VuKCk7XG5cbiAgICBlbHNlXG4gICAgICAgIHRoaXMuX2VtaXRDb2RlUG9pbnQoY3ApO1xufTtcblxuXG4vLzEyLjIuNC4yIENoYXJhY3RlciByZWZlcmVuY2UgaW4gZGF0YSBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bQ0hBUkFDVEVSX1JFRkVSRU5DRV9JTl9EQVRBX1NUQVRFXSA9IGZ1bmN0aW9uIGNoYXJhY3RlclJlZmVyZW5jZUluRGF0YVN0YXRlKGNwKSB7XG4gICAgdGhpcy5hZGRpdGlvbmFsQWxsb3dlZENwID0gdm9pZCAwO1xuXG4gICAgdmFyIHJlZmVyZW5jZWRDb2RlUG9pbnRzID0gdGhpcy5fY29uc3VtZUNoYXJhY3RlclJlZmVyZW5jZShjcCwgZmFsc2UpO1xuXG4gICAgaWYgKCF0aGlzLl9lbnN1cmVIaWJlcm5hdGlvbigpKSB7XG4gICAgICAgIGlmIChyZWZlcmVuY2VkQ29kZVBvaW50cylcbiAgICAgICAgICAgIHRoaXMuX2VtaXRTZXZlcmFsQ29kZVBvaW50cyhyZWZlcmVuY2VkQ29kZVBvaW50cyk7XG5cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5fZW1pdENoYXIoJyYnKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0gREFUQV9TVEFURTtcbiAgICB9XG59O1xuXG5cbi8vMTIuMi40LjMgUkNEQVRBIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tSQ0RBVEFfU1RBVEVdID0gZnVuY3Rpb24gcmNkYXRhU3RhdGUoY3ApIHtcbiAgICB0aGlzLnByZXByb2Nlc3Nvci5kcm9wUGFyc2VkQ2h1bmsoKTtcblxuICAgIGlmIChjcCA9PT0gJC5BTVBFUlNBTkQpXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDSEFSQUNURVJfUkVGRVJFTkNFX0lOX1JDREFUQV9TVEFURTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkxFU1NfVEhBTl9TSUdOKVxuICAgICAgICB0aGlzLnN0YXRlID0gUkNEQVRBX0xFU1NfVEhBTl9TSUdOX1NUQVRFO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuTlVMTClcbiAgICAgICAgdGhpcy5fZW1pdENoYXIoVU5JQ09ERS5SRVBMQUNFTUVOVF9DSEFSQUNURVIpO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuRU9GKVxuICAgICAgICB0aGlzLl9lbWl0RU9GVG9rZW4oKTtcblxuICAgIGVsc2VcbiAgICAgICAgdGhpcy5fZW1pdENvZGVQb2ludChjcCk7XG59O1xuXG5cbi8vMTIuMi40LjQgQ2hhcmFjdGVyIHJlZmVyZW5jZSBpbiBSQ0RBVEEgc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW0NIQVJBQ1RFUl9SRUZFUkVOQ0VfSU5fUkNEQVRBX1NUQVRFXSA9IGZ1bmN0aW9uIGNoYXJhY3RlclJlZmVyZW5jZUluUmNkYXRhU3RhdGUoY3ApIHtcbiAgICB0aGlzLmFkZGl0aW9uYWxBbGxvd2VkQ3AgPSB2b2lkIDA7XG5cbiAgICB2YXIgcmVmZXJlbmNlZENvZGVQb2ludHMgPSB0aGlzLl9jb25zdW1lQ2hhcmFjdGVyUmVmZXJlbmNlKGNwLCBmYWxzZSk7XG5cbiAgICBpZiAoIXRoaXMuX2Vuc3VyZUhpYmVybmF0aW9uKCkpIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZWRDb2RlUG9pbnRzKVxuICAgICAgICAgICAgdGhpcy5fZW1pdFNldmVyYWxDb2RlUG9pbnRzKHJlZmVyZW5jZWRDb2RlUG9pbnRzKTtcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLl9lbWl0Q2hhcignJicpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSBSQ0RBVEFfU1RBVEU7XG4gICAgfVxufTtcblxuXG4vLzEyLjIuNC41IFJBV1RFWFQgc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW1JBV1RFWFRfU1RBVEVdID0gZnVuY3Rpb24gcmF3dGV4dFN0YXRlKGNwKSB7XG4gICAgdGhpcy5wcmVwcm9jZXNzb3IuZHJvcFBhcnNlZENodW5rKCk7XG5cbiAgICBpZiAoY3AgPT09ICQuTEVTU19USEFOX1NJR04pXG4gICAgICAgIHRoaXMuc3RhdGUgPSBSQVdURVhUX0xFU1NfVEhBTl9TSUdOX1NUQVRFO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuTlVMTClcbiAgICAgICAgdGhpcy5fZW1pdENoYXIoVU5JQ09ERS5SRVBMQUNFTUVOVF9DSEFSQUNURVIpO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuRU9GKVxuICAgICAgICB0aGlzLl9lbWl0RU9GVG9rZW4oKTtcblxuICAgIGVsc2VcbiAgICAgICAgdGhpcy5fZW1pdENvZGVQb2ludChjcCk7XG59O1xuXG5cbi8vMTIuMi40LjYgU2NyaXB0IGRhdGEgc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW1NDUklQVF9EQVRBX1NUQVRFXSA9IGZ1bmN0aW9uIHNjcmlwdERhdGFTdGF0ZShjcCkge1xuICAgIHRoaXMucHJlcHJvY2Vzc29yLmRyb3BQYXJzZWRDaHVuaygpO1xuXG4gICAgaWYgKGNwID09PSAkLkxFU1NfVEhBTl9TSUdOKVxuICAgICAgICB0aGlzLnN0YXRlID0gU0NSSVBUX0RBVEFfTEVTU19USEFOX1NJR05fU1RBVEU7XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5OVUxMKVxuICAgICAgICB0aGlzLl9lbWl0Q2hhcihVTklDT0RFLlJFUExBQ0VNRU5UX0NIQVJBQ1RFUik7XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5FT0YpXG4gICAgICAgIHRoaXMuX2VtaXRFT0ZUb2tlbigpO1xuXG4gICAgZWxzZVxuICAgICAgICB0aGlzLl9lbWl0Q29kZVBvaW50KGNwKTtcbn07XG5cblxuLy8xMi4yLjQuNyBQTEFJTlRFWFQgc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW1BMQUlOVEVYVF9TVEFURV0gPSBmdW5jdGlvbiBwbGFpbnRleHRTdGF0ZShjcCkge1xuICAgIHRoaXMucHJlcHJvY2Vzc29yLmRyb3BQYXJzZWRDaHVuaygpO1xuXG4gICAgaWYgKGNwID09PSAkLk5VTEwpXG4gICAgICAgIHRoaXMuX2VtaXRDaGFyKFVOSUNPREUuUkVQTEFDRU1FTlRfQ0hBUkFDVEVSKTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkVPRilcbiAgICAgICAgdGhpcy5fZW1pdEVPRlRva2VuKCk7XG5cbiAgICBlbHNlXG4gICAgICAgIHRoaXMuX2VtaXRDb2RlUG9pbnQoY3ApO1xufTtcblxuXG4vLzEyLjIuNC44IFRhZyBvcGVuIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tUQUdfT1BFTl9TVEFURV0gPSBmdW5jdGlvbiB0YWdPcGVuU3RhdGUoY3ApIHtcbiAgICBpZiAoY3AgPT09ICQuRVhDTEFNQVRJT05fTUFSSylcbiAgICAgICAgdGhpcy5zdGF0ZSA9IE1BUktVUF9ERUNMQVJBVElPTl9PUEVOX1NUQVRFO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuU09MSURVUylcbiAgICAgICAgdGhpcy5zdGF0ZSA9IEVORF9UQUdfT1BFTl9TVEFURTtcblxuICAgIGVsc2UgaWYgKGlzQXNjaWlMZXR0ZXIoY3ApKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVN0YXJ0VGFnVG9rZW4oKTtcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShUQUdfTkFNRV9TVEFURSk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuUVVFU1RJT05fTUFSSylcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShCT0dVU19DT01NRU5UX1NUQVRFKTtcblxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignPCcpO1xuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKERBVEFfU1RBVEUpO1xuICAgIH1cbn07XG5cblxuLy8xMi4yLjQuOSBFbmQgdGFnIG9wZW4gc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW0VORF9UQUdfT1BFTl9TVEFURV0gPSBmdW5jdGlvbiBlbmRUYWdPcGVuU3RhdGUoY3ApIHtcbiAgICBpZiAoaXNBc2NpaUxldHRlcihjcCkpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlRW5kVGFnVG9rZW4oKTtcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShUQUdfTkFNRV9TVEFURSk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuR1JFQVRFUl9USEFOX1NJR04pXG4gICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuRU9GKSB7XG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoREFUQV9TVEFURSk7XG4gICAgICAgIHRoaXMuX2VtaXRDaGFyKCc8Jyk7XG4gICAgICAgIHRoaXMuX2VtaXRDaGFyKCcvJyk7XG4gICAgfVxuXG4gICAgZWxzZVxuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKEJPR1VTX0NPTU1FTlRfU1RBVEUpO1xufTtcblxuXG4vLzEyLjIuNC4xMCBUYWcgbmFtZSBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bVEFHX05BTUVfU1RBVEVdID0gZnVuY3Rpb24gdGFnTmFtZVN0YXRlKGNwKSB7XG4gICAgaWYgKGlzV2hpdGVzcGFjZShjcCkpXG4gICAgICAgIHRoaXMuc3RhdGUgPSBCRUZPUkVfQVRUUklCVVRFX05BTUVfU1RBVEU7XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5TT0xJRFVTKVxuICAgICAgICB0aGlzLnN0YXRlID0gU0VMRl9DTE9TSU5HX1NUQVJUX1RBR19TVEFURTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkdSRUFURVJfVEhBTl9TSUdOKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoaXNBc2NpaVVwcGVyKGNwKSlcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4udGFnTmFtZSArPSB0b0FzY2lpTG93ZXJDaGFyKGNwKTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLk5VTEwpXG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLnRhZ05hbWUgKz0gVU5JQ09ERS5SRVBMQUNFTUVOVF9DSEFSQUNURVI7XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5FT0YpXG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoREFUQV9TVEFURSk7XG5cbiAgICBlbHNlXG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLnRhZ05hbWUgKz0gdG9DaGFyKGNwKTtcbn07XG5cblxuLy8xMi4yLjQuMTEgUkNEQVRBIGxlc3MtdGhhbiBzaWduIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tSQ0RBVEFfTEVTU19USEFOX1NJR05fU1RBVEVdID0gZnVuY3Rpb24gcmNkYXRhTGVzc1RoYW5TaWduU3RhdGUoY3ApIHtcbiAgICBpZiAoY3AgPT09ICQuU09MSURVUykge1xuICAgICAgICB0aGlzLnRlbXBCdWZmID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSBSQ0RBVEFfRU5EX1RBR19PUEVOX1NUQVRFO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignPCcpO1xuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKFJDREFUQV9TVEFURSk7XG4gICAgfVxufTtcblxuXG4vLzEyLjIuNC4xMiBSQ0RBVEEgZW5kIHRhZyBvcGVuIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tSQ0RBVEFfRU5EX1RBR19PUEVOX1NUQVRFXSA9IGZ1bmN0aW9uIHJjZGF0YUVuZFRhZ09wZW5TdGF0ZShjcCkge1xuICAgIGlmIChpc0FzY2lpTGV0dGVyKGNwKSkge1xuICAgICAgICB0aGlzLl9jcmVhdGVFbmRUYWdUb2tlbigpO1xuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKFJDREFUQV9FTkRfVEFHX05BTUVfU1RBVEUpO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignPCcpO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignLycpO1xuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKFJDREFUQV9TVEFURSk7XG4gICAgfVxufTtcblxuXG4vLzEyLjIuNC4xMyBSQ0RBVEEgZW5kIHRhZyBuYW1lIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tSQ0RBVEFfRU5EX1RBR19OQU1FX1NUQVRFXSA9IGZ1bmN0aW9uIHJjZGF0YUVuZFRhZ05hbWVTdGF0ZShjcCkge1xuICAgIGlmIChpc0FzY2lpVXBwZXIoY3ApKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLnRhZ05hbWUgKz0gdG9Bc2NpaUxvd2VyQ2hhcihjcCk7XG4gICAgICAgIHRoaXMudGVtcEJ1ZmYucHVzaChjcCk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoaXNBc2NpaUxvd2VyKGNwKSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi50YWdOYW1lICs9IHRvQ2hhcihjcCk7XG4gICAgICAgIHRoaXMudGVtcEJ1ZmYucHVzaChjcCk7XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0FwcHJvcHJpYXRlRW5kVGFnVG9rZW4oKSkge1xuICAgICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjcCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQkVGT1JFX0FUVFJJQlVURV9OQU1FX1NUQVRFO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNwID09PSAkLlNPTElEVVMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU0VMRl9DTE9TSU5HX1NUQVJUX1RBR19TVEFURTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjcCA9PT0gJC5HUkVBVEVSX1RIQU5fU0lHTikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbWl0Q2hhcignPCcpO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignLycpO1xuICAgICAgICB0aGlzLl9lbWl0U2V2ZXJhbENvZGVQb2ludHModGhpcy50ZW1wQnVmZik7XG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoUkNEQVRBX1NUQVRFKTtcbiAgICB9XG59O1xuXG5cbi8vMTIuMi40LjE0IFJBV1RFWFQgbGVzcy10aGFuIHNpZ24gc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW1JBV1RFWFRfTEVTU19USEFOX1NJR05fU1RBVEVdID0gZnVuY3Rpb24gcmF3dGV4dExlc3NUaGFuU2lnblN0YXRlKGNwKSB7XG4gICAgaWYgKGNwID09PSAkLlNPTElEVVMpIHtcbiAgICAgICAgdGhpcy50ZW1wQnVmZiA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlID0gUkFXVEVYVF9FTkRfVEFHX09QRU5fU1RBVEU7XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2VtaXRDaGFyKCc8Jyk7XG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoUkFXVEVYVF9TVEFURSk7XG4gICAgfVxufTtcblxuXG4vLzEyLjIuNC4xNSBSQVdURVhUIGVuZCB0YWcgb3BlbiBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bUkFXVEVYVF9FTkRfVEFHX09QRU5fU1RBVEVdID0gZnVuY3Rpb24gcmF3dGV4dEVuZFRhZ09wZW5TdGF0ZShjcCkge1xuICAgIGlmIChpc0FzY2lpTGV0dGVyKGNwKSkge1xuICAgICAgICB0aGlzLl9jcmVhdGVFbmRUYWdUb2tlbigpO1xuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKFJBV1RFWFRfRU5EX1RBR19OQU1FX1NUQVRFKTtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fZW1pdENoYXIoJzwnKTtcbiAgICAgICAgdGhpcy5fZW1pdENoYXIoJy8nKTtcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShSQVdURVhUX1NUQVRFKTtcbiAgICB9XG59O1xuXG5cbi8vMTIuMi40LjE2IFJBV1RFWFQgZW5kIHRhZyBuYW1lIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tSQVdURVhUX0VORF9UQUdfTkFNRV9TVEFURV0gPSBmdW5jdGlvbiByYXd0ZXh0RW5kVGFnTmFtZVN0YXRlKGNwKSB7XG4gICAgaWYgKGlzQXNjaWlVcHBlcihjcCkpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4udGFnTmFtZSArPSB0b0FzY2lpTG93ZXJDaGFyKGNwKTtcbiAgICAgICAgdGhpcy50ZW1wQnVmZi5wdXNoKGNwKTtcbiAgICB9XG5cbiAgICBlbHNlIGlmIChpc0FzY2lpTG93ZXIoY3ApKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLnRhZ05hbWUgKz0gdG9DaGFyKGNwKTtcbiAgICAgICAgdGhpcy50ZW1wQnVmZi5wdXNoKGNwKTtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQXBwcm9wcmlhdGVFbmRUYWdUb2tlbigpKSB7XG4gICAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGNwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBCRUZPUkVfQVRUUklCVVRFX05BTUVfU1RBVEU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3AgPT09ICQuU09MSURVUykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTRUxGX0NMT1NJTkdfU1RBUlRfVEFHX1NUQVRFO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNwID09PSAkLkdSRUFURVJfVEhBTl9TSUdOKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdEN1cnJlbnRUb2tlbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VtaXRDaGFyKCc8Jyk7XG4gICAgICAgIHRoaXMuX2VtaXRDaGFyKCcvJyk7XG4gICAgICAgIHRoaXMuX2VtaXRTZXZlcmFsQ29kZVBvaW50cyh0aGlzLnRlbXBCdWZmKTtcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShSQVdURVhUX1NUQVRFKTtcbiAgICB9XG59O1xuXG5cbi8vMTIuMi40LjE3IFNjcmlwdCBkYXRhIGxlc3MtdGhhbiBzaWduIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tTQ1JJUFRfREFUQV9MRVNTX1RIQU5fU0lHTl9TVEFURV0gPSBmdW5jdGlvbiBzY3JpcHREYXRhTGVzc1RoYW5TaWduU3RhdGUoY3ApIHtcbiAgICBpZiAoY3AgPT09ICQuU09MSURVUykge1xuICAgICAgICB0aGlzLnRlbXBCdWZmID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTQ1JJUFRfREFUQV9FTkRfVEFHX09QRU5fU1RBVEU7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuRVhDTEFNQVRJT05fTUFSSykge1xuICAgICAgICB0aGlzLnN0YXRlID0gU0NSSVBUX0RBVEFfRVNDQVBFX1NUQVJUX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignPCcpO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignIScpO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignPCcpO1xuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKFNDUklQVF9EQVRBX1NUQVRFKTtcbiAgICB9XG59O1xuXG5cbi8vMTIuMi40LjE4IFNjcmlwdCBkYXRhIGVuZCB0YWcgb3BlbiBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bU0NSSVBUX0RBVEFfRU5EX1RBR19PUEVOX1NUQVRFXSA9IGZ1bmN0aW9uIHNjcmlwdERhdGFFbmRUYWdPcGVuU3RhdGUoY3ApIHtcbiAgICBpZiAoaXNBc2NpaUxldHRlcihjcCkpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlRW5kVGFnVG9rZW4oKTtcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShTQ1JJUFRfREFUQV9FTkRfVEFHX05BTUVfU1RBVEUpO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignPCcpO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignLycpO1xuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKFNDUklQVF9EQVRBX1NUQVRFKTtcbiAgICB9XG59O1xuXG5cbi8vMTIuMi40LjE5IFNjcmlwdCBkYXRhIGVuZCB0YWcgbmFtZSBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bU0NSSVBUX0RBVEFfRU5EX1RBR19OQU1FX1NUQVRFXSA9IGZ1bmN0aW9uIHNjcmlwdERhdGFFbmRUYWdOYW1lU3RhdGUoY3ApIHtcbiAgICBpZiAoaXNBc2NpaVVwcGVyKGNwKSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi50YWdOYW1lICs9IHRvQXNjaWlMb3dlckNoYXIoY3ApO1xuICAgICAgICB0aGlzLnRlbXBCdWZmLnB1c2goY3ApO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGlzQXNjaWlMb3dlcihjcCkpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4udGFnTmFtZSArPSB0b0NoYXIoY3ApO1xuICAgICAgICB0aGlzLnRlbXBCdWZmLnB1c2goY3ApO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5faXNBcHByb3ByaWF0ZUVuZFRhZ1Rva2VuKCkpIHtcbiAgICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoY3ApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IEJFRk9SRV9BVFRSSUJVVEVfTkFNRV9TVEFURTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKGNwID09PSAkLlNPTElEVVMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU0VMRl9DTE9TSU5HX1NUQVJUX1RBR19TVEFURTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKGNwID09PSAkLkdSRUFURVJfVEhBTl9TSUdOKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdEN1cnJlbnRUb2tlbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VtaXRDaGFyKCc8Jyk7XG4gICAgICAgIHRoaXMuX2VtaXRDaGFyKCcvJyk7XG4gICAgICAgIHRoaXMuX2VtaXRTZXZlcmFsQ29kZVBvaW50cyh0aGlzLnRlbXBCdWZmKTtcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShTQ1JJUFRfREFUQV9TVEFURSk7XG4gICAgfVxufTtcblxuXG4vLzEyLjIuNC4yMCBTY3JpcHQgZGF0YSBlc2NhcGUgc3RhcnQgc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW1NDUklQVF9EQVRBX0VTQ0FQRV9TVEFSVF9TVEFURV0gPSBmdW5jdGlvbiBzY3JpcHREYXRhRXNjYXBlU3RhcnRTdGF0ZShjcCkge1xuICAgIGlmIChjcCA9PT0gJC5IWVBIRU5fTUlOVVMpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNDUklQVF9EQVRBX0VTQ0FQRV9TVEFSVF9EQVNIX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignLScpO1xuICAgIH1cblxuICAgIGVsc2VcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShTQ1JJUFRfREFUQV9TVEFURSk7XG59O1xuXG5cbi8vMTIuMi40LjIxIFNjcmlwdCBkYXRhIGVzY2FwZSBzdGFydCBkYXNoIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tTQ1JJUFRfREFUQV9FU0NBUEVfU1RBUlRfREFTSF9TVEFURV0gPSBmdW5jdGlvbiBzY3JpcHREYXRhRXNjYXBlU3RhcnREYXNoU3RhdGUoY3ApIHtcbiAgICBpZiAoY3AgPT09ICQuSFlQSEVOX01JTlVTKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTQ1JJUFRfREFUQV9FU0NBUEVEX0RBU0hfREFTSF9TVEFURTtcbiAgICAgICAgdGhpcy5fZW1pdENoYXIoJy0nKTtcbiAgICB9XG5cbiAgICBlbHNlXG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoU0NSSVBUX0RBVEFfU1RBVEUpO1xufTtcblxuXG4vLzEyLjIuNC4yMiBTY3JpcHQgZGF0YSBlc2NhcGVkIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tTQ1JJUFRfREFUQV9FU0NBUEVEX1NUQVRFXSA9IGZ1bmN0aW9uIHNjcmlwdERhdGFFc2NhcGVkU3RhdGUoY3ApIHtcbiAgICBpZiAoY3AgPT09ICQuSFlQSEVOX01JTlVTKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTQ1JJUFRfREFUQV9FU0NBUEVEX0RBU0hfU1RBVEU7XG4gICAgICAgIHRoaXMuX2VtaXRDaGFyKCctJyk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuTEVTU19USEFOX1NJR04pXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTQ1JJUFRfREFUQV9FU0NBUEVEX0xFU1NfVEhBTl9TSUdOX1NUQVRFO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuTlVMTClcbiAgICAgICAgdGhpcy5fZW1pdENoYXIoVU5JQ09ERS5SRVBMQUNFTUVOVF9DSEFSQUNURVIpO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuRU9GKVxuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKERBVEFfU1RBVEUpO1xuXG4gICAgZWxzZVxuICAgICAgICB0aGlzLl9lbWl0Q29kZVBvaW50KGNwKTtcbn07XG5cblxuLy8xMi4yLjQuMjMgU2NyaXB0IGRhdGEgZXNjYXBlZCBkYXNoIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tTQ1JJUFRfREFUQV9FU0NBUEVEX0RBU0hfU1RBVEVdID0gZnVuY3Rpb24gc2NyaXB0RGF0YUVzY2FwZWREYXNoU3RhdGUoY3ApIHtcbiAgICBpZiAoY3AgPT09ICQuSFlQSEVOX01JTlVTKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTQ1JJUFRfREFUQV9FU0NBUEVEX0RBU0hfREFTSF9TVEFURTtcbiAgICAgICAgdGhpcy5fZW1pdENoYXIoJy0nKTtcbiAgICB9XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5MRVNTX1RIQU5fU0lHTilcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNDUklQVF9EQVRBX0VTQ0FQRURfTEVTU19USEFOX1NJR05fU1RBVEU7XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5OVUxMKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTQ1JJUFRfREFUQV9FU0NBUEVEX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcihVTklDT0RFLlJFUExBQ0VNRU5UX0NIQVJBQ1RFUik7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuRU9GKVxuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKERBVEFfU1RBVEUpO1xuXG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTQ1JJUFRfREFUQV9FU0NBUEVEX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q29kZVBvaW50KGNwKTtcbiAgICB9XG59O1xuXG5cbi8vMTIuMi40LjI0IFNjcmlwdCBkYXRhIGVzY2FwZWQgZGFzaCBkYXNoIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tTQ1JJUFRfREFUQV9FU0NBUEVEX0RBU0hfREFTSF9TVEFURV0gPSBmdW5jdGlvbiBzY3JpcHREYXRhRXNjYXBlZERhc2hEYXNoU3RhdGUoY3ApIHtcbiAgICBpZiAoY3AgPT09ICQuSFlQSEVOX01JTlVTKVxuICAgICAgICB0aGlzLl9lbWl0Q2hhcignLScpO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuTEVTU19USEFOX1NJR04pXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTQ1JJUFRfREFUQV9FU0NBUEVEX0xFU1NfVEhBTl9TSUdOX1NUQVRFO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuR1JFQVRFUl9USEFOX1NJR04pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNDUklQVF9EQVRBX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignPicpO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGNwID09PSAkLk5VTEwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNDUklQVF9EQVRBX0VTQ0FQRURfU1RBVEU7XG4gICAgICAgIHRoaXMuX2VtaXRDaGFyKFVOSUNPREUuUkVQTEFDRU1FTlRfQ0hBUkFDVEVSKTtcbiAgICB9XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5FT0YpXG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoREFUQV9TVEFURSk7XG5cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNDUklQVF9EQVRBX0VTQ0FQRURfU1RBVEU7XG4gICAgICAgIHRoaXMuX2VtaXRDb2RlUG9pbnQoY3ApO1xuICAgIH1cbn07XG5cblxuLy8xMi4yLjQuMjUgU2NyaXB0IGRhdGEgZXNjYXBlZCBsZXNzLXRoYW4gc2lnbiBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bU0NSSVBUX0RBVEFfRVNDQVBFRF9MRVNTX1RIQU5fU0lHTl9TVEFURV0gPSBmdW5jdGlvbiBzY3JpcHREYXRhRXNjYXBlZExlc3NUaGFuU2lnblN0YXRlKGNwKSB7XG4gICAgaWYgKGNwID09PSAkLlNPTElEVVMpIHtcbiAgICAgICAgdGhpcy50ZW1wQnVmZiA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlID0gU0NSSVBUX0RBVEFfRVNDQVBFRF9FTkRfVEFHX09QRU5fU1RBVEU7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoaXNBc2NpaUxldHRlcihjcCkpIHtcbiAgICAgICAgdGhpcy50ZW1wQnVmZiA9IFtdO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignPCcpO1xuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKFNDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVfU1RBUlRfU1RBVEUpO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignPCcpO1xuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKFNDUklQVF9EQVRBX0VTQ0FQRURfU1RBVEUpO1xuICAgIH1cbn07XG5cblxuLy8xMi4yLjQuMjYgU2NyaXB0IGRhdGEgZXNjYXBlZCBlbmQgdGFnIG9wZW4gc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW1NDUklQVF9EQVRBX0VTQ0FQRURfRU5EX1RBR19PUEVOX1NUQVRFXSA9IGZ1bmN0aW9uIHNjcmlwdERhdGFFc2NhcGVkRW5kVGFnT3BlblN0YXRlKGNwKSB7XG4gICAgaWYgKGlzQXNjaWlMZXR0ZXIoY3ApKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUVuZFRhZ1Rva2VuKCk7XG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoU0NSSVBUX0RBVEFfRVNDQVBFRF9FTkRfVEFHX05BTUVfU1RBVEUpO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignPCcpO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignLycpO1xuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKFNDUklQVF9EQVRBX0VTQ0FQRURfU1RBVEUpO1xuICAgIH1cbn07XG5cblxuLy8xMi4yLjQuMjcgU2NyaXB0IGRhdGEgZXNjYXBlZCBlbmQgdGFnIG5hbWUgc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW1NDUklQVF9EQVRBX0VTQ0FQRURfRU5EX1RBR19OQU1FX1NUQVRFXSA9IGZ1bmN0aW9uIHNjcmlwdERhdGFFc2NhcGVkRW5kVGFnTmFtZVN0YXRlKGNwKSB7XG4gICAgaWYgKGlzQXNjaWlVcHBlcihjcCkpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4udGFnTmFtZSArPSB0b0FzY2lpTG93ZXJDaGFyKGNwKTtcbiAgICAgICAgdGhpcy50ZW1wQnVmZi5wdXNoKGNwKTtcbiAgICB9XG5cbiAgICBlbHNlIGlmIChpc0FzY2lpTG93ZXIoY3ApKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLnRhZ05hbWUgKz0gdG9DaGFyKGNwKTtcbiAgICAgICAgdGhpcy50ZW1wQnVmZi5wdXNoKGNwKTtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQXBwcm9wcmlhdGVFbmRUYWdUb2tlbigpKSB7XG4gICAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGNwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBCRUZPUkVfQVRUUklCVVRFX05BTUVfU1RBVEU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3AgPT09ICQuU09MSURVUykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTRUxGX0NMT1NJTkdfU1RBUlRfVEFHX1NUQVRFO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNwID09PSAkLkdSRUFURVJfVEhBTl9TSUdOKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdEN1cnJlbnRUb2tlbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VtaXRDaGFyKCc8Jyk7XG4gICAgICAgIHRoaXMuX2VtaXRDaGFyKCcvJyk7XG4gICAgICAgIHRoaXMuX2VtaXRTZXZlcmFsQ29kZVBvaW50cyh0aGlzLnRlbXBCdWZmKTtcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShTQ1JJUFRfREFUQV9FU0NBUEVEX1NUQVRFKTtcbiAgICB9XG59O1xuXG5cbi8vMTIuMi40LjI4IFNjcmlwdCBkYXRhIGRvdWJsZSBlc2NhcGUgc3RhcnQgc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW1NDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVfU1RBUlRfU1RBVEVdID0gZnVuY3Rpb24gc2NyaXB0RGF0YURvdWJsZUVzY2FwZVN0YXJ0U3RhdGUoY3ApIHtcbiAgICBpZiAoaXNXaGl0ZXNwYWNlKGNwKSB8fCBjcCA9PT0gJC5TT0xJRFVTIHx8IGNwID09PSAkLkdSRUFURVJfVEhBTl9TSUdOKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmlzVGVtcEJ1ZmZlckVxdWFsVG9TY3JpcHRTdHJpbmcoKSA/IFNDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX1NUQVRFIDogU0NSSVBUX0RBVEFfRVNDQVBFRF9TVEFURTtcbiAgICAgICAgdGhpcy5fZW1pdENvZGVQb2ludChjcCk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoaXNBc2NpaVVwcGVyKGNwKSkge1xuICAgICAgICB0aGlzLnRlbXBCdWZmLnB1c2godG9Bc2NpaUxvd2VyQ29kZVBvaW50KGNwKSk7XG4gICAgICAgIHRoaXMuX2VtaXRDb2RlUG9pbnQoY3ApO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGlzQXNjaWlMb3dlcihjcCkpIHtcbiAgICAgICAgdGhpcy50ZW1wQnVmZi5wdXNoKGNwKTtcbiAgICAgICAgdGhpcy5fZW1pdENvZGVQb2ludChjcCk7XG4gICAgfVxuXG4gICAgZWxzZVxuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKFNDUklQVF9EQVRBX0VTQ0FQRURfU1RBVEUpO1xufTtcblxuXG4vLzEyLjIuNC4yOSBTY3JpcHQgZGF0YSBkb3VibGUgZXNjYXBlZCBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bU0NSSVBUX0RBVEFfRE9VQkxFX0VTQ0FQRURfU1RBVEVdID0gZnVuY3Rpb24gc2NyaXB0RGF0YURvdWJsZUVzY2FwZWRTdGF0ZShjcCkge1xuICAgIGlmIChjcCA9PT0gJC5IWVBIRU5fTUlOVVMpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX0RBU0hfU1RBVEU7XG4gICAgICAgIHRoaXMuX2VtaXRDaGFyKCctJyk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuTEVTU19USEFOX1NJR04pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX0xFU1NfVEhBTl9TSUdOX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignPCcpO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGNwID09PSAkLk5VTEwpXG4gICAgICAgIHRoaXMuX2VtaXRDaGFyKFVOSUNPREUuUkVQTEFDRU1FTlRfQ0hBUkFDVEVSKTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkVPRilcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShEQVRBX1NUQVRFKTtcblxuICAgIGVsc2VcbiAgICAgICAgdGhpcy5fZW1pdENvZGVQb2ludChjcCk7XG59O1xuXG5cbi8vMTIuMi40LjMwIFNjcmlwdCBkYXRhIGRvdWJsZSBlc2NhcGVkIGRhc2ggc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW1NDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX0RBU0hfU1RBVEVdID0gZnVuY3Rpb24gc2NyaXB0RGF0YURvdWJsZUVzY2FwZWREYXNoU3RhdGUoY3ApIHtcbiAgICBpZiAoY3AgPT09ICQuSFlQSEVOX01JTlVTKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTQ1JJUFRfREFUQV9ET1VCTEVfRVNDQVBFRF9EQVNIX0RBU0hfU1RBVEU7XG4gICAgICAgIHRoaXMuX2VtaXRDaGFyKCctJyk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuTEVTU19USEFOX1NJR04pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX0xFU1NfVEhBTl9TSUdOX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignPCcpO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGNwID09PSAkLk5VTEwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcihVTklDT0RFLlJFUExBQ0VNRU5UX0NIQVJBQ1RFUik7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuRU9GKVxuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKERBVEFfU1RBVEUpO1xuXG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTQ1JJUFRfREFUQV9ET1VCTEVfRVNDQVBFRF9TVEFURTtcbiAgICAgICAgdGhpcy5fZW1pdENvZGVQb2ludChjcCk7XG4gICAgfVxufTtcblxuXG4vLzEyLjIuNC4zMSBTY3JpcHQgZGF0YSBkb3VibGUgZXNjYXBlZCBkYXNoIGRhc2ggc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW1NDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX0RBU0hfREFTSF9TVEFURV0gPSBmdW5jdGlvbiBzY3JpcHREYXRhRG91YmxlRXNjYXBlZERhc2hEYXNoU3RhdGUoY3ApIHtcbiAgICBpZiAoY3AgPT09ICQuSFlQSEVOX01JTlVTKVxuICAgICAgICB0aGlzLl9lbWl0Q2hhcignLScpO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuTEVTU19USEFOX1NJR04pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX0xFU1NfVEhBTl9TSUdOX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhcignPCcpO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkdSRUFURVJfVEhBTl9TSUdOKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTQ1JJUFRfREFUQV9TVEFURTtcbiAgICAgICAgdGhpcy5fZW1pdENoYXIoJz4nKTtcbiAgICB9XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5OVUxMKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTQ1JJUFRfREFUQV9ET1VCTEVfRVNDQVBFRF9TVEFURTtcbiAgICAgICAgdGhpcy5fZW1pdENoYXIoVU5JQ09ERS5SRVBMQUNFTUVOVF9DSEFSQUNURVIpO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkVPRilcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShEQVRBX1NUQVRFKTtcblxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gU0NSSVBUX0RBVEFfRE9VQkxFX0VTQ0FQRURfU1RBVEU7XG4gICAgICAgIHRoaXMuX2VtaXRDb2RlUG9pbnQoY3ApO1xuICAgIH1cbn07XG5cblxuLy8xMi4yLjQuMzIgU2NyaXB0IGRhdGEgZG91YmxlIGVzY2FwZWQgbGVzcy10aGFuIHNpZ24gc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW1NDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX0xFU1NfVEhBTl9TSUdOX1NUQVRFXSA9IGZ1bmN0aW9uIHNjcmlwdERhdGFEb3VibGVFc2NhcGVkTGVzc1RoYW5TaWduU3RhdGUoY3ApIHtcbiAgICBpZiAoY3AgPT09ICQuU09MSURVUykge1xuICAgICAgICB0aGlzLnRlbXBCdWZmID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTQ1JJUFRfREFUQV9ET1VCTEVfRVNDQVBFX0VORF9TVEFURTtcbiAgICAgICAgdGhpcy5fZW1pdENoYXIoJy8nKTtcbiAgICB9XG5cbiAgICBlbHNlXG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoU0NSSVBUX0RBVEFfRE9VQkxFX0VTQ0FQRURfU1RBVEUpO1xufTtcblxuXG4vLzEyLjIuNC4zMyBTY3JpcHQgZGF0YSBkb3VibGUgZXNjYXBlIGVuZCBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bU0NSSVBUX0RBVEFfRE9VQkxFX0VTQ0FQRV9FTkRfU1RBVEVdID0gZnVuY3Rpb24gc2NyaXB0RGF0YURvdWJsZUVzY2FwZUVuZFN0YXRlKGNwKSB7XG4gICAgaWYgKGlzV2hpdGVzcGFjZShjcCkgfHwgY3AgPT09ICQuU09MSURVUyB8fCBjcCA9PT0gJC5HUkVBVEVSX1RIQU5fU0lHTikge1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5pc1RlbXBCdWZmZXJFcXVhbFRvU2NyaXB0U3RyaW5nKCkgPyBTQ1JJUFRfREFUQV9FU0NBUEVEX1NUQVRFIDogU0NSSVBUX0RBVEFfRE9VQkxFX0VTQ0FQRURfU1RBVEU7XG5cbiAgICAgICAgdGhpcy5fZW1pdENvZGVQb2ludChjcCk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoaXNBc2NpaVVwcGVyKGNwKSkge1xuICAgICAgICB0aGlzLnRlbXBCdWZmLnB1c2godG9Bc2NpaUxvd2VyQ29kZVBvaW50KGNwKSk7XG4gICAgICAgIHRoaXMuX2VtaXRDb2RlUG9pbnQoY3ApO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGlzQXNjaWlMb3dlcihjcCkpIHtcbiAgICAgICAgdGhpcy50ZW1wQnVmZi5wdXNoKGNwKTtcbiAgICAgICAgdGhpcy5fZW1pdENvZGVQb2ludChjcCk7XG4gICAgfVxuXG4gICAgZWxzZVxuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKFNDUklQVF9EQVRBX0RPVUJMRV9FU0NBUEVEX1NUQVRFKTtcbn07XG5cblxuLy8xMi4yLjQuMzQgQmVmb3JlIGF0dHJpYnV0ZSBuYW1lIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tCRUZPUkVfQVRUUklCVVRFX05BTUVfU1RBVEVdID0gZnVuY3Rpb24gYmVmb3JlQXR0cmlidXRlTmFtZVN0YXRlKGNwKSB7XG4gICAgaWYgKGlzV2hpdGVzcGFjZShjcCkpXG4gICAgICAgIHJldHVybjtcblxuICAgIGlmIChjcCA9PT0gJC5TT0xJRFVTIHx8IGNwID09PSAkLkdSRUFURVJfVEhBTl9TSUdOIHx8IGNwID09PSAkLkVPRilcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShBRlRFUl9BVFRSSUJVVEVfTkFNRV9TVEFURSk7XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5FUVVBTFNfU0lHTikge1xuICAgICAgICB0aGlzLl9jcmVhdGVBdHRyKCc9Jyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBBVFRSSUJVVEVfTkFNRV9TVEFURTtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlQXR0cignJyk7XG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoQVRUUklCVVRFX05BTUVfU1RBVEUpO1xuICAgIH1cbn07XG5cblxuLy8xMi4yLjQuMzUgQXR0cmlidXRlIG5hbWUgc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW0FUVFJJQlVURV9OQU1FX1NUQVRFXSA9IGZ1bmN0aW9uIGF0dHJpYnV0ZU5hbWVTdGF0ZShjcCkge1xuICAgIGlmIChpc1doaXRlc3BhY2UoY3ApIHx8IGNwID09PSAkLlNPTElEVVMgfHwgY3AgPT09ICQuR1JFQVRFUl9USEFOX1NJR04gfHwgY3AgPT09ICQuRU9GKSB7XG4gICAgICAgIHRoaXMuX2xlYXZlQXR0ck5hbWUoQUZURVJfQVRUUklCVVRFX05BTUVfU1RBVEUpO1xuICAgICAgICB0aGlzLl91bmNvbnN1bWUoKTtcbiAgICB9XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5FUVVBTFNfU0lHTilcbiAgICAgICAgdGhpcy5fbGVhdmVBdHRyTmFtZShCRUZPUkVfQVRUUklCVVRFX1ZBTFVFX1NUQVRFKTtcblxuICAgIGVsc2UgaWYgKGlzQXNjaWlVcHBlcihjcCkpXG4gICAgICAgIHRoaXMuY3VycmVudEF0dHIubmFtZSArPSB0b0FzY2lpTG93ZXJDaGFyKGNwKTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLlFVT1RBVElPTl9NQVJLIHx8IGNwID09PSAkLkFQT1NUUk9QSEUgfHwgY3AgPT09ICQuTEVTU19USEFOX1NJR04pXG4gICAgICAgIHRoaXMuY3VycmVudEF0dHIubmFtZSArPSB0b0NoYXIoY3ApO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuTlVMTClcbiAgICAgICAgdGhpcy5jdXJyZW50QXR0ci5uYW1lICs9IFVOSUNPREUuUkVQTEFDRU1FTlRfQ0hBUkFDVEVSO1xuXG4gICAgZWxzZVxuICAgICAgICB0aGlzLmN1cnJlbnRBdHRyLm5hbWUgKz0gdG9DaGFyKGNwKTtcbn07XG5cblxuLy8xMi4yLjQuMzYgQWZ0ZXIgYXR0cmlidXRlIG5hbWUgc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW0FGVEVSX0FUVFJJQlVURV9OQU1FX1NUQVRFXSA9IGZ1bmN0aW9uIGFmdGVyQXR0cmlidXRlTmFtZVN0YXRlKGNwKSB7XG4gICAgaWYgKGlzV2hpdGVzcGFjZShjcCkpXG4gICAgICAgIHJldHVybjtcblxuICAgIGlmIChjcCA9PT0gJC5TT0xJRFVTKVxuICAgICAgICB0aGlzLnN0YXRlID0gU0VMRl9DTE9TSU5HX1NUQVJUX1RBR19TVEFURTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkVRVUFMU19TSUdOKVxuICAgICAgICB0aGlzLnN0YXRlID0gQkVGT1JFX0FUVFJJQlVURV9WQUxVRV9TVEFURTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkdSRUFURVJfVEhBTl9TSUdOKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuRU9GKVxuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKERBVEFfU1RBVEUpO1xuXG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUF0dHIoJycpO1xuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKEFUVFJJQlVURV9OQU1FX1NUQVRFKTtcbiAgICB9XG59O1xuXG5cbi8vMTIuMi40LjM3IEJlZm9yZSBhdHRyaWJ1dGUgdmFsdWUgc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW0JFRk9SRV9BVFRSSUJVVEVfVkFMVUVfU1RBVEVdID0gZnVuY3Rpb24gYmVmb3JlQXR0cmlidXRlVmFsdWVTdGF0ZShjcCkge1xuICAgIGlmIChpc1doaXRlc3BhY2UoY3ApKVxuICAgICAgICByZXR1cm47XG5cbiAgICBpZiAoY3AgPT09ICQuUVVPVEFUSU9OX01BUkspXG4gICAgICAgIHRoaXMuc3RhdGUgPSBBVFRSSUJVVEVfVkFMVUVfRE9VQkxFX1FVT1RFRF9TVEFURTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkFQT1NUUk9QSEUpXG4gICAgICAgIHRoaXMuc3RhdGUgPSBBVFRSSUJVVEVfVkFMVUVfU0lOR0xFX1FVT1RFRF9TVEFURTtcblxuICAgIGVsc2VcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShBVFRSSUJVVEVfVkFMVUVfVU5RVU9URURfU1RBVEUpO1xufTtcblxuXG4vLzEyLjIuNC4zOCBBdHRyaWJ1dGUgdmFsdWUgKGRvdWJsZS1xdW90ZWQpIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tBVFRSSUJVVEVfVkFMVUVfRE9VQkxFX1FVT1RFRF9TVEFURV0gPSBmdW5jdGlvbiBhdHRyaWJ1dGVWYWx1ZURvdWJsZVF1b3RlZFN0YXRlKGNwKSB7XG4gICAgaWYgKGNwID09PSAkLlFVT1RBVElPTl9NQVJLKVxuICAgICAgICB0aGlzLnN0YXRlID0gQUZURVJfQVRUUklCVVRFX1ZBTFVFX1FVT1RFRF9TVEFURTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkFNUEVSU0FORCkge1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxBbGxvd2VkQ3AgPSAkLlFVT1RBVElPTl9NQVJLO1xuICAgICAgICB0aGlzLnJldHVyblN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQVJBQ1RFUl9SRUZFUkVOQ0VfSU5fQVRUUklCVVRFX1ZBTFVFX1NUQVRFO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGNwID09PSAkLk5VTEwpXG4gICAgICAgIHRoaXMuY3VycmVudEF0dHIudmFsdWUgKz0gVU5JQ09ERS5SRVBMQUNFTUVOVF9DSEFSQUNURVI7XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5FT0YpXG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoREFUQV9TVEFURSk7XG5cbiAgICBlbHNlXG4gICAgICAgIHRoaXMuY3VycmVudEF0dHIudmFsdWUgKz0gdG9DaGFyKGNwKTtcbn07XG5cblxuLy8xMi4yLjQuMzkgQXR0cmlidXRlIHZhbHVlIChzaW5nbGUtcXVvdGVkKSBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bQVRUUklCVVRFX1ZBTFVFX1NJTkdMRV9RVU9URURfU1RBVEVdID0gZnVuY3Rpb24gYXR0cmlidXRlVmFsdWVTaW5nbGVRdW90ZWRTdGF0ZShjcCkge1xuICAgIGlmIChjcCA9PT0gJC5BUE9TVFJPUEhFKVxuICAgICAgICB0aGlzLnN0YXRlID0gQUZURVJfQVRUUklCVVRFX1ZBTFVFX1FVT1RFRF9TVEFURTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkFNUEVSU0FORCkge1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxBbGxvd2VkQ3AgPSAkLkFQT1NUUk9QSEU7XG4gICAgICAgIHRoaXMucmV0dXJuU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBUkFDVEVSX1JFRkVSRU5DRV9JTl9BVFRSSUJVVEVfVkFMVUVfU1RBVEU7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuTlVMTClcbiAgICAgICAgdGhpcy5jdXJyZW50QXR0ci52YWx1ZSArPSBVTklDT0RFLlJFUExBQ0VNRU5UX0NIQVJBQ1RFUjtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkVPRilcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShEQVRBX1NUQVRFKTtcblxuICAgIGVsc2VcbiAgICAgICAgdGhpcy5jdXJyZW50QXR0ci52YWx1ZSArPSB0b0NoYXIoY3ApO1xufTtcblxuXG4vLzEyLjIuNC40MCBBdHRyaWJ1dGUgdmFsdWUgKHVucXVvdGVkKSBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bQVRUUklCVVRFX1ZBTFVFX1VOUVVPVEVEX1NUQVRFXSA9IGZ1bmN0aW9uIGF0dHJpYnV0ZVZhbHVlVW5xdW90ZWRTdGF0ZShjcCkge1xuICAgIGlmIChpc1doaXRlc3BhY2UoY3ApKVxuICAgICAgICB0aGlzLl9sZWF2ZUF0dHJWYWx1ZShCRUZPUkVfQVRUUklCVVRFX05BTUVfU1RBVEUpO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuQU1QRVJTQU5EKSB7XG4gICAgICAgIHRoaXMuYWRkaXRpb25hbEFsbG93ZWRDcCA9ICQuR1JFQVRFUl9USEFOX1NJR047XG4gICAgICAgIHRoaXMucmV0dXJuU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBUkFDVEVSX1JFRkVSRU5DRV9JTl9BVFRSSUJVVEVfVkFMVUVfU1RBVEU7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuR1JFQVRFUl9USEFOX1NJR04pIHtcbiAgICAgICAgdGhpcy5fbGVhdmVBdHRyVmFsdWUoREFUQV9TVEFURSk7XG4gICAgICAgIHRoaXMuX2VtaXRDdXJyZW50VG9rZW4oKTtcbiAgICB9XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5OVUxMKVxuICAgICAgICB0aGlzLmN1cnJlbnRBdHRyLnZhbHVlICs9IFVOSUNPREUuUkVQTEFDRU1FTlRfQ0hBUkFDVEVSO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuUVVPVEFUSU9OX01BUksgfHwgY3AgPT09ICQuQVBPU1RST1BIRSB8fCBjcCA9PT0gJC5MRVNTX1RIQU5fU0lHTiB8fFxuICAgICAgICAgICAgIGNwID09PSAkLkVRVUFMU19TSUdOIHx8IGNwID09PSAkLkdSQVZFX0FDQ0VOVClcbiAgICAgICAgdGhpcy5jdXJyZW50QXR0ci52YWx1ZSArPSB0b0NoYXIoY3ApO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuRU9GKVxuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKERBVEFfU1RBVEUpO1xuXG4gICAgZWxzZVxuICAgICAgICB0aGlzLmN1cnJlbnRBdHRyLnZhbHVlICs9IHRvQ2hhcihjcCk7XG59O1xuXG5cbi8vMTIuMi40LjQxIENoYXJhY3RlciByZWZlcmVuY2UgaW4gYXR0cmlidXRlIHZhbHVlIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tDSEFSQUNURVJfUkVGRVJFTkNFX0lOX0FUVFJJQlVURV9WQUxVRV9TVEFURV0gPSBmdW5jdGlvbiBjaGFyYWN0ZXJSZWZlcmVuY2VJbkF0dHJpYnV0ZVZhbHVlU3RhdGUoY3ApIHtcbiAgICB2YXIgcmVmZXJlbmNlZENvZGVQb2ludHMgPSB0aGlzLl9jb25zdW1lQ2hhcmFjdGVyUmVmZXJlbmNlKGNwLCB0cnVlKTtcblxuICAgIGlmICghdGhpcy5fZW5zdXJlSGliZXJuYXRpb24oKSkge1xuICAgICAgICBpZiAocmVmZXJlbmNlZENvZGVQb2ludHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVmZXJlbmNlZENvZGVQb2ludHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QXR0ci52YWx1ZSArPSB0b0NoYXIocmVmZXJlbmNlZENvZGVQb2ludHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEF0dHIudmFsdWUgKz0gJyYnO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnJldHVyblN0YXRlO1xuICAgIH1cbn07XG5cblxuLy8xMi4yLjQuNDIgQWZ0ZXIgYXR0cmlidXRlIHZhbHVlIChxdW90ZWQpIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tBRlRFUl9BVFRSSUJVVEVfVkFMVUVfUVVPVEVEX1NUQVRFXSA9IGZ1bmN0aW9uIGFmdGVyQXR0cmlidXRlVmFsdWVRdW90ZWRTdGF0ZShjcCkge1xuICAgIGlmIChpc1doaXRlc3BhY2UoY3ApKVxuICAgICAgICB0aGlzLl9sZWF2ZUF0dHJWYWx1ZShCRUZPUkVfQVRUUklCVVRFX05BTUVfU1RBVEUpO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuU09MSURVUylcbiAgICAgICAgdGhpcy5fbGVhdmVBdHRyVmFsdWUoU0VMRl9DTE9TSU5HX1NUQVJUX1RBR19TVEFURSk7XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5HUkVBVEVSX1RIQU5fU0lHTikge1xuICAgICAgICB0aGlzLl9sZWF2ZUF0dHJWYWx1ZShEQVRBX1NUQVRFKTtcbiAgICAgICAgdGhpcy5fZW1pdEN1cnJlbnRUb2tlbigpO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkVPRilcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShEQVRBX1NUQVRFKTtcblxuICAgIGVsc2VcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShCRUZPUkVfQVRUUklCVVRFX05BTUVfU1RBVEUpO1xufTtcblxuXG4vLzEyLjIuNC40MyBTZWxmLWNsb3Npbmcgc3RhcnQgdGFnIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tTRUxGX0NMT1NJTkdfU1RBUlRfVEFHX1NUQVRFXSA9IGZ1bmN0aW9uIHNlbGZDbG9zaW5nU3RhcnRUYWdTdGF0ZShjcCkge1xuICAgIGlmIChjcCA9PT0gJC5HUkVBVEVSX1RIQU5fU0lHTikge1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5zZWxmQ2xvc2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuRU9GKVxuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKERBVEFfU1RBVEUpO1xuXG4gICAgZWxzZVxuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKEJFRk9SRV9BVFRSSUJVVEVfTkFNRV9TVEFURSk7XG59O1xuXG5cbi8vMTIuMi40LjQ0IEJvZ3VzIGNvbW1lbnQgc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW0JPR1VTX0NPTU1FTlRfU1RBVEVdID0gZnVuY3Rpb24gYm9ndXNDb21tZW50U3RhdGUoKSB7XG4gICAgdGhpcy5fY3JlYXRlQ29tbWVudFRva2VuKCk7XG4gICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShCT0dVU19DT01NRU5UX1NUQVRFX0NPTlRJTlVBVElPTik7XG59O1xuXG4vL0hBQ0s6IHRvIHN1cHBvcnQgc3RyZWFtaW5nIGFuZCBtYWtlIEJPR1VTX0NPTU1FTlRfU1RBVEUgcmVlbnRyYW50IHdlJ3ZlXG4vL2ludHJvZHVjZWQgQk9HVVNfQ09NTUVOVF9TVEFURV9DT05USU5VQVRJT04gc3RhdGUgd2hpY2ggd2lsbCBub3QgcHJvZHVjZVxuLy9jb21tZW50IHRva2VuIG9uIGVhY2ggY2FsbC5cbl9bQk9HVVNfQ09NTUVOVF9TVEFURV9DT05USU5VQVRJT05dID0gZnVuY3Rpb24gYm9ndXNDb21tZW50U3RhdGVDb250aW51YXRpb24oY3ApIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoY3AgPT09ICQuR1JFQVRFUl9USEFOX1NJR04pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmIChjcCA9PT0gJC5FT0YpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoREFUQV9TVEFURSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uZGF0YSArPSBjcCA9PT0gJC5OVUxMID8gVU5JQ09ERS5SRVBMQUNFTUVOVF9DSEFSQUNURVIgOiB0b0NoYXIoY3ApO1xuXG4gICAgICAgICAgICB0aGlzLl9oaWJlcm5hdGlvblNuYXBzaG90KCk7XG4gICAgICAgICAgICBjcCA9IHRoaXMuX2NvbnN1bWUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2Vuc3VyZUhpYmVybmF0aW9uKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdEN1cnJlbnRUb2tlbigpO1xufTtcblxuLy8xMi4yLjQuNDUgTWFya3VwIGRlY2xhcmF0aW9uIG9wZW4gc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW01BUktVUF9ERUNMQVJBVElPTl9PUEVOX1NUQVRFXSA9IGZ1bmN0aW9uIG1hcmt1cERlY2xhcmF0aW9uT3BlblN0YXRlKGNwKSB7XG4gICAgdmFyIGRhc2hEYXNoTWF0Y2ggPSB0aGlzLl9jb25zdW1lU3Vic2VxdWVudElmTWF0Y2goJCQuREFTSF9EQVNIX1NUUklORywgY3AsIHRydWUpLFxuICAgICAgICBkb2N0eXBlTWF0Y2ggPSAhZGFzaERhc2hNYXRjaCAmJiB0aGlzLl9jb25zdW1lU3Vic2VxdWVudElmTWF0Y2goJCQuRE9DVFlQRV9TVFJJTkcsIGNwLCBmYWxzZSksXG4gICAgICAgIGNkYXRhTWF0Y2ggPSAhZGFzaERhc2hNYXRjaCAmJiAhZG9jdHlwZU1hdGNoICYmXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLmFsbG93Q0RBVEEgJiZcbiAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVTdWJzZXF1ZW50SWZNYXRjaCgkJC5DREFUQV9TVEFSVF9TVFJJTkcsIGNwLCB0cnVlKTtcblxuICAgIGlmICghdGhpcy5fZW5zdXJlSGliZXJuYXRpb24oKSkge1xuICAgICAgICBpZiAoZGFzaERhc2hNYXRjaCkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ29tbWVudFRva2VuKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ09NTUVOVF9TVEFSVF9TVEFURTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGRvY3R5cGVNYXRjaClcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBET0NUWVBFX1NUQVRFO1xuXG4gICAgICAgIGVsc2UgaWYgKGNkYXRhTWF0Y2gpXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0RBVEFfU0VDVElPTl9TVEFURTtcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKEJPR1VTX0NPTU1FTlRfU1RBVEUpO1xuICAgIH1cbn07XG5cblxuLy8xMi4yLjQuNDYgQ29tbWVudCBzdGFydCBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bQ09NTUVOVF9TVEFSVF9TVEFURV0gPSBmdW5jdGlvbiBjb21tZW50U3RhcnRTdGF0ZShjcCkge1xuICAgIGlmIChjcCA9PT0gJC5IWVBIRU5fTUlOVVMpXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT01NRU5UX1NUQVJUX0RBU0hfU1RBVEU7XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5OVUxMKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLmRhdGEgKz0gVU5JQ09ERS5SRVBMQUNFTUVOVF9DSEFSQUNURVI7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkdSRUFURVJfVEhBTl9TSUdOKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuRU9GKSB7XG4gICAgICAgIHRoaXMuX2VtaXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShEQVRBX1NUQVRFKTtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uZGF0YSArPSB0b0NoYXIoY3ApO1xuICAgICAgICB0aGlzLnN0YXRlID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG59O1xuXG5cbi8vMTIuMi40LjQ3IENvbW1lbnQgc3RhcnQgZGFzaCBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bQ09NTUVOVF9TVEFSVF9EQVNIX1NUQVRFXSA9IGZ1bmN0aW9uIGNvbW1lbnRTdGFydERhc2hTdGF0ZShjcCkge1xuICAgIGlmIChjcCA9PT0gJC5IWVBIRU5fTUlOVVMpXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT01NRU5UX0VORF9TVEFURTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLk5VTEwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uZGF0YSArPSAnLSc7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLmRhdGEgKz0gVU5JQ09ERS5SRVBMQUNFTUVOVF9DSEFSQUNURVI7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkdSRUFURVJfVEhBTl9TSUdOKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuRU9GKSB7XG4gICAgICAgIHRoaXMuX2VtaXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShEQVRBX1NUQVRFKTtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uZGF0YSArPSAnLSc7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLmRhdGEgKz0gdG9DaGFyKGNwKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxufTtcblxuXG4vLzEyLjIuNC40OCBDb21tZW50IHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tDT01NRU5UX1NUQVRFXSA9IGZ1bmN0aW9uIGNvbW1lbnRTdGF0ZShjcCkge1xuICAgIGlmIChjcCA9PT0gJC5IWVBIRU5fTUlOVVMpXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT01NRU5UX0VORF9EQVNIX1NUQVRFO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuTlVMTClcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uZGF0YSArPSBVTklDT0RFLlJFUExBQ0VNRU5UX0NIQVJBQ1RFUjtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkVPRikge1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoREFUQV9TVEFURSk7XG4gICAgfVxuXG4gICAgZWxzZVxuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5kYXRhICs9IHRvQ2hhcihjcCk7XG59O1xuXG5cbi8vMTIuMi40LjQ5IENvbW1lbnQgZW5kIGRhc2ggc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW0NPTU1FTlRfRU5EX0RBU0hfU1RBVEVdID0gZnVuY3Rpb24gY29tbWVudEVuZERhc2hTdGF0ZShjcCkge1xuICAgIGlmIChjcCA9PT0gJC5IWVBIRU5fTUlOVVMpXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT01NRU5UX0VORF9TVEFURTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLk5VTEwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uZGF0YSArPSAnLSc7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLmRhdGEgKz0gVU5JQ09ERS5SRVBMQUNFTUVOVF9DSEFSQUNURVI7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkVPRikge1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoREFUQV9TVEFURSk7XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLmRhdGEgKz0gJy0nO1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5kYXRhICs9IHRvQ2hhcihjcCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbn07XG5cblxuLy8xMi4yLjQuNTAgQ29tbWVudCBlbmQgc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW0NPTU1FTlRfRU5EX1NUQVRFXSA9IGZ1bmN0aW9uIGNvbW1lbnRFbmRTdGF0ZShjcCkge1xuICAgIGlmIChjcCA9PT0gJC5HUkVBVEVSX1RIQU5fU0lHTikge1xuICAgICAgICB0aGlzLnN0YXRlID0gREFUQV9TVEFURTtcbiAgICAgICAgdGhpcy5fZW1pdEN1cnJlbnRUb2tlbigpO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkVYQ0xBTUFUSU9OX01BUkspXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT01NRU5UX0VORF9CQU5HX1NUQVRFO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuSFlQSEVOX01JTlVTKVxuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5kYXRhICs9ICctJztcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLk5VTEwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uZGF0YSArPSAnLS0nO1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5kYXRhICs9IFVOSUNPREUuUkVQTEFDRU1FTlRfQ0hBUkFDVEVSO1xuICAgICAgICB0aGlzLnN0YXRlID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5FT0YpIHtcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShEQVRBX1NUQVRFKTtcbiAgICAgICAgdGhpcy5fZW1pdEN1cnJlbnRUb2tlbigpO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5kYXRhICs9ICctLSc7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLmRhdGEgKz0gdG9DaGFyKGNwKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxufTtcblxuXG4vLzEyLjIuNC41MSBDb21tZW50IGVuZCBiYW5nIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tDT01NRU5UX0VORF9CQU5HX1NUQVRFXSA9IGZ1bmN0aW9uIGNvbW1lbnRFbmRCYW5nU3RhdGUoY3ApIHtcbiAgICBpZiAoY3AgPT09ICQuSFlQSEVOX01JTlVTKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLmRhdGEgKz0gJy0tISc7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT01NRU5UX0VORF9EQVNIX1NUQVRFO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkdSRUFURVJfVEhBTl9TSUdOKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuTlVMTCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5kYXRhICs9ICctLSEnO1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5kYXRhICs9IFVOSUNPREUuUkVQTEFDRU1FTlRfQ0hBUkFDVEVSO1xuICAgICAgICB0aGlzLnN0YXRlID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5FT0YpIHtcbiAgICAgICAgdGhpcy5fZW1pdEN1cnJlbnRUb2tlbigpO1xuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKERBVEFfU1RBVEUpO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5kYXRhICs9ICctLSEnO1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5kYXRhICs9IHRvQ2hhcihjcCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbn07XG5cblxuLy8xMi4yLjQuNTIgRE9DVFlQRSBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bRE9DVFlQRV9TVEFURV0gPSBmdW5jdGlvbiBkb2N0eXBlU3RhdGUoY3ApIHtcbiAgICBpZiAoaXNXaGl0ZXNwYWNlKGNwKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuR1JFQVRFUl9USEFOX1NJR04pIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlRG9jdHlwZVRva2VuKG51bGwpO1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5mb3JjZVF1aXJrcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2VtaXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IERBVEFfU1RBVEU7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuRU9GKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZURvY3R5cGVUb2tlbihudWxsKTtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uZm9yY2VRdWlya3MgPSB0cnVlO1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoREFUQV9TVEFURSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9jcmVhdGVEb2N0eXBlVG9rZW4oJycpO1xuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKERPQ1RZUEVfTkFNRV9TVEFURSk7XG4gICAgfVxufTtcblxuXG4vLzEyLjIuNC41NCBET0NUWVBFIG5hbWUgc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW0RPQ1RZUEVfTkFNRV9TVEFURV0gPSBmdW5jdGlvbiBkb2N0eXBlTmFtZVN0YXRlKGNwKSB7XG4gICAgaWYgKGlzV2hpdGVzcGFjZShjcCkgfHwgY3AgPT09ICQuR1JFQVRFUl9USEFOX1NJR04gfHwgY3AgPT09ICQuRU9GKVxuICAgICAgICB0aGlzLl9yZWNvbnN1bWVJblN0YXRlKEFGVEVSX0RPQ1RZUEVfTkFNRV9TVEFURSk7XG5cbiAgICBlbHNlIGlmIChpc0FzY2lpVXBwZXIoY3ApKVxuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5uYW1lICs9IHRvQXNjaWlMb3dlckNoYXIoY3ApO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuTlVMTClcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4ubmFtZSArPSBVTklDT0RFLlJFUExBQ0VNRU5UX0NIQVJBQ1RFUjtcblxuICAgIGVsc2VcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4ubmFtZSArPSB0b0NoYXIoY3ApO1xufTtcblxuXG4vLzEyLjIuNC41NSBBZnRlciBET0NUWVBFIG5hbWUgc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW0FGVEVSX0RPQ1RZUEVfTkFNRV9TVEFURV0gPSBmdW5jdGlvbiBhZnRlckRvY3R5cGVOYW1lU3RhdGUoY3ApIHtcbiAgICBpZiAoaXNXaGl0ZXNwYWNlKGNwKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKGNwID09PSAkLkdSRUFURVJfVEhBTl9TSUdOKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBwdWJsaWNNYXRjaCA9IHRoaXMuX2NvbnN1bWVTdWJzZXF1ZW50SWZNYXRjaCgkJC5QVUJMSUNfU1RSSU5HLCBjcCwgZmFsc2UpLFxuICAgICAgICAgICAgc3lzdGVtTWF0Y2ggPSAhcHVibGljTWF0Y2ggJiYgdGhpcy5fY29uc3VtZVN1YnNlcXVlbnRJZk1hdGNoKCQkLlNZU1RFTV9TVFJJTkcsIGNwLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbnN1cmVIaWJlcm5hdGlvbigpKSB7XG4gICAgICAgICAgICBpZiAocHVibGljTWF0Y2gpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IEJFRk9SRV9ET0NUWVBFX1BVQkxJQ19JREVOVElGSUVSX1NUQVRFO1xuXG4gICAgICAgICAgICBlbHNlIGlmIChzeXN0ZW1NYXRjaClcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQkVGT1JFX0RPQ1RZUEVfU1lTVEVNX0lERU5USUZJRVJfU1RBVEU7XG5cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFRva2VuLmZvcmNlUXVpcmtzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQk9HVVNfRE9DVFlQRV9TVEFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLy8xMi4yLjQuNTcgQmVmb3JlIERPQ1RZUEUgcHVibGljIGlkZW50aWZpZXIgc3RhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5fW0JFRk9SRV9ET0NUWVBFX1BVQkxJQ19JREVOVElGSUVSX1NUQVRFXSA9IGZ1bmN0aW9uIGJlZm9yZURvY3R5cGVQdWJsaWNJZGVudGlmaWVyU3RhdGUoY3ApIHtcbiAgICBpZiAoaXNXaGl0ZXNwYWNlKGNwKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKGNwID09PSAkLlFVT1RBVElPTl9NQVJLKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLnB1YmxpY0lkID0gJyc7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBET0NUWVBFX1BVQkxJQ19JREVOVElGSUVSX0RPVUJMRV9RVU9URURfU1RBVEU7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuQVBPU1RST1BIRSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5wdWJsaWNJZCA9ICcnO1xuICAgICAgICB0aGlzLnN0YXRlID0gRE9DVFlQRV9QVUJMSUNfSURFTlRJRklFUl9TSU5HTEVfUVVPVEVEX1NUQVRFO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5mb3JjZVF1aXJrcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoQk9HVVNfRE9DVFlQRV9TVEFURSk7XG4gICAgfVxufTtcblxuXG4vLzEyLjIuNC41OCBET0NUWVBFIHB1YmxpYyBpZGVudGlmaWVyIChkb3VibGUtcXVvdGVkKSBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bRE9DVFlQRV9QVUJMSUNfSURFTlRJRklFUl9ET1VCTEVfUVVPVEVEX1NUQVRFXSA9IGZ1bmN0aW9uIGRvY3R5cGVQdWJsaWNJZGVudGlmaWVyRG91YmxlUXVvdGVkU3RhdGUoY3ApIHtcbiAgICBpZiAoY3AgPT09ICQuUVVPVEFUSU9OX01BUkspXG4gICAgICAgIHRoaXMuc3RhdGUgPSBCRVRXRUVOX0RPQ1RZUEVfUFVCTElDX0FORF9TWVNURU1fSURFTlRJRklFUlNfU1RBVEU7XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5OVUxMKVxuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5wdWJsaWNJZCArPSBVTklDT0RFLlJFUExBQ0VNRU5UX0NIQVJBQ1RFUjtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkdSRUFURVJfVEhBTl9TSUdOKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLmZvcmNlUXVpcmtzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZW1pdEN1cnJlbnRUb2tlbigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gREFUQV9TVEFURTtcbiAgICB9XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5FT0YpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uZm9yY2VRdWlya3MgPSB0cnVlO1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoREFUQV9TVEFURSk7XG4gICAgfVxuXG4gICAgZWxzZVxuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5wdWJsaWNJZCArPSB0b0NoYXIoY3ApO1xufTtcblxuXG4vLzEyLjIuNC41OSBET0NUWVBFIHB1YmxpYyBpZGVudGlmaWVyIChzaW5nbGUtcXVvdGVkKSBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bRE9DVFlQRV9QVUJMSUNfSURFTlRJRklFUl9TSU5HTEVfUVVPVEVEX1NUQVRFXSA9IGZ1bmN0aW9uIGRvY3R5cGVQdWJsaWNJZGVudGlmaWVyU2luZ2xlUXVvdGVkU3RhdGUoY3ApIHtcbiAgICBpZiAoY3AgPT09ICQuQVBPU1RST1BIRSlcbiAgICAgICAgdGhpcy5zdGF0ZSA9IEJFVFdFRU5fRE9DVFlQRV9QVUJMSUNfQU5EX1NZU1RFTV9JREVOVElGSUVSU19TVEFURTtcblxuICAgIGVsc2UgaWYgKGNwID09PSAkLk5VTEwpXG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLnB1YmxpY0lkICs9IFVOSUNPREUuUkVQTEFDRU1FTlRfQ0hBUkFDVEVSO1xuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuR1JFQVRFUl9USEFOX1NJR04pIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uZm9yY2VRdWlya3MgPSB0cnVlO1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkVPRikge1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5mb3JjZVF1aXJrcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2VtaXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShEQVRBX1NUQVRFKTtcbiAgICB9XG5cbiAgICBlbHNlXG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLnB1YmxpY0lkICs9IHRvQ2hhcihjcCk7XG59O1xuXG5cbi8vMTIuMi40LjYxIEJldHdlZW4gRE9DVFlQRSBwdWJsaWMgYW5kIHN5c3RlbSBpZGVudGlmaWVycyBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bQkVUV0VFTl9ET0NUWVBFX1BVQkxJQ19BTkRfU1lTVEVNX0lERU5USUZJRVJTX1NUQVRFXSA9IGZ1bmN0aW9uIGJldHdlZW5Eb2N0eXBlUHVibGljQW5kU3lzdGVtSWRlbnRpZmllcnNTdGF0ZShjcCkge1xuICAgIGlmIChpc1doaXRlc3BhY2UoY3ApKVxuICAgICAgICByZXR1cm47XG5cbiAgICBpZiAoY3AgPT09ICQuR1JFQVRFUl9USEFOX1NJR04pIHtcbiAgICAgICAgdGhpcy5fZW1pdEN1cnJlbnRUb2tlbigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gREFUQV9TVEFURTtcbiAgICB9XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5RVU9UQVRJT05fTUFSSykge1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5zeXN0ZW1JZCA9ICcnO1xuICAgICAgICB0aGlzLnN0YXRlID0gRE9DVFlQRV9TWVNURU1fSURFTlRJRklFUl9ET1VCTEVfUVVPVEVEX1NUQVRFO1xuICAgIH1cblxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuQVBPU1RST1BIRSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5zeXN0ZW1JZCA9ICcnO1xuICAgICAgICB0aGlzLnN0YXRlID0gRE9DVFlQRV9TWVNURU1fSURFTlRJRklFUl9TSU5HTEVfUVVPVEVEX1NUQVRFO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5mb3JjZVF1aXJrcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoQk9HVVNfRE9DVFlQRV9TVEFURSk7XG4gICAgfVxufTtcblxuXG4vLzEyLjIuNC42MyBCZWZvcmUgRE9DVFlQRSBzeXN0ZW0gaWRlbnRpZmllciBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bQkVGT1JFX0RPQ1RZUEVfU1lTVEVNX0lERU5USUZJRVJfU1RBVEVdID0gZnVuY3Rpb24gYmVmb3JlRG9jdHlwZVN5c3RlbUlkZW50aWZpZXJTdGF0ZShjcCkge1xuICAgIGlmIChpc1doaXRlc3BhY2UoY3ApKVxuICAgICAgICByZXR1cm47XG5cbiAgICBpZiAoY3AgPT09ICQuUVVPVEFUSU9OX01BUkspIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uc3lzdGVtSWQgPSAnJztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IERPQ1RZUEVfU1lTVEVNX0lERU5USUZJRVJfRE9VQkxFX1FVT1RFRF9TVEFURTtcbiAgICB9XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5BUE9TVFJPUEhFKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLnN5c3RlbUlkID0gJyc7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBET0NUWVBFX1NZU1RFTV9JREVOVElGSUVSX1NJTkdMRV9RVU9URURfU1RBVEU7XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLmZvcmNlUXVpcmtzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShCT0dVU19ET0NUWVBFX1NUQVRFKTtcbiAgICB9XG59O1xuXG5cbi8vMTIuMi40LjY0IERPQ1RZUEUgc3lzdGVtIGlkZW50aWZpZXIgKGRvdWJsZS1xdW90ZWQpIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tET0NUWVBFX1NZU1RFTV9JREVOVElGSUVSX0RPVUJMRV9RVU9URURfU1RBVEVdID0gZnVuY3Rpb24gZG9jdHlwZVN5c3RlbUlkZW50aWZpZXJEb3VibGVRdW90ZWRTdGF0ZShjcCkge1xuICAgIGlmIChjcCA9PT0gJC5RVU9UQVRJT05fTUFSSylcbiAgICAgICAgdGhpcy5zdGF0ZSA9IEFGVEVSX0RPQ1RZUEVfU1lTVEVNX0lERU5USUZJRVJfU1RBVEU7XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5HUkVBVEVSX1RIQU5fU0lHTikge1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5mb3JjZVF1aXJrcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2VtaXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IERBVEFfU1RBVEU7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuTlVMTClcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uc3lzdGVtSWQgKz0gVU5JQ09ERS5SRVBMQUNFTUVOVF9DSEFSQUNURVI7XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5FT0YpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uZm9yY2VRdWlya3MgPSB0cnVlO1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoREFUQV9TVEFURSk7XG4gICAgfVxuXG4gICAgZWxzZVxuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5zeXN0ZW1JZCArPSB0b0NoYXIoY3ApO1xufTtcblxuXG4vLzEyLjIuNC42NSBET0NUWVBFIHN5c3RlbSBpZGVudGlmaWVyIChzaW5nbGUtcXVvdGVkKSBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bRE9DVFlQRV9TWVNURU1fSURFTlRJRklFUl9TSU5HTEVfUVVPVEVEX1NUQVRFXSA9IGZ1bmN0aW9uIGRvY3R5cGVTeXN0ZW1JZGVudGlmaWVyU2luZ2xlUXVvdGVkU3RhdGUoY3ApIHtcbiAgICBpZiAoY3AgPT09ICQuQVBPU1RST1BIRSlcbiAgICAgICAgdGhpcy5zdGF0ZSA9IEFGVEVSX0RPQ1RZUEVfU1lTVEVNX0lERU5USUZJRVJfU1RBVEU7XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5HUkVBVEVSX1RIQU5fU0lHTikge1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5mb3JjZVF1aXJrcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2VtaXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IERBVEFfU1RBVEU7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY3AgPT09ICQuTlVMTClcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uc3lzdGVtSWQgKz0gVU5JQ09ERS5SRVBMQUNFTUVOVF9DSEFSQUNURVI7XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5FT0YpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uZm9yY2VRdWlya3MgPSB0cnVlO1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoREFUQV9TVEFURSk7XG4gICAgfVxuXG4gICAgZWxzZVxuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbi5zeXN0ZW1JZCArPSB0b0NoYXIoY3ApO1xufTtcblxuXG4vLzEyLjIuNC42NiBBZnRlciBET0NUWVBFIHN5c3RlbSBpZGVudGlmaWVyIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tBRlRFUl9ET0NUWVBFX1NZU1RFTV9JREVOVElGSUVSX1NUQVRFXSA9IGZ1bmN0aW9uIGFmdGVyRG9jdHlwZVN5c3RlbUlkZW50aWZpZXJTdGF0ZShjcCkge1xuICAgIGlmIChpc1doaXRlc3BhY2UoY3ApKVxuICAgICAgICByZXR1cm47XG5cbiAgICBpZiAoY3AgPT09ICQuR1JFQVRFUl9USEFOX1NJR04pIHtcbiAgICAgICAgdGhpcy5fZW1pdEN1cnJlbnRUb2tlbigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gREFUQV9TVEFURTtcbiAgICB9XG5cbiAgICBlbHNlIGlmIChjcCA9PT0gJC5FT0YpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4uZm9yY2VRdWlya3MgPSB0cnVlO1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoREFUQV9TVEFURSk7XG4gICAgfVxuXG4gICAgZWxzZVxuICAgICAgICB0aGlzLnN0YXRlID0gQk9HVVNfRE9DVFlQRV9TVEFURTtcbn07XG5cblxuLy8xMi4yLjQuNjcgQm9ndXMgRE9DVFlQRSBzdGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbl9bQk9HVVNfRE9DVFlQRV9TVEFURV0gPSBmdW5jdGlvbiBib2d1c0RvY3R5cGVTdGF0ZShjcCkge1xuICAgIGlmIChjcCA9PT0gJC5HUkVBVEVSX1RIQU5fU0lHTikge1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGNwID09PSAkLkVPRikge1xuICAgICAgICB0aGlzLl9lbWl0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIHRoaXMuX3JlY29uc3VtZUluU3RhdGUoREFUQV9TVEFURSk7XG4gICAgfVxufTtcblxuXG4vLzEyLjIuNC42OCBDREFUQSBzZWN0aW9uIHN0YXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX1tDREFUQV9TRUNUSU9OX1NUQVRFXSA9IGZ1bmN0aW9uIGNkYXRhU2VjdGlvblN0YXRlKGNwKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGNwID09PSAkLkVPRikge1xuICAgICAgICAgICAgdGhpcy5fcmVjb25zdW1lSW5TdGF0ZShEQVRBX1NUQVRFKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2RhdGFFbmRNYXRjaCA9IHRoaXMuX2NvbnN1bWVTdWJzZXF1ZW50SWZNYXRjaCgkJC5DREFUQV9FTkRfU1RSSU5HLCBjcCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9lbnN1cmVIaWJlcm5hdGlvbigpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBpZiAoY2RhdGFFbmRNYXRjaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBEQVRBX1NUQVRFO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9lbWl0Q29kZVBvaW50KGNwKTtcblxuICAgICAgICAgICAgdGhpcy5faGliZXJuYXRpb25TbmFwc2hvdCgpO1xuICAgICAgICAgICAgY3AgPSB0aGlzLl9jb25zdW1lKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9lbnN1cmVIaWJlcm5hdGlvbigpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZTUvbGliL3Rva2VuaXplci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDM3KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzU2NoZWR1bGVyLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDkwKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvbXVsdGljYXN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV0aWxcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ1dGlsXCJcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKCt2YWx1ZSk7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzRGF0ZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy91dGlsL2lzRGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDExKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg5Mik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3JlZHVjZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJzdHJlYW1cIlxuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsImltcG9ydCB7IEluamVjdGFibGUsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQWxlcnRTZXJ2aWNlIHtcclxuICAgIGFsZXJ0Q2hhbmdlZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICBwcml2YXRlIHNob3dBbGVydCA9ICh0aXRsZTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcsIGFjdGlvbjogKCkgPT4gdm9pZCA9ICgpID0+IHsgfSkgPT5cclxuICAgICAgICB0aGlzLmFsZXJ0Q2hhbmdlZC5lbWl0KHsgYWN0aW9uOiBhY3Rpb24sIG1lc3NhZ2U6IG1lc3NhZ2UsIHRpdGxlOiB0aXRsZSB9KTtcclxuICAgIHB1YmxpYyBzaG93KHRpdGxlOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZywgYWN0aW9uOiAoKSA9PiB2b2lkID0gKCkgPT4geyB9KSB7XHJcbiAgICAgICAgdGhpcy5zaG93QWxlcnQodGl0bGUsIG1lc3NhZ2UsIGFjdGlvbik7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9zZXJ2aWNlcy9mcm9udGVuZC9hbGVydC5zZXJ2aWNlLnRzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9DVU1FTlRfTU9ERSA9IHJlcXVpcmUoJy4vaHRtbCcpLkRPQ1VNRU5UX01PREU7XG5cbi8vQ29uc3RcbnZhciBWQUxJRF9ET0NUWVBFX05BTUUgPSAnaHRtbCcsXG4gICAgUVVJUktTX01PREVfU1lTVEVNX0lEID0gJ2h0dHA6Ly93d3cuaWJtLmNvbS9kYXRhL2R0ZC92MTEvaWJteGh0bWwxLXRyYW5zaXRpb25hbC5kdGQnLFxuICAgIFFVSVJLU19NT0RFX1BVQkxJQ19JRF9QUkVGSVhFUyA9IFtcbiAgICAgICAgJysvL3NpbG1hcmlsLy9kdGQgaHRtbCBwcm8gdjByMTEgMTk5NzAxMDEvL2VuJyxcbiAgICAgICAgJy0vL2FkdmFzb2Z0IGx0ZC8vZHRkIGh0bWwgMy4wIGFzd2VkaXQgKyBleHRlbnNpb25zLy9lbicsXG4gICAgICAgICctLy9hcy8vZHRkIGh0bWwgMy4wIGFzd2VkaXQgKyBleHRlbnNpb25zLy9lbicsXG4gICAgICAgICctLy9pZXRmLy9kdGQgaHRtbCAyLjAgbGV2ZWwgMS8vZW4nLFxuICAgICAgICAnLS8vaWV0Zi8vZHRkIGh0bWwgMi4wIGxldmVsIDIvL2VuJyxcbiAgICAgICAgJy0vL2lldGYvL2R0ZCBodG1sIDIuMCBzdHJpY3QgbGV2ZWwgMS8vZW4nLFxuICAgICAgICAnLS8vaWV0Zi8vZHRkIGh0bWwgMi4wIHN0cmljdCBsZXZlbCAyLy9lbicsXG4gICAgICAgICctLy9pZXRmLy9kdGQgaHRtbCAyLjAgc3RyaWN0Ly9lbicsXG4gICAgICAgICctLy9pZXRmLy9kdGQgaHRtbCAyLjAvL2VuJyxcbiAgICAgICAgJy0vL2lldGYvL2R0ZCBodG1sIDIuMWUvL2VuJyxcbiAgICAgICAgJy0vL2lldGYvL2R0ZCBodG1sIDMuMC8vZW4nLFxuICAgICAgICAnLS8vaWV0Zi8vZHRkIGh0bWwgMy4wLy9lbi8vJyxcbiAgICAgICAgJy0vL2lldGYvL2R0ZCBodG1sIDMuMiBmaW5hbC8vZW4nLFxuICAgICAgICAnLS8vaWV0Zi8vZHRkIGh0bWwgMy4yLy9lbicsXG4gICAgICAgICctLy9pZXRmLy9kdGQgaHRtbCAzLy9lbicsXG4gICAgICAgICctLy9pZXRmLy9kdGQgaHRtbCBsZXZlbCAwLy9lbicsXG4gICAgICAgICctLy9pZXRmLy9kdGQgaHRtbCBsZXZlbCAwLy9lbi8vMi4wJyxcbiAgICAgICAgJy0vL2lldGYvL2R0ZCBodG1sIGxldmVsIDEvL2VuJyxcbiAgICAgICAgJy0vL2lldGYvL2R0ZCBodG1sIGxldmVsIDEvL2VuLy8yLjAnLFxuICAgICAgICAnLS8vaWV0Zi8vZHRkIGh0bWwgbGV2ZWwgMi8vZW4nLFxuICAgICAgICAnLS8vaWV0Zi8vZHRkIGh0bWwgbGV2ZWwgMi8vZW4vLzIuMCcsXG4gICAgICAgICctLy9pZXRmLy9kdGQgaHRtbCBsZXZlbCAzLy9lbicsXG4gICAgICAgICctLy9pZXRmLy9kdGQgaHRtbCBsZXZlbCAzLy9lbi8vMy4wJyxcbiAgICAgICAgJy0vL2lldGYvL2R0ZCBodG1sIHN0cmljdCBsZXZlbCAwLy9lbicsXG4gICAgICAgICctLy9pZXRmLy9kdGQgaHRtbCBzdHJpY3QgbGV2ZWwgMC8vZW4vLzIuMCcsXG4gICAgICAgICctLy9pZXRmLy9kdGQgaHRtbCBzdHJpY3QgbGV2ZWwgMS8vZW4nLFxuICAgICAgICAnLS8vaWV0Zi8vZHRkIGh0bWwgc3RyaWN0IGxldmVsIDEvL2VuLy8yLjAnLFxuICAgICAgICAnLS8vaWV0Zi8vZHRkIGh0bWwgc3RyaWN0IGxldmVsIDIvL2VuJyxcbiAgICAgICAgJy0vL2lldGYvL2R0ZCBodG1sIHN0cmljdCBsZXZlbCAyLy9lbi8vMi4wJyxcbiAgICAgICAgJy0vL2lldGYvL2R0ZCBodG1sIHN0cmljdCBsZXZlbCAzLy9lbicsXG4gICAgICAgICctLy9pZXRmLy9kdGQgaHRtbCBzdHJpY3QgbGV2ZWwgMy8vZW4vLzMuMCcsXG4gICAgICAgICctLy9pZXRmLy9kdGQgaHRtbCBzdHJpY3QvL2VuJyxcbiAgICAgICAgJy0vL2lldGYvL2R0ZCBodG1sIHN0cmljdC8vZW4vLzIuMCcsXG4gICAgICAgICctLy9pZXRmLy9kdGQgaHRtbCBzdHJpY3QvL2VuLy8zLjAnLFxuICAgICAgICAnLS8vaWV0Zi8vZHRkIGh0bWwvL2VuJyxcbiAgICAgICAgJy0vL2lldGYvL2R0ZCBodG1sLy9lbi8vMi4wJyxcbiAgICAgICAgJy0vL2lldGYvL2R0ZCBodG1sLy9lbi8vMy4wJyxcbiAgICAgICAgJy0vL21ldHJpdXMvL2R0ZCBtZXRyaXVzIHByZXNlbnRhdGlvbmFsLy9lbicsXG4gICAgICAgICctLy9taWNyb3NvZnQvL2R0ZCBpbnRlcm5ldCBleHBsb3JlciAyLjAgaHRtbCBzdHJpY3QvL2VuJyxcbiAgICAgICAgJy0vL21pY3Jvc29mdC8vZHRkIGludGVybmV0IGV4cGxvcmVyIDIuMCBodG1sLy9lbicsXG4gICAgICAgICctLy9taWNyb3NvZnQvL2R0ZCBpbnRlcm5ldCBleHBsb3JlciAyLjAgdGFibGVzLy9lbicsXG4gICAgICAgICctLy9taWNyb3NvZnQvL2R0ZCBpbnRlcm5ldCBleHBsb3JlciAzLjAgaHRtbCBzdHJpY3QvL2VuJyxcbiAgICAgICAgJy0vL21pY3Jvc29mdC8vZHRkIGludGVybmV0IGV4cGxvcmVyIDMuMCBodG1sLy9lbicsXG4gICAgICAgICctLy9taWNyb3NvZnQvL2R0ZCBpbnRlcm5ldCBleHBsb3JlciAzLjAgdGFibGVzLy9lbicsXG4gICAgICAgICctLy9uZXRzY2FwZSBjb21tLiBjb3JwLi8vZHRkIGh0bWwvL2VuJyxcbiAgICAgICAgJy0vL25ldHNjYXBlIGNvbW0uIGNvcnAuLy9kdGQgc3RyaWN0IGh0bWwvL2VuJyxcbiAgICAgICAgJy0vL29cXCdyZWlsbHkgYW5kIGFzc29jaWF0ZXMvL2R0ZCBodG1sIDIuMC8vZW4nLFxuICAgICAgICAnLS8vb1xcJ3JlaWxseSBhbmQgYXNzb2NpYXRlcy8vZHRkIGh0bWwgZXh0ZW5kZWQgMS4wLy9lbicsXG4gICAgICAgICctLy9zcHlnbGFzcy8vZHRkIGh0bWwgMi4wIGV4dGVuZGVkLy9lbicsXG4gICAgICAgICctLy9zcS8vZHRkIGh0bWwgMi4wIGhvdG1ldGFsICsgZXh0ZW5zaW9ucy8vZW4nLFxuICAgICAgICAnLS8vc3VuIG1pY3Jvc3lzdGVtcyBjb3JwLi8vZHRkIGhvdGphdmEgaHRtbC8vZW4nLFxuICAgICAgICAnLS8vc3VuIG1pY3Jvc3lzdGVtcyBjb3JwLi8vZHRkIGhvdGphdmEgc3RyaWN0IGh0bWwvL2VuJyxcbiAgICAgICAgJy0vL3czYy8vZHRkIGh0bWwgMyAxOTk1LTAzLTI0Ly9lbicsXG4gICAgICAgICctLy93M2MvL2R0ZCBodG1sIDMuMiBkcmFmdC8vZW4nLFxuICAgICAgICAnLS8vdzNjLy9kdGQgaHRtbCAzLjIgZmluYWwvL2VuJyxcbiAgICAgICAgJy0vL3czYy8vZHRkIGh0bWwgMy4yLy9lbicsXG4gICAgICAgICctLy93M2MvL2R0ZCBodG1sIDMuMnMgZHJhZnQvL2VuJyxcbiAgICAgICAgJy0vL3czYy8vZHRkIGh0bWwgNC4wIGZyYW1lc2V0Ly9lbicsXG4gICAgICAgICctLy93M2MvL2R0ZCBodG1sIDQuMCB0cmFuc2l0aW9uYWwvL2VuJyxcbiAgICAgICAgJy0vL3czYy8vZHRkIGh0bWwgZXhwZXJpbWVudGFsIDE5OTYwNzEyLy9lbicsXG4gICAgICAgICctLy93M2MvL2R0ZCBodG1sIGV4cGVyaW1lbnRhbCA5NzA0MjEvL2VuJyxcbiAgICAgICAgJy0vL3czYy8vZHRkIHczIGh0bWwvL2VuJyxcbiAgICAgICAgJy0vL3czby8vZHRkIHczIGh0bWwgMy4wLy9lbicsXG4gICAgICAgICctLy93M28vL2R0ZCB3MyBodG1sIDMuMC8vZW4vLycsXG4gICAgICAgICctLy93ZWJ0ZWNocy8vZHRkIG1vemlsbGEgaHRtbCAyLjAvL2VuJyxcbiAgICAgICAgJy0vL3dlYnRlY2hzLy9kdGQgbW96aWxsYSBodG1sLy9lbidcbiAgICBdLFxuICAgIFFVSVJLU19NT0RFX05PX1NZU1RFTV9JRF9QVUJMSUNfSURfUFJFRklYRVMgPSBRVUlSS1NfTU9ERV9QVUJMSUNfSURfUFJFRklYRVMuY29uY2F0KFtcbiAgICAgICAgJy0vL3czYy8vZHRkIGh0bWwgNC4wMSBmcmFtZXNldC8vJyxcbiAgICAgICAgJy0vL3czYy8vZHRkIGh0bWwgNC4wMSB0cmFuc2l0aW9uYWwvLydcbiAgICBdKSxcbiAgICBRVUlSS1NfTU9ERV9QVUJMSUNfSURTID0gW1xuICAgICAgICAnLS8vdzNvLy9kdGQgdzMgaHRtbCBzdHJpY3QgMy4wLy9lbi8vJyxcbiAgICAgICAgJy0vdzNjL2R0ZCBodG1sIDQuMCB0cmFuc2l0aW9uYWwvZW4nLFxuICAgICAgICAnaHRtbCdcbiAgICBdLFxuICAgIExJTUlURURfUVVJUktTX1BVQkxJQ19JRF9QUkVGSVhFUyA9IFtcbiAgICAgICAgJy0vL1czQy8vRFREIFhIVE1MIDEuMCBGcmFtZXNldC8vJyxcbiAgICAgICAgJy0vL1czQy8vRFREIFhIVE1MIDEuMCBUcmFuc2l0aW9uYWwvLydcbiAgICBdLFxuICAgIExJTUlURURfUVVJUktTX1dJVEhfU1lTVEVNX0lEX1BVQkxJQ19JRF9QUkVGSVhFUyA9IExJTUlURURfUVVJUktTX1BVQkxJQ19JRF9QUkVGSVhFUy5jb25jYXQoW1xuICAgICAgICAnLS8vVzNDLy9EVEQgSFRNTCA0LjAxIEZyYW1lc2V0Ly8nLFxuICAgICAgICAnLS8vVzNDLy9EVEQgSFRNTCA0LjAxIFRyYW5zaXRpb25hbC8vJ1xuICAgIF0pO1xuXG5cbi8vVXRpbHNcbmZ1bmN0aW9uIGVucXVvdGVEb2N0eXBlSWQoaWQpIHtcbiAgICB2YXIgcXVvdGUgPSBpZC5pbmRleE9mKCdcIicpICE9PSAtMSA/ICdcXCcnIDogJ1wiJztcblxuICAgIHJldHVybiBxdW90ZSArIGlkICsgcXVvdGU7XG59XG5cbmZ1bmN0aW9uIGhhc1ByZWZpeChwdWJsaWNJZCwgcHJlZml4ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwdWJsaWNJZC5pbmRleE9mKHByZWZpeGVzW2ldKSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuXG4vL0FQSVxuZXhwb3J0cy5nZXREb2N1bWVudE1vZGUgPSBmdW5jdGlvbiAobmFtZSwgcHVibGljSWQsIHN5c3RlbUlkKSB7XG4gICAgaWYgKG5hbWUgIT09IFZBTElEX0RPQ1RZUEVfTkFNRSlcbiAgICAgICAgcmV0dXJuIERPQ1VNRU5UX01PREUuUVVJUktTO1xuXG4gICAgaWYgKHN5c3RlbUlkICYmIHN5c3RlbUlkLnRvTG93ZXJDYXNlKCkgPT09IFFVSVJLU19NT0RFX1NZU1RFTV9JRClcbiAgICAgICAgcmV0dXJuIERPQ1VNRU5UX01PREUuUVVJUktTO1xuXG4gICAgaWYgKHB1YmxpY0lkICE9PSBudWxsKSB7XG4gICAgICAgIHB1YmxpY0lkID0gcHVibGljSWQudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAoUVVJUktTX01PREVfUFVCTElDX0lEUy5pbmRleE9mKHB1YmxpY0lkKSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIERPQ1VNRU5UX01PREUuUVVJUktTO1xuXG4gICAgICAgIHZhciBwcmVmaXhlcyA9IHN5c3RlbUlkID09PSBudWxsID8gUVVJUktTX01PREVfTk9fU1lTVEVNX0lEX1BVQkxJQ19JRF9QUkVGSVhFUyA6IFFVSVJLU19NT0RFX1BVQkxJQ19JRF9QUkVGSVhFUztcblxuICAgICAgICBpZiAoaGFzUHJlZml4KHB1YmxpY0lkLCBwcmVmaXhlcykpXG4gICAgICAgICAgICByZXR1cm4gRE9DVU1FTlRfTU9ERS5RVUlSS1M7XG5cbiAgICAgICAgcHJlZml4ZXMgPSBzeXN0ZW1JZCA9PT0gbnVsbCA/IExJTUlURURfUVVJUktTX1BVQkxJQ19JRF9QUkVGSVhFUyA6IExJTUlURURfUVVJUktTX1dJVEhfU1lTVEVNX0lEX1BVQkxJQ19JRF9QUkVGSVhFUztcblxuICAgICAgICBpZiAoaGFzUHJlZml4KHB1YmxpY0lkLCBwcmVmaXhlcykpXG4gICAgICAgICAgICByZXR1cm4gRE9DVU1FTlRfTU9ERS5MSU1JVEVEX1FVSVJLUztcbiAgICB9XG5cbiAgICByZXR1cm4gRE9DVU1FTlRfTU9ERS5OT19RVUlSS1M7XG59O1xuXG5leHBvcnRzLnNlcmlhbGl6ZUNvbnRlbnQgPSBmdW5jdGlvbiAobmFtZSwgcHVibGljSWQsIHN5c3RlbUlkKSB7XG4gICAgdmFyIHN0ciA9ICchRE9DVFlQRSAnO1xuXG4gICAgaWYgKG5hbWUpXG4gICAgICAgIHN0ciArPSBuYW1lO1xuXG4gICAgaWYgKHB1YmxpY0lkICE9PSBudWxsKVxuICAgICAgICBzdHIgKz0gJyBQVUJMSUMgJyArIGVucXVvdGVEb2N0eXBlSWQocHVibGljSWQpO1xuXG4gICAgZWxzZSBpZiAoc3lzdGVtSWQgIT09IG51bGwpXG4gICAgICAgIHN0ciArPSAnIFNZU1RFTSc7XG5cbiAgICBpZiAoc3lzdGVtSWQgIT09IG51bGwpXG4gICAgICAgIHN0ciArPSAnICcgKyBlbnF1b3RlRG9jdHlwZUlkKHN5c3RlbUlkKTtcblxuICAgIHJldHVybiBzdHI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlNS9saWIvY29tbW9uL2RvY3R5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VPcHRpb25zKGRlZmF1bHRzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHJldHVybiBbZGVmYXVsdHMsIG9wdGlvbnNdLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBvcHRPYmopIHtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0T2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIG1lcmdlZFtrZXldID0gb3B0T2JqW2tleV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlNS9saWIvY29tbW9uL21lcmdlX29wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpLFxuICAgIFNlcmlhbGl6ZXIgPSByZXF1aXJlKCcuL3NlcmlhbGl6ZXInKTtcblxuXG4vLyBTaG9ydGhhbmRzXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoaHRtbCwgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZShodG1sKTtcbn07XG5cbmV4cG9ydHMucGFyc2VGcmFnbWVudCA9IGZ1bmN0aW9uIHBhcnNlRnJhZ21lbnQoZnJhZ21lbnRDb250ZXh0LCBodG1sLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBmcmFnbWVudENvbnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMgPSBodG1sO1xuICAgICAgICBodG1sID0gZnJhZ21lbnRDb250ZXh0O1xuICAgICAgICBmcmFnbWVudENvbnRleHQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZUZyYWdtZW50KGh0bWwsIGZyYWdtZW50Q29udGV4dCk7XG59O1xuXG5leHBvcnRzLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gICAgdmFyIHNlcmlhbGl6ZXIgPSBuZXcgU2VyaWFsaXplcihub2RlLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBzZXJpYWxpemVyLnNlcmlhbGl6ZSgpO1xufTtcblxuXG4vLyBUcmVlIGFkYXB0ZXJzXG5leHBvcnRzLnRyZWVBZGFwdGVycyA9IHtcbiAgICBkZWZhdWx0OiByZXF1aXJlKCcuL3RyZWVfYWRhcHRlcnMvZGVmYXVsdCcpLFxuICAgIGh0bWxwYXJzZXIyOiByZXF1aXJlKCcuL3RyZWVfYWRhcHRlcnMvaHRtbHBhcnNlcjInKVxufTtcblxuXG4vLyBTdHJlYW1pbmdcbmV4cG9ydHMuUGFyc2VyU3RyZWFtID0gcmVxdWlyZSgnLi9wYXJzZXIvcGFyc2VyX3N0cmVhbScpO1xuZXhwb3J0cy5QbGFpblRleHRDb252ZXJzaW9uU3RyZWFtID0gcmVxdWlyZSgnLi9wYXJzZXIvcGxhaW5fdGV4dF9jb252ZXJzaW9uX3N0cmVhbScpO1xuZXhwb3J0cy5TZXJpYWxpemVyU3RyZWFtID0gcmVxdWlyZSgnLi9zZXJpYWxpemVyL3NlcmlhbGl6ZXJfc3RyZWFtJyk7XG5leHBvcnRzLlNBWFBhcnNlciA9IHJlcXVpcmUoJy4vc2F4Jyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFyc2U1L2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPQ1VNRU5UX01PREUgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbCcpLkRPQ1VNRU5UX01PREU7XG5cbi8vTm9kZSBjb25zdHJ1Y3Rpb25cbmV4cG9ydHMuY3JlYXRlRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZU5hbWU6ICcjZG9jdW1lbnQnLFxuICAgICAgICBtb2RlOiBET0NVTUVOVF9NT0RFLk5PX1FVSVJLUyxcbiAgICAgICAgY2hpbGROb2RlczogW11cbiAgICB9O1xufTtcblxuZXhwb3J0cy5jcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVOYW1lOiAnI2RvY3VtZW50LWZyYWdtZW50JyxcbiAgICAgICAgY2hpbGROb2RlczogW11cbiAgICB9O1xufTtcblxuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWVzcGFjZVVSSSwgYXR0cnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBub2RlTmFtZTogdGFnTmFtZSxcbiAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgICAgYXR0cnM6IGF0dHJzLFxuICAgICAgICBuYW1lc3BhY2VVUkk6IG5hbWVzcGFjZVVSSSxcbiAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgIHBhcmVudE5vZGU6IG51bGxcbiAgICB9O1xufTtcblxuZXhwb3J0cy5jcmVhdGVDb21tZW50Tm9kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZU5hbWU6ICcjY29tbWVudCcsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHBhcmVudE5vZGU6IG51bGxcbiAgICB9O1xufTtcblxudmFyIGNyZWF0ZVRleHROb2RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZU5hbWU6ICcjdGV4dCcsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgcGFyZW50Tm9kZTogbnVsbFxuICAgIH07XG59O1xuXG5cbi8vVHJlZSBtdXRhdGlvblxudmFyIGFwcGVuZENoaWxkID0gZXhwb3J0cy5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChwYXJlbnROb2RlLCBuZXdOb2RlKSB7XG4gICAgcGFyZW50Tm9kZS5jaGlsZE5vZGVzLnB1c2gobmV3Tm9kZSk7XG4gICAgbmV3Tm9kZS5wYXJlbnROb2RlID0gcGFyZW50Tm9kZTtcbn07XG5cbnZhciBpbnNlcnRCZWZvcmUgPSBleHBvcnRzLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgdmFyIGluc2VydGlvbklkeCA9IHBhcmVudE5vZGUuY2hpbGROb2Rlcy5pbmRleE9mKHJlZmVyZW5jZU5vZGUpO1xuXG4gICAgcGFyZW50Tm9kZS5jaGlsZE5vZGVzLnNwbGljZShpbnNlcnRpb25JZHgsIDAsIG5ld05vZGUpO1xuICAgIG5ld05vZGUucGFyZW50Tm9kZSA9IHBhcmVudE5vZGU7XG59O1xuXG5leHBvcnRzLnNldFRlbXBsYXRlQ29udGVudCA9IGZ1bmN0aW9uICh0ZW1wbGF0ZUVsZW1lbnQsIGNvbnRlbnRFbGVtZW50KSB7XG4gICAgdGVtcGxhdGVFbGVtZW50LmNvbnRlbnQgPSBjb250ZW50RWxlbWVudDtcbn07XG5cbmV4cG9ydHMuZ2V0VGVtcGxhdGVDb250ZW50ID0gZnVuY3Rpb24gKHRlbXBsYXRlRWxlbWVudCkge1xuICAgIHJldHVybiB0ZW1wbGF0ZUVsZW1lbnQuY29udGVudDtcbn07XG5cbmV4cG9ydHMuc2V0RG9jdW1lbnRUeXBlID0gZnVuY3Rpb24gKGRvY3VtZW50LCBuYW1lLCBwdWJsaWNJZCwgc3lzdGVtSWQpIHtcbiAgICB2YXIgZG9jdHlwZU5vZGUgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2N1bWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5jaGlsZE5vZGVzW2ldLm5vZGVOYW1lID09PSAnI2RvY3VtZW50VHlwZScpIHtcbiAgICAgICAgICAgIGRvY3R5cGVOb2RlID0gZG9jdW1lbnQuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRvY3R5cGVOb2RlKSB7XG4gICAgICAgIGRvY3R5cGVOb2RlLm5hbWUgPSBuYW1lO1xuICAgICAgICBkb2N0eXBlTm9kZS5wdWJsaWNJZCA9IHB1YmxpY0lkO1xuICAgICAgICBkb2N0eXBlTm9kZS5zeXN0ZW1JZCA9IHN5c3RlbUlkO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgICBhcHBlbmRDaGlsZChkb2N1bWVudCwge1xuICAgICAgICAgICAgbm9kZU5hbWU6ICcjZG9jdW1lbnRUeXBlJyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBwdWJsaWNJZDogcHVibGljSWQsXG4gICAgICAgICAgICBzeXN0ZW1JZDogc3lzdGVtSWRcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuZXhwb3J0cy5zZXREb2N1bWVudE1vZGUgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIG1vZGUpIHtcbiAgICBkb2N1bWVudC5tb2RlID0gbW9kZTtcbn07XG5cbmV4cG9ydHMuZ2V0RG9jdW1lbnRNb2RlID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50Lm1vZGU7XG59O1xuXG5leHBvcnRzLmRldGFjaE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdmFyIGlkeCA9IG5vZGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzLmluZGV4T2Yobm9kZSk7XG5cbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZSA9IG51bGw7XG4gICAgfVxufTtcblxuZXhwb3J0cy5pbnNlcnRUZXh0ID0gZnVuY3Rpb24gKHBhcmVudE5vZGUsIHRleHQpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgcHJldk5vZGUgPSBwYXJlbnROb2RlLmNoaWxkTm9kZXNbcGFyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChwcmV2Tm9kZS5ub2RlTmFtZSA9PT0gJyN0ZXh0Jykge1xuICAgICAgICAgICAgcHJldk5vZGUudmFsdWUgKz0gdGV4dDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFwcGVuZENoaWxkKHBhcmVudE5vZGUsIGNyZWF0ZVRleHROb2RlKHRleHQpKTtcbn07XG5cbmV4cG9ydHMuaW5zZXJ0VGV4dEJlZm9yZSA9IGZ1bmN0aW9uIChwYXJlbnROb2RlLCB0ZXh0LCByZWZlcmVuY2VOb2RlKSB7XG4gICAgdmFyIHByZXZOb2RlID0gcGFyZW50Tm9kZS5jaGlsZE5vZGVzW3BhcmVudE5vZGUuY2hpbGROb2Rlcy5pbmRleE9mKHJlZmVyZW5jZU5vZGUpIC0gMV07XG5cbiAgICBpZiAocHJldk5vZGUgJiYgcHJldk5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCcpXG4gICAgICAgIHByZXZOb2RlLnZhbHVlICs9IHRleHQ7XG4gICAgZWxzZVxuICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50Tm9kZSwgY3JlYXRlVGV4dE5vZGUodGV4dCksIHJlZmVyZW5jZU5vZGUpO1xufTtcblxuZXhwb3J0cy5hZG9wdEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAocmVjaXBpZW50LCBhdHRycykge1xuICAgIHZhciByZWNpcGllbnRBdHRyc01hcCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNpcGllbnQuYXR0cnMubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlY2lwaWVudEF0dHJzTWFwLnB1c2gocmVjaXBpZW50LmF0dHJzW2ldLm5hbWUpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhdHRycy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVjaXBpZW50QXR0cnNNYXAuaW5kZXhPZihhdHRyc1tqXS5uYW1lKSA9PT0gLTEpXG4gICAgICAgICAgICByZWNpcGllbnQuYXR0cnMucHVzaChhdHRyc1tqXSk7XG4gICAgfVxufTtcblxuXG4vL1RyZWUgdHJhdmVyc2luZ1xuZXhwb3J0cy5nZXRGaXJzdENoaWxkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzWzBdO1xufTtcblxuZXhwb3J0cy5nZXRDaGlsZE5vZGVzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzO1xufTtcblxuZXhwb3J0cy5nZXRQYXJlbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlO1xufTtcblxuZXhwb3J0cy5nZXRBdHRyTGlzdCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuYXR0cnM7XG59O1xuXG4vL05vZGUgZGF0YVxuZXhwb3J0cy5nZXRUYWdOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC50YWdOYW1lO1xufTtcblxuZXhwb3J0cy5nZXROYW1lc3BhY2VVUkkgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50Lm5hbWVzcGFjZVVSSTtcbn07XG5cbmV4cG9ydHMuZ2V0VGV4dE5vZGVDb250ZW50ID0gZnVuY3Rpb24gKHRleHROb2RlKSB7XG4gICAgcmV0dXJuIHRleHROb2RlLnZhbHVlO1xufTtcblxuZXhwb3J0cy5nZXRDb21tZW50Tm9kZUNvbnRlbnQgPSBmdW5jdGlvbiAoY29tbWVudE5vZGUpIHtcbiAgICByZXR1cm4gY29tbWVudE5vZGUuZGF0YTtcbn07XG5cbmV4cG9ydHMuZ2V0RG9jdW1lbnRUeXBlTm9kZU5hbWUgPSBmdW5jdGlvbiAoZG9jdHlwZU5vZGUpIHtcbiAgICByZXR1cm4gZG9jdHlwZU5vZGUubmFtZTtcbn07XG5cbmV4cG9ydHMuZ2V0RG9jdW1lbnRUeXBlTm9kZVB1YmxpY0lkID0gZnVuY3Rpb24gKGRvY3R5cGVOb2RlKSB7XG4gICAgcmV0dXJuIGRvY3R5cGVOb2RlLnB1YmxpY0lkO1xufTtcblxuZXhwb3J0cy5nZXREb2N1bWVudFR5cGVOb2RlU3lzdGVtSWQgPSBmdW5jdGlvbiAoZG9jdHlwZU5vZGUpIHtcbiAgICByZXR1cm4gZG9jdHlwZU5vZGUuc3lzdGVtSWQ7XG59O1xuXG4vL05vZGUgdHlwZXNcbmV4cG9ydHMuaXNUZXh0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCc7XG59O1xuXG5leHBvcnRzLmlzQ29tbWVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVOYW1lID09PSAnI2NvbW1lbnQnO1xufTtcblxuZXhwb3J0cy5pc0RvY3VtZW50VHlwZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVOYW1lID09PSAnI2RvY3VtZW50VHlwZSc7XG59O1xuXG5leHBvcnRzLmlzRWxlbWVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiAhIW5vZGUudGFnTmFtZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFyc2U1L2xpYi90cmVlX2FkYXB0ZXJzL2RlZmF1bHQuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xudmFyIG9mXzEgPSByZXF1aXJlKCcuL29mJyk7XG52YXIgZnJvbV8xID0gcmVxdWlyZSgnLi9mcm9tJyk7XG52YXIgY29uY2F0QWxsXzEgPSByZXF1aXJlKCcuLi9vcGVyYXRvcnMvY29uY2F0QWxsJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDcmVhdGVzIGFuIG91dHB1dCBPYnNlcnZhYmxlIHdoaWNoIHNlcXVlbnRpYWxseSBlbWl0cyBhbGwgdmFsdWVzIGZyb20gZ2l2ZW5cbiAqIE9ic2VydmFibGUgYW5kIHRoZW4gbW92ZXMgb24gdG8gdGhlIG5leHQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbmNhdGVuYXRlcyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciBieVxuICogc2VxdWVudGlhbGx5IGVtaXR0aW5nIHRoZWlyIHZhbHVlcywgb25lIE9ic2VydmFibGUgYWZ0ZXIgdGhlIG90aGVyLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbmNhdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgY29uY2F0YCBqb2lucyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciwgYnkgc3Vic2NyaWJpbmcgdG8gdGhlbSBvbmUgYXQgYSB0aW1lIGFuZFxuICogbWVyZ2luZyB0aGVpciByZXN1bHRzIGludG8gdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBZb3UgY2FuIHBhc3MgZWl0aGVyIGFuIGFycmF5IG9mXG4gKiBPYnNlcnZhYmxlcywgb3IgcHV0IHRoZW0gZGlyZWN0bHkgYXMgYXJndW1lbnRzLiBQYXNzaW5nIGFuIGVtcHR5IGFycmF5IHdpbGwgcmVzdWx0XG4gKiBpbiBPYnNlcnZhYmxlIHRoYXQgY29tcGxldGVzIGltbWVkaWF0ZWx5LlxuICpcbiAqIGBjb25jYXRgIHdpbGwgc3Vic2NyaWJlIHRvIGZpcnN0IGlucHV0IE9ic2VydmFibGUgYW5kIGVtaXQgYWxsIGl0cyB2YWx1ZXMsIHdpdGhvdXRcbiAqIGNoYW5naW5nIG9yIGFmZmVjdGluZyB0aGVtIGluIGFueSB3YXkuIFdoZW4gdGhhdCBPYnNlcnZhYmxlIGNvbXBsZXRlcywgaXQgd2lsbFxuICogc3Vic2NyaWJlIHRvIHRoZW4gbmV4dCBPYnNlcnZhYmxlIHBhc3NlZCBhbmQsIGFnYWluLCBlbWl0IGl0cyB2YWx1ZXMuIFRoaXMgd2lsbCBiZVxuICogcmVwZWF0ZWQsIHVudGlsIHRoZSBvcGVyYXRvciBydW5zIG91dCBvZiBPYnNlcnZhYmxlcy4gV2hlbiBsYXN0IGlucHV0IE9ic2VydmFibGUgY29tcGxldGVzLFxuICogYGNvbmNhdGAgd2lsbCBjb21wbGV0ZSBhcyB3ZWxsLiBBdCBhbnkgZ2l2ZW4gbW9tZW50IG9ubHkgb25lIE9ic2VydmFibGUgcGFzc2VkIHRvIG9wZXJhdG9yXG4gKiBlbWl0cyB2YWx1ZXMuIElmIHlvdSB3b3VsZCBsaWtlIHRvIGVtaXQgdmFsdWVzIGZyb20gcGFzc2VkIE9ic2VydmFibGVzIGNvbmN1cnJlbnRseSwgY2hlY2sgb3V0XG4gKiB7QGxpbmsgbWVyZ2V9IGluc3RlYWQsIGVzcGVjaWFsbHkgd2l0aCBvcHRpb25hbCBgY29uY3VycmVudGAgcGFyYW1ldGVyLiBBcyBhIG1hdHRlciBvZiBmYWN0LFxuICogYGNvbmNhdGAgaXMgYW4gZXF1aXZhbGVudCBvZiBgbWVyZ2VgIG9wZXJhdG9yIHdpdGggYGNvbmN1cnJlbnRgIHBhcmFtZXRlciBzZXQgdG8gYDFgLlxuICpcbiAqIE5vdGUgdGhhdCBpZiBzb21lIGlucHV0IE9ic2VydmFibGUgbmV2ZXIgY29tcGxldGVzLCBgY29uY2F0YCB3aWxsIGFsc28gbmV2ZXIgY29tcGxldGVcbiAqIGFuZCBPYnNlcnZhYmxlcyBmb2xsb3dpbmcgdGhlIG9uZSB0aGF0IGRpZCBub3QgY29tcGxldGUgd2lsbCBuZXZlciBiZSBzdWJzY3JpYmVkLiBPbiB0aGUgb3RoZXJcbiAqIGhhbmQsIGlmIHNvbWUgT2JzZXJ2YWJsZSBzaW1wbHkgY29tcGxldGVzIGltbWVkaWF0ZWx5IGFmdGVyIGl0IGlzIHN1YnNjcmliZWQsIGl0IHdpbGwgYmVcbiAqIGludmlzaWJsZSBmb3IgYGNvbmNhdGAsIHdoaWNoIHdpbGwganVzdCBtb3ZlIG9uIHRvIHRoZSBuZXh0IE9ic2VydmFibGUuXG4gKlxuICogSWYgYW55IE9ic2VydmFibGUgaW4gY2hhaW4gZXJyb3JzLCBpbnN0ZWFkIG9mIHBhc3NpbmcgY29udHJvbCB0byB0aGUgbmV4dCBPYnNlcnZhYmxlLFxuICogYGNvbmNhdGAgd2lsbCBlcnJvciBpbW1lZGlhdGVseSBhcyB3ZWxsLiBPYnNlcnZhYmxlcyB0aGF0IHdvdWxkIGJlIHN1YnNjcmliZWQgYWZ0ZXJcbiAqIHRoZSBvbmUgdGhhdCBlbWl0dGVkIGVycm9yLCBuZXZlciB3aWxsLlxuICpcbiAqIElmIHlvdSBwYXNzIHRvIGBjb25jYXRgIHRoZSBzYW1lIE9ic2VydmFibGUgbWFueSB0aW1lcywgaXRzIHN0cmVhbSBvZiB2YWx1ZXNcbiAqIHdpbGwgYmUgXCJyZXBsYXllZFwiIG9uIGV2ZXJ5IHN1YnNjcmlwdGlvbiwgd2hpY2ggbWVhbnMgeW91IGNhbiByZXBlYXQgZ2l2ZW4gT2JzZXJ2YWJsZVxuICogYXMgbWFueSB0aW1lcyBhcyB5b3UgbGlrZS4gSWYgcGFzc2luZyB0aGUgc2FtZSBPYnNlcnZhYmxlIHRvIGBjb25jYXRgIDEwMDAgdGltZXMgYmVjb21lcyB0ZWRpb3VzLFxuICogeW91IGNhbiBhbHdheXMgdXNlIHtAbGluayByZXBlYXR9LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIGEgdGltZXIgY291bnRpbmcgZnJvbSAwIHRvIDMgd2l0aCBhIHN5bmNocm9ub3VzIHNlcXVlbmNlIGZyb20gMSB0byAxMDwvY2FwdGlvbj5cbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg0KTtcbiAqIHZhciBzZXF1ZW5jZSA9IFJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgMTApO1xuICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuY29uY2F0KHRpbWVyLCBzZXF1ZW5jZSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIHJlc3VsdHMgaW46XG4gKiAvLyAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAyIC0xMDAwbXMtPiAzIC1pbW1lZGlhdGUtPiAxIC4uLiAxMFxuICpcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db25jYXRlbmF0ZSBhbiBhcnJheSBvZiAzIE9ic2VydmFibGVzPC9jYXB0aW9uPlxuICogdmFyIHRpbWVyMSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgxMCk7XG4gKiB2YXIgdGltZXIyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgyMDAwKS50YWtlKDYpO1xuICogdmFyIHRpbWVyMyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKS50YWtlKDEwKTtcbiAqIHZhciByZXN1bHQgPSBSeC5PYnNlcnZhYmxlLmNvbmNhdChbdGltZXIxLCB0aW1lcjIsIHRpbWVyM10pOyAvLyBub3RlIHRoYXQgYXJyYXkgaXMgcGFzc2VkXG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIHJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIChQcmludHMgdG8gY29uc29sZSBzZXF1ZW50aWFsbHkpXG4gKiAvLyAtMTAwMG1zLT4gMCAtMTAwMG1zLT4gMSAtMTAwMG1zLT4gLi4uIDlcbiAqIC8vIC0yMDAwbXMtPiAwIC0yMDAwbXMtPiAxIC0yMDAwbXMtPiAuLi4gNVxuICogLy8gLTUwMG1zLT4gMCAtNTAwbXMtPiAxIC01MDBtcy0+IC4uLiA5XG4gKlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIHRoZSBzYW1lIE9ic2VydmFibGUgdG8gcmVwZWF0IGl0PC9jYXB0aW9uPlxuICogY29uc3QgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMik7XG4gKlxuICogUnguT2JzZXJ2YWJsZS5jb25jYXQodGltZXIsIHRpbWVyKSAvLyBjb25jYXRpbmcgdGhlIHNhbWUgT2JzZXJ2YWJsZSFcbiAqIC5zdWJzY3JpYmUoXG4gKiAgIHZhbHVlID0+IGNvbnNvbGUubG9nKHZhbHVlKSxcbiAqICAgZXJyID0+IHt9LFxuICogICAoKSA9PiBjb25zb2xlLmxvZygnLi4uYW5kIGl0IGlzIGRvbmUhJylcbiAqICk7XG4gKlxuICogLy8gTG9nczpcbiAqIC8vIDAgYWZ0ZXIgMXNcbiAqIC8vIDEgYWZ0ZXIgMnNcbiAqIC8vIDAgYWZ0ZXIgM3NcbiAqIC8vIDEgYWZ0ZXIgNHNcbiAqIC8vIFwiLi4uYW5kIGl0IGlzIGRvbmUhXCIgYWxzbyBhZnRlciA0c1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcFRvfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBpbnB1dDEgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBjb25jYXRlbmF0ZSB3aXRoIG90aGVycy5cbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBpbnB1dDIgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBjb25jYXRlbmF0ZSB3aXRoIG90aGVycy5cbiAqIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gQW4gb3B0aW9uYWwgSVNjaGVkdWxlciB0byBzY2hlZHVsZSBlYWNoXG4gKiBPYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFsbCB2YWx1ZXMgb2YgZWFjaCBwYXNzZWQgT2JzZXJ2YWJsZSBtZXJnZWQgaW50byBhXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgaW4gb3JkZXIsIGluIHNlcmlhbCBmYXNoaW9uLlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBjb25jYXRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKG9ic2VydmFibGVzLmxlbmd0aCA9PT0gMSB8fCAob2JzZXJ2YWJsZXMubGVuZ3RoID09PSAyICYmIGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIob2JzZXJ2YWJsZXNbMV0pKSkge1xuICAgICAgICByZXR1cm4gZnJvbV8xLmZyb20ob2JzZXJ2YWJsZXNbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0QWxsXzEuY29uY2F0QWxsKCkob2ZfMS5vZi5hcHBseSh2b2lkIDAsIG9ic2VydmFibGVzKSk7XG59XG5leHBvcnRzLmNvbmNhdCA9IGNvbmNhdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vYnNlcnZhYmxlL2NvbmNhdC5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvcm9vdC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg4KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0VtcHR5T2JzZXJ2YWJsZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg4OSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL21hcC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg5Nik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvci5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjQuMy42XG4gKiAoYykgMjAxMC0yMDE3IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInKSwgcmVxdWlyZSgnQGFuZ3VsYXIvYW5pbWF0aW9ucy9icm93c2VyJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvbW1vbicpLCByZXF1aXJlKCdAYW5ndWxhci9jb21tb24vaHR0cCcpLCByZXF1aXJlKCdAYW5ndWxhci9jb21waWxlcicpLCByZXF1aXJlKCdAYW5ndWxhci9odHRwJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucycpLCByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKSwgcmVxdWlyZSgncnhqcy9TdWJqZWN0JyksIHJlcXVpcmUoJ3VybCcpLCByZXF1aXJlKCdyeGpzL29wZXJhdG9yL2ZpbHRlcicpLCByZXF1aXJlKCdyeGpzL29wZXJhdG9yL2ZpcnN0JyksIHJlcXVpcmUoJ3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlJykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb3JlJywgJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInLCAnQGFuZ3VsYXIvYW5pbWF0aW9ucy9icm93c2VyJywgJ0Bhbmd1bGFyL2NvbW1vbicsICdAYW5ndWxhci9jb21tb24vaHR0cCcsICdAYW5ndWxhci9jb21waWxlcicsICdAYW5ndWxhci9odHRwJywgJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucycsICdyeGpzL09ic2VydmFibGUnLCAncnhqcy9TdWJqZWN0JywgJ3VybCcsICdyeGpzL29wZXJhdG9yL2ZpbHRlcicsICdyeGpzL29wZXJhdG9yL2ZpcnN0JywgJ3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5uZyA9IGdsb2JhbC5uZyB8fCB7fSwgZ2xvYmFsLm5nLnBsYXRmb3JtU2VydmVyID0gZ2xvYmFsLm5nLnBsYXRmb3JtU2VydmVyIHx8IHt9KSxnbG9iYWwubmcuY29yZSxnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyLGdsb2JhbC5fYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIsZ2xvYmFsLm5nLmNvbW1vbixnbG9iYWwuX2FuZ3VsYXJfY29tbW9uX2h0dHAsZ2xvYmFsLm5nLmNvbXBpbGVyLGdsb2JhbC5fYW5ndWxhcl9odHRwLGdsb2JhbC5fYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXJfYW5pbWF0aW9ucyxnbG9iYWwuUngsZ2xvYmFsLlJ4LGdsb2JhbC51cmwsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvcmUsX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3NlcixfYW5ndWxhcl9jb21tb24sX2FuZ3VsYXJfY29tbW9uX2h0dHAsX2FuZ3VsYXJfY29tcGlsZXIsX2FuZ3VsYXJfaHR0cCxfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXJfYW5pbWF0aW9ucyxyeGpzX09ic2VydmFibGUscnhqc19TdWJqZWN0LHVybCxyeGpzX29wZXJhdG9yX2ZpbHRlcixyeGpzX29wZXJhdG9yX2ZpcnN0LHJ4anNfb3BlcmF0b3JfdG9Qcm9taXNlKSB7ICd1c2Ugc3RyaWN0JztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cblxuLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHY0LjMuNlxuICogKGMpIDIwMTAtMjAxNyBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBwYXJzZTUgPSByZXF1aXJlKCdwYXJzZTUnKTtcbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgcGxhdGZvcm0gc3RhdGUuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBQbGF0Zm9ybVN0YXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kb2NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQbGF0Zm9ybVN0YXRlKF9kb2MpIHtcbiAgICAgICAgdGhpcy5fZG9jID0gX2RvYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcGxhdGZvcm0gdG8gc3RyaW5nLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGxhdGZvcm1TdGF0ZS5wcm90b3R5cGUucmVuZGVyVG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5nZXRJbm5lckhUTUwodGhpcy5fZG9jKTsgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IERPTSBzdGF0ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBsYXRmb3JtU3RhdGUucHJvdG90eXBlLmdldERvY3VtZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZG9jOyB9O1xuICAgIHJldHVybiBQbGF0Zm9ybVN0YXRlO1xufSgpKTtcblBsYXRmb3JtU3RhdGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuUGxhdGZvcm1TdGF0ZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRE9DVU1FTlQsXSB9LF0gfSxcbl07IH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgeGhyMiA9IHJlcXVpcmUoJ3hocjInKTtcbnZhciBpc0Fic29sdXRlVXJsID0gL15bYS16QS1aXFwtXFwrLl0rOlxcL1xcLy87XG4vKipcbiAqIEBwYXJhbSB7P30gdXJsXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJlcXVlc3RVcmwodXJsJCQxKSB7XG4gICAgaWYgKCFpc0Fic29sdXRlVXJsLnRlc3QodXJsJCQxKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUkxzIHJlcXVlc3RlZCB2aWEgSHR0cCBvbiB0aGUgc2VydmVyIG11c3QgYmUgYWJzb2x1dGUuIFVSTDogXCIgKyB1cmwkJDEpO1xuICAgIH1cbn1cbnZhciBTZXJ2ZXJYaHIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcnZlclhocigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJ2ZXJYaHIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IHhocjIuWE1MSHR0cFJlcXVlc3QoKTsgfTtcbiAgICByZXR1cm4gU2VydmVyWGhyO1xufSgpKTtcblNlcnZlclhoci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5TZXJ2ZXJYaHIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbnZhciBTZXJ2ZXJYc3JmU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcnZlclhzcmZTdHJhdGVneSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcnZlclhzcmZTdHJhdGVneS5wcm90b3R5cGUuY29uZmlndXJlUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXEpIHsgfTtcbiAgICByZXR1cm4gU2VydmVyWHNyZlN0cmF0ZWd5O1xufSgpKTtcblNlcnZlclhzcmZTdHJhdGVneS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5TZXJ2ZXJYc3JmU3RyYXRlZ3kuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBab25lTWFjcm9UYXNrV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWm9uZU1hY3JvVGFza1dyYXBwZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWm9uZU1hY3JvVGFza1dyYXBwZXIucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFzayA9ICgobnVsbCkpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdWIgPSBudWxsO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2F2ZWRSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2F2ZWRFcnJvciA9IG51bGw7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2hlZHVsZVRhc2sgPSBmdW5jdGlvbiAoX3Rhc2spIHtcbiAgICAgICAgICAgICAgICB0YXNrID0gX3Rhc2s7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWxlZ2F0ZSA9IF90aGlzLmRlbGVnYXRlKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHN1YiA9IGRlbGVnYXRlLnN1YnNjcmliZShmdW5jdGlvbiAocmVzKSB7IHJldHVybiBzYXZlZFJlc3VsdCA9IHJlczsgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBodHRwIG9ic2VydmFibGUgd2FzIGNvbXBsZXRlZCB0d2ljZS4gVGhpcyBzaG91bGRuXFwndCBoYXBwZW4sIHBsZWFzZSBmaWxlIGEgYnVnLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNhdmVkRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLmludm9rZSgpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gaHR0cCBvYnNlcnZhYmxlIHdhcyBjb21wbGV0ZWQgdHdpY2UuIFRoaXMgc2hvdWxkblxcJ3QgaGFwcGVuLCBwbGVhc2UgZmlsZSBhIGJ1Zy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5pbnZva2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYW5jZWxUYXNrID0gZnVuY3Rpb24gKF90YXNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICBzdWIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbkNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzYXZlZEVycm9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHNhdmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChzYXZlZFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIE1vY2tCYWNrZW5kIGZvciBIdHRwIGlzIHN5bmNocm9ub3VzLCB3aGljaCBtZWFucyB0aGF0IGlmIHNjaGVkdWxlVGFzayBpcyBieVxuICAgICAgICAgICAgLy8gc2NoZWR1bGVNYWNyb1Rhc2ssIHRoZSByZXF1ZXN0IHdpbGwgaGl0IE1vY2tCYWNrZW5kIGFuZCB0aGUgcmVzcG9uc2Ugd2lsbCBiZVxuICAgICAgICAgICAgLy8gc2VudCwgY2F1c2luZyB0YXNrLmludm9rZSgpIHRvIGJlIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIF90YXNrID0gWm9uZS5jdXJyZW50LnNjaGVkdWxlTWFjcm9UYXNrKCdab25lTWFjcm9UYXNrV3JhcHBlci5zdWJzY3JpYmUnLCBvbkNvbXBsZXRlLCB7fSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSwgY2FuY2VsVGFzayk7XG4gICAgICAgICAgICBzY2hlZHVsZVRhc2soX3Rhc2spO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZWR1bGVkICYmIHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzay56b25lLmNhbmNlbFRhc2sodGFzayk7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICBzdWIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSByZXF1ZXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBab25lTWFjcm9UYXNrV3JhcHBlci5wcm90b3R5cGUuZGVsZWdhdGUgPSBmdW5jdGlvbiAocmVxdWVzdCkgeyB9O1xuICAgIHJldHVybiBab25lTWFjcm9UYXNrV3JhcHBlcjtcbn0oKSk7XG52YXIgWm9uZU1hY3JvVGFza0Nvbm5lY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab25lTWFjcm9UYXNrQ29ubmVjdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gez99IGJhY2tlbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBab25lTWFjcm9UYXNrQ29ubmVjdGlvbihyZXF1ZXN0LCBiYWNrZW5kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICBfdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICAgICAgdmFsaWRhdGVSZXF1ZXN0VXJsKHJlcXVlc3QudXJsKTtcbiAgICAgICAgX3RoaXMucmVzcG9uc2UgPSBfdGhpcy53cmFwKHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWm9uZU1hY3JvVGFza0Nvbm5lY3Rpb24ucHJvdG90eXBlLmRlbGVnYXRlID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbiA9IHRoaXMuYmFja2VuZC5jcmVhdGVDb25uZWN0aW9uKHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gKHRoaXMubGFzdENvbm5lY3Rpb24ucmVzcG9uc2UpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFpvbmVNYWNyb1Rhc2tDb25uZWN0aW9uLnByb3RvdHlwZSwgXCJyZWFkeVN0YXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMubGFzdENvbm5lY3Rpb24gPyB0aGlzLmxhc3RDb25uZWN0aW9uLnJlYWR5U3RhdGUgOiBfYW5ndWxhcl9odHRwLlJlYWR5U3RhdGUuVW5zZW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gWm9uZU1hY3JvVGFza0Nvbm5lY3Rpb247XG59KFpvbmVNYWNyb1Rhc2tXcmFwcGVyKSk7XG52YXIgWm9uZU1hY3JvVGFza0JhY2tlbmQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYmFja2VuZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFpvbmVNYWNyb1Rhc2tCYWNrZW5kKGJhY2tlbmQpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXF1ZXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBab25lTWFjcm9UYXNrQmFja2VuZC5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9uZU1hY3JvVGFza0Nvbm5lY3Rpb24ocmVxdWVzdCwgdGhpcy5iYWNrZW5kKTtcbiAgICB9O1xuICAgIHJldHVybiBab25lTWFjcm9UYXNrQmFja2VuZDtcbn0oKSk7XG52YXIgWm9uZUNsaWVudEJhY2tlbmQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab25lQ2xpZW50QmFja2VuZCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGJhY2tlbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBab25lQ2xpZW50QmFja2VuZChiYWNrZW5kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJhY2tlbmQgPSBiYWNrZW5kO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWm9uZUNsaWVudEJhY2tlbmQucHJvdG90eXBlLmhhbmRsZSA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7IHJldHVybiB0aGlzLndyYXAocmVxdWVzdCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXF1ZXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBab25lQ2xpZW50QmFja2VuZC5wcm90b3R5cGUuZGVsZWdhdGUgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmhhbmRsZShyZXF1ZXN0KTtcbiAgICB9O1xuICAgIHJldHVybiBab25lQ2xpZW50QmFja2VuZDtcbn0oWm9uZU1hY3JvVGFza1dyYXBwZXIpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB4aHJCYWNrZW5kXG4gKiBAcGFyYW0gez99IG9wdGlvbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGh0dHBGYWN0b3J5KHhockJhY2tlbmQsIG9wdGlvbnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYWNyb0JhY2tlbmQgPSBuZXcgWm9uZU1hY3JvVGFza0JhY2tlbmQoeGhyQmFja2VuZCk7XG4gICAgcmV0dXJuIG5ldyBfYW5ndWxhcl9odHRwLkh0dHAobWFjcm9CYWNrZW5kLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBiYWNrZW5kXG4gKiBAcGFyYW0gez99IGludGVyY2VwdG9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gem9uZVdyYXBwZWRJbnRlcmNlcHRpbmdIYW5kbGVyKGJhY2tlbmQsIGludGVyY2VwdG9ycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlYWxCYWNrZW5kID0gX2FuZ3VsYXJfY29tbW9uX2h0dHAuybVpbnRlcmNlcHRpbmdIYW5kbGVyKGJhY2tlbmQsIGludGVyY2VwdG9ycyk7XG4gICAgcmV0dXJuIG5ldyBab25lQ2xpZW50QmFja2VuZChyZWFsQmFja2VuZCk7XG59XG52YXIgU0VSVkVSX0hUVFBfUFJPVklERVJTID0gW1xuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfaHR0cC5IdHRwLCB1c2VGYWN0b3J5OiBodHRwRmFjdG9yeSwgZGVwczogW19hbmd1bGFyX2h0dHAuWEhSQmFja2VuZCwgX2FuZ3VsYXJfaHR0cC5SZXF1ZXN0T3B0aW9uc10gfSxcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2h0dHAuQnJvd3NlclhociwgdXNlQ2xhc3M6IFNlcnZlclhociB9LCB7IHByb3ZpZGU6IF9hbmd1bGFyX2h0dHAuWFNSRlN0cmF0ZWd5LCB1c2VDbGFzczogU2VydmVyWHNyZlN0cmF0ZWd5IH0sXG4gICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb21tb25faHR0cC5YaHJGYWN0b3J5LCB1c2VDbGFzczogU2VydmVyWGhyIH0sIHtcbiAgICAgICAgcHJvdmlkZTogX2FuZ3VsYXJfY29tbW9uX2h0dHAuSHR0cEhhbmRsZXIsXG4gICAgICAgIHVzZUZhY3Rvcnk6IHpvbmVXcmFwcGVkSW50ZXJjZXB0aW5nSGFuZGxlcixcbiAgICAgICAgZGVwczogW19hbmd1bGFyX2NvbW1vbl9odHRwLkh0dHBCYWNrZW5kLCBbbmV3IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSwgX2FuZ3VsYXJfY29tbW9uX2h0dHAuSFRUUF9JTlRFUkNFUFRPUlNdXVxuICAgIH1cbl07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFRoZSBESSB0b2tlbiBmb3Igc2V0dGluZyB0aGUgaW5pdGlhbCBjb25maWcgZm9yIHRoZSBwbGF0Zm9ybS5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqL1xudmFyIElOSVRJQUxfQ09ORklHID0gbmV3IF9hbmd1bGFyX2NvcmUuSW5qZWN0aW9uVG9rZW4oJ1NlcnZlci5JTklUSUFMX0NPTkZJRycpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IHVybFN0clxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcGFyc2VVcmwodXJsU3RyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyc2VkVXJsID0gdXJsLnBhcnNlKHVybFN0cik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhcnNlZFVybC5wYXRobmFtZSB8fCAnJyxcbiAgICAgICAgc2VhcmNoOiBwYXJzZWRVcmwuc2VhcmNoIHx8ICcnLFxuICAgICAgICBoYXNoOiBwYXJzZWRVcmwuaGFzaCB8fCAnJyxcbiAgICB9O1xufVxuLyoqXG4gKiBTZXJ2ZXItc2lkZSBpbXBsZW1lbnRhdGlvbiBvZiBVUkwgc3RhdGUuIEltcGxlbWVudHMgYHBhdGhuYW1lYCwgYHNlYXJjaGAsIGFuZCBgaGFzaGBcbiAqIGJ1dCBub3QgdGhlIHN0YXRlIHN0YWNrLlxuICovXG52YXIgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZG9jXG4gICAgICogQHBhcmFtIHs/fSBfY29uZmlnXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2VydmVyUGxhdGZvcm1Mb2NhdGlvbihfZG9jLCBfY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2RvYyA9IF9kb2M7XG4gICAgICAgIHRoaXMuX3BhdGggPSAnLyc7XG4gICAgICAgIHRoaXMuX3NlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLl9oYXNoID0gJyc7XG4gICAgICAgIHRoaXMuX2hhc2hVcGRhdGUgPSBuZXcgcnhqc19TdWJqZWN0LlN1YmplY3QoKTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IF9jb25maWc7XG4gICAgICAgIGlmICghIWNvbmZpZyAmJiAhIWNvbmZpZy51cmwpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWRVcmwgPSBwYXJzZVVybChjb25maWcudXJsKTtcbiAgICAgICAgICAgIHRoaXMuX3BhdGggPSBwYXJzZWRVcmwucGF0aG5hbWU7XG4gICAgICAgICAgICB0aGlzLl9zZWFyY2ggPSBwYXJzZWRVcmwuc2VhcmNoO1xuICAgICAgICAgICAgdGhpcy5faGFzaCA9IHBhcnNlZFVybC5oYXNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUuZ2V0QmFzZUhyZWZGcm9tRE9NID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKChfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5nZXRCYXNlSHJlZih0aGlzLl9kb2MpKSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUub25Qb3BTdGF0ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAvLyBOby1vcDogYSBzdGF0ZSBzdGFjayBpcyBub3QgaW1wbGVtZW50ZWQsIHNvXG4gICAgICAgIC8vIG5vIGV2ZW50cyB3aWxsIGV2ZXIgY29tZS5cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLm9uSGFzaENoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9oYXNoVXBkYXRlLnN1YnNjcmliZShmbik7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcInBhdGhuYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhdGg7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJzZWFyY2hcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2VhcmNoOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwiaGFzaFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9oYXNoOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwidXJsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiXCIgKyB0aGlzLnBhdGhuYW1lICsgdGhpcy5zZWFyY2ggKyB0aGlzLmhhc2g7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG9sZFVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUuc2V0SGFzaCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2xkVXJsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9oYXNoID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgZmlyZSBldmVudHMgaWYgdGhlIGhhc2ggaGFzIG5vdCBjaGFuZ2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hhc2ggPSB2YWx1ZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3VXJsID0gdGhpcy51cmw7XG4gICAgICAgIHNjaGVkdWxlTWljcm9UYXNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9oYXNoVXBkYXRlLm5leHQoLyoqIEB0eXBlIHs/fSAqLyAoeyB0eXBlOiAnaGFzaGNoYW5nZScsIG9sZFVybDogb2xkVXJsLCBuZXdVcmw6IG5ld1VybCB9KSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7P30gdGl0bGVcbiAgICAgKiBAcGFyYW0gez99IG5ld1VybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgbmV3VXJsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZFVybCA9IHRoaXMudXJsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJzZWRVcmwgPSBwYXJzZVVybChuZXdVcmwpO1xuICAgICAgICB0aGlzLl9wYXRoID0gcGFyc2VkVXJsLnBhdGhuYW1lO1xuICAgICAgICB0aGlzLl9zZWFyY2ggPSBwYXJzZWRVcmwuc2VhcmNoO1xuICAgICAgICB0aGlzLnNldEhhc2gocGFyc2VkVXJsLmhhc2gsIG9sZFVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlXG4gICAgICogQHBhcmFtIHs/fSB0aXRsZVxuICAgICAqIEBwYXJhbSB7P30gbmV3VXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5wdXNoU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCBuZXdVcmwpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCBuZXdVcmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTsgfTtcbiAgICByZXR1cm4gU2VydmVyUGxhdGZvcm1Mb2NhdGlvbjtcbn0oKSk7XG5TZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblNlcnZlclBsYXRmb3JtTG9jYXRpb24uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkRPQ1VNRU5ULF0gfSxdIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW0lOSVRJQUxfQ09ORklHLF0gfSxdIH0sXG5dOyB9O1xuLyoqXG4gKiBAcGFyYW0gez99IGZuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzY2hlZHVsZU1pY3JvVGFzayhmbikge1xuICAgIFpvbmUuY3VycmVudC5zY2hlZHVsZU1pY3JvVGFzaygnc2NoZWR1bGVNaWNyb3Rhc2snLCBmbik7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgcGFyc2U1JDEgPSByZXF1aXJlKCdwYXJzZTUnKTtcbnZhciB0cmVlQWRhcHRlcjtcbnZhciBfYXR0clRvUHJvcE1hcCA9IHtcbiAgICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgICAnaW5uZXJIdG1sJzogJ2lubmVySFRNTCcsXG4gICAgJ3JlYWRvbmx5JzogJ3JlYWRPbmx5JyxcbiAgICAndGFiaW5kZXgnOiAndGFiSW5kZXgnLFxufTtcbnZhciBtYXBQcm9wcyA9IFsnYXR0cmlicycsICd4LWF0dHJpYnNOYW1lc3BhY2UnLCAneC1hdHRyaWJzUHJlZml4J107XG4vKipcbiAqIEBwYXJhbSB7P30gbWV0aG9kTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX25vdEltcGxlbWVudGVkKG1ldGhvZE5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gUGFyc2U1RG9tQWRhcHRlcjogJyArIG1ldGhvZE5hbWUpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGVsXG4gKiBAcGFyYW0gez99IG5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9nZXRFbGVtZW50KGVsLCBuYW1lKSB7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGVsLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZSA9IGVsLmNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBQYXJzZXMgYSBkb2N1bWVudCBzdHJpbmcgdG8gYSBEb2N1bWVudCBvYmplY3QuXG4gKiBAcGFyYW0gez99IGh0bWxcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHBhcnNlRG9jdW1lbnQoaHRtbCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRvYyA9IHBhcnNlNSQxLnBhcnNlKGh0bWwsIHsgdHJlZUFkYXB0ZXI6IHBhcnNlNSQxLnRyZWVBZGFwdGVycy5odG1scGFyc2VyMiB9KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkb2NFbGVtZW50ID0gX2dldEVsZW1lbnQoZG9jLCAnaHRtbCcpO1xuICAgIGRvY1snaGVhZCddID0gX2dldEVsZW1lbnQoZG9jRWxlbWVudCwgJ2hlYWQnKTtcbiAgICBkb2NbJ2JvZHknXSA9IF9nZXRFbGVtZW50KGRvY0VsZW1lbnQsICdib2R5Jyk7XG4gICAgZG9jWydfd2luZG93J10gPSB7fTtcbiAgICByZXR1cm4gZG9jO1xufVxuLyoqXG4gKiBBIGBEb21BZGFwdGVyYCBwb3dlcmVkIGJ5IHRoZSBgcGFyc2U1YCBOb2RlSlMgbW9kdWxlLlxuICpcbiAqIFxcQHNlY3VyaXR5IFRyZWFkIGNhcmVmdWxseSEgSW50ZXJhY3Rpbmcgd2l0aCB0aGUgRE9NIGRpcmVjdGx5IGlzIGRhbmdlcm91cyBhbmRcbiAqIGNhbiBpbnRyb2R1Y2UgWFNTIHJpc2tzLlxuICovXG52YXIgUGFyc2U1RG9tQWRhcHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhcnNlNURvbUFkYXB0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFyc2U1RG9tQWRhcHRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIubWFrZUN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyZWVBZGFwdGVyID0gcGFyc2U1JDEudHJlZUFkYXB0ZXJzLmh0bWxwYXJzZXIyO1xuICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVzZXRSb290RG9tQWRhcHRlcihuZXcgUGFyc2U1RG9tQWRhcHRlcigpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZUFcbiAgICAgKiBAcGFyYW0gez99IG5vZGVCXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChub2RlQSwgbm9kZUIpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXIgPSBub2RlQjtcbiAgICAgICAgd2hpbGUgKGlubmVyKSB7XG4gICAgICAgICAgICBpZiAoaW5uZXIgPT09IG5vZGVBKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaW5uZXIgPSBpbm5lci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5oYXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBfSFRNTEVsZW1lbnRQcm9wZXJ0eUxpc3QuaW5kZXhPZihuYW1lKSA+IC0xO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SW5uZXJIVE1MKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2lubmVyVGV4dCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VGV4dChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdjbGFzc05hbWUnKSB7XG4gICAgICAgICAgICBlbC5hdHRyaWJzWydjbGFzcyddID0gZWwuY2xhc3NOYW1lID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgcHJvcGVydHkgaW4gYSBzZXBhcmF0ZSBwcm9wZXJ0eSBiYWcgc28gdGhhdCBpdCBkb2Vzbid0IGNsb2JiZXJcbiAgICAgICAgICAgIC8vIGFjdHVhbCBwYXJzZTUgcHJvcGVydGllcyBvbiB0aGUgRWxlbWVudC5cbiAgICAgICAgICAgIGVsLnByb3BlcnRpZXMgPSBlbC5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgICAgICAgZWwucHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZWwucHJvcGVydGllcyA/IGVsLnByb3BlcnRpZXNbbmFtZV0gOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5sb2dFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikgeyBjb25zb2xlLmVycm9yKGVycm9yKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoZXJyb3IpIHsgY29uc29sZS5sb2coZXJyb3IpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmxvZ0dyb3VwID0gZnVuY3Rpb24gKGVycm9yKSB7IGNvbnNvbGUuZXJyb3IoZXJyb3IpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUubG9nR3JvdXBFbmQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLCBcImF0dHJUb1Byb3BNYXBcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX2F0dHJUb1Byb3BNYXA7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gKGVsLCBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKGVsLCBzZWxlY3RvcilbMF0gfHwgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsID0gZnVuY3Rpb24gKGVsLCBzZWxlY3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gX3JlY3Vyc2l2ZSA9IGZ1bmN0aW9uIChyZXN1bHQsIG5vZGUsIHNlbGVjdG9yLCBtYXRjaGVyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjTm9kZXMgPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBpZiAoY05vZGVzICYmIGNOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGNOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZE5vZGUgPSBjTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5lbGVtZW50TWF0Y2hlcyhjaGlsZE5vZGUsIHNlbGVjdG9yLCBtYXRjaGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfcmVjdXJzaXZlKHJlc3VsdCwgY2hpbGROb2RlLCBzZWxlY3RvciwgbWF0Y2hlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVyID0gbmV3IF9hbmd1bGFyX2NvbXBpbGVyLlNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICBtYXRjaGVyLmFkZFNlbGVjdGFibGVzKF9hbmd1bGFyX2NvbXBpbGVyLkNzc1NlbGVjdG9yLnBhcnNlKHNlbGVjdG9yKSk7XG4gICAgICAgIF9yZWN1cnNpdmUocmVzLCBlbCwgc2VsZWN0b3IsIG1hdGNoZXIpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7Pz19IG1hdGNoZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmVsZW1lbnRNYXRjaGVzID0gZnVuY3Rpb24gKG5vZGUsIHNlbGVjdG9yLCBtYXRjaGVyKSB7XG4gICAgICAgIGlmIChtYXRjaGVyID09PSB2b2lkIDApIHsgbWF0Y2hlciA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRoaXMuaXNFbGVtZW50Tm9kZShub2RlKSAmJiBzZWxlY3RvciA9PT0gJyonKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHNlbGVjdG9yICYmIHNlbGVjdG9yLmNoYXJBdCgwKSA9PSAnIycpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5vZGUsICdpZCcpID09IHNlbGVjdG9yLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVyKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlciA9IG5ldyBfYW5ndWxhcl9jb21waWxlci5TZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVyLmFkZFNlbGVjdGFibGVzKF9hbmd1bGFyX2NvbXBpbGVyLkNzc1NlbGVjdG9yLnBhcnNlKHNlbGVjdG9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjc3NTZWxlY3RvciA9IG5ldyBfYW5ndWxhcl9jb21waWxlci5Dc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgY3NzU2VsZWN0b3Iuc2V0RWxlbWVudCh0aGlzLnRhZ05hbWUobm9kZSkpO1xuICAgICAgICAgICAgaWYgKG5vZGUuYXR0cmlicykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0ck5hbWUgaW4gbm9kZS5hdHRyaWJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yLmFkZEF0dHJpYnV0ZShhdHRyTmFtZSwgbm9kZS5hdHRyaWJzW2F0dHJOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NMaXN0ID0gdGhpcy5jbGFzc0xpc3Qobm9kZSk7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgY2xhc3NMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3NzU2VsZWN0b3IuYWRkQ2xhc3NOYW1lKGNsYXNzTGlzdFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaGVyLm1hdGNoKGNzc1NlbGVjdG9yLCBmdW5jdGlvbiAoc2VsZWN0b3IsIGNiKSB7IHJlc3VsdCA9IHRydWU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBldnRcbiAgICAgKiBAcGFyYW0gez99IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChlbCwgZXZ0LCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaXN0ZW5lcnNNYXAgPSBlbC5fZXZlbnRMaXN0ZW5lcnNNYXA7XG4gICAgICAgIGlmICghbGlzdGVuZXJzTWFwKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNNYXAgPSB7fTtcbiAgICAgICAgICAgIGVsLl9ldmVudExpc3RlbmVyc01hcCA9IGxpc3RlbmVyc01hcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNNYXBbZXZ0XSB8fCBbXTtcbiAgICAgICAgbGlzdGVuZXJzTWFwW2V2dF0gPSBsaXN0ZW5lcnMuY29uY2F0KFtsaXN0ZW5lcl0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gZXZ0XG4gICAgICogQHBhcmFtIHs/fSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUub25BbmRDYW5jZWwgPSBmdW5jdGlvbiAoZWwsIGV2dCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5vbihlbCwgZXZ0LCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJlbW92ZSgvKiogQHR5cGUgez99ICovICgoZWwuX2V2ZW50TGlzdGVuZXJzTWFwW2V2dF0pKSwgbGlzdGVuZXIpOyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gZXZ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGVsLCBldnQpIHtcbiAgICAgICAgaWYgKCFldnQudGFyZ2V0KSB7XG4gICAgICAgICAgICBldnQudGFyZ2V0ID0gZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLl9ldmVudExpc3RlbmVyc01hcCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGlzdGVuZXJzID0gZWwuX2V2ZW50TGlzdGVuZXJzTWFwW2V2dC50eXBlXTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXShldnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZWwucGFyZW50LCBldnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbC5fd2luZG93KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZWwuX3dpbmRvdywgZXZ0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZU1vdXNlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7IHJldHVybiB0aGlzLmNyZWF0ZUV2ZW50KGV2ZW50VHlwZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudCA9ICh7XG4gICAgICAgICAgICB0eXBlOiBldmVudFR5cGUsXG4gICAgICAgICAgICBkZWZhdWx0UHJldmVudGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7ICgoZXZlbnQpKS5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTsgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoZXZlbnQpIHsgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5pc1ByZXZlbnRlZCA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQucmV0dXJuVmFsdWUgIT0gbnVsbCAmJiAhZXZlbnQucmV0dXJuVmFsdWU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBwYXJzZTUkMS5zZXJpYWxpemUodGhpcy50ZW1wbGF0ZUF3YXJlUm9vdChlbCksIHsgdHJlZUFkYXB0ZXI6IHRyZWVBZGFwdGVyIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VGVtcGxhdGVDb250ZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmdldE91dGVySFRNTCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmcmFnbWVudCA9IHRyZWVBZGFwdGVyLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChmcmFnbWVudCwgZWwpO1xuICAgICAgICByZXR1cm4gcGFyc2U1JDEuc2VyaWFsaXplKGZyYWdtZW50LCB7IHRyZWVBZGFwdGVyOiB0cmVlQWRhcHRlciB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUubm9kZU5hbWUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS50YWdOYW1lOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUubm9kZVZhbHVlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubm9kZVZhbHVlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uIChub2RlKSB7IHRocm93IF9ub3RJbXBsZW1lbnRlZCgndHlwZScpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLmNoaWxkTm9kZXNbMF07IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuZmlyc3RDaGlsZCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuZmlyc3RDaGlsZDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5uZXh0U2libGluZyA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwubmV4dFNpYmxpbmc7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUucGFyZW50RWxlbWVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwucGFyZW50OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmNoaWxkTm9kZXMgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmNoaWxkTm9kZXM7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuY2hpbGROb2Rlc0FzTGlzdCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZE5vZGVzID0gZWwuY2hpbGROb2RlcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzID0gbmV3IEFycmF5KGNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmNsZWFyTm9kZXMgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgd2hpbGUgKGVsLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZWwuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGVsLCBub2RlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKG5vZGUpO1xuICAgICAgICB0cmVlQWRhcHRlci5hcHBlbmRDaGlsZCh0aGlzLnRlbXBsYXRlQXdhcmVSb290KGVsKSwgbm9kZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChlbCwgbm9kZSkge1xuICAgICAgICBpZiAoZWwuY2hpbGROb2Rlcy5pbmRleE9mKG5vZGUpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IHBhcmVudC5jaGlsZE5vZGVzLmluZGV4T2YoZWwpO1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2ID0gZWwucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXh0ID0gZWwubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsLnByZXYgPSBudWxsO1xuICAgICAgICBlbC5uZXh0ID0gbnVsbDtcbiAgICAgICAgZWwucGFyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IHJlZlxuICAgICAqIEBwYXJhbSB7P30gbmV3Tm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKHBhcmVudCwgcmVmLCBuZXdOb2RlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKG5ld05vZGUpO1xuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICB0cmVlQWRhcHRlci5pbnNlcnRCZWZvcmUocGFyZW50LCBuZXdOb2RlLCByZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChwYXJlbnQsIG5ld05vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEBwYXJhbSB7P30gcmVmXG4gICAgICogQHBhcmFtIHs/fSBub2Rlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuaW5zZXJ0QWxsQmVmb3JlID0gZnVuY3Rpb24gKHBhcmVudCwgcmVmLCBub2Rlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7IHJldHVybiBfdGhpcy5pbnNlcnRCZWZvcmUocGFyZW50LCByZWYsIG4pOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSByZWZcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24gKHBhcmVudCwgcmVmLCBub2RlKSB7XG4gICAgICAgIGlmIChyZWYubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgcmVmLm5leHRTaWJsaW5nLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQocGFyZW50LCBub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLnNldElubmVySFRNTCA9IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jbGVhck5vZGVzKGVsKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGVudCA9IHBhcnNlNSQxLnBhcnNlRnJhZ21lbnQodmFsdWUsIHsgdHJlZUFkYXB0ZXI6IHRyZWVBZGFwdGVyIH0pO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgY29udGVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cmVlQWRhcHRlci5hcHBlbmRDaGlsZChlbCwgY29udGVudC5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7Pz19IGlzUmVjdXJzaXZlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKGVsLCBpc1JlY3Vyc2l2ZSkge1xuICAgICAgICBpZiAodGhpcy5pc1RleHROb2RlKGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDb21tZW50Tm9kZShlbCkpIHtcbiAgICAgICAgICAgIC8vIEluIHRoZSBET00sIGNvbW1lbnRzIHdpdGhpbiBhbiBlbGVtZW50IHJldHVybiBhbiBlbXB0eSBzdHJpbmcgZm9yIHRleHRDb250ZW50XG4gICAgICAgICAgICAvLyBIb3dldmVyLCBjb21tZW50IG5vZGUgaW5zdGFuY2VzIHJldHVybiB0aGUgY29tbWVudCBjb250ZW50IGZvciB0ZXh0Q29udGVudCBnZXR0ZXJcbiAgICAgICAgICAgIHJldHVybiBpc1JlY3Vyc2l2ZSA/ICcnIDogZWwuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVsLmNoaWxkTm9kZXMgfHwgZWwuY2hpbGROb2Rlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHRDb250ZW50ID0gJyc7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBlbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZXh0Q29udGVudCArPSB0aGlzLmdldFRleHQoZWwuY2hpbGROb2Rlc1tpXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHRDb250ZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVGV4dE5vZGUoZWwpIHx8IHRoaXMuaXNDb21tZW50Tm9kZShlbCkpIHtcbiAgICAgICAgICAgIGVsLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJOb2RlcyhlbCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKVxuICAgICAgICAgICAgICAgIHRyZWVBZGFwdGVyLmluc2VydFRleHQoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnZhbHVlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHsgZWwudmFsdWUgPSB2YWx1ZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRDaGVja2VkID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jaGVja2VkOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRDaGVja2VkID0gZnVuY3Rpb24gKGVsLCB2YWx1ZSkgeyBlbC5jaGVja2VkID0gdmFsdWU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVDb21tZW50ID0gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIHRyZWVBZGFwdGVyLmNyZWF0ZUNvbW1lbnROb2RlKHRleHQpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaHRtbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlVGVtcGxhdGUgPSBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZSA9IHRyZWVBZGFwdGVyLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJywgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCBbXSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnQgPSBwYXJzZTUkMS5wYXJzZUZyYWdtZW50KGh0bWwsIHsgdHJlZUFkYXB0ZXI6IHRyZWVBZGFwdGVyIH0pO1xuICAgICAgICB0cmVlQWRhcHRlci5zZXRUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRhZ05hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgICByZXR1cm4gdHJlZUFkYXB0ZXIuY3JlYXRlRWxlbWVudCh0YWdOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsIFtdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbnNcbiAgICAgKiBAcGFyYW0gez99IHRhZ05hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnROUyA9IGZ1bmN0aW9uIChucywgdGFnTmFtZSkge1xuICAgICAgICByZXR1cm4gdHJlZUFkYXB0ZXIuY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBucywgW10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVUZXh0Tm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHQgPSAodGhpcy5jcmVhdGVDb21tZW50KHRleHQpKTtcbiAgICAgICAgdC50eXBlID0gJ3RleHQnO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0ck5hbWVcbiAgICAgKiBAcGFyYW0gez99IGF0dHJWYWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlU2NyaXB0VGFnID0gZnVuY3Rpb24gKGF0dHJOYW1lLCBhdHRyVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWVBZGFwdGVyLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgW3sgbmFtZTogYXR0ck5hbWUsIHZhbHVlOiBhdHRyVmFsdWUgfV0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGUgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHRoaXMuc2V0VGV4dChzdHlsZSwgY3NzKTtcbiAgICAgICAgcmV0dXJuIChzdHlsZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVTaGFkb3dSb290ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLnNoYWRvd1Jvb3QgPSB0cmVlQWRhcHRlci5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGVsLnNoYWRvd1Jvb3QucGFyZW50ID0gZWw7XG4gICAgICAgIHJldHVybiBlbC5zaGFkb3dSb290O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0U2hhZG93Um9vdCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuc2hhZG93Um9vdDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRIb3N0ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5ob3N0OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmdldERpc3RyaWJ1dGVkTm9kZXMgPSBmdW5jdGlvbiAoZWwpIHsgdGhyb3cgX25vdEltcGxlbWVudGVkKCdnZXREaXN0cmlidXRlZE5vZGVzJyk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIF9yZWN1cnNpdmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUNsb25lID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yobm9kZSkpO1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wIGluIG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiAndmFsdWUnIGluIGRlc2MgJiYgdHlwZW9mIGRlc2MudmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVDbG9uZVtwcm9wXSA9IG5vZGVbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZUNsb25lLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBub2RlQ2xvbmUucHJldiA9IG51bGw7XG4gICAgICAgICAgICBub2RlQ2xvbmUubmV4dCA9IG51bGw7XG4gICAgICAgICAgICBub2RlQ2xvbmUuY2hpbGRyZW4gPSBudWxsO1xuICAgICAgICAgICAgbWFwUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAobWFwTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlW21hcE5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUNsb25lW21hcE5hbWVdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcCBpbiBub2RlW21hcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlQ2xvbmVbbWFwTmFtZV1bcHJvcF0gPSBub2RlW21hcE5hbWVdW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjTm9kZXMgPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKGNOb2Rlcykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNOb2Rlc0Nsb25lID0gbmV3IEFycmF5KGNOb2Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBjTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGROb2RlID0gY05vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZE5vZGVDbG9uZSA9IF9yZWN1cnNpdmUoY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY05vZGVzQ2xvbmVbaV0gPSBjaGlsZE5vZGVDbG9uZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVDbG9uZS5wcmV2ID0gY05vZGVzQ2xvbmVbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY05vZGVzQ2xvbmVbaSAtIDFdLm5leHQgPSBjaGlsZE5vZGVDbG9uZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVDbG9uZS5wYXJlbnQgPSBub2RlQ2xvbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGVDbG9uZS5jaGlsZHJlbiA9IGNOb2Rlc0Nsb25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVDbG9uZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9yZWN1cnNpdmUobm9kZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnQsICcuJyArIG5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudCwgbmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmNsYXNzTGlzdCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzQXR0clZhbHVlID0gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlicztcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlc1snY2xhc3MnXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjbGFzc0F0dHJWYWx1ZSA9IGF0dHJpYnV0ZXNbJ2NsYXNzJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYXNzQXR0clZhbHVlID8gY2xhc3NBdHRyVmFsdWUudHJpbSgpLnNwbGl0KC9cXHMrL2cpIDogW107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNsYXNzTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTGlzdCA9IHRoaXMuY2xhc3NMaXN0KGVsZW1lbnQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IGNsYXNzTGlzdC5pbmRleE9mKGNsYXNzTmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgICAgICAgY2xhc3NMaXN0LnB1c2goY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYXR0cmlic1snY2xhc3MnXSA9IGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NMaXN0LmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjbGFzc05hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc0xpc3QgPSB0aGlzLmNsYXNzTGlzdChlbGVtZW50KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBjbGFzc0xpc3QuaW5kZXhPZihjbGFzc05hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgY2xhc3NMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBlbGVtZW50LmF0dHJpYnNbJ2NsYXNzJ10gPSBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTGlzdC5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY2xhc3NOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NMaXN0KGVsZW1lbnQpLmluZGV4T2YoY2xhc3NOYW1lKSA+IC0xO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzdHlsZU5hbWVcbiAgICAgKiBAcGFyYW0gez89fSBzdHlsZVZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5oYXNTdHlsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU5hbWUsIHN0eWxlVmFsdWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLmdldFN0eWxlKGVsZW1lbnQsIHN0eWxlTmFtZSkgfHwgJyc7XG4gICAgICAgIHJldHVybiBzdHlsZVZhbHVlID8gdmFsdWUgPT0gc3R5bGVWYWx1ZSA6IHZhbHVlLmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuX3JlYWRTdHlsZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlTWFwID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnM7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXNbJ3N0eWxlJ10gIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVBdHRyVmFsdWUgPSBhdHRyaWJ1dGVzWydzdHlsZSddO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVMaXN0ID0gc3R5bGVBdHRyVmFsdWUuc3BsaXQoLzsrL2cpO1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHN0eWxlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZUxpc3RbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZSA9IChzdHlsZUxpc3RbaV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2xvbiA9IHN0eWxlLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBDU1Mgc3R5bGU6IFwiICsgc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICgoc3R5bGVNYXApKVtzdHlsZS5zdWJzdHIoMCwgY29sb24pLnRyaW0oKV0gPSBzdHlsZS5zdWJzdHIoY29sb24gKyAxKS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZU1hcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzdHlsZU1hcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuX3dyaXRlU3R5bGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVNYXApIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVBdHRyVmFsdWUgPSAnJztcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgaW4gc3R5bGVNYXApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld1ZhbHVlID0gc3R5bGVNYXBba2V5XTtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlQXR0clZhbHVlICs9IGtleSArICc6JyArIHN0eWxlTWFwW2tleV0gKyAnOyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5hdHRyaWJzWydzdHlsZSddID0gc3R5bGVBdHRyVmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlTmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IHN0eWxlVmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZU1hcCA9IHRoaXMuX3JlYWRTdHlsZUF0dHJpYnV0ZShlbGVtZW50KTtcbiAgICAgICAgKChzdHlsZU1hcCkpW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgICAgICB0aGlzLl93cml0ZVN0eWxlQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlTWFwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVTdHlsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU5hbWUpIHsgdGhpcy5zZXRTdHlsZShlbGVtZW50LCBzdHlsZU5hbWUsIG51bGwpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRTdHlsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU5hbWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVNYXAgPSB0aGlzLl9yZWFkU3R5bGVBdHRyaWJ1dGUoZWxlbWVudCk7XG4gICAgICAgIHJldHVybiBzdHlsZU1hcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpID8gKChzdHlsZU1hcCkpW3N0eWxlTmFtZV0gOiAnJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUudGFnTmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT0gJ3N0eWxlJyA/ICdTVFlMRScgOiBlbGVtZW50LnRhZ05hbWU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5hdHRyaWJ1dGVNYXAgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsQXR0cnMgPSB0cmVlQWRhcHRlci5nZXRBdHRyTGlzdChlbGVtZW50KTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGVsQXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJpYiA9IGVsQXR0cnNbaV07XG4gICAgICAgICAgICByZXMuc2V0KGF0dHJpYi5uYW1lLCBhdHRyaWIudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuaGFzQXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5hdHRyaWJzICYmIGVsZW1lbnQuYXR0cmlic1thdHRyaWJ1dGVdICE9IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IG5zXG4gICAgICogQHBhcmFtIHs/fSBhdHRyaWJ1dGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmhhc0F0dHJpYnV0ZU5TID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5zLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlKSA/IGVsZW1lbnQuYXR0cmlic1thdHRyaWJ1dGVdIDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gbnNcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTlMgPSBmdW5jdGlvbiAoZWxlbWVudCwgbnMsIGF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgZWxlbWVudC5hdHRyaWJzW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IG5zXG4gICAgICogQHBhcmFtIHs/fSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVOUyA9IGZ1bmN0aW9uIChlbGVtZW50LCBucywgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cmlidXRlKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50LmF0dHJpYnNbYXR0cmlidXRlXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBuc1xuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlTlMgPSBmdW5jdGlvbiAoZWxlbWVudCwgbnMsIG5hbWUpIHsgdGhyb3cgJ25vdCBpbXBsZW1lbnRlZCc7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUudGVtcGxhdGVBd2FyZVJvb3QgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNUZW1wbGF0ZUVsZW1lbnQoZWwpID8gdHJlZUFkYXB0ZXIuZ2V0VGVtcGxhdGVDb250ZW50KGVsKSA6IGVsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVIdG1sRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld0RvYyA9IHRyZWVBZGFwdGVyLmNyZWF0ZURvY3VtZW50KCk7XG4gICAgICAgIG5ld0RvYy50aXRsZSA9ICdmYWtlVGl0bGUnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoZWFkID0gdHJlZUFkYXB0ZXIuY3JlYXRlRWxlbWVudCgnaGVhZCcsIG51bGwsIFtdKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9keSA9IHRyZWVBZGFwdGVyLmNyZWF0ZUVsZW1lbnQoJ2JvZHknLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsIFtdKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChuZXdEb2MsIGhlYWQpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKG5ld0RvYywgYm9keSk7XG4gICAgICAgIG5ld0RvY1snaGVhZCddID0gaGVhZDtcbiAgICAgICAgbmV3RG9jWydib2R5J10gPSBib2R5O1xuICAgICAgICBuZXdEb2NbJ193aW5kb3cnXSA9IHt9O1xuICAgICAgICByZXR1cm4gbmV3RG9jO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiB7IGxlZnQ6IDAsIHRvcDogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZG9jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uIChkb2MpIHsgcmV0dXJuIHRoaXMuZ2V0VGV4dCh0aGlzLmdldFRpdGxlTm9kZShkb2MpKSB8fCAnJzsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRvY1xuICAgICAqIEBwYXJhbSB7P30gbmV3VGl0bGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24gKGRvYywgbmV3VGl0bGUpIHtcbiAgICAgICAgdGhpcy5zZXRUZXh0KHRoaXMuZ2V0VGl0bGVOb2RlKGRvYyksIG5ld1RpdGxlIHx8ICcnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmlzVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRWxlbWVudE5vZGUoZWwpICYmIHRoaXMudGFnTmFtZShlbCkgPT09ICd0ZW1wbGF0ZSc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmlzVGV4dE5vZGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdHJlZUFkYXB0ZXIuaXNUZXh0Tm9kZShub2RlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmlzQ29tbWVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdHJlZUFkYXB0ZXIuaXNDb21tZW50Tm9kZShub2RlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmlzRWxlbWVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZSA/IHRyZWVBZGFwdGVyLmlzRWxlbWVudE5vZGUobm9kZSkgOiBmYWxzZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmhhc1NoYWRvd1Jvb3QgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5zaGFkb3dSb290ICE9IG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5pc1NoYWRvd1Jvb3QgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdGhpcy5nZXRTaGFkb3dSb290KG5vZGUpID09IG5vZGU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5pbXBvcnRJbnRvRG9jID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRoaXMuY2xvbmUobm9kZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5hZG9wdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRIcmVmID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShlbCwgJ2hyZWYnKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBiYXNlVXJsXG4gICAgICogQHBhcmFtIHs/fSBocmVmXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5yZXNvbHZlQW5kU2V0SHJlZiA9IGZ1bmN0aW9uIChlbCwgYmFzZVVybCwgaHJlZikge1xuICAgICAgICBpZiAoaHJlZiA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbC5ocmVmID0gYmFzZVVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLmhyZWYgPSBiYXNlVXJsICsgJy8uLi8nICsgaHJlZjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IHBhcnNlZFJ1bGVzXG4gICAgICogQHBhcmFtIHs/PX0gY3NzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5fYnVpbGRSdWxlcyA9IGZ1bmN0aW9uIChwYXJzZWRSdWxlcywgY3NzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJ1bGVzID0gW107XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBwYXJzZWRSdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyc2VkUnVsZSA9IHBhcnNlZFJ1bGVzW2ldO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcnVsZSA9IHt9O1xuICAgICAgICAgICAgcnVsZVsnY3NzVGV4dCddID0gY3NzO1xuICAgICAgICAgICAgcnVsZVsnc3R5bGUnXSA9IHsgY29udGVudDogJycsIGNzc1RleHQ6ICcnIH07XG4gICAgICAgICAgICBpZiAocGFyc2VkUnVsZS50eXBlID09ICdydWxlJykge1xuICAgICAgICAgICAgICAgIHJ1bGVbJ3R5cGUnXSA9IDE7XG4gICAgICAgICAgICAgICAgcnVsZVsnc2VsZWN0b3JUZXh0J10gPVxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRSdWxlLnNlbGVjdG9ycy5qb2luKCcsICcucmVwbGFjZSgvXFxzezIsfS9nLCAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxzKn5cXHMqL2csICcgfiAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xccypcXCtcXHMqL2csICcgKyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xccyo+XFxzKi9nLCAnID4gJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFsoXFx3Kyk9KFxcdyspXFxdL2csICdbJDE9XCIkMlwiXScpKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkUnVsZS5kZWNsYXJhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBqID0gMDsgaiA8IHBhcnNlZFJ1bGUuZGVjbGFyYXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlY2xhcmF0aW9uID0gcGFyc2VkUnVsZS5kZWNsYXJhdGlvbnNbal07XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVbJ3N0eWxlJ10gPSBkZWNsYXJhdGlvbi5wcm9wZXJ0eVtkZWNsYXJhdGlvbi52YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVbJ3N0eWxlJ10uY3NzVGV4dCArPSBkZWNsYXJhdGlvbi5wcm9wZXJ0eSArICc6ICcgKyBkZWNsYXJhdGlvbi52YWx1ZSArICc7JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJzZWRSdWxlLnR5cGUgPT0gJ21lZGlhJykge1xuICAgICAgICAgICAgICAgIHJ1bGVbJ3R5cGUnXSA9IDQ7XG4gICAgICAgICAgICAgICAgcnVsZVsnbWVkaWEnXSA9IHsgbWVkaWFUZXh0OiBwYXJzZWRSdWxlLm1lZGlhIH07XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZFJ1bGUucnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZVsnY3NzUnVsZXMnXSA9IHRoaXMuX2J1aWxkUnVsZXMocGFyc2VkUnVsZS5ydWxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzRE9NRXZlbnRzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c05hdGl2ZVNoYWRvd0RPTSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZG9jXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmdldEdsb2JhbEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gKGRvYywgdGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gJ3dpbmRvdycpIHtcbiAgICAgICAgICAgIHJldHVybiAoKGRvYykpLl93aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09ICdib2R5Jykge1xuICAgICAgICAgICAgcmV0dXJuIGRvYy5ib2R5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRvY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0QmFzZUhyZWYgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2UgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoZG9jLCAnYmFzZScpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBocmVmID0gJyc7XG4gICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgICBocmVmID0gdGhpcy5nZXRIcmVmKGJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8oYWx4aHViKTogTmVlZCByZWxhdGl2ZSBwYXRoIGxvZ2ljIGZyb20gQnJvd3NlckRvbUFkYXB0ZXIgaGVyZT9cbiAgICAgICAgcmV0dXJuIGhyZWYgPT0gbnVsbCA/IG51bGwgOiBocmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5yZXNldEJhc2VFbGVtZW50ID0gZnVuY3Rpb24gKCkgeyB0aHJvdyAnbm90IGltcGxlbWVudGVkJzsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmdldEhpc3RvcnkgPSBmdW5jdGlvbiAoKSB7IHRocm93ICdub3QgaW1wbGVtZW50ZWQnOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7IHRocm93ICdub3QgaW1wbGVtZW50ZWQnOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VXNlckFnZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Zha2UgdXNlciBhZ2VudCc7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uIChlbCwgbmFtZSkgeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoZWwsICdkYXRhLScgKyBuYW1lKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24gKGVsKSB7IHRocm93ICdub3QgaW1wbGVtZW50ZWQnOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkgeyB0aGlzLnNldEF0dHJpYnV0ZShlbCwgJ2RhdGEtJyArIG5hbWUsIHZhbHVlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzV2ViQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5wZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERhdGUubm93KCk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRBbmltYXRpb25QcmVmaXggPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnJzsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmdldFRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAndHJhbnNpdGlvbmVuZCc7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c0FuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmV3Tm9kZVxuICAgICAqIEBwYXJhbSB7P30gb2xkTm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUucmVwbGFjZUNoaWxkID0gZnVuY3Rpb24gKGVsLCBuZXdOb2RlLCBvbGROb2RlKSB7IHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZUh0bWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHRlbXBsYXRlSHRtbCkgeyB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG1ldGhvZE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGFyZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChlbCwgbWV0aG9kTmFtZSwgYXJncykgeyB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmdldEV2ZW50S2V5ID0gZnVuY3Rpb24gKGV2ZW50KSB7IHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZTVEb21BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c0Nvb2tpZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmdldENvb2tpZSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2U1RG9tQWRhcHRlci5wcm90b3R5cGUuc2V0Q29va2llID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7IHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwga2V5ZnJhbWVzLCBvcHRpb25zKSB7IHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkb2NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlNURvbUFkYXB0ZXIucHJvdG90eXBlLmdldFRpdGxlTm9kZSA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGl0bGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoZG9jLCAndGl0bGUnKTtcbiAgICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICAgICAgdGl0bGUgPSAodGhpcy5jcmVhdGVFbGVtZW50KCd0aXRsZScpKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5xdWVyeVNlbGVjdG9yKGRvYywgJ2hlYWQnKSwgdGl0bGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aXRsZTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZTVEb21BZGFwdGVyO1xufShfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVEb21BZGFwdGVyKSk7XG4vLyBUT0RPOiBidWlsZCBhIHByb3BlciBsaXN0LCB0aGlzIG9uZSBpcyBhbGwgdGhlIGtleXMgb2YgYSBIVE1MSW5wdXRFbGVtZW50XG52YXIgX0hUTUxFbGVtZW50UHJvcGVydHlMaXN0ID0gW1xuICAgICd3ZWJraXRFbnRyaWVzJyxcbiAgICAnaW5jcmVtZW50YWwnLFxuICAgICd3ZWJraXRkaXJlY3RvcnknLFxuICAgICdzZWxlY3Rpb25EaXJlY3Rpb24nLFxuICAgICdzZWxlY3Rpb25FbmQnLFxuICAgICdzZWxlY3Rpb25TdGFydCcsXG4gICAgJ2xhYmVscycsXG4gICAgJ3ZhbGlkYXRpb25NZXNzYWdlJyxcbiAgICAndmFsaWRpdHknLFxuICAgICd3aWxsVmFsaWRhdGUnLFxuICAgICd3aWR0aCcsXG4gICAgJ3ZhbHVlQXNOdW1iZXInLFxuICAgICd2YWx1ZUFzRGF0ZScsXG4gICAgJ3ZhbHVlJyxcbiAgICAndXNlTWFwJyxcbiAgICAnZGVmYXVsdFZhbHVlJyxcbiAgICAndHlwZScsXG4gICAgJ3N0ZXAnLFxuICAgICdzcmMnLFxuICAgICdzaXplJyxcbiAgICAncmVxdWlyZWQnLFxuICAgICdyZWFkT25seScsXG4gICAgJ3BsYWNlaG9sZGVyJyxcbiAgICAncGF0dGVybicsXG4gICAgJ25hbWUnLFxuICAgICdtdWx0aXBsZScsXG4gICAgJ21pbicsXG4gICAgJ21pbkxlbmd0aCcsXG4gICAgJ21heExlbmd0aCcsXG4gICAgJ21heCcsXG4gICAgJ2xpc3QnLFxuICAgICdpbmRldGVybWluYXRlJyxcbiAgICAnaGVpZ2h0JyxcbiAgICAnZm9ybVRhcmdldCcsXG4gICAgJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgICAnZm9ybU1ldGhvZCcsXG4gICAgJ2Zvcm1FbmN0eXBlJyxcbiAgICAnZm9ybUFjdGlvbicsXG4gICAgJ2ZpbGVzJyxcbiAgICAnZm9ybScsXG4gICAgJ2Rpc2FibGVkJyxcbiAgICAnZGlyTmFtZScsXG4gICAgJ2NoZWNrZWQnLFxuICAgICdkZWZhdWx0Q2hlY2tlZCcsXG4gICAgJ2F1dG9mb2N1cycsXG4gICAgJ2F1dG9jb21wbGV0ZScsXG4gICAgJ2FsdCcsXG4gICAgJ2FsaWduJyxcbiAgICAnYWNjZXB0JyxcbiAgICAnb25hdXRvY29tcGxldGVlcnJvcicsXG4gICAgJ29uYXV0b2NvbXBsZXRlJyxcbiAgICAnb253YWl0aW5nJyxcbiAgICAnb252b2x1bWVjaGFuZ2UnLFxuICAgICdvbnRvZ2dsZScsXG4gICAgJ29udGltZXVwZGF0ZScsXG4gICAgJ29uc3VzcGVuZCcsXG4gICAgJ29uc3VibWl0JyxcbiAgICAnb25zdGFsbGVkJyxcbiAgICAnb25zaG93JyxcbiAgICAnb25zZWxlY3QnLFxuICAgICdvbnNlZWtpbmcnLFxuICAgICdvbnNlZWtlZCcsXG4gICAgJ29uc2Nyb2xsJyxcbiAgICAnb25yZXNpemUnLFxuICAgICdvbnJlc2V0JyxcbiAgICAnb25yYXRlY2hhbmdlJyxcbiAgICAnb25wcm9ncmVzcycsXG4gICAgJ29ucGxheWluZycsXG4gICAgJ29ucGxheScsXG4gICAgJ29ucGF1c2UnLFxuICAgICdvbm1vdXNld2hlZWwnLFxuICAgICdvbm1vdXNldXAnLFxuICAgICdvbm1vdXNlb3ZlcicsXG4gICAgJ29ubW91c2VvdXQnLFxuICAgICdvbm1vdXNlbW92ZScsXG4gICAgJ29ubW91c2VsZWF2ZScsXG4gICAgJ29ubW91c2VlbnRlcicsXG4gICAgJ29ubW91c2Vkb3duJyxcbiAgICAnb25sb2Fkc3RhcnQnLFxuICAgICdvbmxvYWRlZG1ldGFkYXRhJyxcbiAgICAnb25sb2FkZWRkYXRhJyxcbiAgICAnb25sb2FkJyxcbiAgICAnb25rZXl1cCcsXG4gICAgJ29ua2V5cHJlc3MnLFxuICAgICdvbmtleWRvd24nLFxuICAgICdvbmludmFsaWQnLFxuICAgICdvbmlucHV0JyxcbiAgICAnb25mb2N1cycsXG4gICAgJ29uZXJyb3InLFxuICAgICdvbmVuZGVkJyxcbiAgICAnb25lbXB0aWVkJyxcbiAgICAnb25kdXJhdGlvbmNoYW5nZScsXG4gICAgJ29uZHJvcCcsXG4gICAgJ29uZHJhZ3N0YXJ0JyxcbiAgICAnb25kcmFnb3ZlcicsXG4gICAgJ29uZHJhZ2xlYXZlJyxcbiAgICAnb25kcmFnZW50ZXInLFxuICAgICdvbmRyYWdlbmQnLFxuICAgICdvbmRyYWcnLFxuICAgICdvbmRibGNsaWNrJyxcbiAgICAnb25jdWVjaGFuZ2UnLFxuICAgICdvbmNvbnRleHRtZW51JyxcbiAgICAnb25jbG9zZScsXG4gICAgJ29uY2xpY2snLFxuICAgICdvbmNoYW5nZScsXG4gICAgJ29uY2FucGxheXRocm91Z2gnLFxuICAgICdvbmNhbnBsYXknLFxuICAgICdvbmNhbmNlbCcsXG4gICAgJ29uYmx1cicsXG4gICAgJ29uYWJvcnQnLFxuICAgICdzcGVsbGNoZWNrJyxcbiAgICAnaXNDb250ZW50RWRpdGFibGUnLFxuICAgICdjb250ZW50RWRpdGFibGUnLFxuICAgICdvdXRlclRleHQnLFxuICAgICdpbm5lclRleHQnLFxuICAgICdhY2Nlc3NLZXknLFxuICAgICdoaWRkZW4nLFxuICAgICd3ZWJraXRkcm9wem9uZScsXG4gICAgJ2RyYWdnYWJsZScsXG4gICAgJ3RhYkluZGV4JyxcbiAgICAnZGlyJyxcbiAgICAndHJhbnNsYXRlJyxcbiAgICAnbGFuZycsXG4gICAgJ3RpdGxlJyxcbiAgICAnY2hpbGRFbGVtZW50Q291bnQnLFxuICAgICdsYXN0RWxlbWVudENoaWxkJyxcbiAgICAnZmlyc3RFbGVtZW50Q2hpbGQnLFxuICAgICdjaGlsZHJlbicsXG4gICAgJ29ud2Via2l0ZnVsbHNjcmVlbmVycm9yJyxcbiAgICAnb253ZWJraXRmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICAnbmV4dEVsZW1lbnRTaWJsaW5nJyxcbiAgICAncHJldmlvdXNFbGVtZW50U2libGluZycsXG4gICAgJ29ud2hlZWwnLFxuICAgICdvbnNlbGVjdHN0YXJ0JyxcbiAgICAnb25zZWFyY2gnLFxuICAgICdvbnBhc3RlJyxcbiAgICAnb25jdXQnLFxuICAgICdvbmNvcHknLFxuICAgICdvbmJlZm9yZXBhc3RlJyxcbiAgICAnb25iZWZvcmVjdXQnLFxuICAgICdvbmJlZm9yZWNvcHknLFxuICAgICdzaGFkb3dSb290JyxcbiAgICAnZGF0YXNldCcsXG4gICAgJ2NsYXNzTGlzdCcsXG4gICAgJ2NsYXNzTmFtZScsXG4gICAgJ291dGVySFRNTCcsXG4gICAgJ2lubmVySFRNTCcsXG4gICAgJ3Njcm9sbEhlaWdodCcsXG4gICAgJ3Njcm9sbFdpZHRoJyxcbiAgICAnc2Nyb2xsVG9wJyxcbiAgICAnc2Nyb2xsTGVmdCcsXG4gICAgJ2NsaWVudEhlaWdodCcsXG4gICAgJ2NsaWVudFdpZHRoJyxcbiAgICAnY2xpZW50VG9wJyxcbiAgICAnY2xpZW50TGVmdCcsXG4gICAgJ29mZnNldFBhcmVudCcsXG4gICAgJ29mZnNldEhlaWdodCcsXG4gICAgJ29mZnNldFdpZHRoJyxcbiAgICAnb2Zmc2V0VG9wJyxcbiAgICAnb2Zmc2V0TGVmdCcsXG4gICAgJ2xvY2FsTmFtZScsXG4gICAgJ3ByZWZpeCcsXG4gICAgJ25hbWVzcGFjZVVSSScsXG4gICAgJ2lkJyxcbiAgICAnc3R5bGUnLFxuICAgICdhdHRyaWJ1dGVzJyxcbiAgICAndGFnTmFtZScsXG4gICAgJ3BhcmVudEVsZW1lbnQnLFxuICAgICd0ZXh0Q29udGVudCcsXG4gICAgJ2Jhc2VVUkknLFxuICAgICdvd25lckRvY3VtZW50JyxcbiAgICAnbmV4dFNpYmxpbmcnLFxuICAgICdwcmV2aW91c1NpYmxpbmcnLFxuICAgICdsYXN0Q2hpbGQnLFxuICAgICdmaXJzdENoaWxkJyxcbiAgICAnY2hpbGROb2RlcycsXG4gICAgJ3BhcmVudE5vZGUnLFxuICAgICdub2RlVHlwZScsXG4gICAgJ25vZGVWYWx1ZScsXG4gICAgJ25vZGVOYW1lJyxcbiAgICAnY2xvc3VyZV9sbV83MTQ2MTcnLFxuICAgICdfX2pzYWN0aW9uJyxcbl07XG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0gez99IGxpc3RcbiAqIEBwYXJhbSB7P30gZWxcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZShsaXN0LCBlbCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gbGlzdC5pbmRleE9mKGVsKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEVNUFRZX0FSUkFZID0gW107XG52YXIgU2VydmVyUmVuZGVyZXJGYWN0b3J5MiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuZ1pvbmVcbiAgICAgKiBAcGFyYW0gez99IGRvY3VtZW50XG4gICAgICogQHBhcmFtIHs/fSBzaGFyZWRTdHlsZXNIb3N0XG4gICAgICovXG4gICAgZnVuY3Rpb24gU2VydmVyUmVuZGVyZXJGYWN0b3J5MihuZ1pvbmUsIGRvY3VtZW50LCBzaGFyZWRTdHlsZXNIb3N0KSB7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuc2hhcmVkU3R5bGVzSG9zdCA9IHNoYXJlZFN0eWxlc0hvc3Q7XG4gICAgICAgIHRoaXMucmVuZGVyZXJCeUNvbXBJZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBuZXcgX2FuZ3VsYXJfY29tcGlsZXIuRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFJlbmRlcmVyID0gbmV3IERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIoZG9jdW1lbnQsIG5nWm9uZSwgdGhpcy5zY2hlbWEpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcnZlclJlbmRlcmVyRmFjdG9yeTIucHJvdG90eXBlLmNyZWF0ZVJlbmRlcmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIHR5cGUpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICF0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0UmVuZGVyZXI7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlLmVuY2Fwc3VsYXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmU6XG4gICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQ6IHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZW5kZXJlciA9IHRoaXMucmVuZGVyZXJCeUNvbXBJZC5nZXQodHlwZS5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZW5kZXJlcikge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlciA9IG5ldyBFbXVsYXRlZEVuY2Fwc3VsYXRpb25TZXJ2ZXJSZW5kZXJlcjIodGhpcy5kb2N1bWVudCwgdGhpcy5uZ1pvbmUsIHRoaXMuc2hhcmVkU3R5bGVzSG9zdCwgdGhpcy5zY2hlbWEsIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyQnlDb21wSWQuc2V0KHR5cGUuaWQsIHJlbmRlcmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKChyZW5kZXJlcikpLmFwcGx5VG9Ib3N0KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmU6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYXRpdmUgZW5jYXBzdWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoZSBzZXJ2ZXIhJyk7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyQnlDb21wSWQuaGFzKHR5cGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWZsYXR0ZW5TdHlsZXModHlwZS5pZCwgdHlwZS5zdHlsZXMsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFyZWRTdHlsZXNIb3N0LmFkZFN0eWxlcyhzdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyQnlDb21wSWQuc2V0KHR5cGUuaWQsIHRoaXMuZGVmYXVsdFJlbmRlcmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFJlbmRlcmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcnZlclJlbmRlcmVyRmFjdG9yeTIucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyUmVuZGVyZXJGYWN0b3J5Mi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyO1xufSgpKTtcblNlcnZlclJlbmRlcmVyRmFjdG9yeTIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuU2VydmVyUmVuZGVyZXJGYWN0b3J5Mi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdab25lLCB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5ET0NVTUVOVCxdIH0sXSB9LFxuICAgIHsgdHlwZTogX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1U2hhcmVkU3R5bGVzSG9zdCwgfSxcbl07IH07XG52YXIgRGVmYXVsdFNlcnZlclJlbmRlcmVyMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkb2N1bWVudFxuICAgICAqIEBwYXJhbSB7P30gbmdab25lXG4gICAgICogQHBhcmFtIHs/fSBzY2hlbWFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEZWZhdWx0U2VydmVyUmVuZGVyZXIyKGRvY3VtZW50LCBuZ1pvbmUsIHNjaGVtYSkge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5kYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChuYW1lLCBuYW1lc3BhY2UsIGRlYnVnSW5mbykge1xuICAgICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuY3JlYXRlRWxlbWVudE5TKF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtU5BTUVTUEFDRV9VUklTW25hbWVzcGFjZV0sIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5jcmVhdGVFbGVtZW50KG5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuY3JlYXRlQ29tbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVidWdJbmZvKSB7IHJldHVybiBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5jcmVhdGVDb21tZW50KHZhbHVlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5jcmVhdGVUZXh0ID0gZnVuY3Rpb24gKHZhbHVlLCBkZWJ1Z0luZm8pIHsgcmV0dXJuIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmNyZWF0ZVRleHROb2RlKHZhbHVlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEBwYXJhbSB7P30gbmV3Q2hpbGRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKHBhcmVudCwgbmV3Q2hpbGQpIHsgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuYXBwZW5kQ2hpbGQocGFyZW50LCBuZXdDaGlsZCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IG5ld0NoaWxkXG4gICAgICogQHBhcmFtIHs/fSByZWZDaGlsZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKHBhcmVudCwgbmV3Q2hpbGQsIHJlZkNoaWxkKSB7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmluc2VydEJlZm9yZShwYXJlbnQsIHJlZkNoaWxkLCBuZXdDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBvbGRDaGlsZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAocGFyZW50LCBvbGRDaGlsZCkge1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5yZW1vdmVDaGlsZChwYXJlbnQsIG9sZENoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3Rvck9yTm9kZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuc2VsZWN0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3JPck5vZGUsIGRlYnVnSW5mbykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbDtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rvck9yTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVsID0gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucXVlcnlTZWxlY3Rvcih0aGlzLmRvY3VtZW50LCBzZWxlY3Rvck9yTm9kZSk7XG4gICAgICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNlbGVjdG9yIFxcXCJcIiArIHNlbGVjdG9yT3JOb2RlICsgXCJcXFwiIGRpZCBub3QgbWF0Y2ggYW55IGVsZW1lbnRzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwgPSBzZWxlY3Rvck9yTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5jbGVhck5vZGVzKGVsKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5wYXJlbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLnBhcmVudEVsZW1lbnQobm9kZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5uZXh0U2libGluZyA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5uZXh0U2libGluZyhub2RlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLnNldEF0dHJpYnV0ZU5TKGVsLCBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVOQU1FU1BBQ0VfVVJJU1tuYW1lc3BhY2VdLCBuYW1lc3BhY2UgKyAnOicgKyBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5zZXRBdHRyaWJ1dGUoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gKGVsLCBuYW1lLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucmVtb3ZlQXR0cmlidXRlTlMoZWwsIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtU5BTUVTUEFDRV9VUklTW25hbWVzcGFjZV0sIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucmVtb3ZlQXR0cmlidXRlKGVsLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIG5hbWUpIHsgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuYWRkQ2xhc3MoZWwsIG5hbWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGVsLCBuYW1lKSB7IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLnJlbW92ZUNsYXNzKGVsLCBuYW1lKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IGZsYWdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uIChlbCwgc3R5bGUsIHZhbHVlLCBmbGFncykge1xuICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5zZXRTdHlsZShlbCwgc3R5bGUsIHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHBhcmFtIHs/fSBmbGFnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUucmVtb3ZlU3R5bGUgPSBmdW5jdGlvbiAoZWwsIHN0eWxlLCBmbGFncykge1xuICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5yZW1vdmVTdHlsZShlbCwgc3R5bGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdOYW1lXG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eU5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLl9pc1NhZmVUb1JlZmxlY3RQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hLnNlY3VyaXR5Q29udGV4dCh0YWdOYW1lLCBwcm9wZXJ0eU5hbWUsIHRydWUpID09PVxuICAgICAgICAgICAgdGhpcy5zY2hlbWEuc2VjdXJpdHlDb250ZXh0KHRhZ05hbWUsIHByb3BlcnR5TmFtZSwgZmFsc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBjaGVja05vU3ludGhldGljUHJvcChuYW1lLCAncHJvcGVydHknKTtcbiAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuc2V0UHJvcGVydHkoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgLy8gTWlycm9yIHByb3BlcnR5IHZhbHVlcyBmb3Iga25vd24gSFRNTCBlbGVtZW50IHByb3BlcnRpZXMgaW4gdGhlIGF0dHJpYnV0ZXMuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhZ05hbWUgPSAoKGVsLnRhZ05hbWUpKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpICYmXG4gICAgICAgICAgICB0aGlzLnNjaGVtYS5oYXNFbGVtZW50KHRhZ05hbWUsIEVNUFRZX0FSUkFZKSAmJlxuICAgICAgICAgICAgdGhpcy5zY2hlbWEuaGFzUHJvcGVydHkodGFnTmFtZSwgbmFtZSwgRU1QVFlfQVJSQVkpICYmXG4gICAgICAgICAgICB0aGlzLl9pc1NhZmVUb1JlZmxlY3RQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoZWwsIG5hbWUsIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkgeyBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5zZXRUZXh0KG5vZGUsIHZhbHVlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFxuICAgICAqIEBwYXJhbSB7P30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBOb3RlOiBXZSBhcmUgbm90IHVzaW5nIHRoZSBFdmVudHNQbHVnaW4gaGVyZSBhcyB0aGlzIGlzIG5vdCBuZWVkZWRcbiAgICAgICAgLy8gdG8gcnVuIG91ciB0ZXN0cy5cbiAgICAgICAgY2hlY2tOb1N5bnRoZXRpY1Byb3AoZXZlbnROYW1lLCAnbGlzdGVuZXInKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWwgPSB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmdldEdsb2JhbEV2ZW50VGFyZ2V0KHRoaXMuZG9jdW1lbnQsIHRhcmdldCkgOiB0YXJnZXQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHNpZGVIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5uZ1pvbmUucnVuR3VhcmRlZChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhldmVudCk7IH0pOyB9O1xuICAgICAgICByZXR1cm4gdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkub25BbmRDYW5jZWwoZWwsIGV2ZW50TmFtZSwgb3V0c2lkZUhhbmRsZXIpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBEZWZhdWx0U2VydmVyUmVuZGVyZXIyO1xufSgpKTtcbnZhciBBVF9DSEFSQ09ERSA9ICdAJy5jaGFyQ29kZUF0KDApO1xuLyoqXG4gKiBAcGFyYW0gez99IG5hbWVcbiAqIEBwYXJhbSB7P30gbmFtZUtpbmRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNoZWNrTm9TeW50aGV0aWNQcm9wKG5hbWUsIG5hbWVLaW5kKSB7XG4gICAgaWYgKG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gQVRfQ0hBUkNPREUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm91bmQgdGhlIHN5bnRoZXRpYyBcIiArIG5hbWVLaW5kICsgXCIgXCIgKyBuYW1lICsgXCIuIFBsZWFzZSBpbmNsdWRlIGVpdGhlciBcXFwiQnJvd3NlckFuaW1hdGlvbnNNb2R1bGVcXFwiIG9yIFxcXCJOb29wQW5pbWF0aW9uc01vZHVsZVxcXCIgaW4geW91ciBhcHBsaWNhdGlvbi5cIik7XG4gICAgfVxufVxudmFyIEVtdWxhdGVkRW5jYXBzdWxhdGlvblNlcnZlclJlbmRlcmVyMiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVtdWxhdGVkRW5jYXBzdWxhdGlvblNlcnZlclJlbmRlcmVyMiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRvY3VtZW50XG4gICAgICogQHBhcmFtIHs/fSBuZ1pvbmVcbiAgICAgKiBAcGFyYW0gez99IHNoYXJlZFN0eWxlc0hvc3RcbiAgICAgKiBAcGFyYW0gez99IHNjaGVtYVxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gRW11bGF0ZWRFbmNhcHN1bGF0aW9uU2VydmVyUmVuZGVyZXIyKGRvY3VtZW50LCBuZ1pvbmUsIHNoYXJlZFN0eWxlc0hvc3QsIHNjaGVtYSwgY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBuZ1pvbmUsIHNjaGVtYSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB2YXIgc3R5bGVzID0gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1ZmxhdHRlblN0eWxlcyhjb21wb25lbnQuaWQsIGNvbXBvbmVudC5zdHlsZXMsIFtdKTtcbiAgICAgICAgc2hhcmVkU3R5bGVzSG9zdC5hZGRTdHlsZXMoc3R5bGVzKTtcbiAgICAgICAgX3RoaXMuY29udGVudEF0dHIgPSBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVzaGltQ29udGVudEF0dHJpYnV0ZShjb21wb25lbnQuaWQpO1xuICAgICAgICBfdGhpcy5ob3N0QXR0ciA9IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtXNoaW1Ib3N0QXR0cmlidXRlKGNvbXBvbmVudC5pZCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbXVsYXRlZEVuY2Fwc3VsYXRpb25TZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLmFwcGx5VG9Ib3N0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHsgX3N1cGVyLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBlbGVtZW50LCB0aGlzLmhvc3RBdHRyLCAnJyk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtdWxhdGVkRW5jYXBzdWxhdGlvblNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWwgPSBfc3VwZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBwYXJlbnQsIG5hbWUpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnNldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIGVsLCB0aGlzLmNvbnRlbnRBdHRyLCAnJyk7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIHJldHVybiBFbXVsYXRlZEVuY2Fwc3VsYXRpb25TZXJ2ZXJSZW5kZXJlcjI7XG59KERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBTZXJ2ZXJTdHlsZXNIb3N0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VydmVyU3R5bGVzSG9zdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRvY1xuICAgICAqIEBwYXJhbSB7P30gdHJhbnNpdGlvbklkXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2VydmVyU3R5bGVzSG9zdChkb2MsIHRyYW5zaXRpb25JZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIF90aGlzLnRyYW5zaXRpb25JZCA9IHRyYW5zaXRpb25JZDtcbiAgICAgICAgX3RoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgIF90aGlzLmhlYWQgPSBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5nZXRFbGVtZW50c0J5VGFnTmFtZShkb2MsICdoZWFkJylbMF07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyU3R5bGVzSG9zdC5wcm90b3R5cGUuX2FkZFN0eWxlID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFkYXB0ZXIgPSAoX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbCA9IGFkYXB0ZXIuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgYWRhcHRlci5zZXRUZXh0KGVsLCBzdHlsZSk7XG4gICAgICAgIGlmICghIXRoaXMudHJhbnNpdGlvbklkKSB7XG4gICAgICAgICAgICBhZGFwdGVyLnNldEF0dHJpYnV0ZShlbCwgJ25nLXRyYW5zaXRpb24nLCB0aGlzLnRyYW5zaXRpb25JZCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRhcHRlci5hcHBlbmRDaGlsZCh0aGlzLmhlYWQsIGVsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYWRkaXRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJ2ZXJTdHlsZXNIb3N0LnByb3RvdHlwZS5vblN0eWxlc0FkZGVkID0gZnVuY3Rpb24gKGFkZGl0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhZGRpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHsgcmV0dXJuIF90aGlzLl9hZGRTdHlsZShzdHlsZSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcnZlclN0eWxlc0hvc3Q7XG59KF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtVNoYXJlZFN0eWxlc0hvc3QpKTtcblNlcnZlclN0eWxlc0hvc3QuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuU2VydmVyU3R5bGVzSG9zdC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRE9DVU1FTlQsXSB9LF0gfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1VFJBTlNJVElPTl9JRCxdIH0sXSB9LFxuXTsgfTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBJTlRFUk5BTF9TRVJWRVJfUExBVEZPUk1fUFJPVklERVJTID0gW1xuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkRPQ1VNRU5ULCB1c2VGYWN0b3J5OiBfZG9jdW1lbnQsIGRlcHM6IFtfYW5ndWxhcl9jb3JlLkluamVjdG9yXSB9LFxuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5QTEFURk9STV9JRCwgdXNlVmFsdWU6IF9hbmd1bGFyX2NvbW1vbi7JtVBMQVRGT1JNX1NFUlZFUl9JRCB9LFxuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5QTEFURk9STV9JTklUSUFMSVpFUiwgdXNlRmFjdG9yeTogaW5pdFBhcnNlNUFkYXB0ZXIsIG11bHRpOiB0cnVlLCBkZXBzOiBbX2FuZ3VsYXJfY29yZS5JbmplY3Rvcl0gfSxcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvbW1vbi5QbGF0Zm9ybUxvY2F0aW9uLCB1c2VDbGFzczogU2VydmVyUGxhdGZvcm1Mb2NhdGlvbiB9LCBQbGF0Zm9ybVN0YXRlLFxuICAgIC8vIEFkZCBzcGVjaWFsIHByb3ZpZGVyIHRoYXQgYWxsb3dzIG11bHRpcGxlIGluc3RhbmNlcyBvZiBwbGF0Zm9ybVNlcnZlciogdG8gYmUgY3JlYXRlZC5cbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuybVBTExPV19NVUxUSVBMRV9QTEFURk9STVMsIHVzZVZhbHVlOiB0cnVlIH1cbl07XG4vKipcbiAqIEBwYXJhbSB7P30gaW5qZWN0b3JcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGluaXRQYXJzZTVBZGFwdGVyKGluamVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgUGFyc2U1RG9tQWRhcHRlci5tYWtlQ3VycmVudCgpOyB9O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gKiBAcGFyYW0gez99IGVuZ2luZVxuICogQHBhcmFtIHs/fSB6b25lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVNlcnZlclJlbmRlcmVyRmFjdG9yeShyZW5kZXJlciwgZW5naW5lLCB6b25lKSB7XG4gICAgcmV0dXJuIG5ldyBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXJfYW5pbWF0aW9ucy7JtUFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeShyZW5kZXJlciwgZW5naW5lLCB6b25lKTtcbn1cbnZhciBTRVJWRVJfUkVOREVSX1BST1ZJREVSUyA9IFtcbiAgICBTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyLFxuICAgIHtcbiAgICAgICAgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlckZhY3RvcnkyLFxuICAgICAgICB1c2VGYWN0b3J5OiBpbnN0YW50aWF0ZVNlcnZlclJlbmRlcmVyRmFjdG9yeSxcbiAgICAgICAgZGVwczogW1NlcnZlclJlbmRlcmVyRmFjdG9yeTIsIF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtUFuaW1hdGlvbkVuZ2luZSwgX2FuZ3VsYXJfY29yZS5OZ1pvbmVdXG4gICAgfSxcbiAgICBTZXJ2ZXJTdHlsZXNIb3N0LFxuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1U2hhcmVkU3R5bGVzSG9zdCwgdXNlRXhpc3Rpbmc6IFNlcnZlclN0eWxlc0hvc3QgfSxcbl07XG4vKipcbiAqIFRoZSBuZyBtb2R1bGUgZm9yIHRoZSBzZXJ2ZXIuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBTZXJ2ZXJNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcnZlck1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFNlcnZlck1vZHVsZTtcbn0oKSk7XG5TZXJ2ZXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0czogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5Ccm93c2VyTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbX2FuZ3VsYXJfaHR0cC5IdHRwTW9kdWxlLCBfYW5ndWxhcl9jb21tb25faHR0cC5IdHRwQ2xpZW50TW9kdWxlLCBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXJfYW5pbWF0aW9ucy5Ob29wQW5pbWF0aW9uc01vZHVsZV0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIFNFUlZFUl9SRU5ERVJfUFJPVklERVJTLFxuICAgICAgICAgICAgICAgICAgICBTRVJWRVJfSFRUUF9QUk9WSURFUlMsXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5UZXN0YWJpbGl0eSwgdXNlVmFsdWU6IG51bGwgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5TZXJ2ZXJNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogQHBhcmFtIHs/fSBpbmplY3RvclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2RvY3VtZW50KGluamVjdG9yKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZmlnID0gaW5qZWN0b3IuZ2V0KElOSVRJQUxfQ09ORklHLCBudWxsKTtcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5kb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gcGFyc2VEb2N1bWVudChjb25maWcuZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmNyZWF0ZUh0bWxEb2N1bWVudCgpO1xuICAgIH1cbn1cbi8qKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBwbGF0Zm9ybVNlcnZlciA9IF9hbmd1bGFyX2NvcmUuY3JlYXRlUGxhdGZvcm1GYWN0b3J5KF9hbmd1bGFyX2NvcmUucGxhdGZvcm1Db3JlLCAnc2VydmVyJywgSU5URVJOQUxfU0VSVkVSX1BMQVRGT1JNX1BST1ZJREVSUyk7XG4vKipcbiAqIFRoZSBzZXJ2ZXIgcGxhdGZvcm0gdGhhdCBzdXBwb3J0cyB0aGUgcnVudGltZSBjb21waWxlci5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqL1xudmFyIHBsYXRmb3JtRHluYW1pY1NlcnZlciA9IF9hbmd1bGFyX2NvcmUuY3JlYXRlUGxhdGZvcm1GYWN0b3J5KF9hbmd1bGFyX2NvbXBpbGVyLnBsYXRmb3JtQ29yZUR5bmFtaWMsICdzZXJ2ZXJEeW5hbWljJywgSU5URVJOQUxfU0VSVkVSX1BMQVRGT1JNX1BST1ZJREVSUyk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgcGFyc2U1JDIgPSByZXF1aXJlKCdwYXJzZTUnKTtcbi8qKlxuICogQHBhcmFtIHs/fSBwbGF0Zm9ybUZhY3RvcnlcbiAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2dldFBsYXRmb3JtKHBsYXRmb3JtRmFjdG9yeSwgb3B0aW9ucykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4dHJhUHJvdmlkZXJzID0gb3B0aW9ucy5leHRyYVByb3ZpZGVycyA/IG9wdGlvbnMuZXh0cmFQcm92aWRlcnMgOiBbXTtcbiAgICByZXR1cm4gcGxhdGZvcm1GYWN0b3J5KFtcbiAgICAgICAgeyBwcm92aWRlOiBJTklUSUFMX0NPTkZJRywgdXNlVmFsdWU6IHsgZG9jdW1lbnQ6IG9wdGlvbnMuZG9jdW1lbnQsIHVybDogb3B0aW9ucy51cmwgfSB9LFxuICAgICAgICBleHRyYVByb3ZpZGVyc1xuICAgIF0pO1xufVxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHs/fSBwbGF0Zm9ybVxuICogQHBhcmFtIHs/fSBtb2R1bGVSZWZQcm9taXNlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfcmVuZGVyKHBsYXRmb3JtLCBtb2R1bGVSZWZQcm9taXNlKSB7XG4gICAgcmV0dXJuIG1vZHVsZVJlZlByb21pc2UudGhlbihmdW5jdGlvbiAobW9kdWxlUmVmKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zaXRpb25JZCA9IG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1VFJBTlNJVElPTl9JRCwgbnVsbCk7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZW5kZXJNb2R1bGVbRmFjdG9yeV0oKSByZXF1aXJlcyB0aGUgdXNlIG9mIEJyb3dzZXJNb2R1bGUud2l0aFNlcnZlclRyYW5zaXRpb24oKSB0byBlbnN1cmVcXG50aGUgc2VydmVyLXJlbmRlcmVkIGFwcCBjYW4gYmUgcHJvcGVybHkgYm9vdHN0cmFwcGVkIGludG8gYSBjbGllbnQgYXBwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcHBsaWNhdGlvblJlZiA9IG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoX2FuZ3VsYXJfY29yZS5BcHBsaWNhdGlvblJlZik7XG4gICAgICAgIHJldHVybiByeGpzX29wZXJhdG9yX3RvUHJvbWlzZS50b1Byb21pc2VcbiAgICAgICAgICAgIC5jYWxsKHJ4anNfb3BlcmF0b3JfZmlyc3QuZmlyc3QuY2FsbChyeGpzX29wZXJhdG9yX2ZpbHRlci5maWx0ZXIuY2FsbChhcHBsaWNhdGlvblJlZi5pc1N0YWJsZSwgZnVuY3Rpb24gKGlzU3RhYmxlKSB7IHJldHVybiBpc1N0YWJsZTsgfSkpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0cHV0ID0gcGxhdGZvcm0uaW5qZWN0b3IuZ2V0KFBsYXRmb3JtU3RhdGUpLnJlbmRlclRvU3RyaW5nKCk7XG4gICAgICAgICAgICBwbGF0Zm9ybS5kZXN0cm95KCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogUmVuZGVycyBhIE1vZHVsZSB0byBzdHJpbmcuXG4gKlxuICogYGRvY3VtZW50YCBpcyB0aGUgZnVsbCBkb2N1bWVudCBIVE1MIG9mIHRoZSBwYWdlIHRvIHJlbmRlciwgYXMgYSBzdHJpbmcuXG4gKiBgdXJsYCBpcyB0aGUgVVJMIGZvciB0aGUgY3VycmVudCByZW5kZXIgcmVxdWVzdC5cbiAqIGBleHRyYVByb3ZpZGVyc2AgYXJlIHRoZSBwbGF0Zm9ybSBsZXZlbCBwcm92aWRlcnMgZm9yIHRoZSBjdXJyZW50IHJlbmRlciByZXF1ZXN0LlxuICpcbiAqIERvIG5vdCB1c2UgdGhpcyBpbiBhIHByb2R1Y3Rpb24gc2VydmVyIGVudmlyb25tZW50LiBVc2UgcHJlLWNvbXBpbGVkIHtcXEBsaW5rIE5nTW9kdWxlRmFjdG9yeX0gd2l0aFxuICoge1xcQGxpbmsgcmVuZGVyTW9kdWxlRmFjdG9yeX0gaW5zdGVhZC5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0gez99IG1vZHVsZVxuICogQHBhcmFtIHs/fSBvcHRpb25zXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZW5kZXJNb2R1bGUobW9kdWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxhdGZvcm0gPSBfZ2V0UGxhdGZvcm0ocGxhdGZvcm1EeW5hbWljU2VydmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gX3JlbmRlcihwbGF0Zm9ybSwgcGxhdGZvcm0uYm9vdHN0cmFwTW9kdWxlKG1vZHVsZSkpO1xufVxuLyoqXG4gKiBSZW5kZXJzIGEge1xcQGxpbmsgTmdNb2R1bGVGYWN0b3J5fSB0byBzdHJpbmcuXG4gKlxuICogYGRvY3VtZW50YCBpcyB0aGUgZnVsbCBkb2N1bWVudCBIVE1MIG9mIHRoZSBwYWdlIHRvIHJlbmRlciwgYXMgYSBzdHJpbmcuXG4gKiBgdXJsYCBpcyB0aGUgVVJMIGZvciB0aGUgY3VycmVudCByZW5kZXIgcmVxdWVzdC5cbiAqIGBleHRyYVByb3ZpZGVyc2AgYXJlIHRoZSBwbGF0Zm9ybSBsZXZlbCBwcm92aWRlcnMgZm9yIHRoZSBjdXJyZW50IHJlbmRlciByZXF1ZXN0LlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7P30gbW9kdWxlRmFjdG9yeVxuICogQHBhcmFtIHs/fSBvcHRpb25zXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZW5kZXJNb2R1bGVGYWN0b3J5KG1vZHVsZUZhY3RvcnksIG9wdGlvbnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF0Zm9ybSA9IF9nZXRQbGF0Zm9ybShwbGF0Zm9ybVNlcnZlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF9yZW5kZXIocGxhdGZvcm0sIHBsYXRmb3JtLmJvb3RzdHJhcE1vZHVsZUZhY3RvcnkobW9kdWxlRmFjdG9yeSkpO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVudHJ5IHBvaW50IGZvciBhbGwgcHVibGljIEFQSXMgb2YgdGhlIGNvbW1vbiBwYWNrYWdlLlxuICovXG4vKipcbiAqIFxcQHN0YWJsZVxuICovXG52YXIgVkVSU0lPTiA9IG5ldyBfYW5ndWxhcl9jb3JlLlZlcnNpb24oJzQuMy42Jyk7XG5cbmV4cG9ydHMuUGxhdGZvcm1TdGF0ZSA9IFBsYXRmb3JtU3RhdGU7XG5leHBvcnRzLlNlcnZlck1vZHVsZSA9IFNlcnZlck1vZHVsZTtcbmV4cG9ydHMucGxhdGZvcm1EeW5hbWljU2VydmVyID0gcGxhdGZvcm1EeW5hbWljU2VydmVyO1xuZXhwb3J0cy5wbGF0Zm9ybVNlcnZlciA9IHBsYXRmb3JtU2VydmVyO1xuZXhwb3J0cy5JTklUSUFMX0NPTkZJRyA9IElOSVRJQUxfQ09ORklHO1xuZXhwb3J0cy5yZW5kZXJNb2R1bGUgPSByZW5kZXJNb2R1bGU7XG5leHBvcnRzLnJlbmRlck1vZHVsZUZhY3RvcnkgPSByZW5kZXJNb2R1bGVGYWN0b3J5O1xuZXhwb3J0cy5WRVJTSU9OID0gVkVSU0lPTjtcbmV4cG9ydHMuybVJTlRFUk5BTF9TRVJWRVJfUExBVEZPUk1fUFJPVklERVJTID0gSU5URVJOQUxfU0VSVkVSX1BMQVRGT1JNX1BST1ZJREVSUztcbmV4cG9ydHMuybVTRVJWRVJfUkVOREVSX1BST1ZJREVSUyA9IFNFUlZFUl9SRU5ERVJfUFJPVklERVJTO1xuZXhwb3J0cy7JtVNlcnZlclJlbmRlcmVyRmFjdG9yeTIgPSBTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyO1xuZXhwb3J0cy7JtWcgPSBTRVJWRVJfSFRUUF9QUk9WSURFUlM7XG5leHBvcnRzLsm1YyA9IFNlcnZlclhocjtcbmV4cG9ydHMuybVkID0gU2VydmVyWHNyZlN0cmF0ZWd5O1xuZXhwb3J0cy7JtWUgPSBodHRwRmFjdG9yeTtcbmV4cG9ydHMuybVmID0gem9uZVdyYXBwZWRJbnRlcmNlcHRpbmdIYW5kbGVyO1xuZXhwb3J0cy7JtWEgPSBpbnN0YW50aWF0ZVNlcnZlclJlbmRlcmVyRmFjdG9yeTtcbmV4cG9ydHMuybViID0gU2VydmVyU3R5bGVzSG9zdDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsYXRmb3JtLXNlcnZlci51bWQuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGFuZ3VsYXIvcGxhdGZvcm0tc2VydmVyL2J1bmRsZXMvcGxhdGZvcm0tc2VydmVyLnVtZC5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsImltcG9ydCB7IEluamVjdGFibGUsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgTG9hZGluZ1NlcnZpY2Uge1xyXG4gICAgbG9hZGluZ0NoYW5nZWQ6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIHB1YmxpYyBzaG93TG9hZGluZyA9IChpc0xvYWRpbmc6Ym9vbGVhbikgPT5cclxuICAgICAgICB0aGlzLmxvYWRpbmdDaGFuZ2VkLmVtaXQoaXNMb2FkaW5nKTtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3NlcnZpY2VzL2Zyb250ZW5kL2xvYWRpbmcuc2VydmljZS50cyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSwgZW1pdHRpbmcgdmFsdWVzIG9ubHkgZnJvbSB0aGUgbW9zdCByZWNlbnRseSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgc3dpdGNofS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zd2l0Y2hNYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiAoc28tY2FsbGVkIFwiaW5uZXJcIikgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZVxuICogaW5uZXIgT2JzZXJ2YWJsZXMsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnlcbiAqIHRoYXQgaW5uZXIgT2JzZXJ2YWJsZS4gV2hlbiBhIG5ldyBpbm5lciBPYnNlcnZhYmxlIGlzIGVtaXR0ZWQsIGBzd2l0Y2hNYXBgXG4gKiBzdG9wcyBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBlYXJsaWVyLWVtaXR0ZWQgaW5uZXIgT2JzZXJ2YWJsZSBhbmQgYmVnaW5zXG4gKiBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBuZXcgb25lLiBJdCBjb250aW51ZXMgdG8gYmVoYXZlIGxpa2UgdGhpcyBmb3JcbiAqIHN1YnNlcXVlbnQgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnN3aXRjaE1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0TWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXBUb31cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gKGFuZCB0aGUgb3B0aW9uYWwgYHJlc3VsdFNlbGVjdG9yYCkgdG8gZWFjaCBpdGVtIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgdGFraW5nIG9ubHkgdGhlIHZhbHVlcyBmcm9tIHRoZSBtb3N0IHJlY2VudGx5XG4gKiBwcm9qZWN0ZWQgaW5uZXIgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoTWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzd2l0Y2hNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc3dpdGNoTWFwT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBTd2l0Y2hNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvcikpO1xuICAgIH07XG59XG5leHBvcnRzLnN3aXRjaE1hcCA9IHN3aXRjaE1hcDtcbnZhciBTd2l0Y2hNYXBPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3dpdGNoTWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgIH1cbiAgICBTd2l0Y2hNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN3aXRjaE1hcFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcm9qZWN0LCB0aGlzLnJlc3VsdFNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoTWFwT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTd2l0Y2hNYXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3dpdGNoTWFwU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hNYXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdCh2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5uZXJTdWIocmVzdWx0LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX2lubmVyU3ViID0gZnVuY3Rpb24gKHJlc3VsdCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChpbm5lclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZCh0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXN1bHQsIHZhbHVlLCBpbmRleCkpO1xuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSB0aGlzLmlubmVyU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoIWlubmVyU3Vic2NyaXB0aW9uIHx8IGlubmVyU3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICBpZiAodGhpcy5yZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fdHJ5Tm90aWZ5TmV4dChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeU5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoTWFwU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2hNYXAuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL3N3aXRjaE1hcC5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDc0KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9maWx0ZXIuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHY0LjMuNlxuICogKGMpIDIwMTAtMjAxNyBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvYW5pbWF0aW9ucycpKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGFuZ3VsYXIvYW5pbWF0aW9ucyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5hbmltYXRpb25zID0gZ2xvYmFsLm5nLmFuaW1hdGlvbnMgfHwge30sIGdsb2JhbC5uZy5hbmltYXRpb25zLmJyb3dzZXIgPSBnbG9iYWwubmcuYW5pbWF0aW9ucy5icm93c2VyIHx8IHt9KSxnbG9iYWwubmcuYW5pbWF0aW9ucykpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsX2FuZ3VsYXJfYW5pbWF0aW9ucykgeyAndXNlIHN0cmljdCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2NC4zLjZcbiAqIChjKSAyMDEwLTIwMTcgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZUdyb3VwUGxheWVyKHBsYXllcnMpIHtcbiAgICBzd2l0Y2ggKHBsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfYW5pbWF0aW9ucy5Ob29wQW5pbWF0aW9uUGxheWVyKCk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBwbGF5ZXJzWzBdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfYW5ndWxhcl9hbmltYXRpb25zLsm1QW5pbWF0aW9uR3JvdXBQbGF5ZXIocGxheWVycyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplS2V5ZnJhbWVzKGRyaXZlciwgbm9ybWFsaXplciwgZWxlbWVudCwga2V5ZnJhbWVzLCBwcmVTdHlsZXMsIHBvc3RTdHlsZXMpIHtcbiAgICBpZiAocHJlU3R5bGVzID09PSB2b2lkIDApIHsgcHJlU3R5bGVzID0ge307IH1cbiAgICBpZiAocG9zdFN0eWxlcyA9PT0gdm9pZCAwKSB7IHBvc3RTdHlsZXMgPSB7fTsgfVxuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgbm9ybWFsaXplZEtleWZyYW1lcyA9IFtdO1xuICAgIHZhciBwcmV2aW91c09mZnNldCA9IC0xO1xuICAgIHZhciBwcmV2aW91c0tleWZyYW1lID0gbnVsbDtcbiAgICBrZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoa2YpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGtmWydvZmZzZXQnXTtcbiAgICAgICAgdmFyIGlzU2FtZU9mZnNldCA9IG9mZnNldCA9PSBwcmV2aW91c09mZnNldDtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRLZXlmcmFtZSA9IChpc1NhbWVPZmZzZXQgJiYgcHJldmlvdXNLZXlmcmFtZSkgfHwge307XG4gICAgICAgIE9iamVjdC5rZXlzKGtmKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZFByb3AgPSBwcm9wO1xuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZSA9IGtmW3Byb3BdO1xuICAgICAgICAgICAgaWYgKHByb3AgIT09ICdvZmZzZXQnKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVyLm5vcm1hbGl6ZVByb3BlcnR5TmFtZShub3JtYWxpemVkUHJvcCwgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vcm1hbGl6ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2FuaW1hdGlvbnMuybVQUkVfU1RZTEU6XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWUgPSBwcmVTdHlsZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9hbmltYXRpb25zLkFVVE9fU1RZTEU6XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWUgPSBwb3N0U3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZXIubm9ybWFsaXplU3R5bGVWYWx1ZShwcm9wLCBub3JtYWxpemVkUHJvcCwgbm9ybWFsaXplZFZhbHVlLCBlcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9ybWFsaXplZEtleWZyYW1lW25vcm1hbGl6ZWRQcm9wXSA9IG5vcm1hbGl6ZWRWYWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaXNTYW1lT2Zmc2V0KSB7XG4gICAgICAgICAgICBub3JtYWxpemVkS2V5ZnJhbWVzLnB1c2gobm9ybWFsaXplZEtleWZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c0tleWZyYW1lID0gbm9ybWFsaXplZEtleWZyYW1lO1xuICAgICAgICBwcmV2aW91c09mZnNldCA9IG9mZnNldDtcbiAgICB9KTtcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB2YXIgTElORV9TVEFSVCA9ICdcXG4gLSAnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gYW5pbWF0ZSBkdWUgdG8gdGhlIGZvbGxvd2luZyBlcnJvcnM6XCIgKyBMSU5FX1NUQVJUICsgZXJyb3JzLmpvaW4oTElORV9TVEFSVCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZEtleWZyYW1lcztcbn1cbmZ1bmN0aW9uIGxpc3Rlbk9uUGxheWVyKHBsYXllciwgZXZlbnROYW1lLCBldmVudCwgY2FsbGJhY2spIHtcbiAgICBzd2l0Y2ggKGV2ZW50TmFtZSkge1xuICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICBwbGF5ZXIub25TdGFydChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhldmVudCAmJiBjb3B5QW5pbWF0aW9uRXZlbnQoZXZlbnQsICdzdGFydCcsIHBsYXllci50b3RhbFRpbWUpKTsgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgICBwbGF5ZXIub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKGV2ZW50ICYmIGNvcHlBbmltYXRpb25FdmVudChldmVudCwgJ2RvbmUnLCBwbGF5ZXIudG90YWxUaW1lKSk7IH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICAgICAgcGxheWVyLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhldmVudCAmJiBjb3B5QW5pbWF0aW9uRXZlbnQoZXZlbnQsICdkZXN0cm95JywgcGxheWVyLnRvdGFsVGltZSkpOyB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvcHlBbmltYXRpb25FdmVudChlLCBwaGFzZU5hbWUsIHRvdGFsVGltZSkge1xuICAgIHZhciBldmVudCA9IG1ha2VBbmltYXRpb25FdmVudChlLmVsZW1lbnQsIGUudHJpZ2dlck5hbWUsIGUuZnJvbVN0YXRlLCBlLnRvU3RhdGUsIHBoYXNlTmFtZSB8fCBlLnBoYXNlTmFtZSwgdG90YWxUaW1lID09IHVuZGVmaW5lZCA/IGUudG90YWxUaW1lIDogdG90YWxUaW1lKTtcbiAgICB2YXIgZGF0YSA9IGVbJ19kYXRhJ107XG4gICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICBldmVudFsnX2RhdGEnXSA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBldmVudDtcbn1cbmZ1bmN0aW9uIG1ha2VBbmltYXRpb25FdmVudChlbGVtZW50LCB0cmlnZ2VyTmFtZSwgZnJvbVN0YXRlLCB0b1N0YXRlLCBwaGFzZU5hbWUsIHRvdGFsVGltZSkge1xuICAgIGlmIChwaGFzZU5hbWUgPT09IHZvaWQgMCkgeyBwaGFzZU5hbWUgPSAnJzsgfVxuICAgIGlmICh0b3RhbFRpbWUgPT09IHZvaWQgMCkgeyB0b3RhbFRpbWUgPSAwOyB9XG4gICAgcmV0dXJuIHsgZWxlbWVudDogZWxlbWVudCwgdHJpZ2dlck5hbWU6IHRyaWdnZXJOYW1lLCBmcm9tU3RhdGU6IGZyb21TdGF0ZSwgdG9TdGF0ZTogdG9TdGF0ZSwgcGhhc2VOYW1lOiBwaGFzZU5hbWUsIHRvdGFsVGltZTogdG90YWxUaW1lIH07XG59XG5mdW5jdGlvbiBnZXRPclNldEFzSW5NYXAobWFwLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHZhbHVlID0gbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUgPSBkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IG1hcFtrZXldO1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1hcFtrZXldID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGltZWxpbmVDb21tYW5kKGNvbW1hbmQpIHtcbiAgICB2YXIgc2VwYXJhdG9yUG9zID0gY29tbWFuZC5pbmRleE9mKCc6Jyk7XG4gICAgdmFyIGlkID0gY29tbWFuZC5zdWJzdHJpbmcoMSwgc2VwYXJhdG9yUG9zKTtcbiAgICB2YXIgYWN0aW9uID0gY29tbWFuZC5zdWJzdHIoc2VwYXJhdG9yUG9zICsgMSk7XG4gICAgcmV0dXJuIFtpZCwgYWN0aW9uXTtcbn1cbnZhciBfY29udGFpbnMgPSBmdW5jdGlvbiAoZWxtMSwgZWxtMikgeyByZXR1cm4gZmFsc2U7IH07XG52YXIgX21hdGNoZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IpIHsgcmV0dXJuIGZhbHNlOyB9O1xudmFyIF9xdWVyeSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvciwgbXVsdGkpIHtcbiAgICByZXR1cm4gW107XG59O1xuaWYgKHR5cGVvZiBFbGVtZW50ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gdGhpcyBpcyB3ZWxsIHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnNcbiAgICBfY29udGFpbnMgPSBmdW5jdGlvbiAoZWxtMSwgZWxtMikgeyByZXR1cm4gZWxtMS5jb250YWlucyhlbG0yKTsgfTtcbiAgICBpZiAoRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuICAgICAgICBfbWF0Y2hlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvcikgeyByZXR1cm4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKTsgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBwcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xuICAgICAgICB2YXIgZm5fMSA9IHByb3RvLm1hdGNoZXNTZWxlY3RvciB8fCBwcm90by5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgcHJvdG8ubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgIHByb3RvLm9NYXRjaGVzU2VsZWN0b3IgfHwgcHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuICAgICAgICBpZiAoZm5fMSkge1xuICAgICAgICAgICAgX21hdGNoZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IpIHsgcmV0dXJuIGZuXzEuYXBwbHkoZWxlbWVudCwgW3NlbGVjdG9yXSk7IH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3F1ZXJ5ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yLCBtdWx0aSkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAobXVsdGkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaC5hcHBseShyZXN1bHRzLCBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlbG0gPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG59XG52YXIgbWF0Y2hlc0VsZW1lbnQgPSBfbWF0Y2hlcztcbnZhciBjb250YWluc0VsZW1lbnQgPSBfY29udGFpbnM7XG52YXIgaW52b2tlUXVlcnkgPSBfcXVlcnk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xudmFyIE5vb3BBbmltYXRpb25Ecml2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vb3BBbmltYXRpb25Ecml2ZXIoKSB7XG4gICAgfVxuICAgIE5vb3BBbmltYXRpb25Ecml2ZXIucHJvdG90eXBlLm1hdGNoZXNFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzRWxlbWVudChlbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgfTtcbiAgICBOb29wQW5pbWF0aW9uRHJpdmVyLnByb3RvdHlwZS5jb250YWluc0VsZW1lbnQgPSBmdW5jdGlvbiAoZWxtMSwgZWxtMikgeyByZXR1cm4gY29udGFpbnNFbGVtZW50KGVsbTEsIGVsbTIpOyB9O1xuICAgIE5vb3BBbmltYXRpb25Ecml2ZXIucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yLCBtdWx0aSkge1xuICAgICAgICByZXR1cm4gaW52b2tlUXVlcnkoZWxlbWVudCwgc2VsZWN0b3IsIG11bHRpKTtcbiAgICB9O1xuICAgIE5vb3BBbmltYXRpb25Ecml2ZXIucHJvdG90eXBlLmNvbXB1dGVTdHlsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCAnJztcbiAgICB9O1xuICAgIE5vb3BBbmltYXRpb25Ecml2ZXIucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwga2V5ZnJhbWVzLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgcHJldmlvdXNQbGF5ZXJzKSB7XG4gICAgICAgIGlmIChwcmV2aW91c1BsYXllcnMgPT09IHZvaWQgMCkgeyBwcmV2aW91c1BsYXllcnMgPSBbXTsgfVxuICAgICAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2FuaW1hdGlvbnMuTm9vcEFuaW1hdGlvblBsYXllcigpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vb3BBbmltYXRpb25Ecml2ZXI7XG59KCkpO1xuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBBbmltYXRpb25Ecml2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkRyaXZlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIEFuaW1hdGlvbkRyaXZlcjtcbn0oKSk7XG5BbmltYXRpb25Ecml2ZXIuTk9PUCA9IG5ldyBOb29wQW5pbWF0aW9uRHJpdmVyKCk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgT05FX1NFQ09ORCA9IDEwMDA7XG52YXIgU1VCU1RJVFVUSU9OX0VYUFJfU1RBUlQgPSAne3snO1xudmFyIFNVQlNUSVRVVElPTl9FWFBSX0VORCA9ICd9fSc7XG52YXIgRU5URVJfQ0xBU1NOQU1FID0gJ25nLWVudGVyJztcbnZhciBMRUFWRV9DTEFTU05BTUUgPSAnbmctbGVhdmUnO1xudmFyIEVOVEVSX1NFTEVDVE9SID0gJy5uZy1lbnRlcic7XG52YXIgTEVBVkVfU0VMRUNUT1IgPSAnLm5nLWxlYXZlJztcbnZhciBOR19UUklHR0VSX0NMQVNTTkFNRSA9ICduZy10cmlnZ2VyJztcbnZhciBOR19UUklHR0VSX1NFTEVDVE9SID0gJy5uZy10cmlnZ2VyJztcbnZhciBOR19BTklNQVRJTkdfQ0xBU1NOQU1FID0gJ25nLWFuaW1hdGluZyc7XG52YXIgTkdfQU5JTUFUSU5HX1NFTEVDVE9SID0gJy5uZy1hbmltYXRpbmcnO1xuZnVuY3Rpb24gcmVzb2x2ZVRpbWluZ1ZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIHZhciBtYXRjaGVzID0gdmFsdWUubWF0Y2goL14oLT9bXFwuXFxkXSspKG0/cykvKTtcbiAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5sZW5ndGggPCAyKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gX2NvbnZlcnRUaW1lVmFsdWVUb01TKHBhcnNlRmxvYXQobWF0Y2hlc1sxXSksIG1hdGNoZXNbMl0pO1xufVxuZnVuY3Rpb24gX2NvbnZlcnRUaW1lVmFsdWVUb01TKHZhbHVlLCB1bml0KSB7XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICogT05FX1NFQ09ORDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlVGltaW5nKHRpbWluZ3MsIGVycm9ycywgYWxsb3dOZWdhdGl2ZVZhbHVlcykge1xuICAgIHJldHVybiB0aW1pbmdzLmhhc093blByb3BlcnR5KCdkdXJhdGlvbicpID9cbiAgICAgICAgdGltaW5ncyA6XG4gICAgICAgIHBhcnNlVGltZUV4cHJlc3Npb24odGltaW5ncywgZXJyb3JzLCBhbGxvd05lZ2F0aXZlVmFsdWVzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGltZUV4cHJlc3Npb24oZXhwLCBlcnJvcnMsIGFsbG93TmVnYXRpdmVWYWx1ZXMpIHtcbiAgICB2YXIgcmVnZXggPSAvXigtP1tcXC5cXGRdKykobT9zKSg/OlxccysoLT9bXFwuXFxkXSspKG0/cykpPyg/OlxccysoWy1hLXpdKyg/OlxcKC4rP1xcKSk/KSk/JC9pO1xuICAgIHZhciBkdXJhdGlvbjtcbiAgICB2YXIgZGVsYXkgPSAwO1xuICAgIHZhciBlYXNpbmcgPSAnJztcbiAgICBpZiAodHlwZW9mIGV4cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBleHAubWF0Y2gocmVnZXgpO1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJUaGUgcHJvdmlkZWQgdGltaW5nIHZhbHVlIFxcXCJcIiArIGV4cCArIFwiXFxcIiBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IGR1cmF0aW9uOiAwLCBkZWxheTogMCwgZWFzaW5nOiAnJyB9O1xuICAgICAgICB9XG4gICAgICAgIGR1cmF0aW9uID0gX2NvbnZlcnRUaW1lVmFsdWVUb01TKHBhcnNlRmxvYXQobWF0Y2hlc1sxXSksIG1hdGNoZXNbMl0pO1xuICAgICAgICB2YXIgZGVsYXlNYXRjaCA9IG1hdGNoZXNbM107XG4gICAgICAgIGlmIChkZWxheU1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGF5ID0gX2NvbnZlcnRUaW1lVmFsdWVUb01TKE1hdGguZmxvb3IocGFyc2VGbG9hdChkZWxheU1hdGNoKSksIG1hdGNoZXNbNF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlYXNpbmdWYWwgPSBtYXRjaGVzWzVdO1xuICAgICAgICBpZiAoZWFzaW5nVmFsKSB7XG4gICAgICAgICAgICBlYXNpbmcgPSBlYXNpbmdWYWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGR1cmF0aW9uID0gZXhwO1xuICAgIH1cbiAgICBpZiAoIWFsbG93TmVnYXRpdmVWYWx1ZXMpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5zRXJyb3JzID0gZmFsc2U7XG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gZXJyb3JzLmxlbmd0aDtcbiAgICAgICAgaWYgKGR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJEdXJhdGlvbiB2YWx1ZXMgYmVsb3cgMCBhcmUgbm90IGFsbG93ZWQgZm9yIHRoaXMgYW5pbWF0aW9uIHN0ZXAuXCIpO1xuICAgICAgICAgICAgY29udGFpbnNFcnJvcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWxheSA8IDApIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiRGVsYXkgdmFsdWVzIGJlbG93IDAgYXJlIG5vdCBhbGxvd2VkIGZvciB0aGlzIGFuaW1hdGlvbiBzdGVwLlwiKTtcbiAgICAgICAgICAgIGNvbnRhaW5zRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbnNFcnJvcnMpIHtcbiAgICAgICAgICAgIGVycm9ycy5zcGxpY2Uoc3RhcnRJbmRleCwgMCwgXCJUaGUgcHJvdmlkZWQgdGltaW5nIHZhbHVlIFxcXCJcIiArIGV4cCArIFwiXFxcIiBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkdXJhdGlvbjogZHVyYXRpb24sIGRlbGF5OiBkZWxheSwgZWFzaW5nOiBlYXNpbmcgfTtcbn1cbmZ1bmN0aW9uIGNvcHlPYmoob2JqLCBkZXN0aW5hdGlvbikge1xuICAgIGlmIChkZXN0aW5hdGlvbiA9PT0gdm9pZCAwKSB7IGRlc3RpbmF0aW9uID0ge307IH1cbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgZGVzdGluYXRpb25bcHJvcF0gPSBvYmpbcHJvcF07IH0pO1xuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlcyhzdHlsZXMpIHtcbiAgICB2YXIgbm9ybWFsaXplZFN0eWxlcyA9IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcbiAgICAgICAgc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGNvcHlTdHlsZXMoZGF0YSwgZmFsc2UsIG5vcm1hbGl6ZWRTdHlsZXMpOyB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvcHlTdHlsZXMoc3R5bGVzLCBmYWxzZSwgbm9ybWFsaXplZFN0eWxlcyk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkU3R5bGVzO1xufVxuZnVuY3Rpb24gY29weVN0eWxlcyhzdHlsZXMsIHJlYWRQcm90b3R5cGUsIGRlc3RpbmF0aW9uKSB7XG4gICAgaWYgKGRlc3RpbmF0aW9uID09PSB2b2lkIDApIHsgZGVzdGluYXRpb24gPSB7fTsgfVxuICAgIGlmIChyZWFkUHJvdG90eXBlKSB7XG4gICAgICAgIC8vIHdlIG1ha2UgdXNlIG9mIGEgZm9yLWluIGxvb3Agc28gdGhhdCB0aGVcbiAgICAgICAgLy8gcHJvdG90eXBpY2FsbHkgaW5oZXJpdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICAgIC8vIHJldmVhbGVkIGZyb20gdGhlIGJhY2tGaWxsIG1hcFxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlcykge1xuICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcF0gPSBzdHlsZXNbcHJvcF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvcHlPYmooc3R5bGVzLCBkZXN0aW5hdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbn1cbmZ1bmN0aW9uIHNldFN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgICBpZiAoZWxlbWVudFsnc3R5bGUnXSkge1xuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciBjYW1lbFByb3AgPSBkYXNoQ2FzZVRvQ2FtZWxDYXNlKHByb3ApO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtjYW1lbFByb3BdID0gc3R5bGVzW3Byb3BdO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBlcmFzZVN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgICBpZiAoZWxlbWVudFsnc3R5bGUnXSkge1xuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciBjYW1lbFByb3AgPSBkYXNoQ2FzZVRvQ2FtZWxDYXNlKHByb3ApO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtjYW1lbFByb3BdID0gJyc7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KHN0ZXBzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3RlcHMpKSB7XG4gICAgICAgIGlmIChzdGVwcy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBzdGVwc1swXTtcbiAgICAgICAgcmV0dXJuIF9hbmd1bGFyX2FuaW1hdGlvbnMuc2VxdWVuY2Uoc3RlcHMpO1xuICAgIH1cbiAgICByZXR1cm4gc3RlcHM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVN0eWxlUGFyYW1zKHZhbHVlLCBvcHRpb25zLCBlcnJvcnMpIHtcbiAgICB2YXIgcGFyYW1zID0gb3B0aW9ucy5wYXJhbXMgfHwge307XG4gICAgdmFyIG1hdGNoZXMgPSBleHRyYWN0U3R5bGVQYXJhbXModmFsdWUpO1xuICAgIGlmIChtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICBtYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKHZhck5hbWUpIHtcbiAgICAgICAgICAgIGlmICghcGFyYW1zLmhhc093blByb3BlcnR5KHZhck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJVbmFibGUgdG8gcmVzb2x2ZSB0aGUgbG9jYWwgYW5pbWF0aW9uIHBhcmFtIFwiICsgdmFyTmFtZSArIFwiIGluIHRoZSBnaXZlbiBsaXN0IG9mIHZhbHVlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxudmFyIFBBUkFNX1JFR0VYID0gbmV3IFJlZ0V4cChTVUJTVElUVVRJT05fRVhQUl9TVEFSVCArIFwiXFxcXHMqKC4rPylcXFxccypcIiArIFNVQlNUSVRVVElPTl9FWFBSX0VORCwgJ2cnKTtcbmZ1bmN0aW9uIGV4dHJhY3RTdHlsZVBhcmFtcyh2YWx1ZSkge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdmFsID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIG1hdGNoID0gdm9pZCAwO1xuICAgICAgICB3aGlsZSAobWF0Y2ggPSBQQVJBTV9SRUdFWC5leGVjKHZhbCkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBQQVJBTV9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVQYXJhbXModmFsdWUsIHBhcmFtcywgZXJyb3JzKSB7XG4gICAgdmFyIG9yaWdpbmFsID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB2YXIgc3RyID0gb3JpZ2luYWwucmVwbGFjZShQQVJBTV9SRUdFWCwgZnVuY3Rpb24gKF8sIHZhck5hbWUpIHtcbiAgICAgICAgdmFyIGxvY2FsVmFsID0gcGFyYW1zW3Zhck5hbWVdO1xuICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgdGhlIHZhbHVlIHdhcyBuZXZlciBvdmVyaWRkZW4gYnkgdGhlIGRhdGEgcGFzc2VkIGluIGJ5IHRoZSB1c2VyXG4gICAgICAgIGlmICghcGFyYW1zLmhhc093blByb3BlcnR5KHZhck5hbWUpKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChcIlBsZWFzZSBwcm92aWRlIGEgdmFsdWUgZm9yIHRoZSBhbmltYXRpb24gcGFyYW0gXCIgKyB2YXJOYW1lKTtcbiAgICAgICAgICAgIGxvY2FsVmFsID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsVmFsLnRvU3RyaW5nKCk7XG4gICAgfSk7XG4gICAgLy8gd2UgZG8gdGhpcyB0byBhc3NlcnQgdGhhdCBudW1lcmljIHZhbHVlcyBzdGF5IGFzIHRoZXkgYXJlXG4gICAgcmV0dXJuIHN0ciA9PSBvcmlnaW5hbCA/IHZhbHVlIDogc3RyO1xufVxuZnVuY3Rpb24gaXRlcmF0b3JUb0FycmF5KGl0ZXJhdG9yKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIHZhciBpdGVtID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIHdoaWxlICghaXRlbS5kb25lKSB7XG4gICAgICAgIGFyci5wdXNoKGl0ZW0udmFsdWUpO1xuICAgICAgICBpdGVtID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxudmFyIERBU0hfQ0FTRV9SRUdFWFAgPSAvLSsoW2EtejAtOV0pL2c7XG5mdW5jdGlvbiBkYXNoQ2FzZVRvQ2FtZWxDYXNlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoREFTSF9DQVNFX1JFR0VYUCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhbGxvd1ByZXZpb3VzUGxheWVyU3R5bGVzTWVyZ2UoZHVyYXRpb24sIGRlbGF5KSB7XG4gICAgcmV0dXJuIGR1cmF0aW9uID09PSAwIHx8IGRlbGF5ID09PSAwO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEVNUFRZX0FOSU1BVElPTl9PUFRJT05TID0ge307XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3QoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IEVNUFRZX0FOSU1BVElPTl9PUFRJT05TO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXN0LnByb3RvdHlwZSwgXCJwYXJhbXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5vcHRpb25zWydwYXJhbXMnXSB8fCBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQXN0O1xufSgpKTtcbnZhciBUcmlnZ2VyQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJpZ2dlckFzdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlc1xuICAgICAqIEBwYXJhbSB7P30gdHJhbnNpdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmlnZ2VyQXN0KG5hbWUsIHN0YXRlcywgdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnN0YXRlcyA9IHN0YXRlcztcbiAgICAgICAgX3RoaXMudHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucztcbiAgICAgICAgX3RoaXMucXVlcnlDb3VudCA9IDA7XG4gICAgICAgIF90aGlzLmRlcENvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyaWdnZXJBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUcmlnZ2VyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBUcmlnZ2VyQXN0O1xufShBc3QpKTtcbnZhciBTdGF0ZUFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YXRlQXN0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGF0ZUFzdChuYW1lLCBzdHlsZSQkMSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMuc3R5bGUgPSBzdHlsZSQkMTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0U3RhdGUodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFN0YXRlQXN0O1xufShBc3QpKTtcbnZhciBUcmFuc2l0aW9uQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJhbnNpdGlvbkFzdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1hdGNoZXJzXG4gICAgICogQHBhcmFtIHs/fSBhbmltYXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uQXN0KG1hdGNoZXJzLCBhbmltYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWF0Y2hlcnMgPSBtYXRjaGVycztcbiAgICAgICAgX3RoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgICAgICBfdGhpcy5xdWVyeUNvdW50ID0gMDtcbiAgICAgICAgX3RoaXMuZGVwQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRyYW5zaXRpb24odGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFRyYW5zaXRpb25Bc3Q7XG59KEFzdCkpO1xudmFyIFNlcXVlbmNlQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VxdWVuY2VBc3QsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGVwc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNlcXVlbmNlQXN0KHN0ZXBzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXF1ZW5jZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFNlcXVlbmNlKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBTZXF1ZW5jZUFzdDtcbn0oQXN0KSk7XG52YXIgR3JvdXBBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcm91cEFzdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0ZXBzXG4gICAgICovXG4gICAgZnVuY3Rpb24gR3JvdXBBc3Qoc3RlcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RlcHMgPSBzdGVwcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEdyb3VwQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0R3JvdXAodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEdyb3VwQXN0O1xufShBc3QpKTtcbnZhciBBbmltYXRlQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5pbWF0ZUFzdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRpbWluZ3NcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gQW5pbWF0ZUFzdCh0aW1pbmdzLCBzdHlsZSQkMSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50aW1pbmdzID0gdGltaW5ncztcbiAgICAgICAgX3RoaXMuc3R5bGUgPSBzdHlsZSQkMTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRlKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBBbmltYXRlQXN0O1xufShBc3QpKTtcbnZhciBTdHlsZUFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0eWxlQXN0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzXG4gICAgICogQHBhcmFtIHs/fSBlYXNpbmdcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0eWxlQXN0KHN0eWxlcywgZWFzaW5nLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICBfdGhpcy5lYXNpbmcgPSBlYXNpbmc7XG4gICAgICAgIF90aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgX3RoaXMuaXNFbXB0eVN0ZXAgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuY29udGFpbnNEeW5hbWljU3R5bGVzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdHlsZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFN0eWxlKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBTdHlsZUFzdDtcbn0oQXN0KSk7XG52YXIgS2V5ZnJhbWVzQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS2V5ZnJhbWVzQXN0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gS2V5ZnJhbWVzQXN0KHN0eWxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBLZXlmcmFtZXNBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXlmcmFtZXModGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEtleWZyYW1lc0FzdDtcbn0oQXN0KSk7XG52YXIgUmVmZXJlbmNlQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVmZXJlbmNlQXN0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYW5pbWF0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVmZXJlbmNlQXN0KGFuaW1hdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWZlcmVuY2VBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWZlcmVuY2UodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFJlZmVyZW5jZUFzdDtcbn0oQXN0KSk7XG52YXIgQW5pbWF0ZUNoaWxkQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5pbWF0ZUNoaWxkQXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFuaW1hdGVDaGlsZEFzdCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0ZUNoaWxkQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0ZUNoaWxkKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBBbmltYXRlQ2hpbGRBc3Q7XG59KEFzdCkpO1xudmFyIEFuaW1hdGVSZWZBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbmltYXRlUmVmQXN0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYW5pbWF0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gQW5pbWF0ZVJlZkFzdChhbmltYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0ZVJlZkFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGVSZWYodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEFuaW1hdGVSZWZBc3Q7XG59KEFzdCkpO1xudmFyIFF1ZXJ5QXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUXVlcnlBc3QsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbGltaXRcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbmFsXG4gICAgICogQHBhcmFtIHs/fSBpbmNsdWRlU2VsZlxuICAgICAqIEBwYXJhbSB7P30gYW5pbWF0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gUXVlcnlBc3Qoc2VsZWN0b3IsIGxpbWl0LCBvcHRpb25hbCwgaW5jbHVkZVNlbGYsIGFuaW1hdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICBfdGhpcy5saW1pdCA9IGxpbWl0O1xuICAgICAgICBfdGhpcy5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgICBfdGhpcy5pbmNsdWRlU2VsZiA9IGluY2x1ZGVTZWxmO1xuICAgICAgICBfdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBRdWVyeUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFF1ZXJ5KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBRdWVyeUFzdDtcbn0oQXN0KSk7XG52YXIgU3RhZ2dlckFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YWdnZXJBc3QsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0aW1pbmdzXG4gICAgICogQHBhcmFtIHs/fSBhbmltYXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGFnZ2VyQXN0KHRpbWluZ3MsIGFuaW1hdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50aW1pbmdzID0gdGltaW5ncztcbiAgICAgICAgX3RoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhZ2dlckFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFN0YWdnZXIodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFN0YWdnZXJBc3Q7XG59KEFzdCkpO1xudmFyIFRpbWluZ0FzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRpbWluZ0FzdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGR1cmF0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gZGVsYXlcbiAgICAgKiBAcGFyYW0gez89fSBlYXNpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUaW1pbmdBc3QoZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIGlmIChlYXNpbmcgPT09IHZvaWQgMCkgeyBlYXNpbmcgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIF90aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIF90aGlzLmVhc2luZyA9IGVhc2luZztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWluZ0FzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRpbWluZyh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gVGltaW5nQXN0O1xufShBc3QpKTtcbnZhciBEeW5hbWljVGltaW5nQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRHluYW1pY1RpbWluZ0FzdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gRHluYW1pY1RpbWluZ0FzdCh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAwLCAwLCAnJykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIER5bmFtaWNUaW1pbmdBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUaW1pbmcodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIER5bmFtaWNUaW1pbmdBc3Q7XG59KFRpbWluZ0FzdCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IHZpc2l0b3JcbiAqIEBwYXJhbSB7P30gbm9kZVxuICogQHBhcmFtIHs/fSBjb250ZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB2aXNpdEFuaW1hdGlvbk5vZGUodmlzaXRvciwgbm9kZSwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgNyAvKiBUcmlnZ2VyICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUcmlnZ2VyKC8qKiBAdHlwZSB7P30gKi8gKG5vZGUpLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAwIC8qIFN0YXRlICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdGF0ZSgvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgMSAvKiBUcmFuc2l0aW9uICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUcmFuc2l0aW9uKC8qKiBAdHlwZSB7P30gKi8gKG5vZGUpLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAyIC8qIFNlcXVlbmNlICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTZXF1ZW5jZSgvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgMyAvKiBHcm91cCAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0R3JvdXAoLyoqIEB0eXBlIHs/fSAqLyAobm9kZSksIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDQgLyogQW5pbWF0ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0ZSgvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgNSAvKiBLZXlmcmFtZXMgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEtleWZyYW1lcygvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgNiAvKiBTdHlsZSAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3R5bGUoLyoqIEB0eXBlIHs/fSAqLyAobm9kZSksIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDggLyogUmVmZXJlbmNlICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWZlcmVuY2UoLyoqIEB0eXBlIHs/fSAqLyAobm9kZSksIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDkgLyogQW5pbWF0ZUNoaWxkICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRlQ2hpbGQoLyoqIEB0eXBlIHs/fSAqLyAobm9kZSksIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDEwIC8qIEFuaW1hdGVSZWYgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGVSZWYoLyoqIEB0eXBlIHs/fSAqLyAobm9kZSksIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDExIC8qIFF1ZXJ5ICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRRdWVyeSgvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgMTIgLyogU3RhZ2dlciAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3RhZ2dlcigvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSBhbmltYXRpb24gbWV0YWRhdGEgbm9kZSAjXCIgKyBub2RlLnR5cGUpO1xuICAgIH1cbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBBTllfU1RBVEUgPSAnKic7XG4vKipcbiAqIEBwYXJhbSB7P30gdHJhbnNpdGlvblZhbHVlXG4gKiBAcGFyYW0gez99IGVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcGFyc2VUcmFuc2l0aW9uRXhwcih0cmFuc2l0aW9uVmFsdWUsIGVycm9ycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb25zID0gW107XG4gICAgaWYgKHR5cGVvZiB0cmFuc2l0aW9uVmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgKCh0cmFuc2l0aW9uVmFsdWUpKVxuICAgICAgICAgICAgLnNwbGl0KC9cXHMqLFxccyovKVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gcGFyc2VJbm5lclRyYW5zaXRpb25TdHIoc3RyLCBleHByZXNzaW9ucywgZXJyb3JzKTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBleHByZXNzaW9ucy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKHRyYW5zaXRpb25WYWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcmVzc2lvbnM7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZXZlbnRTdHJcbiAqIEBwYXJhbSB7P30gZXhwcmVzc2lvbnNcbiAqIEBwYXJhbSB7P30gZXJyb3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwYXJzZUlubmVyVHJhbnNpdGlvblN0cihldmVudFN0ciwgZXhwcmVzc2lvbnMsIGVycm9ycykge1xuICAgIGlmIChldmVudFN0clswXSA9PSAnOicpIHtcbiAgICAgICAgZXZlbnRTdHIgPSBwYXJzZUFuaW1hdGlvbkFsaWFzKGV2ZW50U3RyLCBlcnJvcnMpO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaCA9IGV2ZW50U3RyLm1hdGNoKC9eKFxcKnxbLVxcd10rKVxccyooPD9bPS1dPilcXHMqKFxcKnxbLVxcd10rKSQvKTtcbiAgICBpZiAobWF0Y2ggPT0gbnVsbCB8fCBtYXRjaC5sZW5ndGggPCA0KSB7XG4gICAgICAgIGVycm9ycy5wdXNoKFwiVGhlIHByb3ZpZGVkIHRyYW5zaXRpb24gZXhwcmVzc2lvbiBcXFwiXCIgKyBldmVudFN0ciArIFwiXFxcIiBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnM7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZyb21TdGF0ZSA9IG1hdGNoWzFdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlcGFyYXRvciA9IG1hdGNoWzJdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvU3RhdGUgPSBtYXRjaFszXTtcbiAgICBleHByZXNzaW9ucy5wdXNoKG1ha2VMYW1iZGFGcm9tU3RhdGVzKGZyb21TdGF0ZSwgdG9TdGF0ZSkpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzRnVsbEFueVN0YXRlRXhwciA9IGZyb21TdGF0ZSA9PSBBTllfU1RBVEUgJiYgdG9TdGF0ZSA9PSBBTllfU1RBVEU7XG4gICAgaWYgKHNlcGFyYXRvclswXSA9PSAnPCcgJiYgIWlzRnVsbEFueVN0YXRlRXhwcikge1xuICAgICAgICBleHByZXNzaW9ucy5wdXNoKG1ha2VMYW1iZGFGcm9tU3RhdGVzKHRvU3RhdGUsIGZyb21TdGF0ZSkpO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBhbGlhc1xuICogQHBhcmFtIHs/fSBlcnJvcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHBhcnNlQW5pbWF0aW9uQWxpYXMoYWxpYXMsIGVycm9ycykge1xuICAgIHN3aXRjaCAoYWxpYXMpIHtcbiAgICAgICAgY2FzZSAnOmVudGVyJzpcbiAgICAgICAgICAgIHJldHVybiAndm9pZCA9PiAqJztcbiAgICAgICAgY2FzZSAnOmxlYXZlJzpcbiAgICAgICAgICAgIHJldHVybiAnKiA9PiB2b2lkJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiVGhlIHRyYW5zaXRpb24gYWxpYXMgdmFsdWUgXFxcIlwiICsgYWxpYXMgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiAnKiA9PiAqJztcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbGhzXG4gKiBAcGFyYW0gez99IHJoc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbWFrZUxhbWJkYUZyb21TdGF0ZXMobGhzLCByaHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZyb21TdGF0ZSwgdG9TdGF0ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaHNNYXRjaCA9IGxocyA9PSBBTllfU1RBVEUgfHwgbGhzID09IGZyb21TdGF0ZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmhzTWF0Y2ggPSByaHMgPT0gQU5ZX1NUQVRFIHx8IHJocyA9PSB0b1N0YXRlO1xuICAgICAgICBpZiAoIWxoc01hdGNoICYmIHR5cGVvZiBmcm9tU3RhdGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgbGhzTWF0Y2ggPSBmcm9tU3RhdGUgPyBsaHMgPT09ICd0cnVlJyA6IGxocyA9PT0gJ2ZhbHNlJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJoc01hdGNoICYmIHR5cGVvZiB0b1N0YXRlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJoc01hdGNoID0gdG9TdGF0ZSA/IHJocyA9PT0gJ3RydWUnIDogcmhzID09PSAnZmFsc2UnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaHNNYXRjaCAmJiByaHNNYXRjaDtcbiAgICB9O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFNFTEZfVE9LRU4gPSAnOnNlbGYnO1xudmFyIFNFTEZfVE9LRU5fUkVHRVggPSBuZXcgUmVnRXhwKFwicypcIiArIFNFTEZfVE9LRU4gKyBcInMqLD9cIiwgJ2cnKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICogQHBhcmFtIHs/fSBlcnJvcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQW5pbWF0aW9uQXN0KG1ldGFkYXRhLCBlcnJvcnMpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yKCkuYnVpbGQobWV0YWRhdGEsIGVycm9ycyk7XG59XG52YXIgTEVBVkVfVE9LRU4gPSAnOmxlYXZlJztcbnZhciBMRUFWRV9UT0tFTl9SRUdFWCA9IG5ldyBSZWdFeHAoTEVBVkVfVE9LRU4sICdnJyk7XG52YXIgRU5URVJfVE9LRU4gPSAnOmVudGVyJztcbnZhciBFTlRFUl9UT0tFTl9SRUdFWCA9IG5ldyBSZWdFeHAoRU5URVJfVE9LRU4sICdnJyk7XG52YXIgUk9PVF9TRUxFQ1RPUiA9ICcnO1xudmFyIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGVycm9ycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZXh0ID0gbmV3IEFuaW1hdGlvbkFzdEJ1aWxkZXJDb250ZXh0KGVycm9ycyk7XG4gICAgICAgIHRoaXMuX3Jlc2V0Q29udGV4dFN0eWxlVGltaW5nU3RhdGUoY29udGV4dCk7XG4gICAgICAgIHJldHVybiAodmlzaXRBbmltYXRpb25Ob2RlKHRoaXMsIG5vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KG1ldGFkYXRhKSwgY29udGV4dCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX3Jlc2V0Q29udGV4dFN0eWxlVGltaW5nU3RhdGUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeVNlbGVjdG9yID0gUk9PVF9TRUxFQ1RPUjtcbiAgICAgICAgY29udGV4dC5jb2xsZWN0ZWRTdHlsZXMgPSB7fTtcbiAgICAgICAgY29udGV4dC5jb2xsZWN0ZWRTdHlsZXNbUk9PVF9TRUxFQ1RPUl0gPSB7fTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50VGltZSA9IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcmlnZ2VyID0gZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJ5Q291bnQgPSBjb250ZXh0LnF1ZXJ5Q291bnQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBDb3VudCA9IGNvbnRleHQuZGVwQ291bnQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0ZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNpdGlvbnMgPSBbXTtcbiAgICAgICAgbWV0YWRhdGEuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVmKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVzZXRDb250ZXh0U3R5bGVUaW1pbmdTdGF0ZShjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChkZWYudHlwZSA9PSAwIC8qIFN0YXRlICovKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGVEZWZfMSA9IChkZWYpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBzdGF0ZURlZl8xLm5hbWU7XG4gICAgICAgICAgICAgICAgbmFtZS5zcGxpdCgvXFxzKixcXHMqLykuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZURlZl8xLm5hbWUgPSBuO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZXMucHVzaChfdGhpcy52aXNpdFN0YXRlKHN0YXRlRGVmXzEsIGNvbnRleHQpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0ZURlZl8xLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVmLnR5cGUgPT0gMSAvKiBUcmFuc2l0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNpdGlvbiA9IF90aGlzLnZpc2l0VHJhbnNpdGlvbigvKiogQHR5cGUgez99ICovIChkZWYpLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBxdWVyeUNvdW50ICs9IHRyYW5zaXRpb24ucXVlcnlDb3VudDtcbiAgICAgICAgICAgICAgICBkZXBDb3VudCArPSB0cmFuc2l0aW9uLmRlcENvdW50O1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zLnB1c2godHJhbnNpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKCdvbmx5IHN0YXRlKCkgYW5kIHRyYW5zaXRpb24oKSBkZWZpbml0aW9ucyBjYW4gc2l0IGluc2lkZSBvZiBhIHRyaWdnZXIoKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gbmV3IFRyaWdnZXJBc3QobWV0YWRhdGEubmFtZSwgc3RhdGVzLCB0cmFuc2l0aW9ucyk7XG4gICAgICAgIGFzdC5vcHRpb25zID0gbm9ybWFsaXplQW5pbWF0aW9uT3B0aW9ucyhtZXRhZGF0YS5vcHRpb25zKTtcbiAgICAgICAgYXN0LnF1ZXJ5Q291bnQgPSBxdWVyeUNvdW50O1xuICAgICAgICBhc3QuZGVwQ291bnQgPSBkZXBDb3VudDtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFN0YXRlID0gZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlQXN0ID0gdGhpcy52aXNpdFN0eWxlKG1ldGFkYXRhLnN0eWxlcywgY29udGV4dCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdFBhcmFtcyA9IChtZXRhZGF0YS5vcHRpb25zICYmIG1ldGFkYXRhLm9wdGlvbnMucGFyYW1zKSB8fCBudWxsO1xuICAgICAgICBpZiAoc3R5bGVBc3QuY29udGFpbnNEeW5hbWljU3R5bGVzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtaXNzaW5nU3Vic18xID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1zXzEgPSBhc3RQYXJhbXMgfHwge307XG4gICAgICAgICAgICBzdHlsZUFzdC5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlc09ial8xID0gKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVzT2JqXzEpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RTdHlsZVBhcmFtcyhzdHlsZXNPYmpfMVtwcm9wXSkuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbXNfMS5oYXNPd25Qcm9wZXJ0eShzdWIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmdTdWJzXzEuYWRkKHN1Yik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG1pc3NpbmdTdWJzXzEuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1pc3NpbmdTdWJzQXJyID0gaXRlcmF0b3JUb0FycmF5KG1pc3NpbmdTdWJzXzEudmFsdWVzKCkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goXCJzdGF0ZShcXFwiXCIgKyBtZXRhZGF0YS5uYW1lICsgXCJcXFwiLCAuLi4pIG11c3QgZGVmaW5lIGRlZmF1bHQgdmFsdWVzIGZvciBhbGwgdGhlIGZvbGxvd2luZyBzdHlsZSBzdWJzdGl0dXRpb25zOiBcIiArIG1pc3NpbmdTdWJzQXJyLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlQXN0ID0gbmV3IFN0YXRlQXN0KG1ldGFkYXRhLm5hbWUsIHN0eWxlQXN0KTtcbiAgICAgICAgaWYgKGFzdFBhcmFtcykge1xuICAgICAgICAgICAgc3RhdGVBc3Qub3B0aW9ucyA9IHsgcGFyYW1zOiBhc3RQYXJhbXMgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGVBc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQucXVlcnlDb3VudCA9IDA7XG4gICAgICAgIGNvbnRleHQuZGVwQ291bnQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeSA9IHZpc2l0QW5pbWF0aW9uTm9kZSh0aGlzLCBub3JtYWxpemVBbmltYXRpb25FbnRyeShtZXRhZGF0YS5hbmltYXRpb24pLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlcnMgPSBwYXJzZVRyYW5zaXRpb25FeHByKG1ldGFkYXRhLmV4cHIsIGNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gbmV3IFRyYW5zaXRpb25Bc3QobWF0Y2hlcnMsIGVudHJ5KTtcbiAgICAgICAgYXN0Lm9wdGlvbnMgPSBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpO1xuICAgICAgICBhc3QucXVlcnlDb3VudCA9IGNvbnRleHQucXVlcnlDb3VudDtcbiAgICAgICAgYXN0LmRlcENvdW50ID0gY29udGV4dC5kZXBDb3VudDtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNlcXVlbmNlID0gZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IG5ldyBTZXF1ZW5jZUFzdChtZXRhZGF0YS5zdGVwcy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHZpc2l0QW5pbWF0aW9uTm9kZShfdGhpcywgcywgY29udGV4dCk7IH0pKTtcbiAgICAgICAgYXN0Lm9wdGlvbnMgPSBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0R3JvdXAgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VycmVudFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdXJ0aGVzdFRpbWUgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGVwcyA9IG1ldGFkYXRhLnN0ZXBzLm1hcChmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJBc3QgPSB2aXNpdEFuaW1hdGlvbk5vZGUoX3RoaXMsIHN0ZXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgZnVydGhlc3RUaW1lID0gTWF0aC5tYXgoZnVydGhlc3RUaW1lLCBjb250ZXh0LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiBpbm5lckFzdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFRpbWUgPSBmdXJ0aGVzdFRpbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IG5ldyBHcm91cEFzdChzdGVwcyk7XG4gICAgICAgIGFzdC5vcHRpb25zID0gbm9ybWFsaXplQW5pbWF0aW9uT3B0aW9ucyhtZXRhZGF0YS5vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFuaW1hdGUgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltaW5nQXN0ID0gY29uc3RydWN0VGltaW5nQXN0KG1ldGFkYXRhLnRpbWluZ3MsIGNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSB0aW1pbmdBc3Q7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVNZXRhZGF0YSA9IG1ldGFkYXRhLnN0eWxlcyA/IG1ldGFkYXRhLnN0eWxlcyA6IF9hbmd1bGFyX2FuaW1hdGlvbnMuc3R5bGUoe30pO1xuICAgICAgICBpZiAoc3R5bGVNZXRhZGF0YS50eXBlID09IDUgLyogS2V5ZnJhbWVzICovKSB7XG4gICAgICAgICAgICBzdHlsZXMgPSB0aGlzLnZpc2l0S2V5ZnJhbWVzKC8qKiBAdHlwZSB7P30gKi8gKHN0eWxlTWV0YWRhdGEpLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlTWV0YWRhdGFfMSA9IChtZXRhZGF0YS5zdHlsZXMpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFzdHlsZU1ldGFkYXRhXzEpIHtcbiAgICAgICAgICAgICAgICBpc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXdTdHlsZURhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAodGltaW5nQXN0LmVhc2luZykge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdHlsZURhdGFbJ2Vhc2luZyddID0gdGltaW5nQXN0LmVhc2luZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3R5bGVNZXRhZGF0YV8xID0gX2FuZ3VsYXJfYW5pbWF0aW9ucy5zdHlsZShuZXdTdHlsZURhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGltZSArPSB0aW1pbmdBc3QuZHVyYXRpb24gKyB0aW1pbmdBc3QuZGVsYXk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZUFzdCA9IHRoaXMudmlzaXRTdHlsZShzdHlsZU1ldGFkYXRhXzEsIGNvbnRleHQpO1xuICAgICAgICAgICAgc3R5bGVBc3QuaXNFbXB0eVN0ZXAgPSBpc0VtcHR5O1xuICAgICAgICAgICAgc3R5bGVzID0gc3R5bGVBc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGVBc3QodGltaW5nQXN0LCBzdHlsZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U3R5bGUgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fbWFrZVN0eWxlQXN0KG1ldGFkYXRhLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVTdHlsZUFzdChhc3QsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLl9tYWtlU3R5bGVBc3QgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0gW107XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGFkYXRhLnN0eWxlcykpIHtcbiAgICAgICAgICAgICgobWV0YWRhdGEuc3R5bGVzKSkuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVUdXBsZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGVUdXBsZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVUdXBsZSA9PSBfYW5ndWxhcl9hbmltYXRpb25zLkFVVE9fU1RZTEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKHN0eWxlVHVwbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goXCJUaGUgcHJvdmlkZWQgc3R5bGUgc3RyaW5nIHZhbHVlIFwiICsgc3R5bGVUdXBsZSArIFwiIGlzIG5vdCBhbGxvd2VkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goLyoqIEB0eXBlIHs/fSAqLyAoc3R5bGVUdXBsZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVzLnB1c2gobWV0YWRhdGEuc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluc0R5bmFtaWNTdHlsZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29sbGVjdGVkRWFzaW5nID0gbnVsbDtcbiAgICAgICAgc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlRGF0YSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHN0eWxlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZU1hcCA9IChzdHlsZURhdGEpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVhc2luZyA9IHN0eWxlTWFwWydlYXNpbmcnXTtcbiAgICAgICAgICAgICAgICBpZiAoZWFzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZEVhc2luZyA9IChlYXNpbmcpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3R5bGVNYXBbJ2Vhc2luZyddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5zRHluYW1pY1N0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHByb3AgaW4gc3R5bGVNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gc3R5bGVNYXBbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudG9TdHJpbmcoKS5pbmRleE9mKFNVQlNUSVRVVElPTl9FWFBSX1NUQVJUKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnNEeW5hbWljU3R5bGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IG5ldyBTdHlsZUFzdChzdHlsZXMsIGNvbGxlY3RlZEVhc2luZywgbWV0YWRhdGEub2Zmc2V0KTtcbiAgICAgICAgYXN0LmNvbnRhaW5zRHluYW1pY1N0eWxlcyA9IGNvbnRhaW5zRHluYW1pY1N0eWxlcztcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlU3R5bGVBc3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ3MgPSBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kVGltZSA9IGNvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0VGltZSA9IGNvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgIGlmICh0aW1pbmdzICYmIHN0YXJ0VGltZSA+IDApIHtcbiAgICAgICAgICAgIHN0YXJ0VGltZSAtPSB0aW1pbmdzLmR1cmF0aW9uICsgdGltaW5ncy5kZWxheTtcbiAgICAgICAgfVxuICAgICAgICBhc3Quc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHR1cGxlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHR1cGxlID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHR1cGxlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29sbGVjdGVkU3R5bGVzID0gY29udGV4dC5jb2xsZWN0ZWRTdHlsZXNbKChjb250ZXh0LmN1cnJlbnRRdWVyeVNlbGVjdG9yKSldO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbGxlY3RlZEVudHJ5ID0gY29sbGVjdGVkU3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZUNvbGxlY3RlZFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGVkRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSAhPSBlbmRUaW1lICYmIHN0YXJ0VGltZSA+PSBjb2xsZWN0ZWRFbnRyeS5zdGFydFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFRpbWUgPD0gY29sbGVjdGVkRW50cnkuZW5kVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIlRoZSBDU1MgcHJvcGVydHkgXFxcIlwiICsgcHJvcCArIFwiXFxcIiB0aGF0IGV4aXN0cyBiZXR3ZWVuIHRoZSB0aW1lcyBvZiBcXFwiXCIgKyBjb2xsZWN0ZWRFbnRyeS5zdGFydFRpbWUgKyBcIm1zXFxcIiBhbmQgXFxcIlwiICsgY29sbGVjdGVkRW50cnkuZW5kVGltZSArIFwibXNcXFwiIGlzIGFsc28gYmVpbmcgYW5pbWF0ZWQgaW4gYSBwYXJhbGxlbCBhbmltYXRpb24gYmV0d2VlbiB0aGUgdGltZXMgb2YgXFxcIlwiICsgc3RhcnRUaW1lICsgXCJtc1xcXCIgYW5kIFxcXCJcIiArIGVuZFRpbWUgKyBcIm1zXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbGxlY3RlZFN0eWxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgYWx3YXlzIGNob29zZSB0aGUgc21hbGxlciBzdGFydCB0aW1lIHZhbHVlIHNpbmNlIHdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gaGF2ZSBhIHJlY29yZCBvZiB0aGUgZW50aXJlIGFuaW1hdGlvbiB3aW5kb3cgd2hlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN0eWxlIHByb3BlcnR5IGlzIGJlaW5nIGFuaW1hdGVkIGluIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gY29sbGVjdGVkRW50cnkuc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlQ29sbGVjdGVkU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkU3R5bGVzW3Byb3BdID0geyBzdGFydFRpbWU6IHN0YXJ0VGltZSwgZW5kVGltZTogZW5kVGltZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlU3R5bGVQYXJhbXModHVwbGVbcHJvcF0sIGNvbnRleHQub3B0aW9ucywgY29udGV4dC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWZyYW1lcyA9IGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWNvbnRleHQuY3VycmVudEFuaW1hdGVUaW1pbmdzKSB7XG4gICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKFwia2V5ZnJhbWVzKCkgbXVzdCBiZSBwbGFjZWQgaW5zaWRlIG9mIGEgY2FsbCB0byBhbmltYXRlKClcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEtleWZyYW1lc0FzdChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTUFYX0tFWUZSQU1FX09GRlNFVCA9IDE7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvdGFsS2V5ZnJhbWVzV2l0aE9mZnNldHMgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldHNPdXRPZk9yZGVyID0gZmFsc2U7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleWZyYW1lc091dE9mUmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlmcmFtZXMgPSBtZXRhZGF0YS5zdGVwcy5tYXAoZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGUkJDEgPSBfdGhpcy5fbWFrZVN0eWxlQXN0KHN0eWxlcywgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXRWYWwgPSBzdHlsZSQkMS5vZmZzZXQgIT0gbnVsbCA/IHN0eWxlJCQxLm9mZnNldCA6IGNvbnN1bWVPZmZzZXQoc3R5bGUkJDEuc3R5bGVzKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0VmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b3RhbEtleWZyYW1lc1dpdGhPZmZzZXRzKys7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gc3R5bGUkJDEub2Zmc2V0ID0gb2Zmc2V0VmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ZnJhbWVzT3V0T2ZSYW5nZSA9IGtleWZyYW1lc091dE9mUmFuZ2UgfHwgb2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiAxO1xuICAgICAgICAgICAgb2Zmc2V0c091dE9mT3JkZXIgPSBvZmZzZXRzT3V0T2ZPcmRlciB8fCBvZmZzZXQgPCBwcmV2aW91c09mZnNldDtcbiAgICAgICAgICAgIHByZXZpb3VzT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGUkJDE7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa2V5ZnJhbWVzT3V0T2ZSYW5nZSkge1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIlBsZWFzZSBlbnN1cmUgdGhhdCBhbGwga2V5ZnJhbWUgb2Zmc2V0cyBhcmUgYmV0d2VlbiAwIGFuZCAxXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXRzT3V0T2ZPcmRlcikge1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIlBsZWFzZSBlbnN1cmUgdGhhdCBhbGwga2V5ZnJhbWUgb2Zmc2V0cyBhcmUgaW4gb3JkZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVuZ3RoID0gbWV0YWRhdGEuc3RlcHMubGVuZ3RoO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBnZW5lcmF0ZWRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAodG90YWxLZXlmcmFtZXNXaXRoT2Zmc2V0cyA+IDAgJiYgdG90YWxLZXlmcmFtZXNXaXRoT2Zmc2V0cyA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIk5vdCBhbGwgc3R5bGUoKSBzdGVwcyB3aXRoaW4gdGhlIGRlY2xhcmVkIGtleWZyYW1lcygpIGNvbnRhaW4gb2Zmc2V0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b3RhbEtleWZyYW1lc1dpdGhPZmZzZXRzID09IDApIHtcbiAgICAgICAgICAgIGdlbmVyYXRlZE9mZnNldCA9IE1BWF9LRVlGUkFNRV9PRkZTRVQgLyAobGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGltaXQgPSBsZW5ndGggLSAxO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50VGltZSA9IGNvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRBbmltYXRlVGltaW5ncyA9ICgoY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5pbWF0ZUR1cmF0aW9uID0gY3VycmVudEFuaW1hdGVUaW1pbmdzLmR1cmF0aW9uO1xuICAgICAgICBrZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoa2YsIGkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IGdlbmVyYXRlZE9mZnNldCA+IDAgPyAoaSA9PSBsaW1pdCA/IDEgOiAoZ2VuZXJhdGVkT2Zmc2V0ICogaSkpIDogb2Zmc2V0c1tpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGR1cmF0aW9uVXBUb1RoaXNGcmFtZSA9IG9mZnNldCAqIGFuaW1hdGVEdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFRpbWUgPSBjdXJyZW50VGltZSArIGN1cnJlbnRBbmltYXRlVGltaW5ncy5kZWxheSArIGR1cmF0aW9uVXBUb1RoaXNGcmFtZTtcbiAgICAgICAgICAgIGN1cnJlbnRBbmltYXRlVGltaW5ncy5kdXJhdGlvbiA9IGR1cmF0aW9uVXBUb1RoaXNGcmFtZTtcbiAgICAgICAgICAgIF90aGlzLl92YWxpZGF0ZVN0eWxlQXN0KGtmLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGtmLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgS2V5ZnJhbWVzQXN0KGtleWZyYW1lcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50cnkgPSB2aXNpdEFuaW1hdGlvbk5vZGUodGhpcywgbm9ybWFsaXplQW5pbWF0aW9uRW50cnkobWV0YWRhdGEuYW5pbWF0aW9uKSwgY29udGV4dCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IG5ldyBSZWZlcmVuY2VBc3QoZW50cnkpO1xuICAgICAgICBhc3Qub3B0aW9ucyA9IG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMobWV0YWRhdGEub3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbmltYXRlQ2hpbGQgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5kZXBDb3VudCsrO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBuZXcgQW5pbWF0ZUNoaWxkQXN0KCk7XG4gICAgICAgIGFzdC5vcHRpb25zID0gbm9ybWFsaXplQW5pbWF0aW9uT3B0aW9ucyhtZXRhZGF0YS5vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFuaW1hdGVSZWYgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5pbWF0aW9uID0gdGhpcy52aXNpdFJlZmVyZW5jZShtZXRhZGF0YS5hbmltYXRpb24sIGNvbnRleHQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBuZXcgQW5pbWF0ZVJlZkFzdChhbmltYXRpb24pO1xuICAgICAgICBhc3Qub3B0aW9ucyA9IG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMobWV0YWRhdGEub3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRRdWVyeSA9IGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRTZWxlY3RvciA9ICgoY29udGV4dC5jdXJyZW50UXVlcnlTZWxlY3RvcikpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25zID0gKChtZXRhZGF0YS5vcHRpb25zIHx8IHt9KSk7XG4gICAgICAgIGNvbnRleHQucXVlcnlDb3VudCsrO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeSA9IG1ldGFkYXRhO1xuICAgICAgICB2YXIgX2EgPSBub3JtYWxpemVTZWxlY3RvcihtZXRhZGF0YS5zZWxlY3RvciksIHNlbGVjdG9yID0gX2FbMF0sIGluY2x1ZGVTZWxmID0gX2FbMV07XG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5U2VsZWN0b3IgPVxuICAgICAgICAgICAgcGFyZW50U2VsZWN0b3IubGVuZ3RoID8gKHBhcmVudFNlbGVjdG9yICsgJyAnICsgc2VsZWN0b3IpIDogc2VsZWN0b3I7XG4gICAgICAgIGdldE9yU2V0QXNJbk1hcChjb250ZXh0LmNvbGxlY3RlZFN0eWxlcywgY29udGV4dC5jdXJyZW50UXVlcnlTZWxlY3Rvciwge30pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeSA9IHZpc2l0QW5pbWF0aW9uTm9kZSh0aGlzLCBub3JtYWxpemVBbmltYXRpb25FbnRyeShtZXRhZGF0YS5hbmltYXRpb24pLCBjb250ZXh0KTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnkgPSBudWxsO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeVNlbGVjdG9yID0gcGFyZW50U2VsZWN0b3I7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IG5ldyBRdWVyeUFzdChzZWxlY3Rvciwgb3B0aW9ucy5saW1pdCB8fCAwLCAhIW9wdGlvbnMub3B0aW9uYWwsIGluY2x1ZGVTZWxmLCBlbnRyeSk7XG4gICAgICAgIGFzdC5vcmlnaW5hbFNlbGVjdG9yID0gbWV0YWRhdGEuc2VsZWN0b3I7XG4gICAgICAgIGFzdC5vcHRpb25zID0gbm9ybWFsaXplQW5pbWF0aW9uT3B0aW9ucyhtZXRhZGF0YS5vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFN0YWdnZXIgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFjb250ZXh0LmN1cnJlbnRRdWVyeSkge1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcInN0YWdnZXIoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBvZiBxdWVyeSgpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ3MgPSBtZXRhZGF0YS50aW1pbmdzID09PSAnZnVsbCcgP1xuICAgICAgICAgICAgeyBkdXJhdGlvbjogMCwgZGVsYXk6IDAsIGVhc2luZzogJ2Z1bGwnIH0gOlxuICAgICAgICAgICAgcmVzb2x2ZVRpbWluZyhtZXRhZGF0YS50aW1pbmdzLCBjb250ZXh0LmVycm9ycywgdHJ1ZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuaW1hdGlvbiA9IHZpc2l0QW5pbWF0aW9uTm9kZSh0aGlzLCBub3JtYWxpemVBbmltYXRpb25FbnRyeShtZXRhZGF0YS5hbmltYXRpb24pLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFnZ2VyQXN0KHRpbWluZ3MsIGFuaW1hdGlvbik7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3I7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhc0FtcGVyc2FuZCA9IHNlbGVjdG9yLnNwbGl0KC9cXHMqLFxccyovKS5maW5kKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4gPT0gU0VMRl9UT0tFTjsgfSkgPyB0cnVlIDogZmFsc2U7XG4gICAgaWYgKGhhc0FtcGVyc2FuZCkge1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoU0VMRl9UT0tFTl9SRUdFWCwgJycpO1xuICAgIH1cbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoRU5URVJfVE9LRU5fUkVHRVgsIEVOVEVSX1NFTEVDVE9SKVxuICAgICAgICAucmVwbGFjZShMRUFWRV9UT0tFTl9SRUdFWCwgTEVBVkVfU0VMRUNUT1IpXG4gICAgICAgIC5yZXBsYWNlKC9AXFwqL2csIE5HX1RSSUdHRVJfU0VMRUNUT1IpXG4gICAgICAgIC5yZXBsYWNlKC9AXFx3Ky9nLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIE5HX1RSSUdHRVJfU0VMRUNUT1IgKyAnLScgKyBtYXRjaC5zdWJzdHIoMSk7IH0pXG4gICAgICAgIC5yZXBsYWNlKC86YW5pbWF0aW5nL2csIE5HX0FOSU1BVElOR19TRUxFQ1RPUik7XG4gICAgcmV0dXJuIFtzZWxlY3RvciwgaGFzQW1wZXJzYW5kXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBvYmpcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhcmFtcyhvYmopIHtcbiAgICByZXR1cm4gb2JqID8gY29weU9iaihvYmopIDogbnVsbDtcbn1cbnZhciBBbmltYXRpb25Bc3RCdWlsZGVyQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBbmltYXRpb25Bc3RCdWlsZGVyQ29udGV4dChlcnJvcnMpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMucXVlcnlDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuZGVwQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRUcmFuc2l0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50UXVlcnkgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRRdWVyeVNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRTdHlsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEFuaW1hdGlvbkFzdEJ1aWxkZXJDb250ZXh0O1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBzdHlsZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVPZmZzZXQoc3R5bGVzKSB7XG4gICAgaWYgKHR5cGVvZiBzdHlsZXMgPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IG51bGw7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGVzKSkge1xuICAgICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVUdXBsZSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHN0eWxlVHVwbGUpICYmIHN0eWxlVHVwbGUuaGFzT3duUHJvcGVydHkoJ29mZnNldCcpKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2JqID0gKHN0eWxlVHVwbGUpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHBhcnNlRmxvYXQoLyoqIEB0eXBlIHs/fSAqLyAob2JqWydvZmZzZXQnXSkpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbJ29mZnNldCddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3Qoc3R5bGVzKSAmJiBzdHlsZXMuaGFzT3duUHJvcGVydHkoJ29mZnNldCcpKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9iaiA9IChzdHlsZXMpO1xuICAgICAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KC8qKiBAdHlwZSB7P30gKi8gKG9ialsnb2Zmc2V0J10pKTtcbiAgICAgICAgZGVsZXRlIG9ialsnb2Zmc2V0J107XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEBwYXJhbSB7P30gZXJyb3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RUaW1pbmdBc3QodmFsdWUsIGVycm9ycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ3MgPSBudWxsO1xuICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnZHVyYXRpb24nKSkge1xuICAgICAgICB0aW1pbmdzID0gKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGR1cmF0aW9uID0gcmVzb2x2ZVRpbWluZygvKiogQHR5cGUgez99ICovICh2YWx1ZSksIGVycm9ycykuZHVyYXRpb247XG4gICAgICAgIHJldHVybiBuZXcgVGltaW5nQXN0KC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKSwgMCwgJycpO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJWYWx1ZSA9ICh2YWx1ZSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNEeW5hbWljID0gc3RyVmFsdWUuc3BsaXQoL1xccysvKS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LmNoYXJBdCgwKSA9PSAneycgJiYgdi5jaGFyQXQoMSkgPT0gJ3snOyB9KTtcbiAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgIHJldHVybiBuZXcgRHluYW1pY1RpbWluZ0FzdChzdHJWYWx1ZSk7XG4gICAgfVxuICAgIHRpbWluZ3MgPSB0aW1pbmdzIHx8IHJlc29sdmVUaW1pbmcoc3RyVmFsdWUsIGVycm9ycyk7XG4gICAgcmV0dXJuIG5ldyBUaW1pbmdBc3QodGltaW5ncy5kdXJhdGlvbiwgdGltaW5ncy5kZWxheSwgdGltaW5ncy5lYXNpbmcpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG9wdGlvbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBjb3B5T2JqKG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9uc1sncGFyYW1zJ10pIHtcbiAgICAgICAgICAgIG9wdGlvbnNbJ3BhcmFtcyddID0gKChub3JtYWxpemVQYXJhbXMob3B0aW9uc1sncGFyYW1zJ10pKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAqIEBwYXJhbSB7P30gcHJlU3R5bGVQcm9wc1xuICogQHBhcmFtIHs/fSBwb3N0U3R5bGVQcm9wc1xuICogQHBhcmFtIHs/fSBkdXJhdGlvblxuICogQHBhcmFtIHs/fSBkZWxheVxuICogQHBhcmFtIHs/PX0gZWFzaW5nXG4gKiBAcGFyYW0gez89fSBzdWJUaW1lbGluZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGltZWxpbmVJbnN0cnVjdGlvbihlbGVtZW50LCBrZXlmcmFtZXMsIHByZVN0eWxlUHJvcHMsIHBvc3RTdHlsZVByb3BzLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgc3ViVGltZWxpbmUpIHtcbiAgICBpZiAoZWFzaW5nID09PSB2b2lkIDApIHsgZWFzaW5nID0gbnVsbDsgfVxuICAgIGlmIChzdWJUaW1lbGluZSA9PT0gdm9pZCAwKSB7IHN1YlRpbWVsaW5lID0gZmFsc2U7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAxIC8qIFRpbWVsaW5lQW5pbWF0aW9uICovLFxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBrZXlmcmFtZXM6IGtleWZyYW1lcyxcbiAgICAgICAgcHJlU3R5bGVQcm9wczogcHJlU3R5bGVQcm9wcyxcbiAgICAgICAgcG9zdFN0eWxlUHJvcHM6IHBvc3RTdHlsZVByb3BzLFxuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgICAgdG90YWxUaW1lOiBkdXJhdGlvbiArIGRlbGF5LCBlYXNpbmc6IGVhc2luZywgc3ViVGltZWxpbmU6IHN1YlRpbWVsaW5lXG4gICAgfTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRJbnN0cnVjdGlvbk1hcCgpIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRJbnN0cnVjdGlvbk1hcC5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RydWN0aW9ucyA9IHRoaXMuX21hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRJbnN0cnVjdGlvbk1hcC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGVsZW1lbnQsIGluc3RydWN0aW9ucykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleGlzdGluZ0luc3RydWN0aW9ucyA9IHRoaXMuX21hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmICghZXhpc3RpbmdJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5zZXQoZWxlbWVudCwgZXhpc3RpbmdJbnN0cnVjdGlvbnMgPSBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhpc3RpbmdJbnN0cnVjdGlvbnMucHVzaC5hcHBseShleGlzdGluZ0luc3RydWN0aW9ucywgaW5zdHJ1Y3Rpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudEluc3RydWN0aW9uTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gdGhpcy5fbWFwLmhhcyhlbGVtZW50KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRJbnN0cnVjdGlvbk1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX21hcC5jbGVhcigpOyB9O1xuICAgIHJldHVybiBFbGVtZW50SW5zdHJ1Y3Rpb25NYXA7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIE9ORV9GUkFNRV9JTl9NSUxMSVNFQ09ORFMgPSAxO1xuLyoqXG4gKiBAcGFyYW0gez99IGRyaXZlclxuICogQHBhcmFtIHs/fSByb290RWxlbWVudFxuICogQHBhcmFtIHs/fSBhc3RcbiAqIEBwYXJhbSB7Pz19IHN0YXJ0aW5nU3R5bGVzXG4gKiBAcGFyYW0gez89fSBmaW5hbFN0eWxlc1xuICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICogQHBhcmFtIHs/PX0gc3ViSW5zdHJ1Y3Rpb25zXG4gKiBAcGFyYW0gez89fSBlcnJvcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQW5pbWF0aW9uVGltZWxpbmVzKGRyaXZlciwgcm9vdEVsZW1lbnQsIGFzdCwgc3RhcnRpbmdTdHlsZXMsIGZpbmFsU3R5bGVzLCBvcHRpb25zLCBzdWJJbnN0cnVjdGlvbnMsIGVycm9ycykge1xuICAgIGlmIChzdGFydGluZ1N0eWxlcyA9PT0gdm9pZCAwKSB7IHN0YXJ0aW5nU3R5bGVzID0ge307IH1cbiAgICBpZiAoZmluYWxTdHlsZXMgPT09IHZvaWQgMCkgeyBmaW5hbFN0eWxlcyA9IHt9OyB9XG4gICAgaWYgKGVycm9ycyA9PT0gdm9pZCAwKSB7IGVycm9ycyA9IFtdOyB9XG4gICAgcmV0dXJuIG5ldyBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yKCkuYnVpbGRLZXlmcmFtZXMoZHJpdmVyLCByb290RWxlbWVudCwgYXN0LCBzdGFydGluZ1N0eWxlcywgZmluYWxTdHlsZXMsIG9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucywgZXJyb3JzKTtcbn1cbnZhciBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRyaXZlclxuICAgICAqIEBwYXJhbSB7P30gcm9vdEVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRpbmdTdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IGZpbmFsU3R5bGVzXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHs/PX0gc3ViSW5zdHJ1Y3Rpb25zXG4gICAgICogQHBhcmFtIHs/PX0gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS5idWlsZEtleWZyYW1lcyA9IGZ1bmN0aW9uIChkcml2ZXIsIHJvb3RFbGVtZW50LCBhc3QsIHN0YXJ0aW5nU3R5bGVzLCBmaW5hbFN0eWxlcywgb3B0aW9ucywgc3ViSW5zdHJ1Y3Rpb25zLCBlcnJvcnMpIHtcbiAgICAgICAgaWYgKGVycm9ycyA9PT0gdm9pZCAwKSB7IGVycm9ycyA9IFtdOyB9XG4gICAgICAgIHN1Ykluc3RydWN0aW9ucyA9IHN1Ykluc3RydWN0aW9ucyB8fCBuZXcgRWxlbWVudEluc3RydWN0aW9uTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRleHQgPSBuZXcgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0KGRyaXZlciwgcm9vdEVsZW1lbnQsIHN1Ykluc3RydWN0aW9ucywgZXJyb3JzLCBbXSk7XG4gICAgICAgIGNvbnRleHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLnNldFN0eWxlcyhbc3RhcnRpbmdTdHlsZXNdLCBudWxsLCBjb250ZXh0LmVycm9ycywgb3B0aW9ucyk7XG4gICAgICAgIGFzdC52aXNpdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgLy8gdGhpcyBjaGVja3MgdG8gc2VlIGlmIGFuIGFjdHVhbCBhbmltYXRpb24gaGFwcGVuZWRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltZWxpbmVzID0gY29udGV4dC50aW1lbGluZXMuZmlsdGVyKGZ1bmN0aW9uICh0aW1lbGluZSkgeyByZXR1cm4gdGltZWxpbmUuY29udGFpbnNBbmltYXRpb24oKTsgfSk7XG4gICAgICAgIGlmICh0aW1lbGluZXMubGVuZ3RoICYmIE9iamVjdC5rZXlzKGZpbmFsU3R5bGVzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRsID0gdGltZWxpbmVzW3RpbWVsaW5lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICghdGwuYWxsb3dPbmx5VGltZWxpbmVTdHlsZXMoKSkge1xuICAgICAgICAgICAgICAgIHRsLnNldFN0eWxlcyhbZmluYWxTdHlsZXNdLCBudWxsLCBjb250ZXh0LmVycm9ycywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbWVsaW5lcy5sZW5ndGggPyB0aW1lbGluZXMubWFwKGZ1bmN0aW9uICh0aW1lbGluZSkgeyByZXR1cm4gdGltZWxpbmUuYnVpbGRLZXlmcmFtZXMoKTsgfSkgOlxuICAgICAgICAgICAgW2NyZWF0ZVRpbWVsaW5lSW5zdHJ1Y3Rpb24ocm9vdEVsZW1lbnQsIFtdLCBbXSwgW10sIDAsIDAsICcnLCBmYWxzZSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHJpZ2dlciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gdGhlc2UgdmFsdWVzIGFyZSBub3QgdmlzaXRlZCBpbiB0aGlzIEFTVFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U3RhdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIHRoZXNlIHZhbHVlcyBhcmUgbm90IHZpc2l0ZWQgaW4gdGhpcyBBU1RcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIHRoZXNlIHZhbHVlcyBhcmUgbm90IHZpc2l0ZWQgaW4gdGhpcyBBU1RcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFuaW1hdGVDaGlsZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudEluc3RydWN0aW9ucyA9IGNvbnRleHQuc3ViSW5zdHJ1Y3Rpb25zLmNvbnN1bWUoY29udGV4dC5lbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnRJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dChhc3Qub3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5jdXJyZW50VGltZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZFRpbWUgPSB0aGlzLl92aXNpdFN1Ykluc3RydWN0aW9ucyhlbGVtZW50SW5zdHJ1Y3Rpb25zLCBpbm5lckNvbnRleHQsIC8qKiBAdHlwZSB7P30gKi8gKGlubmVyQ29udGV4dC5vcHRpb25zKSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRUaW1lICE9IGVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBkbyB0aGlzIG9uIHRoZSB1cHBlciBjb250ZXh0IGJlY2F1c2Ugd2UgY3JlYXRlZCBhIHN1YiBjb250ZXh0IGZvclxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdWIgY2hpbGQgYW5pbWF0aW9uc1xuICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKGVuZFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QW5pbWF0ZVJlZiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJDb250ZXh0ID0gY29udGV4dC5jcmVhdGVTdWJDb250ZXh0KGFzdC5vcHRpb25zKTtcbiAgICAgICAgaW5uZXJDb250ZXh0LnRyYW5zZm9ybUludG9OZXdUaW1lbGluZSgpO1xuICAgICAgICB0aGlzLnZpc2l0UmVmZXJlbmNlKGFzdC5hbmltYXRpb24sIGlubmVyQ29udGV4dCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKGlubmVyQ29udGV4dC5jdXJyZW50VGltZWxpbmUuY3VycmVudFRpbWUpO1xuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5zdHJ1Y3Rpb25zXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRTdWJJbnN0cnVjdGlvbnMgPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb25zLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0VGltZSA9IGNvbnRleHQuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdXJ0aGVzdFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsLWNhc2UgZm9yIHdoZW4gYSB1c2VyIHdhbnRzIHRvIHNraXAgYSBzdWJcbiAgICAgICAgLy8gYW5pbWF0aW9uIGZyb20gYmVpbmcgZmlyZWQgZW50aXJlbHkuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiAhPSBudWxsID8gcmVzb2x2ZVRpbWluZ1ZhbHVlKG9wdGlvbnMuZHVyYXRpb24pIDogbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVsYXkgPSBvcHRpb25zLmRlbGF5ICE9IG51bGwgPyByZXNvbHZlVGltaW5nVmFsdWUob3B0aW9ucy5kZWxheSkgOiBudWxsO1xuICAgICAgICBpZiAoZHVyYXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIGluc3RydWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RydWN0aW9uVGltaW5ncyA9IGNvbnRleHQuYXBwZW5kSW5zdHJ1Y3Rpb25Ub1RpbWVsaW5lKGluc3RydWN0aW9uLCBkdXJhdGlvbiwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIGZ1cnRoZXN0VGltZSA9XG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGZ1cnRoZXN0VGltZSwgaW5zdHJ1Y3Rpb25UaW1pbmdzLmR1cmF0aW9uICsgaW5zdHJ1Y3Rpb25UaW1pbmdzLmRlbGF5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdXJ0aGVzdFRpbWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQudXBkYXRlT3B0aW9ucyhhc3Qub3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGFzdC5hbmltYXRpb24udmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2VxdWVuY2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1YkNvbnRleHRDb3VudCA9IGNvbnRleHQuc3ViQ29udGV4dENvdW50O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHggPSBjb250ZXh0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25zID0gYXN0Lm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zICYmIChvcHRpb25zLnBhcmFtcyB8fCBvcHRpb25zLmRlbGF5KSkge1xuICAgICAgICAgICAgY3R4ID0gY29udGV4dC5jcmVhdGVTdWJDb250ZXh0KG9wdGlvbnMpO1xuICAgICAgICAgICAgY3R4LnRyYW5zZm9ybUludG9OZXdUaW1lbGluZSgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVsYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdHgucHJldmlvdXNOb2RlIGluc3RhbmNlb2YgU3R5bGVBc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmN1cnJlbnRUaW1lbGluZS5zbmFwc2hvdEN1cnJlbnRTdHlsZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnByZXZpb3VzTm9kZSA9IERFRkFVTFRfTk9PUF9QUkVWSU9VU19OT0RFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWxheSA9IHJlc29sdmVUaW1pbmdWYWx1ZShvcHRpb25zLmRlbGF5KTtcbiAgICAgICAgICAgICAgICBjdHguZGVsYXlOZXh0U3RlcChkZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzdC5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFzdC5zdGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnZpc2l0KF90aGlzLCBjdHgpOyB9KTtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgaGVyZSBqdXN0IGluY2FzZSB0aGUgaW5uZXIgc3RlcHMgb25seSBjb250YWluIG9yIGVuZCB3aXRoIGEgc3R5bGUoKSBjYWxsXG4gICAgICAgICAgICBjdHguY3VycmVudFRpbWVsaW5lLmFwcGx5U3R5bGVzVG9LZXlmcmFtZSgpO1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHNvbWUgYW5pbWF0aW9uIGZ1bmN0aW9uIHdpdGhpbiB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIC8vIGVuZGVkIHVwIGNyZWF0aW5nIGEgc3ViIHRpbWVsaW5lICh3aGljaCBtZWFucyB0aGUgY3VycmVudFxuICAgICAgICAgICAgLy8gdGltZWxpbmUgY2Fubm90IG92ZXJsYXAgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIHNlcXVlbmNlKVxuICAgICAgICAgICAgaWYgKGN0eC5zdWJDb250ZXh0Q291bnQgPiBzdWJDb250ZXh0Q291bnQpIHtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRHcm91cCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJUaW1lbGluZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnVydGhlc3RUaW1lID0gY29udGV4dC5jdXJyZW50VGltZWxpbmUuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGF5ID0gYXN0Lm9wdGlvbnMgJiYgYXN0Lm9wdGlvbnMuZGVsYXkgPyByZXNvbHZlVGltaW5nVmFsdWUoYXN0Lm9wdGlvbnMuZGVsYXkpIDogMDtcbiAgICAgICAgYXN0LnN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dChhc3Qub3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgICAgICBpbm5lckNvbnRleHQuZGVsYXlOZXh0U3RlcChkZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzLnZpc2l0KF90aGlzLCBpbm5lckNvbnRleHQpO1xuICAgICAgICAgICAgZnVydGhlc3RUaW1lID0gTWF0aC5tYXgoZnVydGhlc3RUaW1lLCBpbm5lckNvbnRleHQuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIGlubmVyVGltZWxpbmVzLnB1c2goaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGlzIG9wZXJhdGlvbiBpcyBydW4gYWZ0ZXIgdGhlIEFTVCBsb29wIGJlY2F1c2Ugb3RoZXJ3aXNlXG4gICAgICAgIC8vIGlmIHRoZSBwYXJlbnQgdGltZWxpbmUncyBjb2xsZWN0ZWQgc3R5bGVzIHdlcmUgdXBkYXRlZCB0aGVuXG4gICAgICAgIC8vIGl0IHdvdWxkIHBhc3MgaW4gaW52YWxpZCBkYXRhIGludG8gdGhlIG5ldy10by1iZSBmb3JrZWQgaXRlbXNcbiAgICAgICAgaW5uZXJUaW1lbGluZXMuZm9yRWFjaChmdW5jdGlvbiAodGltZWxpbmUpIHsgcmV0dXJuIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLm1lcmdlVGltZWxpbmVDb2xsZWN0ZWRTdHlsZXModGltZWxpbmUpOyB9KTtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoZnVydGhlc3RUaW1lKTtcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUaW1pbmcgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBEeW5hbWljVGltaW5nQXN0KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJWYWx1ZSA9IGNvbnRleHQucGFyYW1zID9cbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZVBhcmFtcyhhc3QudmFsdWUsIGNvbnRleHQucGFyYW1zLCBjb250ZXh0LmVycm9ycykgOlxuICAgICAgICAgICAgICAgIGFzdC52YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVUaW1pbmcoc3RyVmFsdWUsIGNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGR1cmF0aW9uOiBhc3QuZHVyYXRpb24sIGRlbGF5OiBhc3QuZGVsYXksIGVhc2luZzogYXN0LmVhc2luZyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbmltYXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1pbmdzID0gY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSB0aGlzLnZpc2l0VGltaW5nKGFzdC50aW1pbmdzLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltZWxpbmUgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZTtcbiAgICAgICAgaWYgKHRpbWluZ3MuZGVsYXkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaW5jcmVtZW50VGltZSh0aW1pbmdzLmRlbGF5KTtcbiAgICAgICAgICAgIHRpbWVsaW5lLnNuYXBzaG90Q3VycmVudFN0eWxlcygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlJCQxID0gYXN0LnN0eWxlO1xuICAgICAgICBpZiAoc3R5bGUkJDEgaW5zdGFuY2VvZiBLZXlmcmFtZXNBc3QpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRLZXlmcmFtZXMoc3R5bGUkJDEsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5pbmNyZW1lbnRUaW1lKHRpbWluZ3MuZHVyYXRpb24pO1xuICAgICAgICAgICAgdGhpcy52aXNpdFN0eWxlKC8qKiBAdHlwZSB7P30gKi8gKHN0eWxlJCQxKSwgY29udGV4dCk7XG4gICAgICAgICAgICB0aW1lbGluZS5hcHBseVN0eWxlc1RvS2V5ZnJhbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncyA9IG51bGw7XG4gICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U3R5bGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWVsaW5lID0gY29udGV4dC5jdXJyZW50VGltZWxpbmU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ3MgPSAoKGNvbnRleHQuY3VycmVudEFuaW1hdGVUaW1pbmdzKSk7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgZm9yIHdoZW4gYSBzdHlsZSgpIGNhbGxcbiAgICAgICAgLy8gZGlyZWN0bHkgZm9sbG93cyAgYW4gYW5pbWF0ZSgpIGNhbGwgKGJ1dCBub3QgaW5zaWRlIG9mIGFuIGFuaW1hdGUoKSBjYWxsKVxuICAgICAgICBpZiAoIXRpbWluZ3MgJiYgdGltZWxpbmUuZ2V0Q3VycmVudFN0eWxlUHJvcGVydGllcygpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGltZWxpbmUuZm9yd2FyZEZyYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWFzaW5nID0gKHRpbWluZ3MgJiYgdGltaW5ncy5lYXNpbmcpIHx8IGFzdC5lYXNpbmc7XG4gICAgICAgIGlmIChhc3QuaXNFbXB0eVN0ZXApIHtcbiAgICAgICAgICAgIHRpbWVsaW5lLmFwcGx5RW1wdHlTdGVwKGVhc2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aW1lbGluZS5zZXRTdHlsZXMoYXN0LnN0eWxlcywgZWFzaW5nLCBjb250ZXh0LmVycm9ycywgY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWZyYW1lcyA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VycmVudEFuaW1hdGVUaW1pbmdzID0gKChjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncykpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFRpbWUgPSAoKChjb250ZXh0LmN1cnJlbnRUaW1lbGluZSkpKS5kdXJhdGlvbjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHVyYXRpb24gPSBjdXJyZW50QW5pbWF0ZVRpbWluZ3MuZHVyYXRpb247XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclRpbWVsaW5lID0gaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZTtcbiAgICAgICAgaW5uZXJUaW1lbGluZS5lYXNpbmcgPSBjdXJyZW50QW5pbWF0ZVRpbWluZ3MuZWFzaW5nO1xuICAgICAgICBhc3Quc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IHN0ZXAub2Zmc2V0IHx8IDA7XG4gICAgICAgICAgICBpbm5lclRpbWVsaW5lLmZvcndhcmRUaW1lKG9mZnNldCAqIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGlubmVyVGltZWxpbmUuc2V0U3R5bGVzKHN0ZXAuc3R5bGVzLCBzdGVwLmVhc2luZywgY29udGV4dC5lcnJvcnMsIGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgICAgICBpbm5lclRpbWVsaW5lLmFwcGx5U3R5bGVzVG9LZXlmcmFtZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBwYXJlbnQgdGltZWxpbmUgZ2V0cyBhbGwgdGhlIHN0eWxlcyBmcm9tXG4gICAgICAgIC8vIHRoZSBjaGlsZCBldmVuIGlmIHRoZSBuZXcgdGltZWxpbmUgYmVsb3cgaXMgbm90IHVzZWRcbiAgICAgICAgY29udGV4dC5jdXJyZW50VGltZWxpbmUubWVyZ2VUaW1lbGluZUNvbGxlY3RlZFN0eWxlcyhpbm5lclRpbWVsaW5lKTtcbiAgICAgICAgLy8gd2UgZG8gdGhpcyBiZWNhdXNlIHRoZSB3aW5kb3cgYmV0d2VlbiB0aGlzIHRpbWVsaW5lIGFuZCB0aGUgc3ViIHRpbWVsaW5lXG4gICAgICAgIC8vIHNob3VsZCBlbnN1cmUgdGhhdCB0aGUgc3R5bGVzIHdpdGhpbiBhcmUgZXhhY3RseSB0aGUgc2FtZSBhcyB0aGV5IHdlcmUgYmVmb3JlXG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKHN0YXJ0VGltZSArIGR1cmF0aW9uKTtcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRRdWVyeSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gaW4gdGhlIGV2ZW50IHRoYXQgdGhlIGZpcnN0IHN0ZXAgYmVmb3JlIHRoaXMgaXMgYSBzdHlsZSBzdGVwIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gZW5zdXJlIHRoZSBzdHlsZXMgYXJlIGFwcGxpZWQgYmVmb3JlIHRoZSBjaGlsZHJlbiBhcmUgYW5pbWF0ZWRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRUaW1lID0gY29udGV4dC5jdXJyZW50VGltZWxpbmUuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnMgPSAoKGFzdC5vcHRpb25zIHx8IHt9KSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGF5ID0gb3B0aW9ucy5kZWxheSA/IHJlc29sdmVUaW1pbmdWYWx1ZShvcHRpb25zLmRlbGF5KSA6IDA7XG4gICAgICAgIGlmIChkZWxheSAmJiAoY29udGV4dC5wcmV2aW91c05vZGUgaW5zdGFuY2VvZiBTdHlsZUFzdCB8fFxuICAgICAgICAgICAgKHN0YXJ0VGltZSA9PSAwICYmIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLmdldEN1cnJlbnRTdHlsZVByb3BlcnRpZXMoKS5sZW5ndGgpKSkge1xuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGltZWxpbmUuc25hcHNob3RDdXJyZW50U3R5bGVzKCk7XG4gICAgICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IERFRkFVTFRfTk9PUF9QUkVWSU9VU19OT0RFO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZ1cnRoZXN0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxtcyA9IGNvbnRleHQuaW52b2tlUXVlcnkoYXN0LnNlbGVjdG9yLCBhc3Qub3JpZ2luYWxTZWxlY3RvciwgYXN0LmxpbWl0LCBhc3QuaW5jbHVkZVNlbGYsIG9wdGlvbnMub3B0aW9uYWwgPyB0cnVlIDogZmFsc2UsIGNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlUb3RhbCA9IGVsbXMubGVuZ3RoO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzYW1lRWxlbWVudFRpbWVsaW5lID0gbnVsbDtcbiAgICAgICAgZWxtcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeUluZGV4ID0gaTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dChhc3Qub3B0aW9ucywgZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgICAgICBpbm5lckNvbnRleHQuZGVsYXlOZXh0U3RlcChkZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gY29udGV4dC5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc2FtZUVsZW1lbnRUaW1lbGluZSA9IGlubmVyQ29udGV4dC5jdXJyZW50VGltZWxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3QuYW5pbWF0aW9uLnZpc2l0KF90aGlzLCBpbm5lckNvbnRleHQpO1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBoZXJlIGp1c3QgaW5jYXNlIHRoZSBpbm5lciBzdGVwcyBvbmx5IGNvbnRhaW4gb3IgZW5kXG4gICAgICAgICAgICAvLyB3aXRoIGEgc3R5bGUoKSBjYWxsICh3aGljaCBpcyBoZXJlIHRvIHNpZ25hbCB0aGF0IHRoaXMgaXMgYSBwcmVwYXJhdG9yeVxuICAgICAgICAgICAgLy8gY2FsbCB0byBzdHlsZSBhbiBlbGVtZW50IGJlZm9yZSBpdCBpcyBhbmltYXRlZCBhZ2FpbilcbiAgICAgICAgICAgIGlubmVyQ29udGV4dC5jdXJyZW50VGltZWxpbmUuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmRUaW1lID0gaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZS5jdXJyZW50VGltZTtcbiAgICAgICAgICAgIGZ1cnRoZXN0VGltZSA9IE1hdGgubWF4KGZ1cnRoZXN0VGltZSwgZW5kVGltZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeUluZGV4ID0gMDtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlUb3RhbCA9IDA7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKGZ1cnRoZXN0VGltZSk7XG4gICAgICAgIGlmIChzYW1lRWxlbWVudFRpbWVsaW5lKSB7XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5tZXJnZVRpbWVsaW5lQ29sbGVjdGVkU3R5bGVzKHNhbWVFbGVtZW50VGltZWxpbmUpO1xuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGltZWxpbmUuc25hcHNob3RDdXJyZW50U3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdGFnZ2VyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRDb250ZXh0ID0gKChjb250ZXh0LnBhcmVudENvbnRleHQpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGwgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltaW5ncyA9IGFzdC50aW1pbmdzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkdXJhdGlvbiA9IE1hdGguYWJzKHRpbWluZ3MuZHVyYXRpb24pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXhUaW1lID0gZHVyYXRpb24gKiAoY29udGV4dC5jdXJyZW50UXVlcnlUb3RhbCAtIDEpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWxheSA9IGR1cmF0aW9uICogY29udGV4dC5jdXJyZW50UXVlcnlJbmRleDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhZ2dlclRyYW5zZm9ybWVyID0gdGltaW5ncy5kdXJhdGlvbiA8IDAgPyAncmV2ZXJzZScgOiB0aW1pbmdzLmVhc2luZztcbiAgICAgICAgc3dpdGNoIChzdGFnZ2VyVHJhbnNmb3JtZXIpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JldmVyc2UnOlxuICAgICAgICAgICAgICAgIGRlbGF5ID0gbWF4VGltZSAtIGRlbGF5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnVsbCc6XG4gICAgICAgICAgICAgICAgZGVsYXkgPSBwYXJlbnRDb250ZXh0LmN1cnJlbnRTdGFnZ2VyVGltZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lbGluZSA9IGNvbnRleHQuY3VycmVudFRpbWVsaW5lO1xuICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgIHRpbWVsaW5lLmRlbGF5TmV4dFN0ZXAoZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0aW5nVGltZSA9IHRpbWVsaW5lLmN1cnJlbnRUaW1lO1xuICAgICAgICBhc3QuYW5pbWF0aW9uLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICAgICAgLy8gdGltZSA9IGR1cmF0aW9uICsgZGVsYXlcbiAgICAgICAgLy8gdGhlIHJlYXNvbiB3aHkgdGhpcyBjb21wdXRhdGlvbiBpcyBzbyBjb21wbGV4IGlzIGJlY2F1c2VcbiAgICAgICAgLy8gdGhlIGlubmVyIHRpbWVsaW5lIG1heSBlaXRoZXIgaGF2ZSBhIGRlbGF5IHZhbHVlIG9yIGEgc3RyZXRjaGVkXG4gICAgICAgIC8vIGtleWZyYW1lIGRlcGVuZGluZyBvbiBpZiBhIHN1YnRpbWVsaW5lIGlzIG5vdCB1c2VkIG9yIGlzIHVzZWQuXG4gICAgICAgIHBhcmVudENvbnRleHQuY3VycmVudFN0YWdnZXJUaW1lID1cbiAgICAgICAgICAgICh0bC5jdXJyZW50VGltZSAtIHN0YXJ0aW5nVGltZSkgKyAodGwuc3RhcnRUaW1lIC0gcGFyZW50Q29udGV4dC5jdXJyZW50VGltZWxpbmUuc3RhcnRUaW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yO1xufSgpKTtcbnZhciBERUZBVUxUX05PT1BfUFJFVklPVVNfTk9ERSA9ICh7fSk7XG52YXIgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kcml2ZXJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHN1Ykluc3RydWN0aW9uc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHBhcmFtIHs/fSB0aW1lbGluZXNcbiAgICAgKiBAcGFyYW0gez89fSBpbml0aWFsVGltZWxpbmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBbmltYXRpb25UaW1lbGluZUNvbnRleHQoX2RyaXZlciwgZWxlbWVudCwgc3ViSW5zdHJ1Y3Rpb25zLCBlcnJvcnMsIHRpbWVsaW5lcywgaW5pdGlhbFRpbWVsaW5lKSB7XG4gICAgICAgIHRoaXMuX2RyaXZlciA9IF9kcml2ZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc3ViSW5zdHJ1Y3Rpb25zID0gc3ViSW5zdHJ1Y3Rpb25zO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy50aW1lbGluZXMgPSB0aW1lbGluZXM7XG4gICAgICAgIHRoaXMucGFyZW50Q29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGVUaW1pbmdzID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2aW91c05vZGUgPSBERUZBVUxUX05PT1BfUFJFVklPVVNfTk9ERTtcbiAgICAgICAgdGhpcy5zdWJDb250ZXh0Q291bnQgPSAwO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50UXVlcnlJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFF1ZXJ5VG90YWwgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGFnZ2VyVGltZSA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWVsaW5lID0gaW5pdGlhbFRpbWVsaW5lIHx8IG5ldyBUaW1lbGluZUJ1aWxkZXIoZWxlbWVudCwgMCk7XG4gICAgICAgIHRpbWVsaW5lcy5wdXNoKHRoaXMuY3VycmVudFRpbWVsaW5lKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUsIFwicGFyYW1zXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMub3B0aW9ucy5wYXJhbXM7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IHNraXBJZkV4aXN0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0LnByb3RvdHlwZS51cGRhdGVPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNraXBJZkV4aXN0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld09wdGlvbnMgPSAob3B0aW9ucyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnNUb1VwZGF0ZSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gTk9URTogdGhpcyB3aWxsIGdldCBwYXRjaGVkIHVwIHdoZW4gb3RoZXIgYW5pbWF0aW9uIG1ldGhvZHMgc3VwcG9ydCBkdXJhdGlvbiBvdmVycmlkZXNcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuZHVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgKChvcHRpb25zVG9VcGRhdGUpKS5kdXJhdGlvbiA9IHJlc29sdmVUaW1pbmdWYWx1ZShuZXdPcHRpb25zLmR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3T3B0aW9ucy5kZWxheSAhPSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zVG9VcGRhdGUuZGVsYXkgPSByZXNvbHZlVGltaW5nVmFsdWUobmV3T3B0aW9ucy5kZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3UGFyYW1zID0gbmV3T3B0aW9ucy5wYXJhbXM7XG4gICAgICAgIGlmIChuZXdQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtc1RvVXBkYXRlXzEgPSAoKG9wdGlvbnNUb1VwZGF0ZS5wYXJhbXMpKTtcbiAgICAgICAgICAgIGlmICghcGFyYW1zVG9VcGRhdGVfMSkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1RvVXBkYXRlXzEgPSB0aGlzLm9wdGlvbnMucGFyYW1zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhuZXdQYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNraXBJZkV4aXN0cyB8fCAhcGFyYW1zVG9VcGRhdGVfMS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNUb1VwZGF0ZV8xW25hbWVdID0gaW50ZXJwb2xhdGVQYXJhbXMobmV3UGFyYW1zW25hbWVdLCBwYXJhbXNUb1VwZGF0ZV8xLCBfdGhpcy5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUuX2NvcHlPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25zID0ge307XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZFBhcmFtc18xID0gdGhpcy5vcHRpb25zLnBhcmFtcztcbiAgICAgICAgICAgIGlmIChvbGRQYXJhbXNfMSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtc18yID0gb3B0aW9uc1sncGFyYW1zJ10gPSB7fTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMucGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHBhcmFtc18yW25hbWVdID0gb2xkUGFyYW1zXzFbbmFtZV07IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBuZXdUaW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZVN1YkNvbnRleHQgPSBmdW5jdGlvbiAob3B0aW9ucywgZWxlbWVudCwgbmV3VGltZSkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBudWxsOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhcmdldCA9IGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZXh0ID0gbmV3IEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dCh0aGlzLl9kcml2ZXIsIHRhcmdldCwgdGhpcy5zdWJJbnN0cnVjdGlvbnMsIHRoaXMuZXJyb3JzLCB0aGlzLnRpbWVsaW5lcywgdGhpcy5jdXJyZW50VGltZWxpbmUuZm9yayh0YXJnZXQsIG5ld1RpbWUgfHwgMCkpO1xuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IHRoaXMucHJldmlvdXNOb2RlO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncyA9IHRoaXMuY3VycmVudEFuaW1hdGVUaW1pbmdzO1xuICAgICAgICBjb250ZXh0Lm9wdGlvbnMgPSB0aGlzLl9jb3B5T3B0aW9ucygpO1xuICAgICAgICBjb250ZXh0LnVwZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5SW5kZXggPSB0aGlzLmN1cnJlbnRRdWVyeUluZGV4O1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeVRvdGFsID0gdGhpcy5jdXJyZW50UXVlcnlUb3RhbDtcbiAgICAgICAgY29udGV4dC5wYXJlbnRDb250ZXh0ID0gdGhpcztcbiAgICAgICAgdGhpcy5zdWJDb250ZXh0Q291bnQrKztcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBuZXdUaW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLnRyYW5zZm9ybUludG9OZXdUaW1lbGluZSA9IGZ1bmN0aW9uIChuZXdUaW1lKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNOb2RlID0gREVGQVVMVF9OT09QX1BSRVZJT1VTX05PREU7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWVsaW5lID0gdGhpcy5jdXJyZW50VGltZWxpbmUuZm9yayh0aGlzLmVsZW1lbnQsIG5ld1RpbWUpO1xuICAgICAgICB0aGlzLnRpbWVsaW5lcy5wdXNoKHRoaXMuY3VycmVudFRpbWVsaW5lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWVsaW5lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvblxuICAgICAqIEBwYXJhbSB7P30gZHVyYXRpb25cbiAgICAgKiBAcGFyYW0gez99IGRlbGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLmFwcGVuZEluc3RydWN0aW9uVG9UaW1lbGluZSA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbiwgZHVyYXRpb24sIGRlbGF5KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZWRUaW1pbmdzID0ge1xuICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uICE9IG51bGwgPyBkdXJhdGlvbiA6IGluc3RydWN0aW9uLmR1cmF0aW9uLFxuICAgICAgICAgICAgZGVsYXk6IHRoaXMuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lICsgKGRlbGF5ICE9IG51bGwgPyBkZWxheSA6IDApICsgaW5zdHJ1Y3Rpb24uZGVsYXksXG4gICAgICAgICAgICBlYXNpbmc6ICcnXG4gICAgICAgIH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJ1aWxkZXIgPSBuZXcgU3ViVGltZWxpbmVCdWlsZGVyKGluc3RydWN0aW9uLmVsZW1lbnQsIGluc3RydWN0aW9uLmtleWZyYW1lcywgaW5zdHJ1Y3Rpb24ucHJlU3R5bGVQcm9wcywgaW5zdHJ1Y3Rpb24ucG9zdFN0eWxlUHJvcHMsIHVwZGF0ZWRUaW1pbmdzLCBpbnN0cnVjdGlvbi5zdHJldGNoU3RhcnRpbmdLZXlmcmFtZSk7XG4gICAgICAgIHRoaXMudGltZWxpbmVzLnB1c2goYnVpbGRlcik7XG4gICAgICAgIHJldHVybiB1cGRhdGVkVGltaW5ncztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0LnByb3RvdHlwZS5pbmNyZW1lbnRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZWxpbmUuZm9yd2FyZFRpbWUodGhpcy5jdXJyZW50VGltZWxpbmUuZHVyYXRpb24gKyB0aW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVsYXlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUuZGVsYXlOZXh0U3RlcCA9IGZ1bmN0aW9uIChkZWxheSkge1xuICAgICAgICAvLyBuZWdhdGl2ZSBkZWxheXMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkXG4gICAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWVsaW5lLmRlbGF5TmV4dFN0ZXAoZGVsYXkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBvcmlnaW5hbFNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBsaW1pdFxuICAgICAqIEBwYXJhbSB7P30gaW5jbHVkZVNlbGZcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbmFsXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUuaW52b2tlUXVlcnkgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIG9yaWdpbmFsU2VsZWN0b3IsIGxpbWl0LCBpbmNsdWRlU2VsZiwgb3B0aW9uYWwsIGVycm9ycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHRzID0gW107XG4gICAgICAgIGlmIChpbmNsdWRlU2VsZikge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdG9yLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG11bHRpID0gbGltaXQgIT0gMTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaC5hcHBseShyZXN1bHRzLCB0aGlzLl9kcml2ZXIucXVlcnkodGhpcy5lbGVtZW50LCBzZWxlY3RvciwgbXVsdGkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbmFsICYmIHJlc3VsdHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiYHF1ZXJ5KFxcXCJcIiArIG9yaWdpbmFsU2VsZWN0b3IgKyBcIlxcXCIpYCByZXR1cm5lZCB6ZXJvIGVsZW1lbnRzLiAoVXNlIGBxdWVyeShcXFwiXCIgKyBvcmlnaW5hbFNlbGVjdG9yICsgXCJcXFwiLCB7IG9wdGlvbmFsOiB0cnVlIH0pYCBpZiB5b3Ugd2lzaCB0byBhbGxvdyB0aGlzLilcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0O1xufSgpKTtcbnZhciBUaW1lbGluZUJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRUaW1lXG4gICAgICogQHBhcmFtIHs/PX0gX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRpbWVsaW5lQnVpbGRlcihlbGVtZW50LCBzdGFydFRpbWUsIF9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXApIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cCA9IF9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXA7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgICAgICB0aGlzLl9wcmV2aW91c0tleWZyYW1lID0ge307XG4gICAgICAgIHRoaXMuX2N1cnJlbnRLZXlmcmFtZSA9IHt9O1xuICAgICAgICB0aGlzLl9rZXlmcmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3N0eWxlU3VtbWFyeSA9IHt9O1xuICAgICAgICB0aGlzLl9wZW5kaW5nU3R5bGVzID0ge307XG4gICAgICAgIHRoaXMuX2JhY2tGaWxsID0ge307XG4gICAgICAgIHRoaXMuX2N1cnJlbnRFbXB0eVN0ZXBLZXlmcmFtZSA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudFRpbWVsaW5lU3R5bGVzTG9va3VwKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlcyA9IE9iamVjdC5jcmVhdGUodGhpcy5fYmFja0ZpbGwsIHt9KTtcbiAgICAgICAgdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXMgPSB0aGlzLl9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoIXRoaXMuX2dsb2JhbFRpbWVsaW5lU3R5bGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlcyA9IHRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXM7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXAuc2V0KGVsZW1lbnQsIHRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvYWRLZXlmcmFtZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuY29udGFpbnNBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fa2V5ZnJhbWVzLnNpemUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFN0eWxlUHJvcGVydGllcygpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuZ2V0Q3VycmVudFN0eWxlUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2N1cnJlbnRLZXlmcmFtZSk7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUsIFwiY3VycmVudFRpbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zdGFydFRpbWUgKyB0aGlzLmR1cmF0aW9uOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlbGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmRlbGF5TmV4dFN0ZXAgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgLy8gaW4gdGhlIGV2ZW50IHRoYXQgYSBzdHlsZSgpIHN0ZXAgaXMgcGxhY2VkIHJpZ2h0IGJlZm9yZSBhIHN0YWdnZXIoKVxuICAgICAgICAvLyBhbmQgdGhhdCBzdHlsZSgpIHN0ZXAgaXMgdGhlIHZlcnkgZmlyc3Qgc3R5bGUoKSB2YWx1ZSBpbiB0aGUgYW5pbWF0aW9uXG4gICAgICAgIC8vIHRoZW4gd2UgbmVlZCB0byBtYWtlIGEgY29weSBvZiB0aGUga2V5ZnJhbWUgWzAsIGNvcHksIDFdIHNvIHRoYXQgdGhlIGRlbGF5XG4gICAgICAgIC8vIHByb3Blcmx5IGFwcGxpZXMgdGhlIHN0eWxlKCkgdmFsdWVzIHRvIHdvcmsgd2l0aCB0aGUgc3RhZ2dlci4uLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNQcmVTdHlsZVN0ZXAgPSB0aGlzLl9rZXlmcmFtZXMuc2l6ZSA9PSAxICYmIE9iamVjdC5rZXlzKHRoaXMuX3BlbmRpbmdTdHlsZXMpLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuZHVyYXRpb24gfHwgaGFzUHJlU3R5bGVTdGVwKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmRUaW1lKHRoaXMuY3VycmVudFRpbWUgKyBkZWxheSk7XG4gICAgICAgICAgICBpZiAoaGFzUHJlU3R5bGVTdGVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zbmFwc2hvdEN1cnJlbnRTdHlsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lICs9IGRlbGF5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBjdXJyZW50VGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5mb3JrID0gZnVuY3Rpb24gKGVsZW1lbnQsIGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XG4gICAgICAgIHJldHVybiBuZXcgVGltZWxpbmVCdWlsZGVyKGVsZW1lbnQsIGN1cnJlbnRUaW1lIHx8IHRoaXMuY3VycmVudFRpbWUsIHRoaXMuX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuX2xvYWRLZXlmcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRLZXlmcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNLZXlmcmFtZSA9IHRoaXMuX2N1cnJlbnRLZXlmcmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50S2V5ZnJhbWUgPSAoKHRoaXMuX2tleWZyYW1lcy5nZXQodGhpcy5kdXJhdGlvbikpKTtcbiAgICAgICAgaWYgKCF0aGlzLl9jdXJyZW50S2V5ZnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRLZXlmcmFtZSA9IE9iamVjdC5jcmVhdGUodGhpcy5fYmFja0ZpbGwsIHt9KTtcbiAgICAgICAgICAgIHRoaXMuX2tleWZyYW1lcy5zZXQodGhpcy5kdXJhdGlvbiwgdGhpcy5fY3VycmVudEtleWZyYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmZvcndhcmRGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiArPSBPTkVfRlJBTUVfSU5fTUlMTElTRUNPTkRTO1xuICAgICAgICB0aGlzLl9sb2FkS2V5ZnJhbWUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5mb3J3YXJkVGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSB0aW1lO1xuICAgICAgICB0aGlzLl9sb2FkS2V5ZnJhbWUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuX3VwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fc3R5bGVTdW1tYXJ5W3Byb3BdID0geyB0aW1lOiB0aGlzLmN1cnJlbnRUaW1lLCB2YWx1ZTogdmFsdWUgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5hbGxvd09ubHlUaW1lbGluZVN0eWxlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2N1cnJlbnRFbXB0eVN0ZXBLZXlmcmFtZSAhPT0gdGhpcy5fY3VycmVudEtleWZyYW1lOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmFwcGx5RW1wdHlTdGVwID0gZnVuY3Rpb24gKGVhc2luZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZWFzaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0tleWZyYW1lWydlYXNpbmcnXSA9IGVhc2luZztcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIGFuaW1hdGUoZHVyYXRpb24pOlxuICAgICAgICAvLyBhbGwgbWlzc2luZyBzdHlsZXMgYXJlIGZpbGxlZCB3aXRoIGEgYCpgIHZhbHVlIHRoZW5cbiAgICAgICAgLy8gaWYgYW55IGRlc3RpbmF0aW9uIHN0eWxlcyBhcmUgZmlsbGVkIGluIGxhdGVyIG9uIHRoZSBzYW1lXG4gICAgICAgIC8vIGtleWZyYW1lIHRoZW4gdGhleSB3aWxsIG92ZXJyaWRlIHRoZSBvdmVycmlkZGVuIHN0eWxlc1xuICAgICAgICAvLyBXZSB1c2UgYF9nbG9iYWxUaW1lbGluZVN0eWxlc2AgaGVyZSBiZWNhdXNlIHRoZXJlIG1heSBiZVxuICAgICAgICAvLyBzdHlsZXMgaW4gcHJldmlvdXMga2V5ZnJhbWVzIHRoYXQgYXJlIG5vdCBwcmVzZW50IGluIHRoaXMgdGltZWxpbmVcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIF90aGlzLl9iYWNrRmlsbFtwcm9wXSA9IF90aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlc1twcm9wXSB8fCBfYW5ndWxhcl9hbmltYXRpb25zLkFVVE9fU1RZTEU7XG4gICAgICAgICAgICBfdGhpcy5fY3VycmVudEtleWZyYW1lW3Byb3BdID0gX2FuZ3VsYXJfYW5pbWF0aW9ucy5BVVRPX1NUWUxFO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY3VycmVudEVtcHR5U3RlcEtleWZyYW1lID0gdGhpcy5fY3VycmVudEtleWZyYW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLnNldFN0eWxlcyA9IGZ1bmN0aW9uIChpbnB1dCwgZWFzaW5nLCBlcnJvcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGVhc2luZykge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNLZXlmcmFtZVsnZWFzaW5nJ10gPSBlYXNpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1zID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJhbXMpIHx8IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSBmbGF0dGVuU3R5bGVzKGlucHV0LCB0aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlcyk7XG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsID0gaW50ZXJwb2xhdGVQYXJhbXMoc3R5bGVzW3Byb3BdLCBwYXJhbXMsIGVycm9ycyk7XG4gICAgICAgICAgICBfdGhpcy5fcGVuZGluZ1N0eWxlc1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYmFja0ZpbGxbcHJvcF0gPSBfdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXMuaGFzT3duUHJvcGVydHkocHJvcCkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXNbcHJvcF0gOlxuICAgICAgICAgICAgICAgICAgICBfYW5ndWxhcl9hbmltYXRpb25zLkFVVE9fU1RZTEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlU3R5bGUocHJvcCwgdmFsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuYXBwbHlTdHlsZXNUb0tleWZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSB0aGlzLl9wZW5kaW5nU3R5bGVzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wcyA9IE9iamVjdC5rZXlzKHN0eWxlcyk7XG4gICAgICAgIGlmIChwcm9wcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1N0eWxlcyA9IHt9O1xuICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWwgPSBzdHlsZXNbcHJvcF07XG4gICAgICAgICAgICBfdGhpcy5fY3VycmVudEtleWZyYW1lW3Byb3BdID0gdmFsO1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fY3VycmVudEtleWZyYW1lLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2N1cnJlbnRLZXlmcmFtZVtwcm9wXSA9IF90aGlzLl9sb2NhbFRpbWVsaW5lU3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5zbmFwc2hvdEN1cnJlbnRTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbCA9IF90aGlzLl9sb2NhbFRpbWVsaW5lU3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgX3RoaXMuX3BlbmRpbmdTdHlsZXNbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlU3R5bGUocHJvcCwgdmFsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuZ2V0RmluYWxLZXlmcmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2tleWZyYW1lcy5nZXQodGhpcy5kdXJhdGlvbik7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUsIFwicHJvcGVydGllc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wZXJ0aWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHByb3AgaW4gdGhpcy5fY3VycmVudEtleWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGltZWxpbmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUubWVyZ2VUaW1lbGluZUNvbGxlY3RlZFN0eWxlcyA9IGZ1bmN0aW9uICh0aW1lbGluZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0aW1lbGluZS5fc3R5bGVTdW1tYXJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzMCA9IF90aGlzLl9zdHlsZVN1bW1hcnlbcHJvcF07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzMSA9IHRpbWVsaW5lLl9zdHlsZVN1bW1hcnlbcHJvcF07XG4gICAgICAgICAgICBpZiAoIWRldGFpbHMwIHx8IGRldGFpbHMxLnRpbWUgPiBkZXRhaWxzMC50aW1lKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVN0eWxlKHByb3AsIGRldGFpbHMxLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuYnVpbGRLZXlmcmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVN0eWxlUHJvcHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc3RTdHlsZVByb3BzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0VtcHR5ID0gdGhpcy5fa2V5ZnJhbWVzLnNpemUgPT09IDEgJiYgdGhpcy5kdXJhdGlvbiA9PT0gMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmluYWxLZXlmcmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fa2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGtleWZyYW1lLCB0aW1lKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaW5hbEtleWZyYW1lID0gY29weVN0eWxlcyhrZXlmcmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhmaW5hbEtleWZyYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBmaW5hbEtleWZyYW1lW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBfYW5ndWxhcl9hbmltYXRpb25zLsm1UFJFX1NUWUxFKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZVN0eWxlUHJvcHMuYWRkKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBfYW5ndWxhcl9hbmltYXRpb25zLkFVVE9fU1RZTEUpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdFN0eWxlUHJvcHMuYWRkKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgZmluYWxLZXlmcmFtZVsnb2Zmc2V0J10gPSB0aW1lIC8gX3RoaXMuZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbEtleWZyYW1lcy5wdXNoKGZpbmFsS2V5ZnJhbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlUHJvcHMgPSBwcmVTdHlsZVByb3BzLnNpemUgPyBpdGVyYXRvclRvQXJyYXkocHJlU3R5bGVQcm9wcy52YWx1ZXMoKSkgOiBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdFByb3BzID0gcG9zdFN0eWxlUHJvcHMuc2l6ZSA/IGl0ZXJhdG9yVG9BcnJheShwb3N0U3R5bGVQcm9wcy52YWx1ZXMoKSkgOiBbXTtcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBhIDAtc2Vjb25kIGFuaW1hdGlvbiAod2hpY2ggaXMgZGVzaWduZWQganVzdCB0byBwbGFjZSBzdHlsZXMgb25zY3JlZW4pXG4gICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZjAgPSBmaW5hbEtleWZyYW1lc1swXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtmMSA9IGNvcHlPYmooa2YwKTtcbiAgICAgICAgICAgIGtmMFsnb2Zmc2V0J10gPSAwO1xuICAgICAgICAgICAga2YxWydvZmZzZXQnXSA9IDE7XG4gICAgICAgICAgICBmaW5hbEtleWZyYW1lcyA9IFtrZjAsIGtmMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRpbWVsaW5lSW5zdHJ1Y3Rpb24odGhpcy5lbGVtZW50LCBmaW5hbEtleWZyYW1lcywgcHJlUHJvcHMsIHBvc3RQcm9wcywgdGhpcy5kdXJhdGlvbiwgdGhpcy5zdGFydFRpbWUsIHRoaXMuZWFzaW5nLCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZWxpbmVCdWlsZGVyO1xufSgpKTtcbnZhciBTdWJUaW1lbGluZUJ1aWxkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJUaW1lbGluZUJ1aWxkZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAgICAgKiBAcGFyYW0gez99IHByZVN0eWxlUHJvcHNcbiAgICAgKiBAcGFyYW0gez99IHBvc3RTdHlsZVByb3BzXG4gICAgICogQHBhcmFtIHs/fSB0aW1pbmdzXG4gICAgICogQHBhcmFtIHs/PX0gX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3ViVGltZWxpbmVCdWlsZGVyKGVsZW1lbnQsIGtleWZyYW1lcywgcHJlU3R5bGVQcm9wcywgcG9zdFN0eWxlUHJvcHMsIHRpbWluZ3MsIF9zdHJldGNoU3RhcnRpbmdLZXlmcmFtZSkge1xuICAgICAgICBpZiAoX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lID09PSB2b2lkIDApIHsgX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZWxlbWVudCwgdGltaW5ncy5kZWxheSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIF90aGlzLmtleWZyYW1lcyA9IGtleWZyYW1lcztcbiAgICAgICAgX3RoaXMucHJlU3R5bGVQcm9wcyA9IHByZVN0eWxlUHJvcHM7XG4gICAgICAgIF90aGlzLnBvc3RTdHlsZVByb3BzID0gcG9zdFN0eWxlUHJvcHM7XG4gICAgICAgIF90aGlzLl9zdHJldGNoU3RhcnRpbmdLZXlmcmFtZSA9IF9zdHJldGNoU3RhcnRpbmdLZXlmcmFtZTtcbiAgICAgICAgX3RoaXMudGltaW5ncyA9IHsgZHVyYXRpb246IHRpbWluZ3MuZHVyYXRpb24sIGRlbGF5OiB0aW1pbmdzLmRlbGF5LCBlYXNpbmc6IHRpbWluZ3MuZWFzaW5nIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdWJUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmNvbnRhaW5zQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5rZXlmcmFtZXMubGVuZ3RoID4gMTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN1YlRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuYnVpbGRLZXlmcmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleWZyYW1lcyA9IHRoaXMua2V5ZnJhbWVzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnRpbWluZ3MsIGRlbGF5ID0gX2EuZGVsYXksIGR1cmF0aW9uID0gX2EuZHVyYXRpb24sIGVhc2luZyA9IF9hLmVhc2luZztcbiAgICAgICAgaWYgKHRoaXMuX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lICYmIGRlbGF5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXdLZXlmcmFtZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvdGFsVGltZSA9IGR1cmF0aW9uICsgZGVsYXk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydGluZ0dhcCA9IGRlbGF5IC8gdG90YWxUaW1lO1xuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIHN0YXJ0aW5nIGtleWZyYW1lIG5vdyBzdGFydHMgb25jZSB0aGUgZGVsYXkgaXMgZG9uZVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3Rmlyc3RLZXlmcmFtZSA9IGNvcHlTdHlsZXMoa2V5ZnJhbWVzWzBdLCBmYWxzZSk7XG4gICAgICAgICAgICBuZXdGaXJzdEtleWZyYW1lWydvZmZzZXQnXSA9IDA7XG4gICAgICAgICAgICBuZXdLZXlmcmFtZXMucHVzaChuZXdGaXJzdEtleWZyYW1lKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZEZpcnN0S2V5ZnJhbWUgPSBjb3B5U3R5bGVzKGtleWZyYW1lc1swXSwgZmFsc2UpO1xuICAgICAgICAgICAgb2xkRmlyc3RLZXlmcmFtZVsnb2Zmc2V0J10gPSByb3VuZE9mZnNldChzdGFydGluZ0dhcCk7XG4gICAgICAgICAgICBuZXdLZXlmcmFtZXMucHVzaChvbGRGaXJzdEtleWZyYW1lKTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIFdoZW4gdGhlIGtleWZyYW1lIGlzIHN0cmV0Y2hlZCB0aGVuIGl0IG1lYW5zIHRoYXQgdGhlIGRlbGF5IGJlZm9yZSB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgIHN0YXJ0cyBpcyBnb25lLiBJbnN0ZWFkIHRoZSBmaXJzdCBrZXlmcmFtZSBpcyBwbGFjZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgICAgYW5kIGl0IGlzIHRoZW4gY29waWVkIHRvIHdoZXJlIGl0IHN0YXJ0cyB3aGVuIHRoZSBvcmlnaW5hbCBkZWxheSBpcyBvdmVyLiBUaGlzIGJhc2ljYWxseVxuICAgICAgICAgICAgICBtZWFucyBub3RoaW5nIGFuaW1hdGVzIGR1cmluZyB0aGF0IGRlbGF5LCBidXQgdGhlIHN0eWxlcyBhcmUgc3RpbGwgcmVuZGVyZXJlZC4gRm9yIHRoaXNcbiAgICAgICAgICAgICAgdG8gd29yayB0aGUgb3JpZ2luYWwgb2Zmc2V0IHZhbHVlcyB0aGF0IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBrZXlmcmFtZXMgbXVzdCBiZSBcIndhcnBlZFwiXG4gICAgICAgICAgICAgIHNvIHRoYXQgdGhleSBjYW4gdGFrZSB0aGUgbmV3IGtleWZyYW1lICsgZGVsYXkgaW50byBhY2NvdW50LlxuICAgICAgXG4gICAgICAgICAgICAgIGRlbGF5PTEwMDAsIGR1cmF0aW9uPTEwMDAsIGtleWZyYW1lcyA9IDAgLjUgMVxuICAgICAgXG4gICAgICAgICAgICAgIHR1cm5zIGludG9cbiAgICAgIFxuICAgICAgICAgICAgICBkZWxheT0wLCBkdXJhdGlvbj0yMDAwLCBrZXlmcmFtZXMgPSAwIC4zMyAuNjYgMVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBvZmZzZXRzIGJldHdlZW4gMSAuLi4gbiAtMSBhcmUgYWxsIHdhcnBlZCBieSB0aGUga2V5ZnJhbWUgc3RyZXRjaFxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGltaXQgPSBrZXlmcmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDE7IGkgPD0gbGltaXQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtmID0gY29weVN0eWxlcyhrZXlmcmFtZXNbaV0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRPZmZzZXQgPSAoa2ZbJ29mZnNldCddKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lQXRLZXlmcmFtZSA9IGRlbGF5ICsgb2xkT2Zmc2V0ICogZHVyYXRpb247XG4gICAgICAgICAgICAgICAga2ZbJ29mZnNldCddID0gcm91bmRPZmZzZXQodGltZUF0S2V5ZnJhbWUgLyB0b3RhbFRpbWUpO1xuICAgICAgICAgICAgICAgIG5ld0tleWZyYW1lcy5wdXNoKGtmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZSBuZXcgc3RhcnRpbmcga2V5ZnJhbWUgc2hvdWxkIGJlIGFkZGVkIGF0IHRoZSBzdGFydFxuICAgICAgICAgICAgZHVyYXRpb24gPSB0b3RhbFRpbWU7XG4gICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgICAgICBlYXNpbmcgPSAnJztcbiAgICAgICAgICAgIGtleWZyYW1lcyA9IG5ld0tleWZyYW1lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlVGltZWxpbmVJbnN0cnVjdGlvbih0aGlzLmVsZW1lbnQsIGtleWZyYW1lcywgdGhpcy5wcmVTdHlsZVByb3BzLCB0aGlzLnBvc3RTdHlsZVByb3BzLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgdHJ1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3ViVGltZWxpbmVCdWlsZGVyO1xufShUaW1lbGluZUJ1aWxkZXIpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBvZmZzZXRcbiAqIEBwYXJhbSB7Pz19IGRlY2ltYWxQb2ludHNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0KG9mZnNldCwgZGVjaW1hbFBvaW50cykge1xuICAgIGlmIChkZWNpbWFsUG9pbnRzID09PSB2b2lkIDApIHsgZGVjaW1hbFBvaW50cyA9IDM7IH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtdWx0ID0gTWF0aC5wb3coMTAsIGRlY2ltYWxQb2ludHMgLSAxKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChvZmZzZXQgKiBtdWx0KSAvIG11bHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEBwYXJhbSB7P30gYWxsU3R5bGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmbGF0dGVuU3R5bGVzKGlucHV0LCBhbGxTdHlsZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSB7fTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxQcm9wZXJ0aWVzO1xuICAgIGlucHV0LmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gJyonKSB7XG4gICAgICAgICAgICBhbGxQcm9wZXJ0aWVzID0gYWxsUHJvcGVydGllcyB8fCBPYmplY3Qua2V5cyhhbGxTdHlsZXMpO1xuICAgICAgICAgICAgYWxsUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHN0eWxlc1twcm9wXSA9IF9hbmd1bGFyX2FuaW1hdGlvbnMuQVVUT19TVFlMRTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3B5U3R5bGVzKC8qKiBAdHlwZSB7P30gKi8gKHRva2VuKSwgZmFsc2UsIHN0eWxlcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3R5bGVzO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEFuaW1hdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZHJpdmVyXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbihfZHJpdmVyLCBpbnB1dCkge1xuICAgICAgICB0aGlzLl9kcml2ZXIgPSBfZHJpdmVyO1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIHZhciBhc3QgPSBidWlsZEFuaW1hdGlvbkFzdChpbnB1dCwgZXJyb3JzKTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcImFuaW1hdGlvbiB2YWxpZGF0aW9uIGZhaWxlZDpcXG5cIiArIGVycm9ycy5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uQXN0ID0gYXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0aW5nU3R5bGVzXG4gICAgICogQHBhcmFtIHs/fSBkZXN0aW5hdGlvblN0eWxlc1xuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IHN1Ykluc3RydWN0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5idWlsZFRpbWVsaW5lcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdGFydGluZ1N0eWxlcywgZGVzdGluYXRpb25TdHlsZXMsIG9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IEFycmF5LmlzQXJyYXkoc3RhcnRpbmdTdHlsZXMpID8gbm9ybWFsaXplU3R5bGVzKHN0YXJ0aW5nU3R5bGVzKSA6IChzdGFydGluZ1N0eWxlcyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlc3QgPSBBcnJheS5pc0FycmF5KGRlc3RpbmF0aW9uU3R5bGVzKSA/IG5vcm1hbGl6ZVN0eWxlcyhkZXN0aW5hdGlvblN0eWxlcykgOiAoZGVzdGluYXRpb25TdHlsZXMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnMgPSBbXTtcbiAgICAgICAgc3ViSW5zdHJ1Y3Rpb25zID0gc3ViSW5zdHJ1Y3Rpb25zIHx8IG5ldyBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gYnVpbGRBbmltYXRpb25UaW1lbGluZXModGhpcy5fZHJpdmVyLCBlbGVtZW50LCB0aGlzLl9hbmltYXRpb25Bc3QsIHN0YXJ0LCBkZXN0LCBvcHRpb25zLCBzdWJJbnN0cnVjdGlvbnMsIGVycm9ycyk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvck1lc3NhZ2UgPSBcImFuaW1hdGlvbiBidWlsZGluZyBmYWlsZWQ6XFxuXCIgKyBlcnJvcnMuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi8gdmFyIEFuaW1hdGlvblN0eWxlTm9ybWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyO1xufSgpKTtcbi8qKlxuICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKi9cbnZhciBOb29wQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb29wQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyKCkge1xuICAgIH1cbiAgICBOb29wQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lLCBlcnJvcnMpIHsgcmV0dXJuIHByb3BlcnR5TmFtZTsgfTtcbiAgICBOb29wQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVTdHlsZVZhbHVlID0gZnVuY3Rpb24gKHVzZXJQcm92aWRlZFByb3BlcnR5LCBub3JtYWxpemVkUHJvcGVydHksIHZhbHVlLCBlcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIE5vb3BBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXI7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFdlYkFuaW1hdGlvbnNTdHlsZU5vcm1hbGl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdlYkFuaW1hdGlvbnNTdHlsZU5vcm1hbGl6ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eU5hbWVcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplUHJvcGVydHlOYW1lID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgZXJyb3JzKSB7XG4gICAgICAgIHJldHVybiBkYXNoQ2FzZVRvQ2FtZWxDYXNlKHByb3BlcnR5TmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVzZXJQcm92aWRlZFByb3BlcnR5XG4gICAgICogQHBhcmFtIHs/fSBub3JtYWxpemVkUHJvcGVydHlcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNTdHlsZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVN0eWxlVmFsdWUgPSBmdW5jdGlvbiAodXNlclByb3ZpZGVkUHJvcGVydHksIG5vcm1hbGl6ZWRQcm9wZXJ0eSwgdmFsdWUsIGVycm9ycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1bml0ID0gJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0clZhbCA9IHZhbHVlLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICBpZiAoRElNRU5TSU9OQUxfUFJPUF9NQVBbbm9ybWFsaXplZFByb3BlcnR5XSAmJiB2YWx1ZSAhPT0gMCAmJiB2YWx1ZSAhPT0gJzAnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHVuaXQgPSAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsQW5kU3VmZml4TWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXlsrLV0/W1xcZFxcLl0rKFthLXpdKikkLyk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbEFuZFN1ZmZpeE1hdGNoICYmIHZhbEFuZFN1ZmZpeE1hdGNoWzFdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiUGxlYXNlIHByb3ZpZGUgYSBDU1MgdW5pdCB2YWx1ZSBmb3IgXCIgKyB1c2VyUHJvdmlkZWRQcm9wZXJ0eSArIFwiOlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyVmFsICsgdW5pdDtcbiAgICB9O1xuICAgIHJldHVybiBXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyO1xufShBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIpKTtcbnZhciBESU1FTlNJT05BTF9QUk9QX01BUCA9IG1ha2VCb29sZWFuTWFwKCd3aWR0aCxoZWlnaHQsbWluV2lkdGgsbWluSGVpZ2h0LG1heFdpZHRoLG1heEhlaWdodCxsZWZ0LHRvcCxib3R0b20scmlnaHQsZm9udFNpemUsb3V0bGluZVdpZHRoLG91dGxpbmVPZmZzZXQscGFkZGluZ1RvcCxwYWRkaW5nTGVmdCxwYWRkaW5nQm90dG9tLHBhZGRpbmdSaWdodCxtYXJnaW5Ub3AsbWFyZ2luTGVmdCxtYXJnaW5Cb3R0b20sbWFyZ2luUmlnaHQsYm9yZGVyUmFkaXVzLGJvcmRlcldpZHRoLGJvcmRlclRvcFdpZHRoLGJvcmRlckxlZnRXaWR0aCxib3JkZXJSaWdodFdpZHRoLGJvcmRlckJvdHRvbVdpZHRoLHRleHRJbmRlbnQscGVyc3BlY3RpdmUnXG4gICAgLnNwbGl0KCcsJykpO1xuLyoqXG4gKiBAcGFyYW0gez99IGtleXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG1ha2VCb29sZWFuTWFwKGtleXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXAgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbWFwW2tleV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gbWFwO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7P30gdHJpZ2dlck5hbWVcbiAqIEBwYXJhbSB7P30gZnJvbVN0YXRlXG4gKiBAcGFyYW0gez99IHRvU3RhdGVcbiAqIEBwYXJhbSB7P30gaXNSZW1vdmFsVHJhbnNpdGlvblxuICogQHBhcmFtIHs/fSBmcm9tU3R5bGVzXG4gKiBAcGFyYW0gez99IHRvU3R5bGVzXG4gKiBAcGFyYW0gez99IHRpbWVsaW5lc1xuICogQHBhcmFtIHs/fSBxdWVyaWVkRWxlbWVudHNcbiAqIEBwYXJhbSB7P30gcHJlU3R5bGVQcm9wc1xuICogQHBhcmFtIHs/fSBwb3N0U3R5bGVQcm9wc1xuICogQHBhcmFtIHs/PX0gZXJyb3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudCwgdHJpZ2dlck5hbWUsIGZyb21TdGF0ZSwgdG9TdGF0ZSwgaXNSZW1vdmFsVHJhbnNpdGlvbiwgZnJvbVN0eWxlcywgdG9TdHlsZXMsIHRpbWVsaW5lcywgcXVlcmllZEVsZW1lbnRzLCBwcmVTdHlsZVByb3BzLCBwb3N0U3R5bGVQcm9wcywgZXJyb3JzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBUcmFuc2l0aW9uQW5pbWF0aW9uICovLFxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICB0cmlnZ2VyTmFtZTogdHJpZ2dlck5hbWUsXG4gICAgICAgIGlzUmVtb3ZhbFRyYW5zaXRpb246IGlzUmVtb3ZhbFRyYW5zaXRpb24sXG4gICAgICAgIGZyb21TdGF0ZTogZnJvbVN0YXRlLFxuICAgICAgICBmcm9tU3R5bGVzOiBmcm9tU3R5bGVzLFxuICAgICAgICB0b1N0YXRlOiB0b1N0YXRlLFxuICAgICAgICB0b1N0eWxlczogdG9TdHlsZXMsXG4gICAgICAgIHRpbWVsaW5lczogdGltZWxpbmVzLFxuICAgICAgICBxdWVyaWVkRWxlbWVudHM6IHF1ZXJpZWRFbGVtZW50cyxcbiAgICAgICAgcHJlU3R5bGVQcm9wczogcHJlU3R5bGVQcm9wcyxcbiAgICAgICAgcG9zdFN0eWxlUHJvcHM6IHBvc3RTdHlsZVByb3BzLFxuICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgIH07XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgRU1QVFlfT0JKRUNUID0ge307XG52YXIgQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3RyaWdnZXJOYW1lXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IF9zdGF0ZVN0eWxlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRyYW5zaXRpb25GYWN0b3J5KF90cmlnZ2VyTmFtZSwgYXN0LCBfc3RhdGVTdHlsZXMpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlck5hbWUgPSBfdHJpZ2dlck5hbWU7XG4gICAgICAgIHRoaXMuYXN0ID0gYXN0O1xuICAgICAgICB0aGlzLl9zdGF0ZVN0eWxlcyA9IF9zdGF0ZVN0eWxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjdXJyZW50U3RhdGVcbiAgICAgKiBAcGFyYW0gez99IG5leHRTdGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlKSB7XG4gICAgICAgIHJldHVybiBvbmVPck1vcmVUcmFuc2l0aW9uc01hdGNoKHRoaXMuYXN0Lm1hdGNoZXJzLCBjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlTmFtZVxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25GYWN0b3J5LnByb3RvdHlwZS5idWlsZFN0eWxlcyA9IGZ1bmN0aW9uIChzdGF0ZU5hbWUsIHBhcmFtcywgZXJyb3JzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhY2t1cFN0YXRlU3R5bGVyID0gdGhpcy5fc3RhdGVTdHlsZXNbJyonXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGVTdHlsZXIgPSB0aGlzLl9zdGF0ZVN0eWxlc1tzdGF0ZU5hbWVdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYWNrdXBTdHlsZXMgPSBiYWNrdXBTdGF0ZVN0eWxlciA/IGJhY2t1cFN0YXRlU3R5bGVyLmJ1aWxkU3R5bGVzKHBhcmFtcywgZXJyb3JzKSA6IHt9O1xuICAgICAgICByZXR1cm4gc3RhdGVTdHlsZXIgPyBzdGF0ZVN0eWxlci5idWlsZFN0eWxlcyhwYXJhbXMsIGVycm9ycykgOiBiYWNrdXBTdHlsZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRyaXZlclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY3VycmVudFN0YXRlXG4gICAgICogQHBhcmFtIHs/fSBuZXh0U3RhdGVcbiAgICAgKiBAcGFyYW0gez89fSBjdXJyZW50T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IG5leHRPcHRpb25zXG4gICAgICogQHBhcmFtIHs/PX0gc3ViSW5zdHJ1Y3Rpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uRmFjdG9yeS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoZHJpdmVyLCBlbGVtZW50LCBjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSwgY3VycmVudE9wdGlvbnMsIG5leHRPcHRpb25zLCBzdWJJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zaXRpb25BbmltYXRpb25QYXJhbXMgPSB0aGlzLmFzdC5vcHRpb25zICYmIHRoaXMuYXN0Lm9wdGlvbnMucGFyYW1zIHx8IEVNUFRZX09CSkVDVDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VycmVudEFuaW1hdGlvblBhcmFtcyA9IGN1cnJlbnRPcHRpb25zICYmIGN1cnJlbnRPcHRpb25zLnBhcmFtcyB8fCBFTVBUWV9PQkpFQ1Q7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRTdGF0ZVN0eWxlcyA9IHRoaXMuYnVpbGRTdHlsZXMoY3VycmVudFN0YXRlLCBjdXJyZW50QW5pbWF0aW9uUGFyYW1zLCBlcnJvcnMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXh0QW5pbWF0aW9uUGFyYW1zID0gbmV4dE9wdGlvbnMgJiYgbmV4dE9wdGlvbnMucGFyYW1zIHx8IEVNUFRZX09CSkVDVDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV4dFN0YXRlU3R5bGVzID0gdGhpcy5idWlsZFN0eWxlcyhuZXh0U3RhdGUsIG5leHRBbmltYXRpb25QYXJhbXMsIGVycm9ycyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZWRFbGVtZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlU3R5bGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc3RTdHlsZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNSZW1vdmFsID0gbmV4dFN0YXRlID09PSAndm9pZCc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuaW1hdGlvbk9wdGlvbnMgPSB7IHBhcmFtczogT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNpdGlvbkFuaW1hdGlvblBhcmFtcywgbmV4dEFuaW1hdGlvblBhcmFtcykgfTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltZWxpbmVzID0gYnVpbGRBbmltYXRpb25UaW1lbGluZXMoZHJpdmVyLCBlbGVtZW50LCB0aGlzLmFzdC5hbmltYXRpb24sIGN1cnJlbnRTdGF0ZVN0eWxlcywgbmV4dFN0YXRlU3R5bGVzLCBhbmltYXRpb25PcHRpb25zLCBzdWJJbnN0cnVjdGlvbnMsIGVycm9ycyk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVHJhbnNpdGlvbkluc3RydWN0aW9uKGVsZW1lbnQsIHRoaXMuX3RyaWdnZXJOYW1lLCBjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSwgaXNSZW1vdmFsLCBjdXJyZW50U3RhdGVTdHlsZXMsIG5leHRTdGF0ZVN0eWxlcywgW10sIFtdLCBwcmVTdHlsZU1hcCwgcG9zdFN0eWxlTWFwLCBlcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uICh0bCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxtID0gdGwuZWxlbWVudDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVByb3BzID0gZ2V0T3JTZXRBc0luTWFwKHByZVN0eWxlTWFwLCBlbG0sIHt9KTtcbiAgICAgICAgICAgIHRsLnByZVN0eWxlUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gcHJlUHJvcHNbcHJvcF0gPSB0cnVlOyB9KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc3RQcm9wcyA9IGdldE9yU2V0QXNJbk1hcChwb3N0U3R5bGVNYXAsIGVsbSwge30pO1xuICAgICAgICAgICAgdGwucG9zdFN0eWxlUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gcG9zdFByb3BzW3Byb3BdID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICBpZiAoZWxtICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcXVlcmllZEVsZW1lbnRzLmFkZChlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcmllZEVsZW1lbnRzTGlzdCA9IGl0ZXJhdG9yVG9BcnJheShxdWVyaWVkRWxlbWVudHMudmFsdWVzKCkpO1xuICAgICAgICByZXR1cm4gY3JlYXRlVHJhbnNpdGlvbkluc3RydWN0aW9uKGVsZW1lbnQsIHRoaXMuX3RyaWdnZXJOYW1lLCBjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSwgaXNSZW1vdmFsLCBjdXJyZW50U3RhdGVTdHlsZXMsIG5leHRTdGF0ZVN0eWxlcywgdGltZWxpbmVzLCBxdWVyaWVkRWxlbWVudHNMaXN0LCBwcmVTdHlsZU1hcCwgcG9zdFN0eWxlTWFwKTtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25UcmFuc2l0aW9uRmFjdG9yeTtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gbWF0Y2hGbnNcbiAqIEBwYXJhbSB7P30gY3VycmVudFN0YXRlXG4gKiBAcGFyYW0gez99IG5leHRTdGF0ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gb25lT3JNb3JlVHJhbnNpdGlvbnNNYXRjaChtYXRjaEZucywgY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpIHtcbiAgICByZXR1cm4gbWF0Y2hGbnMuc29tZShmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlKTsgfSk7XG59XG52YXIgQW5pbWF0aW9uU3RhdGVTdHlsZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzXG4gICAgICogQHBhcmFtIHs/fSBkZWZhdWx0UGFyYW1zXG4gICAgICovXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVTdHlsZXMoc3R5bGVzLCBkZWZhdWx0UGFyYW1zKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB0aGlzLmRlZmF1bHRQYXJhbXMgPSBkZWZhdWx0UGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25TdGF0ZVN0eWxlcy5wcm90b3R5cGUuYnVpbGRTdHlsZXMgPSBmdW5jdGlvbiAocGFyYW1zLCBlcnJvcnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmluYWxTdHlsZXMgPSB7fTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tYmluZWRQYXJhbXMgPSBjb3B5T2JqKHRoaXMuZGVmYXVsdFBhcmFtcyk7XG4gICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb21iaW5lZFBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0eWxlcy5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVPYmpfMSA9ICh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVPYmpfMSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWwgPSBzdHlsZU9ial8xW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGludGVycG9sYXRlUGFyYW1zKHZhbCwgY29tYmluZWRQYXJhbXMsIGVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxTdHlsZXNbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmluYWxTdHlsZXM7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uU3RhdGVTdHlsZXM7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQHBhcmFtIHs/fSBuYW1lXG4gKiBAcGFyYW0gez99IGFzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYnVpbGRUcmlnZ2VyKG5hbWUsIGFzdCkge1xuICAgIHJldHVybiBuZXcgQW5pbWF0aW9uVHJpZ2dlcihuYW1lLCBhc3QpO1xufVxuLyoqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICovXG52YXIgQW5pbWF0aW9uVHJpZ2dlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBbmltYXRpb25UcmlnZ2VyKG5hbWUsIGFzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFzdCA9IGFzdDtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uRmFjdG9yaWVzID0gW107XG4gICAgICAgIHRoaXMuc3RhdGVzID0ge307XG4gICAgICAgIGFzdC5zdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdFBhcmFtcyA9IChhc3Qub3B0aW9ucyAmJiBhc3Qub3B0aW9ucy5wYXJhbXMpIHx8IHt9O1xuICAgICAgICAgICAgX3RoaXMuc3RhdGVzW2FzdC5uYW1lXSA9IG5ldyBBbmltYXRpb25TdGF0ZVN0eWxlcyhhc3Quc3R5bGUsIGRlZmF1bHRQYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgYmFsYW5jZVByb3BlcnRpZXModGhpcy5zdGF0ZXMsICd0cnVlJywgJzEnKTtcbiAgICAgICAgYmFsYW5jZVByb3BlcnRpZXModGhpcy5zdGF0ZXMsICdmYWxzZScsICcwJyk7XG4gICAgICAgIGFzdC50cmFuc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgIF90aGlzLnRyYW5zaXRpb25GYWN0b3JpZXMucHVzaChuZXcgQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkobmFtZSwgYXN0LCBfdGhpcy5zdGF0ZXMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmFsbGJhY2tUcmFuc2l0aW9uID0gY3JlYXRlRmFsbGJhY2tUcmFuc2l0aW9uKG5hbWUsIHRoaXMuc3RhdGVzKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvblRyaWdnZXIucHJvdG90eXBlLCBcImNvbnRhaW5zUXVlcmllc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmFzdC5xdWVyeUNvdW50ID4gMDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjdXJyZW50U3RhdGVcbiAgICAgKiBAcGFyYW0gez99IG5leHRTdGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJpZ2dlci5wcm90b3R5cGUubWF0Y2hUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5ID0gdGhpcy50cmFuc2l0aW9uRmFjdG9yaWVzLmZpbmQoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYubWF0Y2goY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpOyB9KTtcbiAgICAgICAgcmV0dXJuIGVudHJ5IHx8IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRTdGF0ZVxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyaWdnZXIucHJvdG90eXBlLm1hdGNoU3R5bGVzID0gZnVuY3Rpb24gKGN1cnJlbnRTdGF0ZSwgcGFyYW1zLCBlcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFsbGJhY2tUcmFuc2l0aW9uLmJ1aWxkU3R5bGVzKGN1cnJlbnRTdGF0ZSwgcGFyYW1zLCBlcnJvcnMpO1xuICAgIH07XG4gICAgcmV0dXJuIEFuaW1hdGlvblRyaWdnZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHRyaWdnZXJOYW1lXG4gKiBAcGFyYW0gez99IHN0YXRlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmFsbGJhY2tUcmFuc2l0aW9uKHRyaWdnZXJOYW1lLCBzdGF0ZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVycyA9IFtmdW5jdGlvbiAoZnJvbVN0YXRlLCB0b1N0YXRlKSB7IHJldHVybiB0cnVlOyB9XTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbmltYXRpb24gPSBuZXcgU2VxdWVuY2VBc3QoW10pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zaXRpb24gPSBuZXcgVHJhbnNpdGlvbkFzdChtYXRjaGVycywgYW5pbWF0aW9uKTtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGlvblRyYW5zaXRpb25GYWN0b3J5KHRyaWdnZXJOYW1lLCB0cmFuc2l0aW9uLCBzdGF0ZXMpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG9ialxuICogQHBhcmFtIHs/fSBrZXkxXG4gKiBAcGFyYW0gez99IGtleTJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGJhbGFuY2VQcm9wZXJ0aWVzKG9iaiwga2V5MSwga2V5Mikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5MSkpIHtcbiAgICAgICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5MikpIHtcbiAgICAgICAgICAgIG9ialtrZXkyXSA9IG9ialtrZXkxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5MikpIHtcbiAgICAgICAgb2JqW2tleTFdID0gb2JqW2tleTJdO1xuICAgIH1cbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBFTVBUWV9JTlNUUlVDVElPTl9NQVAgPSBuZXcgRWxlbWVudEluc3RydWN0aW9uTWFwKCk7XG52YXIgVGltZWxpbmVBbmltYXRpb25FbmdpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2RyaXZlclxuICAgICAqIEBwYXJhbSB7P30gX25vcm1hbGl6ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZShfZHJpdmVyLCBfbm9ybWFsaXplcikge1xuICAgICAgICB0aGlzLl9kcml2ZXIgPSBfZHJpdmVyO1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVyID0gX25vcm1hbGl6ZXI7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5fcGxheWVyc0J5SWQgPSB7fTtcbiAgICAgICAgdGhpcy5wbGF5ZXJzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoaWQsIG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBidWlsZEFuaW1hdGlvbkFzdChtZXRhZGF0YSwgZXJyb3JzKTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBidWlsZCB0aGUgYW5pbWF0aW9uIGR1ZSB0byB0aGUgZm9sbG93aW5nIGVycm9yczogXCIgKyBlcnJvcnMuam9pbihcIlxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb25zW2lkXSA9IGFzdDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpXG4gICAgICogQHBhcmFtIHs/fSBwcmVTdHlsZXNcbiAgICAgKiBAcGFyYW0gez89fSBwb3N0U3R5bGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuX2J1aWxkUGxheWVyID0gZnVuY3Rpb24gKGksIHByZVN0eWxlcywgcG9zdFN0eWxlcykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gaS5lbGVtZW50O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlmcmFtZXMgPSBub3JtYWxpemVLZXlmcmFtZXModGhpcy5fZHJpdmVyLCB0aGlzLl9ub3JtYWxpemVyLCBlbGVtZW50LCBpLmtleWZyYW1lcywgcHJlU3R5bGVzLCBwb3N0U3R5bGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyaXZlci5hbmltYXRlKGVsZW1lbnQsIGtleWZyYW1lcywgaS5kdXJhdGlvbiwgaS5kZWxheSwgaS5lYXNpbmcsIFtdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGlkLCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSB0aGlzLl9hbmltYXRpb25zW2lkXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5zdHJ1Y3Rpb25zO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdXRvU3R5bGVzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoYXN0KSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBidWlsZEFuaW1hdGlvblRpbWVsaW5lcyh0aGlzLl9kcml2ZXIsIGVsZW1lbnQsIGFzdCwge30sIHt9LCBvcHRpb25zLCBFTVBUWV9JTlNUUlVDVElPTl9NQVAsIGVycm9ycyk7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IGdldE9yU2V0QXNJbk1hcChhdXRvU3R5bGVzTWFwLCBpbnN0LmVsZW1lbnQsIHt9KTtcbiAgICAgICAgICAgICAgICBpbnN0LnBvc3RTdHlsZVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHN0eWxlc1twcm9wXSA9IG51bGw7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCgnVGhlIHJlcXVlc3RlZCBhbmltYXRpb24gZG9lc25cXCd0IGV4aXN0IG9yIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkJyk7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSB0aGUgYW5pbWF0aW9uIGR1ZSB0byB0aGUgZm9sbG93aW5nIGVycm9yczogXCIgKyBlcnJvcnMuam9pbihcIlxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXV0b1N0eWxlc01hcC5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZXMsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyBzdHlsZXNbcHJvcF0gPSBfdGhpcy5fZHJpdmVyLmNvbXB1dGVTdHlsZShlbGVtZW50LCBwcm9wLCBfYW5ndWxhcl9hbmltYXRpb25zLkFVVE9fU1RZTEUpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBpbnN0cnVjdGlvbnMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSBhdXRvU3R5bGVzTWFwLmdldChpLmVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9idWlsZFBsYXllcihpLCB7fSwgc3R5bGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IG9wdGltaXplR3JvdXBQbGF5ZXIocGxheWVycyk7XG4gICAgICAgIHRoaXMuX3BsYXllcnNCeUlkW2lkXSA9IHBsYXllcjtcbiAgICAgICAgcGxheWVyLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kZXN0cm95KGlkKTsgfSk7XG4gICAgICAgIHRoaXMucGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSB0aGlzLl9nZXRQbGF5ZXIoaWQpO1xuICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5fcGxheWVyc0J5SWRbaWRdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IHRoaXMucGxheWVycy5pbmRleE9mKHBsYXllcik7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9nZXRQbGF5ZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gdGhpcy5fcGxheWVyc0J5SWRbaWRdO1xuICAgICAgICBpZiAoIXBsYXllcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgdGhlIHRpbWVsaW5lIHBsYXllciByZWZlcmVuY2VkIGJ5IFwiICsgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKGlkLCBlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHRyaWdnZXJOYW1lLCBmcm9tU3RhdGUsIHRvU3RhdGUgYXJlIGFsbCBpZ25vcmVkIGZvciB0aW1lbGluZSBhbmltYXRpb25zXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VFdmVudCA9IG1ha2VBbmltYXRpb25FdmVudChlbGVtZW50LCAnJywgJycsICcnKTtcbiAgICAgICAgbGlzdGVuT25QbGF5ZXIodGhpcy5fZ2V0UGxheWVyKGlkKSwgZXZlbnROYW1lLCBiYXNlRXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbW1hbmRcbiAgICAgKiBAcGFyYW0gez99IGFyZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5jb21tYW5kID0gZnVuY3Rpb24gKGlkLCBlbGVtZW50LCBjb21tYW5kLCBhcmdzKSB7XG4gICAgICAgIGlmIChjb21tYW5kID09ICdyZWdpc3RlcicpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoaWQsIC8qKiBAdHlwZSB7P30gKi8gKGFyZ3NbMF0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZCA9PSAnY3JlYXRlJykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9ucyA9ICgoYXJnc1swXSB8fCB7fSkpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGUoaWQsIGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IHRoaXMuX2dldFBsYXllcihpZCk7XG4gICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSAncGxheSc6XG4gICAgICAgICAgICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3BhdXNlJzpcbiAgICAgICAgICAgICAgICBwbGF5ZXIucGF1c2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgICAgICAgICAgICBwbGF5ZXIucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jlc3RhcnQnOlxuICAgICAgICAgICAgICAgIHBsYXllci5yZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmaW5pc2gnOlxuICAgICAgICAgICAgICAgIHBsYXllci5maW5pc2goKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICAgICAgICAgIHBsYXllci5pbml0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZXRQb3NpdGlvbic6XG4gICAgICAgICAgICAgICAgcGxheWVyLnNldFBvc2l0aW9uKHBhcnNlRmxvYXQoLyoqIEB0eXBlIHs/fSAqLyAoYXJnc1swXSkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveShpZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZTtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUVVFVUVEX0NMQVNTTkFNRSA9ICduZy1hbmltYXRlLXF1ZXVlZCc7XG52YXIgUVVFVUVEX1NFTEVDVE9SID0gJy5uZy1hbmltYXRlLXF1ZXVlZCc7XG52YXIgRElTQUJMRURfQ0xBU1NOQU1FID0gJ25nLWFuaW1hdGUtZGlzYWJsZWQnO1xudmFyIERJU0FCTEVEX1NFTEVDVE9SID0gJy5uZy1hbmltYXRlLWRpc2FibGVkJztcbnZhciBFTVBUWV9QTEFZRVJfQVJSQVkgPSBbXTtcbnZhciBOVUxMX1JFTU9WQUxfU1RBVEUgPSB7XG4gICAgbmFtZXNwYWNlSWQ6ICcnLFxuICAgIHNldEZvclJlbW92YWw6IG51bGwsXG4gICAgaGFzQW5pbWF0aW9uOiBmYWxzZSxcbiAgICByZW1vdmVkQmVmb3JlUXVlcmllZDogZmFsc2Vcbn07XG52YXIgTlVMTF9SRU1PVkVEX1FVRVJJRURfU1RBVEUgPSB7XG4gICAgbmFtZXNwYWNlSWQ6ICcnLFxuICAgIHNldEZvclJlbW92YWw6IG51bGwsXG4gICAgaGFzQW5pbWF0aW9uOiBmYWxzZSxcbiAgICByZW1vdmVkQmVmb3JlUXVlcmllZDogdHJ1ZVxufTtcbnZhciBSRU1PVkFMX0ZMQUcgPSAnX19uZ19yZW1vdmVkJztcbnZhciBTdGF0ZVZhbHVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdGVWYWx1ZShpbnB1dCkge1xuICAgICAgICB2YXIgaXNPYmogPSBpbnB1dCAmJiBpbnB1dC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaXNPYmogPyBpbnB1dFsndmFsdWUnXSA6IGlucHV0O1xuICAgICAgICB0aGlzLnZhbHVlID0gbm9ybWFsaXplVHJpZ2dlclZhbHVlKHZhbHVlKTtcbiAgICAgICAgaWYgKGlzT2JqKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGNvcHlPYmooaW5wdXQpO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnNbJ3ZhbHVlJ107XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucGFyYW1zID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlVmFsdWUucHJvdG90eXBlLCBcInBhcmFtc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5vcHRpb25zLnBhcmFtcyk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVWYWx1ZS5wcm90b3R5cGUuYWJzb3JiT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld1BhcmFtcyA9IG9wdGlvbnMucGFyYW1zO1xuICAgICAgICBpZiAobmV3UGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRQYXJhbXNfMiA9ICgodGhpcy5vcHRpb25zLnBhcmFtcykpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobmV3UGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFBhcmFtc18yW3Byb3BdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkUGFyYW1zXzJbcHJvcF0gPSBuZXdQYXJhbXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZVZhbHVlO1xufSgpKTtcbnZhciBWT0lEX1ZBTFVFID0gJ3ZvaWQnO1xudmFyIERFRkFVTFRfU1RBVEVfVkFMVUUgPSBuZXcgU3RhdGVWYWx1ZShWT0lEX1ZBTFVFKTtcbnZhciBERUxFVEVEX1NUQVRFX1ZBTFVFID0gbmV3IFN0YXRlVmFsdWUoJ0RFTEVURUQnKTtcbnZhciBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gX2VuZ2luZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UoaWQsIGhvc3RFbGVtZW50LCBfZW5naW5lKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICB0aGlzLl9lbmdpbmUgPSBfZW5naW5lO1xuICAgICAgICB0aGlzLnBsYXllcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5fZWxlbWVudExpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5faG9zdENsYXNzTmFtZSA9ICduZy10bnMtJyArIGlkO1xuICAgICAgICBhZGRDbGFzcyhob3N0RWxlbWVudCwgdGhpcy5faG9zdENsYXNzTmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gcGhhc2VcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSwgcGhhc2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fdHJpZ2dlcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBsaXN0ZW4gb24gdGhlIGFuaW1hdGlvbiB0cmlnZ2VyIGV2ZW50IFxcXCJcIiArIHBoYXNlICsgXCJcXFwiIGJlY2F1c2UgdGhlIGFuaW1hdGlvbiB0cmlnZ2VyIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZG9lc24ndCBleGlzdCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBoYXNlID09IG51bGwgfHwgcGhhc2UubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBsaXN0ZW4gb24gdGhlIGFuaW1hdGlvbiB0cmlnZ2VyIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgYmVjYXVzZSB0aGUgcHJvdmlkZWQgZXZlbnQgaXMgdW5kZWZpbmVkIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVHJpZ2dlckV2ZW50VmFsaWQocGhhc2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvdmlkZWQgYW5pbWF0aW9uIHRyaWdnZXIgZXZlbnQgXFxcIlwiICsgcGhhc2UgKyBcIlxcXCIgZm9yIHRoZSBhbmltYXRpb24gdHJpZ2dlciBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGlzIG5vdCBzdXBwb3J0ZWQhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpc3RlbmVycyA9IGdldE9yU2V0QXNJbk1hcCh0aGlzLl9lbGVtZW50TGlzdGVuZXJzLCBlbGVtZW50LCBbXSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRhdGEgPSB7IG5hbWU6IG5hbWUsIHBoYXNlOiBwaGFzZSwgY2FsbGJhY2s6IGNhbGxiYWNrIH07XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGRhdGEpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2Vyc1dpdGhTdGF0ZXMgPSBnZXRPclNldEFzSW5NYXAodGhpcy5fZW5naW5lLnN0YXRlc0J5RWxlbWVudCwgZWxlbWVudCwge30pO1xuICAgICAgICBpZiAoIXRyaWdnZXJzV2l0aFN0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgTkdfVFJJR0dFUl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgTkdfVFJJR0dFUl9DTEFTU05BTUUgKyAnLScgKyBuYW1lKTtcbiAgICAgICAgICAgIHRyaWdnZXJzV2l0aFN0YXRlc1tuYW1lXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHRoZSBldmVudCBsaXN0ZW5lciBpcyByZW1vdmVkIEFGVEVSIHRoZSBmbHVzaCBoYXMgb2NjdXJyZWQgc3VjaFxuICAgICAgICAgICAgLy8gdGhhdCBsZWF2ZSBhbmltYXRpb25zIGNhbGxiYWNrcyBjYW4gZmlyZSAob3RoZXJ3aXNlIGlmIHRoZSBub2RlXG4gICAgICAgICAgICAvLyBpcyByZW1vdmVkIGluIGJldHdlZW4gdGhlbiB0aGUgbGlzdGVuZXJzIHdvdWxkIGJlIGRlcmVnaXN0ZXJlZClcbiAgICAgICAgICAgIF90aGlzLl9lbmdpbmUuYWZ0ZXJGbHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fdHJpZ2dlcnNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRyaWdnZXJzV2l0aFN0YXRlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChuYW1lLCBhc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJzW25hbWVdKSB7XG4gICAgICAgICAgICAvLyB0aHJvd1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcnNbbmFtZV0gPSBhc3Q7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5fZ2V0VHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXIgPSB0aGlzLl90cmlnZ2Vyc1tuYW1lXTtcbiAgICAgICAgaWYgKCF0cmlnZ2VyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvdmlkZWQgYW5pbWF0aW9uIHRyaWdnZXIgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyaWdnZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHRyaWdnZXJOYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlZmF1bHRUb0ZhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRyaWdnZXJOYW1lLCB2YWx1ZSwgZGVmYXVsdFRvRmFsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGRlZmF1bHRUb0ZhbGxiYWNrID09PSB2b2lkIDApIHsgZGVmYXVsdFRvRmFsbGJhY2sgPSB0cnVlOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXIgPSB0aGlzLl9nZXRUcmlnZ2VyKHRyaWdnZXJOYW1lKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gbmV3IFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIodGhpcy5pZCwgdHJpZ2dlck5hbWUsIGVsZW1lbnQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2Vyc1dpdGhTdGF0ZXMgPSB0aGlzLl9lbmdpbmUuc3RhdGVzQnlFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKCF0cmlnZ2Vyc1dpdGhTdGF0ZXMpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIE5HX1RSSUdHRVJfQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIE5HX1RSSUdHRVJfQ0xBU1NOQU1FICsgJy0nICsgdHJpZ2dlck5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fZW5naW5lLnN0YXRlc0J5RWxlbWVudC5zZXQoZWxlbWVudCwgdHJpZ2dlcnNXaXRoU3RhdGVzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZyb21TdGF0ZSA9IHRyaWdnZXJzV2l0aFN0YXRlc1t0cmlnZ2VyTmFtZV07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvU3RhdGUgPSBuZXcgU3RhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzT2JqID0gdmFsdWUgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJyk7XG4gICAgICAgIGlmICghaXNPYmogJiYgZnJvbVN0YXRlKSB7XG4gICAgICAgICAgICB0b1N0YXRlLmFic29yYk9wdGlvbnMoZnJvbVN0YXRlLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRyaWdnZXJzV2l0aFN0YXRlc1t0cmlnZ2VyTmFtZV0gPSB0b1N0YXRlO1xuICAgICAgICBpZiAoIWZyb21TdGF0ZSkge1xuICAgICAgICAgICAgZnJvbVN0YXRlID0gREVGQVVMVF9TVEFURV9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcm9tU3RhdGUgPT09IERFTEVURURfU1RBVEVfVkFMVUUpIHtcbiAgICAgICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNSZW1vdmFsID0gdG9TdGF0ZS52YWx1ZSA9PT0gVk9JRF9WQUxVRTtcbiAgICAgICAgLy8gbm9ybWFsbHkgdGhpcyBpc24ndCByZWFjaGVkIGJ5IGhlcmUsIGhvd2V2ZXIsIGlmIGFuIG9iamVjdCBleHByZXNzaW9uXG4gICAgICAgIC8vIGlzIHBhc3NlZCBpbiB0aGVuIGl0IG1heSBiZSBhIG5ldyBvYmplY3QgZWFjaCB0aW1lLiBDb21wYXJpbmcgdGhlIHZhbHVlXG4gICAgICAgIC8vIGlzIGltcG9ydGFudCBzaW5jZSB0aGF0IHdpbGwgc3RheSB0aGUgc2FtZSBkZXNwaXRlIHRoZXJlIGJlaW5nIGEgbmV3IG9iamVjdC5cbiAgICAgICAgLy8gVGhlIHJlbW92YWwgYXJjIGhlcmUgaXMgc3BlY2lhbCBjYXNlZCBiZWNhdXNlIHRoZSBzYW1lIGVsZW1lbnQgaXMgdHJpZ2dlcmVkXG4gICAgICAgIC8vIHR3aWNlIGluIHRoZSBldmVudCB0aGF0IGl0IGNvbnRhaW5zIGFuaW1hdGlvbnMgb24gdGhlIG91dGVyL2lubmVyIHBvcnRpb25zXG4gICAgICAgIC8vIG9mIHRoZSBob3N0IGNvbnRhaW5lclxuICAgICAgICBpZiAoIWlzUmVtb3ZhbCAmJiBmcm9tU3RhdGUudmFsdWUgPT09IHRvU3RhdGUudmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBkZXNwaXRlIHRoZSB2YWx1ZSBub3QgY2hhbmdpbmcsIHNvbWUgaW5uZXIgcGFyYW1zXG4gICAgICAgICAgICAvLyBoYXZlIGNoYW5nZWQgd2hpY2ggbWVhbnMgdGhhdCB0aGUgYW5pbWF0aW9uIGZpbmFsIHN0eWxlcyBuZWVkIHRvIGJlIGFwcGxpZWRcbiAgICAgICAgICAgIGlmICghb2JqRXF1YWxzKGZyb21TdGF0ZS5wYXJhbXMsIHRvU3RhdGUucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZyb21TdHlsZXNfMSA9IHRyaWdnZXIubWF0Y2hTdHlsZXMoZnJvbVN0YXRlLnZhbHVlLCBmcm9tU3RhdGUucGFyYW1zLCBlcnJvcnMpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvU3R5bGVzXzEgPSB0cmlnZ2VyLm1hdGNoU3R5bGVzKHRvU3RhdGUudmFsdWUsIHRvU3RhdGUucGFyYW1zLCBlcnJvcnMpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5yZXBvcnRFcnJvcihlcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLmFmdGVyRmx1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJhc2VTdHlsZXMoZWxlbWVudCwgZnJvbVN0eWxlc18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFN0eWxlcyhlbGVtZW50LCB0b1N0eWxlc18xKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnNPbkVsZW1lbnQgPSBnZXRPclNldEFzSW5NYXAodGhpcy5fZW5naW5lLnBsYXllcnNCeUVsZW1lbnQsIGVsZW1lbnQsIFtdKTtcbiAgICAgICAgcGxheWVyc09uRWxlbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcmVtb3ZlIHRoZSBwbGF5ZXIgaWYgaXQgaXMgcXVldWVkIG9uIHRoZSBFWEFDVCBzYW1lIHRyaWdnZXIvbmFtZXNwYWNlXG4gICAgICAgICAgICAvLyB3ZSBvbmx5IGFsc28gZGVhbCB3aXRoIHF1ZXVlZCBwbGF5ZXJzIGhlcmUgYmVjYXVzZSBpZiB0aGUgYW5pbWF0aW9uIGhhc1xuICAgICAgICAgICAgLy8gc3RhcnRlZCB0aGVuIHdlIHdhbnQgdG8ga2VlcCB0aGUgcGxheWVyIGFsaXZlIHVudGlsIHRoZSBmbHVzaCBoYXBwZW5zXG4gICAgICAgICAgICAvLyAod2hpY2ggaXMgd2hlcmUgdGhlIHByZXZpb3VzUGxheWVycyBhcmUgcGFzc2VkIGludG8gdGhlIG5ldyBwYWx5ZXIpXG4gICAgICAgICAgICBpZiAocGxheWVyLm5hbWVzcGFjZUlkID09IF90aGlzLmlkICYmIHBsYXllci50cmlnZ2VyTmFtZSA9PSB0cmlnZ2VyTmFtZSAmJiBwbGF5ZXIucXVldWVkKSB7XG4gICAgICAgICAgICAgICAgcGxheWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zaXRpb24gPSB0cmlnZ2VyLm1hdGNoVHJhbnNpdGlvbihmcm9tU3RhdGUudmFsdWUsIHRvU3RhdGUudmFsdWUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0ZhbGxiYWNrVHJhbnNpdGlvbiA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGlmICghZGVmYXVsdFRvRmFsbGJhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdHJhbnNpdGlvbiA9IHRyaWdnZXIuZmFsbGJhY2tUcmFuc2l0aW9uO1xuICAgICAgICAgICAgaXNGYWxsYmFja1RyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VuZ2luZS50b3RhbFF1ZXVlZFBsYXllcnMrKztcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaCh7IGVsZW1lbnQ6IGVsZW1lbnQsIHRyaWdnZXJOYW1lOiB0cmlnZ2VyTmFtZSwgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiwgZnJvbVN0YXRlOiBmcm9tU3RhdGUsIHRvU3RhdGU6IHRvU3RhdGUsIHBsYXllcjogcGxheWVyLCBpc0ZhbGxiYWNrVHJhbnNpdGlvbjogaXNGYWxsYmFja1RyYW5zaXRpb24gfSk7XG4gICAgICAgIGlmICghaXNGYWxsYmFja1RyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIFFVRVVFRF9DTEFTU05BTUUpO1xuICAgICAgICAgICAgcGxheWVyLm9uU3RhcnQoZnVuY3Rpb24gKCkgeyByZW1vdmVDbGFzcyhlbGVtZW50LCBRVUVVRURfQ0xBU1NOQU1FKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IF90aGlzLnBsYXllcnMuaW5kZXhPZihwbGF5ZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wbGF5ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzID0gX3RoaXMuX2VuZ2luZS5wbGF5ZXJzQnlFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChwbGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXhfMSA9IHBsYXllcnMuaW5kZXhPZihwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleF8xID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVycy5zcGxpY2UoaW5kZXhfMSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgcGxheWVyc09uRWxlbWVudC5wdXNoKHBsYXllcik7XG4gICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLmRlcmVnaXN0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBkZWxldGUgdGhpcy5fdHJpZ2dlcnNbbmFtZV07XG4gICAgICAgIHRoaXMuX2VuZ2luZS5zdGF0ZXNCeUVsZW1lbnQuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGVNYXAsIGVsZW1lbnQpIHsgZGVsZXRlIHN0YXRlTWFwW25hbWVdOyB9KTtcbiAgICAgICAgdGhpcy5fZWxlbWVudExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcnMsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIF90aGlzLl9lbGVtZW50TGlzdGVuZXJzLnNldChlbGVtZW50LCBsaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkubmFtZSAhPSBuYW1lOyB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5jbGVhckVsZW1lbnRDYWNoZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2VuZ2luZS5zdGF0ZXNCeUVsZW1lbnQuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9lbGVtZW50TGlzdGVuZXJzLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudFBsYXllcnMgPSB0aGlzLl9lbmdpbmUucGxheWVyc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50UGxheWVycykge1xuICAgICAgICAgICAgZWxlbWVudFBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5wbGF5ZXJzQnlFbGVtZW50LmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByb290RWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IGFuaW1hdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLl9kZXN0cm95SW5uZXJOb2RlcyA9IGZ1bmN0aW9uIChyb290RWxlbWVudCwgY29udGV4dCwgYW5pbWF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYW5pbWF0ZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGUgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLl9lbmdpbmUuZHJpdmVyLnF1ZXJ5KHJvb3RFbGVtZW50LCBOR19UUklHR0VSX1NFTEVDVE9SLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChlbG0pIHtcbiAgICAgICAgICAgIGlmIChhbmltYXRlICYmIGNvbnRhaW5zQ2xhc3MoZWxtLCBfdGhpcy5faG9zdENsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lck5zID0gX3RoaXMuX2VuZ2luZS5uYW1lc3BhY2VzQnlIb3N0RWxlbWVudC5nZXQoZWxtKTtcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIGEgaG9zdCBlbGVtZW50IHdpdGggYW5pbWF0aW9ucyBvbiB0aGUgc2FtZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyTnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJOcy5yZW1vdmVOb2RlKGVsbSwgY29udGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZU5vZGUoZWxtLCBjb250ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyRWxlbWVudENhY2hlKGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gZG9Ob3RSZWN1cnNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQsIGRvTm90UmVjdXJzZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmdpbmUgPSB0aGlzLl9lbmdpbmU7XG4gICAgICAgIGlmICghZG9Ob3RSZWN1cnNlICYmIGVsZW1lbnQuY2hpbGRFbGVtZW50Q291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lJbm5lck5vZGVzKGVsZW1lbnQsIGNvbnRleHQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXJTdGF0ZXMgPSBlbmdpbmUuc3RhdGVzQnlFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKHRyaWdnZXJTdGF0ZXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnNfMSA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModHJpZ2dlclN0YXRlcykuZm9yRWFjaChmdW5jdGlvbiAodHJpZ2dlck5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNoZWNrIGlzIGhlcmUgaW4gdGhlIGV2ZW50IHRoYXQgYW4gZWxlbWVudCBpcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgLy8gdHdpY2UgKGJvdGggb24gdGhlIGhvc3QgbGV2ZWwgYW5kIHRoZSBjb21wb25lbnQgbGV2ZWwpXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl90cmlnZ2Vyc1t0cmlnZ2VyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gX3RoaXMudHJpZ2dlcihlbGVtZW50LCB0cmlnZ2VyTmFtZSwgVk9JRF9WQUxVRSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXJzXzEucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocGxheWVyc18xLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGVuZ2luZS5tYXJrRWxlbWVudEFzUmVtb3ZlZCh0aGlzLmlkLCBlbGVtZW50LCB0cnVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBvcHRpbWl6ZUdyb3VwUGxheWVyKHBsYXllcnNfMSkub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuZ2luZS5wcm9jZXNzTGVhdmVOb2RlKGVsZW1lbnQpOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluZCB0aGUgcGxheWVyIHRoYXQgaXMgYW5pbWF0aW5nIGFuZCBtYWtlIHN1cmUgdGhhdCB0aGVcbiAgICAgICAgLy8gcmVtb3ZhbCBpcyBkZWxheWVkIHVudGlsIHRoYXQgcGxheWVyIGhhcyBjb21wbGV0ZWRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbnNQb3RlbnRpYWxQYXJlbnRUcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmIChlbmdpbmUudG90YWxBbmltYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50UGxheWVycyA9IGVuZ2luZS5wbGF5ZXJzLmxlbmd0aCA/IGVuZ2luZS5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudC5nZXQoZWxlbWVudCkgOiBbXTtcbiAgICAgICAgICAgIC8vIHdoZW4gdGhpcyBgaWYgc3RhdGVtZW50YCBkb2VzIG5vdCBjb250aW51ZSBmb3J3YXJkIGl0IG1lYW5zIHRoYXRcbiAgICAgICAgICAgIC8vIGEgcHJldmlvdXMgYW5pbWF0aW9uIHF1ZXJ5IGhhcyBzZWxlY3RlZCB0aGUgY3VycmVudCBlbGVtZW50IGFuZFxuICAgICAgICAgICAgLy8gaXMgYW5pbWF0aW5nIGl0LiBJbiB0aGlzIHNpdHVhdGlvbiB3YW50IHRvIGNvbnRpbnVlIGZvd2FyZHMgYW5kXG4gICAgICAgICAgICAvLyBhbGxvdyB0aGUgZWxlbWVudCB0byBiZSBxdWV1ZWQgdXAgZm9yIGFuaW1hdGlvbiBsYXRlci5cbiAgICAgICAgICAgIGlmIChjdXJyZW50UGxheWVycyAmJiBjdXJyZW50UGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb250YWluc1BvdGVudGlhbFBhcmVudFRyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlcnMgPSBlbmdpbmUuc3RhdGVzQnlFbGVtZW50LmdldChwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJpZ2dlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zUG90ZW50aWFsUGFyZW50VHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhdCB0aGlzIHN0YWdlIHdlIGtub3cgdGhhdCB0aGUgZWxlbWVudCB3aWxsIGVpdGhlciBnZXQgcmVtb3ZlZFxuICAgICAgICAvLyBkdXJpbmcgZmx1c2ggb3Igd2lsbCBiZSBwaWNrZWQgdXAgYnkgYSBwYXJlbnQgcXVlcnkuIEVpdGhlciB3YXlcbiAgICAgICAgLy8gd2UgbmVlZCB0byBmaXJlIHRoZSBsaXN0ZW5lcnMgZm9yIHRoaXMgZWxlbWVudCB3aGVuIGl0IERPRVMgZ2V0XG4gICAgICAgIC8vIHJlbW92ZWQgKG9uY2UgdGhlIHF1ZXJ5IHBhcmVudCBhbmltYXRpb24gaXMgZG9uZSBvciBhZnRlciBmbHVzaClcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGlzdGVuZXJzID0gdGhpcy5fZWxlbWVudExpc3RlbmVycy5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0ZWRUcmlnZ2Vyc18xID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlck5hbWUgPSBsaXN0ZW5lci5uYW1lO1xuICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkVHJpZ2dlcnNfMS5oYXModHJpZ2dlck5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmlzaXRlZFRyaWdnZXJzXzEuYWRkKHRyaWdnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyID0gX3RoaXMuX3RyaWdnZXJzW3RyaWdnZXJOYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2l0aW9uID0gdHJpZ2dlci5mYWxsYmFja1RyYW5zaXRpb247XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudFN0YXRlcyA9ICgoZW5naW5lLnN0YXRlc0J5RWxlbWVudC5nZXQoZWxlbWVudCkpKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmcm9tU3RhdGUgPSBlbGVtZW50U3RhdGVzW3RyaWdnZXJOYW1lXSB8fCBERUZBVUxUX1NUQVRFX1ZBTFVFO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvU3RhdGUgPSBuZXcgU3RhdGVWYWx1ZShWT0lEX1ZBTFVFKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBuZXcgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllcihfdGhpcy5pZCwgdHJpZ2dlck5hbWUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9lbmdpbmUudG90YWxRdWV1ZWRQbGF5ZXJzKys7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyTmFtZTogdHJpZ2dlck5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGZyb21TdGF0ZTogZnJvbVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICB0b1N0YXRlOiB0b1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICBwbGF5ZXI6IHBsYXllcixcbiAgICAgICAgICAgICAgICAgICAgaXNGYWxsYmFja1RyYW5zaXRpb246IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdoZXRoZXIgb3Igbm90IGEgcGFyZW50IGhhcyBhbiBhbmltYXRpb24gd2UgbmVlZCB0byBkZWxheSB0aGUgZGVmZXJyYWwgb2YgdGhlIGxlYXZlXG4gICAgICAgIC8vIG9wZXJhdGlvbiB1bnRpbCB3ZSBoYXZlIG1vcmUgaW5mb3JtYXRpb24gKHdoaWNoIHdlIGRvIGFmdGVyIGZsdXNoKCkgaGFzIGJlZW4gY2FsbGVkKVxuICAgICAgICBpZiAoY29udGFpbnNQb3RlbnRpYWxQYXJlbnRUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBlbmdpbmUubWFya0VsZW1lbnRBc1JlbW92ZWQodGhpcy5pZCwgZWxlbWVudCwgZmFsc2UsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgZG8gdGhpcyBhZnRlciB0aGUgZmx1c2ggaGFzIG9jY3VycmVkIHN1Y2hcbiAgICAgICAgICAgIC8vIHRoYXQgdGhlIGNhbGxiYWNrcyBjYW4gYmUgZmlyZWRcbiAgICAgICAgICAgIGVuZ2luZS5hZnRlckZsdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNsZWFyRWxlbWVudENhY2hlKGVsZW1lbnQpOyB9KTtcbiAgICAgICAgICAgIGVuZ2luZS5kZXN0cm95SW5uZXJBbmltYXRpb25zKGVsZW1lbnQpO1xuICAgICAgICAgICAgZW5naW5lLl9vblJlbW92YWxDb21wbGV0ZShlbGVtZW50LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLmluc2VydE5vZGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgcGFyZW50KSB7IGFkZENsYXNzKGVsZW1lbnQsIHRoaXMuX2hvc3RDbGFzc05hbWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWljcm90YXNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLmRyYWluUXVldWVkVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAobWljcm90YXNrSWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIHRoaXMuX3F1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBlbnRyeS5wbGF5ZXI7XG4gICAgICAgICAgICBpZiAocGxheWVyLmRlc3Ryb3llZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gZW50cnkuZWxlbWVudDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpc3RlbmVycyA9IF90aGlzLl9lbGVtZW50TGlzdGVuZXJzLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm5hbWUgPT0gZW50cnkudHJpZ2dlck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VFdmVudCA9IG1ha2VBbmltYXRpb25FdmVudChlbGVtZW50LCBlbnRyeS50cmlnZ2VyTmFtZSwgZW50cnkuZnJvbVN0YXRlLnZhbHVlLCBlbnRyeS50b1N0YXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICgoYmFzZUV2ZW50KSlbJ19kYXRhJ10gPSBtaWNyb3Rhc2tJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Rlbk9uUGxheWVyKGVudHJ5LnBsYXllciwgbGlzdGVuZXIucGhhc2UsIGJhc2VFdmVudCwgbGlzdGVuZXIuY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGxheWVyLm1hcmtlZEZvckRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZW5naW5lLmFmdGVyRmx1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3cgd2UgY2FuIGRlc3Ryb3kgdGhlIGVsZW1lbnQgcHJvcGVybHkgc2luY2UgdGhlIGV2ZW50IGxpc3RlbmVycyBoYXZlXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZW4gYm91bmQgdG8gdGhlIHBsYXllclxuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9ucy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAvLyBpZiBkZXBDb3VudCA9PSAwIHRoZW0gbW92ZSB0byBmcm9udFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGlmIGEgY29udGFpbnMgYiB0aGVuIG1vdmUgYmFja1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZDAgPSBhLnRyYW5zaXRpb24uYXN0LmRlcENvdW50O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZDEgPSBiLnRyYW5zaXRpb24uYXN0LmRlcENvdW50O1xuICAgICAgICAgICAgaWYgKGQwID09IDAgfHwgZDEgPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkMCAtIGQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9lbmdpbmUuZHJpdmVyLmNvbnRhaW5zRWxlbWVudChhLmVsZW1lbnQsIGIuZWxlbWVudCkgPyAxIDogLTE7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgdGhpcy5fZGVzdHJveUlubmVyTm9kZXModGhpcy5ob3N0RWxlbWVudCwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLmVsZW1lbnRDb250YWluc0RhdGEgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluc0RhdGEgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRMaXN0ZW5lcnMuaGFzKGVsZW1lbnQpKVxuICAgICAgICAgICAgY29udGFpbnNEYXRhID0gdHJ1ZTtcbiAgICAgICAgY29udGFpbnNEYXRhID1cbiAgICAgICAgICAgICh0aGlzLl9xdWV1ZS5maW5kKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkuZWxlbWVudCA9PT0gZWxlbWVudDsgfSkgPyB0cnVlIDogZmFsc2UpIHx8IGNvbnRhaW5zRGF0YTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zRGF0YTtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlO1xufSgpKTtcbnZhciBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRyaXZlclxuICAgICAqIEBwYXJhbSB7P30gX25vcm1hbGl6ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lKGRyaXZlciwgX25vcm1hbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5kcml2ZXIgPSBkcml2ZXI7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZXIgPSBfbm9ybWFsaXplcjtcbiAgICAgICAgdGhpcy5wbGF5ZXJzID0gW107XG4gICAgICAgIHRoaXMubmV3SG9zdEVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBsYXllcnNCeUVsZW1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGxheWVyc0J5UXVlcmllZEVsZW1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc3RhdGVzQnlFbGVtZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmRpc2FibGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMudG90YWxBbmltYXRpb25zID0gMDtcbiAgICAgICAgdGhpcy50b3RhbFF1ZXVlZFBsYXllcnMgPSAwO1xuICAgICAgICB0aGlzLl9uYW1lc3BhY2VMb29rdXAgPSB7fTtcbiAgICAgICAgdGhpcy5fbmFtZXNwYWNlTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9mbHVzaEZucyA9IFtdO1xuICAgICAgICB0aGlzLl93aGVuUXVpZXRGbnMgPSBbXTtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VzQnlIb3N0RWxlbWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRFbnRlckVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuY29sbGVjdGVkTGVhdmVFbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLm9uUmVtb3ZhbENvbXBsZXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fb25SZW1vdmFsQ29tcGxldGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkgeyB0aGlzLm9uUmVtb3ZhbENvbXBsZXRlKGVsZW1lbnQsIGNvbnRleHQpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZSwgXCJxdWV1ZWRQbGF5ZXJzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX25hbWVzcGFjZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAobnMpIHtcbiAgICAgICAgICAgICAgICBucy5wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxheWVyLnF1ZXVlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBsYXllcnM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5jcmVhdGVOYW1lc3BhY2UgPSBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5zID0gbmV3IEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UobmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50LCB0aGlzKTtcbiAgICAgICAgaWYgKGhvc3RFbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhbGFuY2VOYW1lc3BhY2VMaXN0KG5zLCBob3N0RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkZWZlciB0aGlzIGxhdGVyIHVudGlsIGZsdXNoIGR1cmluZyB3aGVuIHRoZSBob3N0IGVsZW1lbnQgaGFzXG4gICAgICAgICAgICAvLyBiZWVuIGluc2VydGVkIHNvIHRoYXQgd2Uga25vdyBleGFjdGx5IHdoZXJlIHRvIHBsYWNlIGl0IGluXG4gICAgICAgICAgICAvLyB0aGUgbmFtZXNwYWNlIGxpc3RcbiAgICAgICAgICAgIHRoaXMubmV3SG9zdEVsZW1lbnRzLnNldChob3N0RWxlbWVudCwgbnMpO1xuICAgICAgICAgICAgLy8gZ2l2ZW4gdGhhdCB0aGlzIGhvc3QgZWxlbWVudCBpcyBhcGFydCBvZiB0aGUgYW5pbWF0aW9uIGNvZGUsIGl0XG4gICAgICAgICAgICAvLyBtYXkgb3IgbWF5IG5vdCBiZSBpbnNlcnRlZCBieSBhIHBhcmVudCBub2RlIHRoYXQgaXMgYW4gb2YgYW5cbiAgICAgICAgICAgIC8vIGFuaW1hdGlvbiByZW5kZXJlciB0eXBlLiBJZiB0aGlzIGhhcHBlbnMgdGhlbiB3ZSBjYW4gc3RpbGwgaGF2ZVxuICAgICAgICAgICAgLy8gYWNjZXNzIHRvIHRoaXMgaXRlbSB3aGVuIHdlIHF1ZXJ5IGZvciA6ZW50ZXIgbm9kZXMuIElmIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIC8vIGlzIGEgcmVuZGVyZXIgdGhlbiB0aGUgc2V0IGRhdGEtc3RydWN0dXJlIHdpbGwgbm9ybWFsaXplIHRoZSBlbnRyeVxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0RW50ZXJFbGVtZW50KGhvc3RFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZXNwYWNlTG9va3VwW25hbWVzcGFjZUlkXSA9IG5zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuc1xuICAgICAqIEBwYXJhbSB7P30gaG9zdEVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9iYWxhbmNlTmFtZXNwYWNlTGlzdCA9IGZ1bmN0aW9uIChucywgaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGltaXQgPSB0aGlzLl9uYW1lc3BhY2VMaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsaW1pdCA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gbGltaXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV4dE5hbWVzcGFjZSA9IHRoaXMuX25hbWVzcGFjZUxpc3RbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJpdmVyLmNvbnRhaW5zRWxlbWVudChuZXh0TmFtZXNwYWNlLmhvc3RFbGVtZW50LCBob3N0RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmFtZXNwYWNlTGlzdC5zcGxpY2UoaSArIDEsIDAsIG5zKTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmFtZXNwYWNlTGlzdC5zcGxpY2UoMCwgMCwgbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbmFtZXNwYWNlTGlzdC5wdXNoKG5zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWVzcGFjZXNCeUhvc3RFbGVtZW50LnNldChob3N0RWxlbWVudCwgbnMpO1xuICAgICAgICByZXR1cm4gbnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5zID0gdGhpcy5fbmFtZXNwYWNlTG9va3VwW25hbWVzcGFjZUlkXTtcbiAgICAgICAgaWYgKCFucykge1xuICAgICAgICAgICAgbnMgPSB0aGlzLmNyZWF0ZU5hbWVzcGFjZShuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBucztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHRyaWdnZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnJlZ2lzdGVyVHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgbmFtZSwgdHJpZ2dlcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IHRoaXMuX25hbWVzcGFjZUxvb2t1cFtuYW1lc3BhY2VJZF07XG4gICAgICAgIGlmIChucyAmJiBucy5yZWdpc3RlcihuYW1lLCB0cmlnZ2VyKSkge1xuICAgICAgICAgICAgdGhpcy50b3RhbEFuaW1hdGlvbnMrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIW5hbWVzcGFjZUlkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IHRoaXMuX2ZldGNoTmFtZXNwYWNlKG5hbWVzcGFjZUlkKTtcbiAgICAgICAgdGhpcy5hZnRlckZsdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWVzcGFjZXNCeUhvc3RFbGVtZW50LmRlbGV0ZShucy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMuX25hbWVzcGFjZUxvb2t1cFtuYW1lc3BhY2VJZF07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IF90aGlzLl9uYW1lc3BhY2VMaXN0LmluZGV4T2YobnMpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbmFtZXNwYWNlTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZnRlckZsdXNoQW5pbWF0aW9uc0RvbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gbnMuZGVzdHJveShjb250ZXh0KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fZmV0Y2hOYW1lc3BhY2UgPSBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHRoaXMuX25hbWVzcGFjZUxvb2t1cFtpZF07IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnROb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl9mZXRjaE5hbWVzcGFjZShuYW1lc3BhY2VJZCkudHJpZ2dlcihlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IGluc2VydEJlZm9yZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuaW5zZXJ0Tm9kZSA9IGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgZWxlbWVudCwgcGFyZW50LCBpbnNlcnRCZWZvcmUpIHtcbiAgICAgICAgaWYgKCFpc0VsZW1lbnROb2RlKGVsZW1lbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHdoZW4gYW4gZWxlbWVudCBpcyByZW1vdmVkIGFuZCByZWluc2VydGVkIChtb3ZlIG9wZXJhdGlvbilcbiAgICAgICAgLy8gd2hlbiB0aGlzIG9jY3VycyB3ZSBkbyBub3Qgd2FudCB0byB1c2UgdGhlIGVsZW1lbnQgZm9yIGRlbGV0aW9uIGxhdGVyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRldGFpbHMgPSAoZWxlbWVudFtSRU1PVkFMX0ZMQUddKTtcbiAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy5zZXRGb3JSZW1vdmFsKSB7XG4gICAgICAgICAgICBkZXRhaWxzLnNldEZvclJlbW92YWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbiB0aGUgZXZlbnQgdGhhdCB0aGUgbmFtZXNwYWNlSWQgaXMgYmxhbmsgdGhlbiB0aGUgY2FsbGVyXG4gICAgICAgIC8vIGNvZGUgZG9lcyBub3QgY29udGFpbiBhbnkgYW5pbWF0aW9uIGNvZGUgaW4gaXQsIGJ1dCBpdCBpc1xuICAgICAgICAvLyBqdXN0IGJlaW5nIGNhbGxlZCBzbyB0aGF0IHRoZSBub2RlIGlzIG1hcmtlZCBhcyBiZWluZyBpbnNlcnRlZFxuICAgICAgICBpZiAobmFtZXNwYWNlSWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZldGNoTmFtZXNwYWNlKG5hbWVzcGFjZUlkKS5pbnNlcnROb2RlKGVsZW1lbnQsIHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSAqZGlyZWN0aXZlcyBhbmQgaG9zdCBlbGVtZW50cyBhcmUgaW5zZXJ0ZWQgYmVmb3JlXG4gICAgICAgIGlmIChpbnNlcnRCZWZvcmUpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdEVudGVyRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5jb2xsZWN0RW50ZXJFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHsgdGhpcy5jb2xsZWN0ZWRFbnRlckVsZW1lbnRzLnB1c2goZWxlbWVudCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUubWFya0VsZW1lbnRBc0Rpc2FibGVkID0gZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkTm9kZXMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlZE5vZGVzLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBESVNBQkxFRF9DTEFTU05BTUUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlzYWJsZWROb2Rlcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZWROb2Rlcy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBESVNBQkxFRF9DTEFTU05BTUUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gZG9Ob3RSZWN1cnNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBjb250ZXh0LCBkb05vdFJlY3Vyc2UpIHtcbiAgICAgICAgaWYgKCFpc0VsZW1lbnROb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl9vblJlbW92YWxDb21wbGV0ZShlbGVtZW50LCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IG5hbWVzcGFjZUlkID8gdGhpcy5fZmV0Y2hOYW1lc3BhY2UobmFtZXNwYWNlSWQpIDogbnVsbDtcbiAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgICBucy5yZW1vdmVOb2RlKGVsZW1lbnQsIGNvbnRleHQsIGRvTm90UmVjdXJzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtFbGVtZW50QXNSZW1vdmVkKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBmYWxzZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBoYXNBbmltYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5tYXJrRWxlbWVudEFzUmVtb3ZlZCA9IGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgZWxlbWVudCwgaGFzQW5pbWF0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29sbGVjdGVkTGVhdmVFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50W1JFTU9WQUxfRkxBR10gPSB7XG4gICAgICAgICAgICBuYW1lc3BhY2VJZDogbmFtZXNwYWNlSWQsXG4gICAgICAgICAgICBzZXRGb3JSZW1vdmFsOiBjb250ZXh0LCBoYXNBbmltYXRpb246IGhhc0FuaW1hdGlvbixcbiAgICAgICAgICAgIHJlbW92ZWRCZWZvcmVRdWVyaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gcGhhc2VcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIG5hbWUsIHBoYXNlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoaXNFbGVtZW50Tm9kZShlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoTmFtZXNwYWNlKG5hbWVzcGFjZUlkKS5saXN0ZW4oZWxlbWVudCwgbmFtZSwgcGhhc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbnRyeVxuICAgICAqIEBwYXJhbSB7P30gc3ViVGltZWxpbmVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fYnVpbGRJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIChlbnRyeSwgc3ViVGltZWxpbmVzKSB7XG4gICAgICAgIHJldHVybiBlbnRyeS50cmFuc2l0aW9uLmJ1aWxkKHRoaXMuZHJpdmVyLCBlbnRyeS5lbGVtZW50LCBlbnRyeS5mcm9tU3RhdGUudmFsdWUsIGVudHJ5LnRvU3RhdGUudmFsdWUsIGVudHJ5LmZyb21TdGF0ZS5vcHRpb25zLCBlbnRyeS50b1N0YXRlLm9wdGlvbnMsIHN1YlRpbWVsaW5lcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5lckVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmRlc3Ryb3lJbm5lckFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoY29udGFpbmVyRWxlbWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50cyA9IHRoaXMuZHJpdmVyLnF1ZXJ5KGNvbnRhaW5lckVsZW1lbnQsIE5HX1RSSUdHRVJfU0VMRUNUT1IsIHRydWUpO1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzID0gX3RoaXMucGxheWVyc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAocGxheWVycykge1xuICAgICAgICAgICAgICAgIHBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3Igd2hlbiBhbiBlbGVtZW50IGlzIHNldCBmb3IgZGVzdHJ1Y3Rpb24sIGJ1dCBoYXNuJ3Qgc3RhcnRlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBzaXR1YXRpb24gd2Ugd2FudCB0byBkZWxheSB0aGUgZGVzdHJ1Y3Rpb24gdW50aWwgdGhlIGZsdXNoIG9jY3Vyc1xuICAgICAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IGFueSBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gdGhlIHBsYXllciBhcmUgdHJpZ2dlcmVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGxheWVyLnF1ZXVlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVyLm1hcmtlZEZvckRlc3Ryb3kgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGVNYXAgPSBfdGhpcy5zdGF0ZXNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHN0YXRlTWFwKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3RhdGVNYXApLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXJOYW1lKSB7IHJldHVybiBzdGF0ZU1hcFt0cmlnZ2VyTmFtZV0gPSBERUxFVEVEX1NUQVRFX1ZBTFVFOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnBsYXllcnNCeVF1ZXJpZWRFbGVtZW50LnNpemUgPT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLmRyaXZlci5xdWVyeShjb250YWluZXJFbGVtZW50LCBOR19BTklNQVRJTkdfU0VMRUNUT1IsIHRydWUpO1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVycyA9IF90aGlzLnBsYXllcnNCeVF1ZXJpZWRFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocGxheWVycykge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmZpbmlzaCgpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS53aGVuUmVuZGVyaW5nRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW1pemVHcm91cFBsYXllcihfdGhpcy5wbGF5ZXJzKS5vbkRvbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnByb2Nlc3NMZWF2ZU5vZGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzID0gKGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSk7XG4gICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMuc2V0Rm9yUmVtb3ZhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHByZXZlbnQgaXQgZnJvbSByZW1vdmluZyBpdCB0d2ljZVxuICAgICAgICAgICAgZWxlbWVudFtSRU1PVkFMX0ZMQUddID0gTlVMTF9SRU1PVkFMX1NUQVRFO1xuICAgICAgICAgICAgaWYgKGRldGFpbHMubmFtZXNwYWNlSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lJbm5lckFuaW1hdGlvbnMoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbnMgPSB0aGlzLl9mZXRjaE5hbWVzcGFjZShkZXRhaWxzLm5hbWVzcGFjZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbnMuY2xlYXJFbGVtZW50Q2FjaGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb25SZW1vdmFsQ29tcGxldGUoZWxlbWVudCwgZGV0YWlscy5zZXRGb3JSZW1vdmFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kcml2ZXIubWF0Y2hlc0VsZW1lbnQoZWxlbWVudCwgRElTQUJMRURfU0VMRUNUT1IpKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtFbGVtZW50QXNEaXNhYmxlZChlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcml2ZXIucXVlcnkoZWxlbWVudCwgRElTQUJMRURfU0VMRUNUT1IsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIF90aGlzLm1hcmtFbGVtZW50QXNEaXNhYmxlZChlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gbWljcm90YXNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKG1pY3JvdGFza0lkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChtaWNyb3Rhc2tJZCA9PT0gdm9pZCAwKSB7IG1pY3JvdGFza0lkID0gLTE7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVycyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5uZXdIb3N0RWxlbWVudHMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5uZXdIb3N0RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobnMsIGVsZW1lbnQpIHsgcmV0dXJuIF90aGlzLl9iYWxhbmNlTmFtZXNwYWNlTGlzdChucywgZWxlbWVudCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5uZXdIb3N0RWxlbWVudHMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbmFtZXNwYWNlTGlzdC5sZW5ndGggJiZcbiAgICAgICAgICAgICh0aGlzLnRvdGFsUXVldWVkUGxheWVycyB8fCB0aGlzLmNvbGxlY3RlZExlYXZlRWxlbWVudHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xlYW51cEZucyA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwbGF5ZXJzID0gdGhpcy5fZmx1c2hBbmltYXRpb25zKGNsZWFudXBGbnMsIG1pY3JvdGFza0lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBjbGVhbnVwRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXBGbnNbaV0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IHRoaXMuY29sbGVjdGVkTGVhdmVFbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NMZWF2ZU5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3RhbFF1ZXVlZFBsYXllcnMgPSAwO1xuICAgICAgICB0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2ZsdXNoRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgdGhpcy5fZmx1c2hGbnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuX3doZW5RdWlldEZucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHdlIG1vdmUgdGhlc2Ugb3ZlciB0byBhIHZhcmlhYmxlIHNvIHRoYXRcbiAgICAgICAgICAgIC8vIGlmIGFueSBuZXcgY2FsbGJhY2tzIGFyZSByZWdpc3RlcmVkIGluIGFub3RoZXJcbiAgICAgICAgICAgIC8vIGZsdXNoIHRoZXkgZG8gbm90IHBvcHVsYXRlIHRoZSBleGlzdGluZyBzZXRcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1aWV0Rm5zXzEgPSB0aGlzLl93aGVuUXVpZXRGbnM7XG4gICAgICAgICAgICB0aGlzLl93aGVuUXVpZXRGbnMgPSBbXTtcbiAgICAgICAgICAgIGlmIChwbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9wdGltaXplR3JvdXBQbGF5ZXIocGxheWVycykub25Eb25lKGZ1bmN0aW9uICgpIHsgcXVpZXRGbnNfMS5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVpZXRGbnNfMS5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHByb2Nlc3MgYW5pbWF0aW9ucyBkdWUgdG8gdGhlIGZvbGxvd2luZyBmYWlsZWQgdHJpZ2dlciB0cmFuc2l0aW9uc1xcbiBcIiArIGVycm9ycy5qb2luKFwiXFxuXCIpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2xlYW51cEZuc1xuICAgICAqIEBwYXJhbSB7P30gbWljcm90YXNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9mbHVzaEFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoY2xlYW51cEZucywgbWljcm90YXNrSWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ViVGltZWxpbmVzID0gbmV3IEVsZW1lbnRJbnN0cnVjdGlvbk1hcCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBza2lwcGVkUGxheWVycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBza2lwcGVkUGxheWVyc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVldWVkSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZWRFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUHJlU3R5bGVFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUG9zdFN0eWxlRWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpc2FibGVkRWxlbWVudHNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBkaXNhYmxlZEVsZW1lbnRzU2V0LmFkZChub2RlKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzVGhhdEFyZURpc2FibGVkID0gX3RoaXMuZHJpdmVyLnF1ZXJ5KG5vZGUsIFFVRVVFRF9TRUxFQ1RPUiwgdHJ1ZSk7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgbm9kZXNUaGF0QXJlRGlzYWJsZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlZEVsZW1lbnRzU2V0LmFkZChub2Rlc1RoYXRBcmVEaXNhYmxlZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBib2R5Tm9kZSA9IGdldEJvZHlOb2RlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbEVudGVyTm9kZXMgPSB0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHMubGVuZ3RoID9cbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGVkRW50ZXJFbGVtZW50cy5maWx0ZXIoY3JlYXRlSXNSb290RmlsdGVyRm4odGhpcy5jb2xsZWN0ZWRFbnRlckVsZW1lbnRzKSkgOlxuICAgICAgICAgICAgW107XG4gICAgICAgIC8vIHRoaXMgbXVzdCBvY2N1ciBiZWZvcmUgdGhlIGluc3RydWN0aW9ucyBhcmUgYnVpbHQgYmVsb3cgc3VjaCB0aGF0XG4gICAgICAgIC8vIHRoZSA6ZW50ZXIgcXVlcmllcyBtYXRjaCB0aGUgZWxlbWVudHMgKHNpbmNlIHRoZSB0aW1lbGluZSBxdWVyaWVzXG4gICAgICAgIC8vIGFyZSBmaXJlZCBkdXJpbmcgaW5zdHJ1Y3Rpb24gYnVpbGRpbmcpLlxuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYWxsRW50ZXJOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWRkQ2xhc3MoYWxsRW50ZXJOb2Rlc1tpXSwgRU5URVJfQ0xBU1NOQU1FKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxMZWF2ZU5vZGVzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlYXZlTm9kZXNXaXRob3V0QW5pbWF0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0YWlscyA9IChlbGVtZW50W1JFTU9WQUxfRkxBR10pO1xuICAgICAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy5zZXRGb3JSZW1vdmFsKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgTEVBVkVfQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICAgICBhbGxMZWF2ZU5vZGVzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXRhaWxzLmhhc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBsZWF2ZU5vZGVzV2l0aG91dEFuaW1hdGlvbnMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2xlYW51cEZucy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFsbEVudGVyTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgRU5URVJfQ0xBU1NOQU1FKTsgfSk7XG4gICAgICAgICAgICBhbGxMZWF2ZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBMRUFWRV9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgIF90aGlzLnByb2Nlc3NMZWF2ZU5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFBsYXllcnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb25lb3VzVHJhbnNpdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gdGhpcy5fbmFtZXNwYWNlTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbnMgPSB0aGlzLl9uYW1lc3BhY2VMaXN0W2ldO1xuICAgICAgICAgICAgbnMuZHJhaW5RdWV1ZWRUcmFuc2l0aW9ucyhtaWNyb3Rhc2tJZCkuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBlbnRyeS5wbGF5ZXI7XG4gICAgICAgICAgICAgICAgYWxsUGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IGVudHJ5LmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKCFib2R5Tm9kZSB8fCAhX3RoaXMuZHJpdmVyLmNvbnRhaW5zRWxlbWVudChib2R5Tm9kZSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnN0cnVjdGlvbiA9ICgoX3RoaXMuX2J1aWxkSW5zdHJ1Y3Rpb24oZW50cnksIHN1YlRpbWVsaW5lcykpKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uZXJyb3JzICYmIGluc3RydWN0aW9uLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb25lb3VzVHJhbnNpdGlvbnMucHVzaChpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgYSB1bm1hdGNoZWQgdHJhbnNpdGlvbiBpcyBxdWV1ZWQgdG8gZ28gdGhlbiBpdCBTSE9VTEQgTk9UIHJlbmRlclxuICAgICAgICAgICAgICAgIC8vIGFuIGFuaW1hdGlvbiBhbmQgY2FuY2VsIHRoZSBwcmV2aW91c2x5IHJ1bm5pbmcgYW5pbWF0aW9ucy5cbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNGYWxsYmFja1RyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLm9uU3RhcnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJhc2VTdHlsZXMoZWxlbWVudCwgaW5zdHJ1Y3Rpb24uZnJvbVN0eWxlcyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIub25EZXN0cm95KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldFN0eWxlcyhlbGVtZW50LCBpbnN0cnVjdGlvbi50b1N0eWxlcyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICBza2lwcGVkUGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IGlmIGEgcGFyZW50IGFuaW1hdGlvbiB1c2VzIHRoaXMgYW5pbWF0aW9uIGFzIGEgc3ViIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGl0IHdpbGwgaW5zdHJ1Y3QgdGhlIHRpbWVsaW5lIGJ1aWxkZXIgdG8gbm90IGFkZCBhIHBsYXllciBkZWxheSwgYnV0XG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBzdHJldGNoIHRoZSBmaXJzdCBrZXlmcmFtZSBnYXAgdXAgdW50aWwgdGhlIGFuaW1hdGlvbiBzdGFydHMuIFRoZVxuICAgICAgICAgICAgICAgIC8vIHJlYXNvbiB0aGlzIGlzIGltcG9ydGFudCBpcyB0byBwcmV2ZW50IGV4dHJhIGluaXRpYWxpemF0aW9uIHN0eWxlcyBmcm9tIGJlaW5nXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgYnkgdGhlIHVzZXIgaW4gdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi50aW1lbGluZXMuZm9yRWFjaChmdW5jdGlvbiAodGwpIHsgcmV0dXJuIHRsLnN0cmV0Y2hTdGFydGluZ0tleWZyYW1lID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICAgICAgc3ViVGltZWxpbmVzLmFwcGVuZChlbGVtZW50LCBpbnN0cnVjdGlvbi50aW1lbGluZXMpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR1cGxlID0geyBpbnN0cnVjdGlvbjogaW5zdHJ1Y3Rpb24sIHBsYXllcjogcGxheWVyLCBlbGVtZW50OiBlbGVtZW50IH07XG4gICAgICAgICAgICAgICAgcXVldWVkSW5zdHJ1Y3Rpb25zLnB1c2godHVwbGUpO1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLnF1ZXJpZWRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBnZXRPclNldEFzSW5NYXAocXVlcmllZEVsZW1lbnRzLCBlbGVtZW50LCBbXSkucHVzaChwbGF5ZXIpOyB9KTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5wcmVTdHlsZVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHN0cmluZ01hcCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wcyA9IE9iamVjdC5rZXlzKHN0cmluZ01hcCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNldFZhbF8xID0gKChhbGxQcmVTdHlsZUVsZW1lbnRzLmdldChlbGVtZW50KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXRWYWxfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFByZVN0eWxlRWxlbWVudHMuc2V0KGVsZW1lbnQsIHNldFZhbF8xID0gbmV3IFNldCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHNldFZhbF8xLmFkZChwcm9wKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5wb3N0U3R5bGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJpbmdNYXAsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcHMgPSBPYmplY3Qua2V5cyhzdHJpbmdNYXApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZXRWYWwgPSAoKGFsbFBvc3RTdHlsZUVsZW1lbnRzLmdldChlbGVtZW50KSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldFZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsUG9zdFN0eWxlRWxlbWVudHMuc2V0KGVsZW1lbnQsIHNldFZhbCA9IG5ldyBTZXQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gc2V0VmFsLmFkZChwcm9wKTsgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb25lb3VzVHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnNfMSA9IFtdO1xuICAgICAgICAgICAgZXJyb25lb3VzVHJhbnNpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgICAgICBlcnJvcnNfMS5wdXNoKFwiQFwiICsgaW5zdHJ1Y3Rpb24udHJpZ2dlck5hbWUgKyBcIiBoYXMgZmFpbGVkIGR1ZSB0bzpcXG5cIik7IC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAoKGluc3RydWN0aW9uLmVycm9ycykpLmZvckVhY2goZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBlcnJvcnNfMS5wdXNoKFwiLSBcIiArIGVycm9yICsgXCJcXG5cIik7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbGxQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKGVycm9yc18xKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGVzZSBjYW4gb25seSBiZSBkZXRlY3RlZCBoZXJlIHNpbmNlIHdlIGhhdmUgYSBtYXAgb2YgYWxsIHRoZSBlbGVtZW50c1xuICAgICAgICAvLyB0aGF0IGhhdmUgYW5pbWF0aW9ucyBhdHRhY2hlZCB0byB0aGVtLi4uXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudGVyTm9kZXNXaXRob3V0QW5pbWF0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYWxsRW50ZXJOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IGFsbEVudGVyTm9kZXNbaV07XG4gICAgICAgICAgICBpZiAoIXN1YlRpbWVsaW5lcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBlbnRlck5vZGVzV2l0aG91dEFuaW1hdGlvbnMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxQcmV2aW91c1BsYXllcnNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvcnRlZFBhcmVudEVsZW1lbnRzID0gW107XG4gICAgICAgIHF1ZXVlZEluc3RydWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IGVudHJ5LmVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoc3ViVGltZWxpbmVzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHNvcnRlZFBhcmVudEVsZW1lbnRzLnVuc2hpZnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2JlZm9yZUFuaW1hdGlvbkJ1aWxkKGVudHJ5LnBsYXllci5uYW1lc3BhY2VJZCwgZW50cnkuaW5zdHJ1Y3Rpb24sIGFsbFByZXZpb3VzUGxheWVyc01hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBza2lwcGVkUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSBwbGF5ZXIuZWxlbWVudDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzUGxheWVycyA9IF90aGlzLl9nZXRQcmV2aW91c1BsYXllcnMoZWxlbWVudCwgZmFsc2UsIHBsYXllci5uYW1lc3BhY2VJZCwgcGxheWVyLnRyaWdnZXJOYW1lLCBudWxsKTtcbiAgICAgICAgICAgIHByZXZpb3VzUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcmV2UGxheWVyKSB7XG4gICAgICAgICAgICAgICAgZ2V0T3JTZXRBc0luTWFwKGFsbFByZXZpb3VzUGxheWVyc01hcCwgZWxlbWVudCwgW10pLnB1c2gocHJldlBsYXllcik7XG4gICAgICAgICAgICAgICAgcHJldlBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgZm9yIG5vZGVzIHRoYXQgd2lsbCBiZSByZW1vdmVkIChlaXRoZXIgYnkpXG4gICAgICAgIC8vIGhhdmluZyB0aGVpciBvd24gbGVhdmUgYW5pbWF0aW9ucyBvciBieSBiZWluZyBxdWVyaWVkIGluIGEgY29udGFpbmVyXG4gICAgICAgIC8vIHRoYXQgd2lsbCBiZSByZW1vdmVkIG9uY2UgYSBwYXJlbnQgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLiBUaGUgaWRlYVxuICAgICAgICAvLyBoZXJlIGlzIHRoYXQgKiBzdHlsZXMgbXVzdCBiZSBpZGVudGljYWwgdG8gISBzdHlsZXMgYmVjYXVzZSBvZlxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoKiBpcyBhbHNvIGZpbGxlZCBpbiBieSBkZWZhdWx0IGluIG1hbnkgcGxhY2VzKS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlICogc3R5bGVzIHdpbGwgcmV0dXJuIGFuIGVtcHR5IHZhbHVlIG9yIGF1dG8gc2luY2UgdGhlIGVsZW1lbnRcbiAgICAgICAgLy8gdGhhdCBpcyBiZWluZyBnZXRDb21wdXRlZFN0eWxlJ2Qgd2lsbCBub3QgYmUgdmlzaWJsZSAoc2luY2UgKiA9IGRlc3RpbmF0aW9uKVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXBsYWNlTm9kZXMgPSBhbGxMZWF2ZU5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VQb3N0U3R5bGVzQXNQcmUobm9kZSwgYWxsUHJlU3R5bGVFbGVtZW50cywgYWxsUG9zdFN0eWxlRWxlbWVudHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUE9TVCBTVEFHRTogZmlsbCB0aGUgKiBzdHlsZXNcbiAgICAgICAgdmFyIF9hID0gY2xvYWtBbmRDb21wdXRlU3R5bGVzKHRoaXMuZHJpdmVyLCBsZWF2ZU5vZGVzV2l0aG91dEFuaW1hdGlvbnMsIGFsbFBvc3RTdHlsZUVsZW1lbnRzLCBfYW5ndWxhcl9hbmltYXRpb25zLkFVVE9fU1RZTEUpLCBwb3N0U3R5bGVzTWFwID0gX2FbMF0sIGFsbExlYXZlUXVlcmllZE5vZGVzID0gX2FbMV07XG4gICAgICAgIGFsbExlYXZlUXVlcmllZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlUG9zdFN0eWxlc0FzUHJlKG5vZGUsIGFsbFByZVN0eWxlRWxlbWVudHMsIGFsbFBvc3RTdHlsZUVsZW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUFJFIFNUQUdFOiBmaWxsIHRoZSAhIHN0eWxlc1xuICAgICAgICB2YXIgcHJlU3R5bGVzTWFwID0gKGFsbFByZVN0eWxlRWxlbWVudHMuc2l6ZSA/XG4gICAgICAgICAgICBjbG9ha0FuZENvbXB1dGVTdHlsZXModGhpcy5kcml2ZXIsIGVudGVyTm9kZXNXaXRob3V0QW5pbWF0aW9ucywgYWxsUHJlU3R5bGVFbGVtZW50cywgX2FuZ3VsYXJfYW5pbWF0aW9ucy7JtVBSRV9TVFlMRSkgOlxuICAgICAgICAgICAgW25ldyBNYXAoKV0pWzBdO1xuICAgICAgICByZXBsYWNlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdCA9IHBvc3RTdHlsZXNNYXAuZ2V0KG5vZGUpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlID0gcHJlU3R5bGVzTWFwLmdldChub2RlKTtcbiAgICAgICAgICAgIHBvc3RTdHlsZXNNYXAuc2V0KG5vZGUsIC8qKiBAdHlwZSB7P30gKi8gKE9iamVjdC5hc3NpZ24oe30sIHBvc3QsIHByZSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJvb3RQbGF5ZXJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1YlBsYXllcnMgPSBbXTtcbiAgICAgICAgcXVldWVkSW5zdHJ1Y3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVudHJ5LmVsZW1lbnQsIHBsYXllciA9IGVudHJ5LnBsYXllciwgaW5zdHJ1Y3Rpb24gPSBlbnRyeS5pbnN0cnVjdGlvbjtcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBpdCB3YXMgbmV2ZXIgY29uc3VtZWQgYnkgYSBwYXJlbnQgYW5pbWF0aW9uIHdoaWNoXG4gICAgICAgICAgICAvLyBtZWFucyB0aGF0IGl0IGlzIGluZGVwZW5kZW50IGFuZCB0aGVyZWZvcmUgc2hvdWxkIGJlIHNldCBmb3IgYW5pbWF0aW9uXG4gICAgICAgICAgICBpZiAoc3ViVGltZWxpbmVzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGlmIChkaXNhYmxlZEVsZW1lbnRzU2V0LmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBza2lwcGVkUGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJQbGF5ZXIgPSBfdGhpcy5fYnVpbGRBbmltYXRpb24ocGxheWVyLm5hbWVzcGFjZUlkLCBpbnN0cnVjdGlvbiwgYWxsUHJldmlvdXNQbGF5ZXJzTWFwLCBza2lwcGVkUGxheWVyc01hcCwgcHJlU3R5bGVzTWFwLCBwb3N0U3R5bGVzTWFwKTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuc2V0UmVhbFBsYXllcihpbm5lclBsYXllcik7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50SGFzUHJpb3JpdHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBzb3J0ZWRQYXJlbnRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnQgPSBzb3J0ZWRQYXJlbnRFbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZHJpdmVyLmNvbnRhaW5zRWxlbWVudChwYXJlbnQsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRIYXNQcmlvcml0eSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRIYXNQcmlvcml0eSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRQbGF5ZXJzID0gX3RoaXMucGxheWVyc0J5RWxlbWVudC5nZXQocGFyZW50SGFzUHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50UGxheWVycyAmJiBwYXJlbnRQbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVyLnBhcmVudFBsYXllciA9IG9wdGltaXplR3JvdXBQbGF5ZXIocGFyZW50UGxheWVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZFBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdFBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVyYXNlU3R5bGVzKGVsZW1lbnQsIGluc3RydWN0aW9uLmZyb21TdHlsZXMpO1xuICAgICAgICAgICAgICAgIHBsYXllci5vbkRlc3Ryb3koZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0U3R5bGVzKGVsZW1lbnQsIGluc3RydWN0aW9uLnRvU3R5bGVzKTsgfSk7XG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgc3RpbGwgbWlnaHQgYmUgYSBhbmNlc3RvciBwbGF5ZXIgYW5pbWF0aW5nIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHRoZXJlZm9yZSB3ZSB3aWxsIHN0aWxsIGFkZCBpdCBhcyBhIHN1YiBwbGF5ZXJcbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIGl0cyBhbmltYXRpb24gbWF5IGJlIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgc3ViUGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkRWxlbWVudHNTZXQuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWRQbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBmaW5kIGFsbCBvZiB0aGUgc3ViIHBsYXllcnMnIGNvcnJlc3BvbmRpbmcgaW5uZXIgYW5pbWF0aW9uIHBsYXllclxuICAgICAgICBzdWJQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgLy8gZXZlbiBpZiBhbnkgcGxheWVycyBhcmUgbm90IGZvdW5kIGZvciBhIHN1YiBhbmltYXRpb24gdGhlbiBpdFxuICAgICAgICAgICAgLy8gd2lsbCBzdGlsbCBjb21wbGV0ZSBpdHNlbGYgYWZ0ZXIgdGhlIG5leHQgdGljayBzaW5jZSBpdCdzIE5vb3BcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnNGb3JFbGVtZW50ID0gc2tpcHBlZFBsYXllcnNNYXAuZ2V0KHBsYXllci5lbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChwbGF5ZXJzRm9yRWxlbWVudCAmJiBwbGF5ZXJzRm9yRWxlbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclBsYXllciA9IG9wdGltaXplR3JvdXBQbGF5ZXIocGxheWVyc0ZvckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHBsYXllci5zZXRSZWFsUGxheWVyKGlubmVyUGxheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoZSByZWFzb24gd2h5IHdlIGRvbid0IGFjdHVhbGx5IHBsYXkgdGhlIGFuaW1hdGlvbiBpc1xuICAgICAgICAvLyBiZWNhdXNlIGFsbCB0aGF0IGEgc2tpcHBlZCBwbGF5ZXIgaXMgZGVzaWduZWQgdG8gZG8gaXMgdG9cbiAgICAgICAgLy8gZmlyZSB0aGUgc3RhcnQvZG9uZSB0cmFuc2l0aW9uIGNhbGxiYWNrIGV2ZW50c1xuICAgICAgICBza2lwcGVkUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIGlmIChwbGF5ZXIucGFyZW50UGxheWVyKSB7XG4gICAgICAgICAgICAgICAgcGxheWVyLnBhcmVudFBsYXllci5vbkRlc3Ryb3koZnVuY3Rpb24gKCkgeyByZXR1cm4gcGxheWVyLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gcnVuIHRocm91Z2ggYWxsIG9mIHRoZSBxdWV1ZWQgcmVtb3ZhbHMgYW5kIHNlZSBpZiB0aGV5XG4gICAgICAgIC8vIHdlcmUgcGlja2VkIHVwIGJ5IGEgcXVlcnkuIElmIG5vdCB0aGVuIHBlcmZvcm0gdGhlIHJlbW92YWxcbiAgICAgICAgLy8gb3BlcmF0aW9uIHJpZ2h0IGF3YXkgdW5sZXNzIGEgcGFyZW50IGFuaW1hdGlvbiBpcyBvbmdvaW5nLlxuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYWxsTGVhdmVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IGFsbExlYXZlTm9kZXNbaV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzID0gKGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBMRUFWRV9DTEFTU05BTUUpO1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGUgZWxlbWVudCBoYXMgYSByZW1vdmFsIGFuaW1hdGlvbiB0aGF0IGlzIGJlaW5nXG4gICAgICAgICAgICAvLyB0YWtlbiBjYXJlIG9mIGFuZCB0aGVyZWZvcmUgdGhlIGlubmVyIGVsZW1lbnRzIHdpbGwgaGFuZyBhcm91bmRcbiAgICAgICAgICAgIC8vIHVudGlsIHRoYXQgYW5pbWF0aW9uIGlzIG92ZXIgKG9yIHRoZSBwYXJlbnQgcXVlcmllZCBhbmltYXRpb24pXG4gICAgICAgICAgICBpZiAoZGV0YWlscyAmJiBkZXRhaWxzLmhhc0FuaW1hdGlvbilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBbXTtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZWxlbWVudCBpcyBxdWVyaWVkIG9yIGlmIGl0IGNvbnRhaW5zIHF1ZXJpZWQgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIHRoZW4gd2Ugd2FudCBmb3IgdGhlIGVsZW1lbnQgbm90IHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgcGFnZVxuICAgICAgICAgICAgLy8gdW50aWwgdGhlIHF1ZXJpZWQgYW5pbWF0aW9ucyBoYXZlIGZpbmlzaGVkXG4gICAgICAgICAgICBpZiAocXVlcmllZEVsZW1lbnRzLnNpemUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyaWVkUGxheWVyUmVzdWx0cyA9IHF1ZXJpZWRFbGVtZW50cy5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJpZWRQbGF5ZXJSZXN1bHRzICYmIHF1ZXJpZWRQbGF5ZXJSZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXJzLnB1c2guYXBwbHkocGxheWVycywgcXVlcmllZFBsYXllclJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyaWVkSW5uZXJFbGVtZW50cyA9IHRoaXMuZHJpdmVyLnF1ZXJ5KGVsZW1lbnQsIE5HX0FOSU1BVElOR19TRUxFQ1RPUiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBqID0gMDsgaiA8IHF1ZXJpZWRJbm5lckVsZW1lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZWRQbGF5ZXJzID0gcXVlcmllZEVsZW1lbnRzLmdldChxdWVyaWVkSW5uZXJFbGVtZW50c1tqXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWVyaWVkUGxheWVycyAmJiBxdWVyaWVkUGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcnMucHVzaC5hcHBseShwbGF5ZXJzLCBxdWVyaWVkUGxheWVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhY3RpdmVQbGF5ZXJzID0gcGxheWVycy5maWx0ZXIoZnVuY3Rpb24gKHApIHsgcmV0dXJuICFwLmRlc3Ryb3llZDsgfSk7XG4gICAgICAgICAgICBpZiAoYWN0aXZlUGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVOb2Rlc0FmdGVyQW5pbWF0aW9uRG9uZSh0aGlzLCBlbGVtZW50LCBhY3RpdmVQbGF5ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xlYXZlTm9kZShlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIGlzIHJlcXVpcmVkIHNvIHRoZSBjbGVhbnVwIG1ldGhvZCBkb2Vzbid0IHJlbW92ZSB0aGVtXG4gICAgICAgIGFsbExlYXZlTm9kZXMubGVuZ3RoID0gMDtcbiAgICAgICAgcm9vdFBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICBfdGhpcy5wbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgIHBsYXllci5vbkRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBfdGhpcy5wbGF5ZXJzLmluZGV4T2YocGxheWVyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5wbGF5ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBsYXllci5wbGF5KCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcm9vdFBsYXllcnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5lbGVtZW50Q29udGFpbnNEYXRhID0gZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5zRGF0YSA9IGZhbHNlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzID0gKGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSk7XG4gICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMuc2V0Rm9yUmVtb3ZhbClcbiAgICAgICAgICAgIGNvbnRhaW5zRGF0YSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnBsYXllcnNCeUVsZW1lbnQuaGFzKGVsZW1lbnQpKVxuICAgICAgICAgICAgY29udGFpbnNEYXRhID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucGxheWVyc0J5UXVlcmllZEVsZW1lbnQuaGFzKGVsZW1lbnQpKVxuICAgICAgICAgICAgY29udGFpbnNEYXRhID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVzQnlFbGVtZW50LmhhcyhlbGVtZW50KSlcbiAgICAgICAgICAgIGNvbnRhaW5zRGF0YSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9mZXRjaE5hbWVzcGFjZShuYW1lc3BhY2VJZCkuZWxlbWVudENvbnRhaW5zRGF0YShlbGVtZW50KSB8fCBjb250YWluc0RhdGE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5hZnRlckZsdXNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHRoaXMuX2ZsdXNoRm5zLnB1c2goY2FsbGJhY2spOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmFmdGVyRmx1c2hBbmltYXRpb25zRG9uZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykgeyB0aGlzLl93aGVuUXVpZXRGbnMucHVzaChjYWxsYmFjayk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBpc1F1ZXJpZWRFbGVtZW50XG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez89fSB0cmlnZ2VyTmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IHRvU3RhdGVWYWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuX2dldFByZXZpb3VzUGxheWVycyA9IGZ1bmN0aW9uIChlbGVtZW50LCBpc1F1ZXJpZWRFbGVtZW50LCBuYW1lc3BhY2VJZCwgdHJpZ2dlck5hbWUsIHRvU3RhdGVWYWx1ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzID0gW107XG4gICAgICAgIGlmIChpc1F1ZXJpZWRFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyaWVkRWxlbWVudFBsYXllcnMgPSB0aGlzLnBsYXllcnNCeVF1ZXJpZWRFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChxdWVyaWVkRWxlbWVudFBsYXllcnMpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXJzID0gcXVlcmllZEVsZW1lbnRQbGF5ZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudFBsYXllcnMgPSB0aGlzLnBsYXllcnNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRQbGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNSZW1vdmFsQW5pbWF0aW9uXzEgPSAhdG9TdGF0ZVZhbHVlIHx8IHRvU3RhdGVWYWx1ZSA9PSBWT0lEX1ZBTFVFO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxheWVyLnF1ZXVlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1JlbW92YWxBbmltYXRpb25fMSAmJiBwbGF5ZXIudHJpZ2dlck5hbWUgIT0gdHJpZ2dlck5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lc3BhY2VJZCB8fCB0cmlnZ2VyTmFtZSkge1xuICAgICAgICAgICAgcGxheWVycyA9IHBsYXllcnMuZmlsdGVyKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNwYWNlSWQgJiYgbmFtZXNwYWNlSWQgIT0gcGxheWVyLm5hbWVzcGFjZUlkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJOYW1lICYmIHRyaWdnZXJOYW1lICE9IHBsYXllci50cmlnZ2VyTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsYXllcnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvblxuICAgICAqIEBwYXJhbSB7P30gYWxsUHJldmlvdXNQbGF5ZXJzTWFwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fYmVmb3JlQW5pbWF0aW9uQnVpbGQgPSBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGluc3RydWN0aW9uLCBhbGxQcmV2aW91c1BsYXllcnNNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlck5hbWUgPSBpbnN0cnVjdGlvbi50cmlnZ2VyTmFtZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcm9vdEVsZW1lbnQgPSBpbnN0cnVjdGlvbi5lbGVtZW50O1xuICAgICAgICAvLyB3aGVuIGEgcmVtb3ZhbCBhbmltYXRpb24gb2NjdXJzLCBBTEwgcHJldmlvdXMgcGxheWVycyBhcmUgY29sbGVjdGVkXG4gICAgICAgIC8vIGFuZCBkZXN0cm95ZWQgKGV2ZW4gaWYgdGhleSBhcmUgb3V0c2lkZSBvZiB0aGUgY3VycmVudCBuYW1lc3BhY2UpXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhcmdldE5hbWVTcGFjZUlkID0gaW5zdHJ1Y3Rpb24uaXNSZW1vdmFsVHJhbnNpdGlvbiA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZUlkO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YXJnZXRUcmlnZ2VyTmFtZSA9IGluc3RydWN0aW9uLmlzUmVtb3ZhbFRyYW5zaXRpb24gPyB1bmRlZmluZWQgOiB0cmlnZ2VyTmFtZTtcbiAgICAgICAgaW5zdHJ1Y3Rpb24udGltZWxpbmVzLm1hcChmdW5jdGlvbiAodGltZWxpbmVJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IHRpbWVsaW5lSW5zdHJ1Y3Rpb24uZWxlbWVudDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzUXVlcmllZEVsZW1lbnQgPSBlbGVtZW50ICE9PSByb290RWxlbWVudDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBnZXRPclNldEFzSW5NYXAoYWxsUHJldmlvdXNQbGF5ZXJzTWFwLCBlbGVtZW50LCBbXSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2aW91c1BsYXllcnMgPSBfdGhpcy5fZ2V0UHJldmlvdXNQbGF5ZXJzKGVsZW1lbnQsIGlzUXVlcmllZEVsZW1lbnQsIHRhcmdldE5hbWVTcGFjZUlkLCB0YXJnZXRUcmlnZ2VyTmFtZSwgaW5zdHJ1Y3Rpb24udG9TdGF0ZSk7XG4gICAgICAgICAgICBwcmV2aW91c1BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVhbFBsYXllciA9IChwbGF5ZXIuZ2V0UmVhbFBsYXllcigpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVhbFBsYXllci5iZWZvcmVEZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWxQbGF5ZXIuYmVmb3JlRGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGlzIG5lZWRzIHRvIGJlIGRvbmUgc28gdGhhdCB0aGUgUFJFL1BPU1Qgc3R5bGVzIGNhbiBiZVxuICAgICAgICAvLyBjb21wdXRlZCBwcm9wZXJseSB3aXRob3V0IGludGVyZmVyaW5nIHdpdGggdGhlIHByZXZpb3VzIGFuaW1hdGlvblxuICAgICAgICBlcmFzZVN0eWxlcyhyb290RWxlbWVudCwgaW5zdHJ1Y3Rpb24uZnJvbVN0eWxlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvblxuICAgICAqIEBwYXJhbSB7P30gYWxsUHJldmlvdXNQbGF5ZXJzTWFwXG4gICAgICogQHBhcmFtIHs/fSBza2lwcGVkUGxheWVyc01hcFxuICAgICAqIEBwYXJhbSB7P30gcHJlU3R5bGVzTWFwXG4gICAgICogQHBhcmFtIHs/fSBwb3N0U3R5bGVzTWFwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fYnVpbGRBbmltYXRpb24gPSBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGluc3RydWN0aW9uLCBhbGxQcmV2aW91c1BsYXllcnNNYXAsIHNraXBwZWRQbGF5ZXJzTWFwLCBwcmVTdHlsZXNNYXAsIHBvc3RTdHlsZXNNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlck5hbWUgPSBpbnN0cnVjdGlvbi50cmlnZ2VyTmFtZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcm9vdEVsZW1lbnQgPSBpbnN0cnVjdGlvbi5lbGVtZW50O1xuICAgICAgICAvLyB3ZSBmaXJzdCBydW4gdGhpcyBzbyB0aGF0IHRoZSBwcmV2aW91cyBhbmltYXRpb24gcGxheWVyXG4gICAgICAgIC8vIGRhdGEgY2FuIGJlIHBhc3NlZCBpbnRvIHRoZSBzdWNjZXNzaXZlIGFuaW1hdGlvbiBwbGF5ZXJzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFF1ZXJpZWRQbGF5ZXJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbENvbnN1bWVkRWxlbWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFN1YkVsZW1lbnRzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxOZXdQbGF5ZXJzID0gaW5zdHJ1Y3Rpb24udGltZWxpbmVzLm1hcChmdW5jdGlvbiAodGltZWxpbmVJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IHRpbWVsaW5lSW5zdHJ1Y3Rpb24uZWxlbWVudDtcbiAgICAgICAgICAgIGFsbENvbnN1bWVkRWxlbWVudHMuYWRkKGVsZW1lbnQpO1xuICAgICAgICAgICAgLy8gRklYTUUgKG1hdHNrbyk6IG1ha2Ugc3VyZSB0by1iZS1yZW1vdmVkIGFuaW1hdGlvbnMgYXJlIHJlbW92ZWQgcHJvcGVybHlcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRldGFpbHMgPSBlbGVtZW50W1JFTU9WQUxfRkxBR107XG4gICAgICAgICAgICBpZiAoZGV0YWlscyAmJiBkZXRhaWxzLnJlbW92ZWRCZWZvcmVRdWVyaWVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfYW5pbWF0aW9ucy5Ob29wQW5pbWF0aW9uUGxheWVyKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1F1ZXJpZWRFbGVtZW50ID0gZWxlbWVudCAhPT0gcm9vdEVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2aW91c1BsYXllcnMgPSBmbGF0dGVuR3JvdXBQbGF5ZXJzKChhbGxQcmV2aW91c1BsYXllcnNNYXAuZ2V0KGVsZW1lbnQpIHx8IEVNUFRZX1BMQVlFUl9BUlJBWSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmdldFJlYWxQbGF5ZXIoKTsgfSkpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBgZWxlbWVudGAgaXMgbm90IGFwYXJ0IG9mIHRoZSBBbmltYXRpb25QbGF5ZXIgZGVmaW5pdGlvbiwgYnV0XG4gICAgICAgICAgICAgICAgLy8gTW9jay9XZWJBbmltYXRpb25zXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBlbGVtZW50IHdpdGhpbiB0aGVpciBpbXBsZW1lbnRhdGlvbi4gVGhpcyB3aWxsIGJlIGFkZGVkIGluIEFuZ3VsYXI1IHRvXG4gICAgICAgICAgICAgICAgLy8gQW5pbWF0aW9uUGxheWVyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHAgPSAocCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBwLmVsZW1lbnQgPyBwcC5lbGVtZW50ID09PSBlbGVtZW50IDogZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVN0eWxlcyA9IHByZVN0eWxlc01hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3N0U3R5bGVzID0gcG9zdFN0eWxlc01hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlmcmFtZXMgPSBub3JtYWxpemVLZXlmcmFtZXMoX3RoaXMuZHJpdmVyLCBfdGhpcy5fbm9ybWFsaXplciwgZWxlbWVudCwgdGltZWxpbmVJbnN0cnVjdGlvbi5rZXlmcmFtZXMsIHByZVN0eWxlcywgcG9zdFN0eWxlcyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBfdGhpcy5fYnVpbGRQbGF5ZXIodGltZWxpbmVJbnN0cnVjdGlvbiwga2V5ZnJhbWVzLCBwcmV2aW91c1BsYXllcnMpO1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHRoaXMgcGFydGljdWxhciBwbGF5ZXIgYmVsb25ncyB0byBhIHN1YiB0cmlnZ2VyLiBJdCBpc1xuICAgICAgICAgICAgLy8gaW1wb3J0YW50IHRoYXQgd2UgbWF0Y2ggdGhpcyBwbGF5ZXIgdXAgd2l0aCB0aGUgY29ycmVzcG9uZGluZyAoQHRyaWdnZXIubGlzdGVuZXIpXG4gICAgICAgICAgICBpZiAodGltZWxpbmVJbnN0cnVjdGlvbi5zdWJUaW1lbGluZSAmJiBza2lwcGVkUGxheWVyc01hcCkge1xuICAgICAgICAgICAgICAgIGFsbFN1YkVsZW1lbnRzLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1F1ZXJpZWRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd3JhcHBlZFBsYXllciA9IG5ldyBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyKG5hbWVzcGFjZUlkLCB0cmlnZ2VyTmFtZSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgd3JhcHBlZFBsYXllci5zZXRSZWFsUGxheWVyKHBsYXllcik7XG4gICAgICAgICAgICAgICAgYWxsUXVlcmllZFBsYXllcnMucHVzaCh3cmFwcGVkUGxheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgICAgIH0pO1xuICAgICAgICBhbGxRdWVyaWVkUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIGdldE9yU2V0QXNJbk1hcChfdGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudCwgcGxheWVyLmVsZW1lbnQsIFtdKS5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICBwbGF5ZXIub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlbGV0ZU9yVW5zZXRJbk1hcChfdGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudCwgcGxheWVyLmVsZW1lbnQsIHBsYXllcik7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYWxsQ29uc3VtZWRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBhZGRDbGFzcyhlbGVtZW50LCBOR19BTklNQVRJTkdfQ0xBU1NOQU1FKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IG9wdGltaXplR3JvdXBQbGF5ZXIoYWxsTmV3UGxheWVycyk7XG4gICAgICAgIHBsYXllci5vbkRlc3Ryb3koZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWxsQ29uc3VtZWRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiByZW1vdmVDbGFzcyhlbGVtZW50LCBOR19BTklNQVRJTkdfQ0xBU1NOQU1FKTsgfSk7XG4gICAgICAgICAgICBzZXRTdHlsZXMocm9vdEVsZW1lbnQsIGluc3RydWN0aW9uLnRvU3R5bGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMgYmFzaWNhbGx5IG1ha2VzIGFsbCBvZiB0aGUgY2FsbGJhY2tzIGZvciBzdWIgZWxlbWVudCBhbmltYXRpb25zXG4gICAgICAgIC8vIGJlIGRlcGVuZGVudCBvbiB0aGUgdXBwZXIgcGxheWVycyBmb3Igd2hlbiB0aGV5IGZpbmlzaFxuICAgICAgICBhbGxTdWJFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IGdldE9yU2V0QXNJbk1hcChza2lwcGVkUGxheWVyc01hcCwgZWxlbWVudCwgW10pLnB1c2gocGxheWVyKTsgfSk7XG4gICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAgICAgKiBAcGFyYW0gez99IHByZXZpb3VzUGxheWVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuX2J1aWxkUGxheWVyID0gZnVuY3Rpb24gKGluc3RydWN0aW9uLCBrZXlmcmFtZXMsIHByZXZpb3VzUGxheWVycykge1xuICAgICAgICBpZiAoa2V5ZnJhbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyaXZlci5hbmltYXRlKGluc3RydWN0aW9uLmVsZW1lbnQsIGtleWZyYW1lcywgaW5zdHJ1Y3Rpb24uZHVyYXRpb24sIGluc3RydWN0aW9uLmRlbGF5LCBpbnN0cnVjdGlvbi5lYXNpbmcsIHByZXZpb3VzUGxheWVycyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciB3aGVuIGFuIGVtcHR5IHRyYW5zaXRpb258ZGVmaW5pdGlvbiBpcyBwcm92aWRlZFxuICAgICAgICAvLyAuLi4gdGhlcmUgaXMgbm8gcG9pbnQgaW4gcmVuZGVyaW5nIGFuIGVtcHR5IGFuaW1hdGlvblxuICAgICAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2FuaW1hdGlvbnMuTm9vcEFuaW1hdGlvblBsYXllcigpO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmU7XG59KCkpO1xudmFyIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IHRyaWdnZXJOYW1lXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllcihuYW1lc3BhY2VJZCwgdHJpZ2dlck5hbWUsIGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VJZCA9IG5hbWVzcGFjZUlkO1xuICAgICAgICB0aGlzLnRyaWdnZXJOYW1lID0gdHJpZ2dlck5hbWU7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3BsYXllciA9IG5ldyBfYW5ndWxhcl9hbmltYXRpb25zLk5vb3BBbmltYXRpb25QbGF5ZXIoKTtcbiAgICAgICAgdGhpcy5fY29udGFpbnNSZWFsUGxheWVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3F1ZXVlZENhbGxiYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXJrZWRGb3JEZXN0cm95ID0gZmFsc2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZSwgXCJxdWV1ZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29udGFpbnNSZWFsUGxheWVyID09IGZhbHNlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUsIFwiZGVzdHJveWVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rlc3Ryb3llZDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwbGF5ZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnNldFJlYWxQbGF5ZXIgPSBmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9jb250YWluc1JlYWxQbGF5ZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3BsYXllciA9IHBsYXllcjtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fcXVldWVkQ2FsbGJhY2tzKS5mb3JFYWNoKGZ1bmN0aW9uIChwaGFzZSkge1xuICAgICAgICAgICAgX3RoaXMuX3F1ZXVlZENhbGxiYWNrc1twaGFzZV0uZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIGxpc3Rlbk9uUGxheWVyKHBsYXllciwgcGhhc2UsIHVuZGVmaW5lZCwgY2FsbGJhY2spOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3F1ZXVlZENhbGxiYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLl9jb250YWluc1JlYWxQbGF5ZXIgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5nZXRSZWFsUGxheWVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxheWVyOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLl9xdWV1ZUV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGdldE9yU2V0QXNJbk1hcCh0aGlzLl9xdWV1ZWRDYWxsYmFja3MsIG5hbWUsIFtdKS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uRG9uZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlRXZlbnQoJ2RvbmUnLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGxheWVyLm9uRG9uZShmbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZCkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWVFdmVudCgnc3RhcnQnLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGxheWVyLm9uU3RhcnQoZm4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZCkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWVFdmVudCgnZGVzdHJveScsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wbGF5ZXIub25EZXN0cm95KGZuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVyLmluaXQoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmhhc1N0YXJ0ZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnF1ZXVlZCA/IGZhbHNlIDogdGhpcy5fcGxheWVyLmhhc1N0YXJ0ZWQoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7ICF0aGlzLnF1ZXVlZCAmJiB0aGlzLl9wbGF5ZXIucGxheSgpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7ICF0aGlzLnF1ZXVlZCAmJiB0aGlzLl9wbGF5ZXIucGF1c2UoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbiAoKSB7ICF0aGlzLnF1ZXVlZCAmJiB0aGlzLl9wbGF5ZXIucmVzdGFydCgpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXIuZmluaXNoKCk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wbGF5ZXIuZGVzdHJveSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHsgIXRoaXMucXVldWVkICYmIHRoaXMuX3BsYXllci5yZXNldCgpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAocCkge1xuICAgICAgICBpZiAoIXRoaXMucXVldWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIuc2V0UG9zaXRpb24ocCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnF1ZXVlZCA/IDAgOiB0aGlzLl9wbGF5ZXIuZ2V0UG9zaXRpb24oKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUsIFwidG90YWxUaW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BsYXllci50b3RhbFRpbWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtYXBcbiAqIEBwYXJhbSB7P30ga2V5XG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkZWxldGVPclVuc2V0SW5NYXAobWFwLCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VycmVudFZhbHVlcztcbiAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGN1cnJlbnRWYWx1ZXMgPSBtYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IGN1cnJlbnRWYWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBtYXAuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGN1cnJlbnRWYWx1ZXMgPSBtYXBba2V5XTtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gY3VycmVudFZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXBba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudFZhbHVlcztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplVHJpZ2dlclZhbHVlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPyAnMScgOiAnMCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlLnRvU3RyaW5nKCkgOiBudWxsO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBub2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0VsZW1lbnROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlWydub2RlVHlwZSddID09PSAxO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGV2ZW50TmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNUcmlnZ2VyRXZlbnRWYWxpZChldmVudE5hbWUpIHtcbiAgICByZXR1cm4gZXZlbnROYW1lID09ICdzdGFydCcgfHwgZXZlbnROYW1lID09ICdkb25lJztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez89fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY2xvYWtFbGVtZW50KGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkVmFsdWUgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogJ25vbmUnO1xuICAgIHJldHVybiBvbGRWYWx1ZTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBkcml2ZXJcbiAqIEBwYXJhbSB7P30gZWxlbWVudHNcbiAqIEBwYXJhbSB7P30gZWxlbWVudFByb3BzTWFwXG4gKiBAcGFyYW0gez99IGRlZmF1bHRTdHlsZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY2xvYWtBbmRDb21wdXRlU3R5bGVzKGRyaXZlciwgZWxlbWVudHMsIGVsZW1lbnRQcm9wc01hcCwgZGVmYXVsdFN0eWxlKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvYWtWYWxzID0gZWxlbWVudHMubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBjbG9ha0VsZW1lbnQoZWxlbWVudCk7IH0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlc01hcCA9IG5ldyBNYXAoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmYWlsZWRFbGVtZW50cyA9IFtdO1xuICAgIGVsZW1lbnRQcm9wc01hcC5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcywgZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSB7fTtcbiAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBzdHlsZXNbcHJvcF0gPSBkcml2ZXIuY29tcHV0ZVN0eWxlKGVsZW1lbnQsIHByb3AsIGRlZmF1bHRTdHlsZSk7XG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBlYXN5IHdheSB0byBkZXRlY3QgdGhpcyBiZWNhdXNlIGEgc3ViIGVsZW1lbnQgY291bGQgYmUgcmVtb3ZlZFxuICAgICAgICAgICAgLy8gYnkgYSBwYXJlbnQgYW5pbWF0aW9uIGVsZW1lbnQgYmVpbmcgZGV0YWNoZWQuXG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFtSRU1PVkFMX0ZMQUddID0gTlVMTF9SRU1PVkVEX1FVRVJJRURfU1RBVEU7XG4gICAgICAgICAgICAgICAgZmFpbGVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhbHVlc01hcC5zZXQoZWxlbWVudCwgc3R5bGVzKTtcbiAgICB9KTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpKSB7IHJldHVybiBjbG9ha0VsZW1lbnQoZWxlbWVudCwgY2xvYWtWYWxzW2ldKTsgfSk7XG4gICAgcmV0dXJuIFt2YWx1ZXNNYXAsIGZhaWxlZEVsZW1lbnRzXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBub2Rlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSXNSb290RmlsdGVyRm4obm9kZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlU2V0ID0gbmV3IFNldChub2Rlcyk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga25vd25Sb290Q29udGFpbmVyID0gbmV3IFNldCgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzUm9vdDtcbiAgICBpc1Jvb3QgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG5vZGVTZXQuaGFzKG5vZGUucGFyZW50Tm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChrbm93blJvb3RDb250YWluZXIuaGFzKG5vZGUucGFyZW50Tm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGlzUm9vdChub2RlLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBrbm93blJvb3RDb250YWluZXIuYWRkKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIGlzUm9vdDtcbn1cbnZhciBDTEFTU0VTX0NBQ0hFX0tFWSA9ICckJGNsYXNzZXMnO1xuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7P30gY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb250YWluc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzZXMgPSBlbGVtZW50W0NMQVNTRVNfQ0FDSEVfS0VZXTtcbiAgICAgICAgcmV0dXJuIGNsYXNzZXMgJiYgY2xhc3Nlc1tjbGFzc05hbWVdO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez99IGNsYXNzTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NlcyA9IGVsZW1lbnRbQ0xBU1NFU19DQUNIRV9LRVldO1xuICAgICAgICBpZiAoIWNsYXNzZXMpIHtcbiAgICAgICAgICAgIGNsYXNzZXMgPSBlbGVtZW50W0NMQVNTRVNfQ0FDSEVfS0VZXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzZXNbY2xhc3NOYW1lXSA9IHRydWU7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7P30gY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc2VzID0gZWxlbWVudFtDTEFTU0VTX0NBQ0hFX0tFWV07XG4gICAgICAgIGlmIChjbGFzc2VzKSB7XG4gICAgICAgICAgICBkZWxldGUgY2xhc3Nlc1tjbGFzc05hbWVdO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRCb2R5Tm9kZSgpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbmdpbmVcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBwbGF5ZXJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZW1vdmVOb2Rlc0FmdGVyQW5pbWF0aW9uRG9uZShlbmdpbmUsIGVsZW1lbnQsIHBsYXllcnMpIHtcbiAgICBvcHRpbWl6ZUdyb3VwUGxheWVyKHBsYXllcnMpLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbmdpbmUucHJvY2Vzc0xlYXZlTm9kZShlbGVtZW50KTsgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcGxheWVyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkdyb3VwUGxheWVycyhwbGF5ZXJzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmluYWxQbGF5ZXJzID0gW107XG4gICAgX2ZsYXR0ZW5Hcm91cFBsYXllcnNSZWN1cihwbGF5ZXJzLCBmaW5hbFBsYXllcnMpO1xuICAgIHJldHVybiBmaW5hbFBsYXllcnM7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcGxheWVyc1xuICogQHBhcmFtIHs/fSBmaW5hbFBsYXllcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9mbGF0dGVuR3JvdXBQbGF5ZXJzUmVjdXIocGxheWVycywgZmluYWxQbGF5ZXJzKSB7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gcGxheWVyc1tpXTtcbiAgICAgICAgaWYgKHBsYXllciBpbnN0YW5jZW9mIF9hbmd1bGFyX2FuaW1hdGlvbnMuybVBbmltYXRpb25Hcm91cFBsYXllcikge1xuICAgICAgICAgICAgX2ZsYXR0ZW5Hcm91cFBsYXllcnNSZWN1cihwbGF5ZXIucGxheWVycywgZmluYWxQbGF5ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbmFsUGxheWVycy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKHBsYXllcikpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IGFcbiAqIEBwYXJhbSB7P30gYlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gb2JqRXF1YWxzKGEsIGIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrMSA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGsyID0gT2JqZWN0LmtleXMoYik7XG4gICAgaWYgKGsxLmxlbmd0aCAhPSBrMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgazEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcCA9IGsxW2ldO1xuICAgICAgICBpZiAoIWIuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgYVtwcm9wXSAhPT0gYltwcm9wXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBhbGxQcmVTdHlsZUVsZW1lbnRzXG4gKiBAcGFyYW0gez99IGFsbFBvc3RTdHlsZUVsZW1lbnRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZXBsYWNlUG9zdFN0eWxlc0FzUHJlKGVsZW1lbnQsIGFsbFByZVN0eWxlRWxlbWVudHMsIGFsbFBvc3RTdHlsZUVsZW1lbnRzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdEVudHJ5ID0gYWxsUG9zdFN0eWxlRWxlbWVudHMuZ2V0KGVsZW1lbnQpO1xuICAgIGlmICghcG9zdEVudHJ5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlRW50cnkgPSBhbGxQcmVTdHlsZUVsZW1lbnRzLmdldChlbGVtZW50KTtcbiAgICBpZiAocHJlRW50cnkpIHtcbiAgICAgICAgcG9zdEVudHJ5LmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuICgocHJlRW50cnkpKS5hZGQoZGF0YSk7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWxsUHJlU3R5bGVFbGVtZW50cy5zZXQoZWxlbWVudCwgcG9zdEVudHJ5KTtcbiAgICB9XG4gICAgYWxsUG9zdFN0eWxlRWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEFuaW1hdGlvbkVuZ2luZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkcml2ZXJcbiAgICAgKiBAcGFyYW0gez99IG5vcm1hbGl6ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBbmltYXRpb25FbmdpbmUoZHJpdmVyLCBub3JtYWxpemVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLm9uUmVtb3ZhbENvbXBsZXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZSA9IG5ldyBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lKGRyaXZlciwgbm9ybWFsaXplcik7XG4gICAgICAgIHRoaXMuX3RpbWVsaW5lRW5naW5lID0gbmV3IFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lKGRyaXZlciwgbm9ybWFsaXplcik7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUub25SZW1vdmFsQ29tcGxldGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkgeyByZXR1cm4gX3RoaXMub25SZW1vdmFsQ29tcGxldGUoZWxlbWVudCwgY29udGV4dCk7IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50SWRcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUucmVnaXN0ZXJUcmlnZ2VyID0gZnVuY3Rpb24gKGNvbXBvbmVudElkLCBuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQsIG5hbWUsIG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhY2hlS2V5ID0gY29tcG9uZW50SWQgKyAnLScgKyBuYW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyID0gdGhpcy5fdHJpZ2dlckNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgaWYgKCF0cmlnZ2VyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IChidWlsZEFuaW1hdGlvbkFzdCgvKiogQHR5cGUgez99ICovIChtZXRhZGF0YSksIGVycm9ycykpO1xuICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYW5pbWF0aW9uIHRyaWdnZXIgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBoYXMgZmFpbGVkIHRvIGJ1aWxkIGR1ZSB0byB0aGUgZm9sbG93aW5nIGVycm9yczpcXG4gLSBcIiArIGVycm9ycy5qb2luKFwiXFxuIC0gXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXIgPSBidWlsZFRyaWdnZXIobmFtZSwgYXN0KTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJDYWNoZVtjYWNoZUtleV0gPSB0cmlnZ2VyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUucmVnaXN0ZXJUcmlnZ2VyKG5hbWVzcGFjZUlkLCBuYW1lLCB0cmlnZ2VyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCkge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLnJlZ2lzdGVyKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5kZXN0cm95KG5hbWVzcGFjZUlkLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEBwYXJhbSB7P30gaW5zZXJ0QmVmb3JlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLm9uSW5zZXJ0ID0gZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBwYXJlbnQsIGluc2VydEJlZm9yZSkge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLmluc2VydE5vZGUobmFtZXNwYWNlSWQsIGVsZW1lbnQsIHBhcmVudCwgaW5zZXJ0QmVmb3JlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5yZW1vdmVOb2RlKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZGlzYWJsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5kaXNhYmxlQW5pbWF0aW9ucyA9IGZ1bmN0aW9uIChlbGVtZW50LCBkaXNhYmxlKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUubWFya0VsZW1lbnRBc0Rpc2FibGVkKGVsZW1lbnQsIGRpc2FibGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICBpZiAocHJvcGVydHkuY2hhckF0KDApID09ICdAJykge1xuICAgICAgICAgICAgdmFyIF9hID0gcGFyc2VUaW1lbGluZUNvbW1hbmQocHJvcGVydHkpLCBpZCA9IF9hWzBdLCBhY3Rpb24gPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSAodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVFbmdpbmUuY29tbWFuZChpZCwgZWxlbWVudCwgYWN0aW9uLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUudHJpZ2dlcihuYW1lc3BhY2VJZCwgZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBldmVudFBoYXNlXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGV2ZW50TmFtZSwgZXZlbnRQaGFzZSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gQEBsaXN0ZW5cbiAgICAgICAgaWYgKGV2ZW50TmFtZS5jaGFyQXQoMCkgPT0gJ0AnKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBwYXJzZVRpbWVsaW5lQ29tbWFuZChldmVudE5hbWUpLCBpZCA9IF9hWzBdLCBhY3Rpb24gPSBfYVsxXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lbGluZUVuZ2luZS5saXN0ZW4oaWQsIGVsZW1lbnQsIGFjdGlvbiwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uRW5naW5lLmxpc3RlbihuYW1lc3BhY2VJZCwgZWxlbWVudCwgZXZlbnROYW1lLCBldmVudFBoYXNlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBtaWNyb3Rhc2tJZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIChtaWNyb3Rhc2tJZCkge1xuICAgICAgICBpZiAobWljcm90YXNrSWQgPT09IHZvaWQgMCkgeyBtaWNyb3Rhc2tJZCA9IC0xOyB9XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUuZmx1c2gobWljcm90YXNrSWQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUsIFwicGxheWVyc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKCh0aGlzLl90cmFuc2l0aW9uRW5naW5lLnBsYXllcnMpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5fdGltZWxpbmVFbmdpbmUucGxheWVycykpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUud2hlblJlbmRlcmluZ0RvbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl90cmFuc2l0aW9uRW5naW5lLndoZW5SZW5kZXJpbmdEb25lKCk7IH07XG4gICAgcmV0dXJuIEFuaW1hdGlvbkVuZ2luZTtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgV2ViQW5pbWF0aW9uc1BsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBwcmV2aW91c1BsYXllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXZWJBbmltYXRpb25zUGxheWVyKGVsZW1lbnQsIGtleWZyYW1lcywgb3B0aW9ucywgcHJldmlvdXNQbGF5ZXJzKSB7XG4gICAgICAgIGlmIChwcmV2aW91c1BsYXllcnMgPT09IHZvaWQgMCkgeyBwcmV2aW91c1BsYXllcnMgPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmtleWZyYW1lcyA9IGtleWZyYW1lcztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5wcmV2aW91c1BsYXllcnMgPSBwcmV2aW91c1BsYXllcnM7XG4gICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gW107XG4gICAgICAgIHRoaXMuX29uRGVzdHJveUZucyA9IFtdO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRpbWUgPSAwO1xuICAgICAgICB0aGlzLnBhcmVudFBsYXllciA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldmlvdXNTdHlsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50U25hcHNob3QgPSB7fTtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBvcHRpb25zWydkdXJhdGlvbiddO1xuICAgICAgICB0aGlzLl9kZWxheSA9IG9wdGlvbnNbJ2RlbGF5J10gfHwgMDtcbiAgICAgICAgdGhpcy50aW1lID0gdGhpcy5fZHVyYXRpb24gKyB0aGlzLl9kZWxheTtcbiAgICAgICAgaWYgKGFsbG93UHJldmlvdXNQbGF5ZXJTdHlsZXNNZXJnZSh0aGlzLl9kdXJhdGlvbiwgdGhpcy5fZGVsYXkpKSB7XG4gICAgICAgICAgICBwcmV2aW91c1BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHBsYXllci5jdXJyZW50U25hcHNob3Q7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBfdGhpcy5wcmV2aW91c1N0eWxlc1twcm9wXSA9IHN0eWxlc1twcm9wXTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLl9vbkZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2J1aWxkUGxheWVyKCk7XG4gICAgICAgIHRoaXMuX3ByZXBhcmVQbGF5ZXJCZWZvcmVTdGFydCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5fYnVpbGRQbGF5ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKHN0eWxlcykgeyByZXR1cm4gY29weVN0eWxlcyhzdHlsZXMsIGZhbHNlKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzU3R5bGVQcm9wcyA9IE9iamVjdC5rZXlzKHRoaXMucHJldmlvdXNTdHlsZXMpO1xuICAgICAgICBpZiAocHJldmlvdXNTdHlsZVByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRpbmdLZXlmcmFtZV8xID0ga2V5ZnJhbWVzWzBdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWlzc2luZ1N0eWxlUHJvcHNfMSA9IFtdO1xuICAgICAgICAgICAgcHJldmlvdXNTdHlsZVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0aW5nS2V5ZnJhbWVfMS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nU3R5bGVQcm9wc18xLnB1c2gocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0aW5nS2V5ZnJhbWVfMVtwcm9wXSA9IF90aGlzLnByZXZpb3VzU3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobWlzc2luZ1N0eWxlUHJvcHNfMS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxmXzEgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZiA9IGtleWZyYW1lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZ1N0eWxlUHJvcHNfMS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZltwcm9wXSA9IF9jb21wdXRlU3R5bGUoc2VsZl8xLmVsZW1lbnQsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDE7IGkgPCBrZXlmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3BfMSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wbGF5ZXIgPSB0aGlzLl90cmlnZ2VyV2ViQW5pbWF0aW9uKHRoaXMuZWxlbWVudCwga2V5ZnJhbWVzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9maW5hbEtleWZyYW1lID0ga2V5ZnJhbWVzLmxlbmd0aCA/IGtleWZyYW1lc1trZXlmcmFtZXMubGVuZ3RoIC0gMV0gOiB7fTtcbiAgICAgICAgdGhpcy5fcGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vbkZpbmlzaCgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuX3ByZXBhcmVQbGF5ZXJCZWZvcmVTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdGhpcyBpcyByZXF1aXJlZCBzbyB0aGF0IHRoZSBwbGF5ZXIgZG9lc24ndCBzdGFydCB0byBhbmltYXRlIHJpZ2h0IGF3YXlcbiAgICAgICAgaWYgKHRoaXMuX2RlbGF5KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldERvbVBsYXllclN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIucGF1c2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGtleWZyYW1lc1xuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuX3RyaWdnZXJXZWJBbmltYXRpb24gPSBmdW5jdGlvbiAoZWxlbWVudCwga2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGpzY29tcGlsZXIgZG9lc24ndCBzZWVtIHRvIGtub3cgYW5pbWF0ZSBpcyBhIG5hdGl2ZSBwcm9wZXJ0eSBiZWNhdXNlIGl0J3Mgbm90IGZ1bGx5XG4gICAgICAgIC8vIHN1cHBvcnRlZCB5ZXQgYWNyb3NzIGNvbW1vbiBicm93c2VycyAod2UgcG9seWZpbGwgaXQgZm9yIEVkZ2UvU2FmYXJpKSBbQ0wgIzE0MzYzMDkyOV1cbiAgICAgICAgcmV0dXJuIChlbGVtZW50WydhbmltYXRlJ10oa2V5ZnJhbWVzLCBvcHRpb25zKSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUsIFwiZG9tUGxheWVyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BsYXllcjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vblN0YXJ0Rm5zLnB1c2goZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLm9uRG9uZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkRvbmVGbnMucHVzaChmbik7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uRGVzdHJveUZucy5wdXNoKGZuKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2J1aWxkUGxheWVyKCk7XG4gICAgICAgIGlmICghdGhpcy5oYXNTdGFydGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGxheWVyLnBsYXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLl9wbGF5ZXIucGF1c2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgdGhpcy5fb25GaW5pc2goKTtcbiAgICAgICAgdGhpcy5fcGxheWVyLmZpbmlzaCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVzZXREb21QbGF5ZXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5fcmVzZXREb21QbGF5ZXJTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BsYXllcikge1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmhhc1N0YXJ0ZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGFydGVkOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9yZXNldERvbVBsYXllclN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICAgICAgdGhpcy5fb25EZXN0cm95Rm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX29uRGVzdHJveUZucyA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHApIHsgdGhpcy5fcGxheWVyLmN1cnJlbnRUaW1lID0gcCAqIHRoaXMudGltZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxheWVyLmN1cnJlbnRUaW1lIC8gdGhpcy50aW1lOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZSwgXCJ0b3RhbFRpbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVsYXkgKyB0aGlzLl9kdXJhdGlvbjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5iZWZvcmVEZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9maW5hbEtleWZyYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgIT0gJ29mZnNldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzW3Byb3BdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9maW5pc2hlZCA/IF90aGlzLl9maW5hbEtleWZyYW1lW3Byb3BdIDogX2NvbXB1dGVTdHlsZShfdGhpcy5lbGVtZW50LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTbmFwc2hvdCA9IHN0eWxlcztcbiAgICB9O1xuICAgIHJldHVybiBXZWJBbmltYXRpb25zUGxheWVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez99IHByb3BcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9jb21wdXRlU3R5bGUoZWxlbWVudCwgcHJvcCkge1xuICAgIHJldHVybiAoKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpKSlbcHJvcF07XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgV2ViQW5pbWF0aW9uc0RyaXZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2ViQW5pbWF0aW9uc0RyaXZlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc0RyaXZlci5wcm90b3R5cGUubWF0Y2hlc0VsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNFbGVtZW50KGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxtMVxuICAgICAqIEBwYXJhbSB7P30gZWxtMlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc0RyaXZlci5wcm90b3R5cGUuY29udGFpbnNFbGVtZW50ID0gZnVuY3Rpb24gKGVsbTEsIGVsbTIpIHsgcmV0dXJuIGNvbnRhaW5zRWxlbWVudChlbG0xLCBlbG0yKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBtdWx0aVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc0RyaXZlci5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IsIG11bHRpKSB7XG4gICAgICAgIHJldHVybiBpbnZva2VRdWVyeShlbGVtZW50LCBzZWxlY3RvciwgbXVsdGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBwcm9wXG4gICAgICogQHBhcmFtIHs/PX0gZGVmYXVsdFZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zRHJpdmVyLnByb3RvdHlwZS5jb21wdXRlU3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoKCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSkpW3Byb3BdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30ga2V5ZnJhbWVzXG4gICAgICogQHBhcmFtIHs/fSBkdXJhdGlvblxuICAgICAqIEBwYXJhbSB7P30gZGVsYXlcbiAgICAgKiBAcGFyYW0gez99IGVhc2luZ1xuICAgICAqIEBwYXJhbSB7Pz19IHByZXZpb3VzUGxheWVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc0RyaXZlci5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBrZXlmcmFtZXMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBwcmV2aW91c1BsYXllcnMpIHtcbiAgICAgICAgaWYgKHByZXZpb3VzUGxheWVycyA9PT0gdm9pZCAwKSB7IHByZXZpb3VzUGxheWVycyA9IFtdOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbGwgPSBkZWxheSA9PSAwID8gJ2JvdGgnIDogJ2ZvcndhcmRzJztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyT3B0aW9ucyA9IHsgZHVyYXRpb246IGR1cmF0aW9uLCBkZWxheTogZGVsYXksIGZpbGw6IGZpbGwgfTtcbiAgICAgICAgLy8gd2UgY2hlY2sgZm9yIHRoaXMgdG8gYXZvaWQgaGF2aW5nIGEgbnVsbHx1bmRlZmluZWQgdmFsdWUgYmUgcHJlc2VudFxuICAgICAgICAvLyBmb3IgdGhlIGVhc2luZyAod2hpY2ggcmVzdWx0cyBpbiBhbiBlcnJvciBmb3IgY2VydGFpbiBicm93c2VycyAjOTc1MilcbiAgICAgICAgaWYgKGVhc2luZykge1xuICAgICAgICAgICAgcGxheWVyT3B0aW9uc1snZWFzaW5nJ10gPSBlYXNpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNXZWJBbmltYXRpb25QbGF5ZXJzID0gKHByZXZpb3VzUGxheWVycy5maWx0ZXIoZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyIGluc3RhbmNlb2YgV2ViQW5pbWF0aW9uc1BsYXllcjsgfSkpO1xuICAgICAgICByZXR1cm4gbmV3IFdlYkFuaW1hdGlvbnNQbGF5ZXIoZWxlbWVudCwga2V5ZnJhbWVzLCBwbGF5ZXJPcHRpb25zLCBwcmV2aW91c1dlYkFuaW1hdGlvblBsYXllcnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFdlYkFuaW1hdGlvbnNEcml2ZXI7XG59KCkpO1xuLyoqXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdXBwb3J0c1dlYkFuaW1hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgKChFbGVtZW50KSkucHJvdG90eXBlWydhbmltYXRlJ10gPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydHMuQW5pbWF0aW9uRHJpdmVyID0gQW5pbWF0aW9uRHJpdmVyO1xuZXhwb3J0cy7JtUFuaW1hdGlvbiA9IEFuaW1hdGlvbjtcbmV4cG9ydHMuybVBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIgPSBBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXI7XG5leHBvcnRzLsm1Tm9vcEFuaW1hdGlvblN0eWxlTm9ybWFsaXplciA9IE5vb3BBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXI7XG5leHBvcnRzLsm1V2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplciA9IFdlYkFuaW1hdGlvbnNTdHlsZU5vcm1hbGl6ZXI7XG5leHBvcnRzLsm1Tm9vcEFuaW1hdGlvbkRyaXZlciA9IE5vb3BBbmltYXRpb25Ecml2ZXI7XG5leHBvcnRzLsm1QW5pbWF0aW9uRW5naW5lID0gQW5pbWF0aW9uRW5naW5lO1xuZXhwb3J0cy7JtVdlYkFuaW1hdGlvbnNEcml2ZXIgPSBXZWJBbmltYXRpb25zRHJpdmVyO1xuZXhwb3J0cy7JtXN1cHBvcnRzV2ViQW5pbWF0aW9ucyA9IHN1cHBvcnRzV2ViQW5pbWF0aW9ucztcbmV4cG9ydHMuybVXZWJBbmltYXRpb25zUGxheWVyID0gV2ViQW5pbWF0aW9uc1BsYXllcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFuaW1hdGlvbnMtYnJvd3Nlci51bWQuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGFuZ3VsYXIvYW5pbWF0aW9ucy9idW5kbGVzL2FuaW1hdGlvbnMtYnJvd3Nlci51bWQuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjQuMy42XG4gKiAoYykgMjAxMC0yMDE3IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCd0c2xpYicpLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyksIHJlcXVpcmUoJ3J4anMvb2JzZXJ2YWJsZS9vZicpLCByZXF1aXJlKCdyeGpzL29wZXJhdG9yL2NvbmNhdE1hcCcpLCByZXF1aXJlKCdyeGpzL29wZXJhdG9yL2ZpbHRlcicpLCByZXF1aXJlKCdyeGpzL29wZXJhdG9yL21hcCcpLCByZXF1aXJlKCdAYW5ndWxhci9jb21tb24nKSwgcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICd0c2xpYicsICdAYW5ndWxhci9jb3JlJywgJ3J4anMvb2JzZXJ2YWJsZS9vZicsICdyeGpzL29wZXJhdG9yL2NvbmNhdE1hcCcsICdyeGpzL29wZXJhdG9yL2ZpbHRlcicsICdyeGpzL29wZXJhdG9yL21hcCcsICdAYW5ndWxhci9jb21tb24nLCAncnhqcy9PYnNlcnZhYmxlJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5uZyA9IGdsb2JhbC5uZyB8fCB7fSwgZ2xvYmFsLm5nLmNvbW1tb24gPSBnbG9iYWwubmcuY29tbW1vbiB8fCB7fSwgZ2xvYmFsLm5nLmNvbW1tb24uaHR0cCA9IGdsb2JhbC5uZy5jb21tbW9uLmh0dHAgfHwge30pLGdsb2JhbC50c2xpYl8xLGdsb2JhbC5uZy5jb3JlLGdsb2JhbC5yeGpzX29ic2VydmFibGVfb2YsZ2xvYmFsLnJ4anNfb3BlcmF0b3JfY29uY2F0TWFwLGdsb2JhbC5yeGpzX29wZXJhdG9yX2ZpbHRlcixnbG9iYWwucnhqc19vcGVyYXRvcl9tYXAsZ2xvYmFsLl9hbmd1bGFyX2NvbW1vbixnbG9iYWwuUngpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLHRzbGliXzEsX2FuZ3VsYXJfY29yZSxyeGpzX29ic2VydmFibGVfb2Yscnhqc19vcGVyYXRvcl9jb25jYXRNYXAscnhqc19vcGVyYXRvcl9maWx0ZXIscnhqc19vcGVyYXRvcl9tYXAsX2FuZ3VsYXJfY29tbW9uLHJ4anNfT2JzZXJ2YWJsZSkgeyAndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2NC4zLjZcbiAqIChjKSAyMDEwLTIwMTcgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFRyYW5zZm9ybXMgYW4gYEh0dHBSZXF1ZXN0YCBpbnRvIGEgc3RyZWFtIG9mIGBIdHRwRXZlbnRgcywgb25lIG9mIHdoaWNoIHdpbGwgbGlrZWx5IGJlIGFcbiAqIGBIdHRwUmVzcG9uc2VgLlxuICpcbiAqIGBIdHRwSGFuZGxlcmAgaXMgaW5qZWN0YWJsZS4gV2hlbiBpbmplY3RlZCwgdGhlIGhhbmRsZXIgaW5zdGFuY2UgZGlzcGF0Y2hlcyByZXF1ZXN0cyB0byB0aGVcbiAqIGZpcnN0IGludGVyY2VwdG9yIGluIHRoZSBjaGFpbiwgd2hpY2ggZGlzcGF0Y2hlcyB0byB0aGUgc2Vjb25kLCBldGMsIGV2ZW50dWFsbHkgcmVhY2hpbmcgdGhlXG4gKiBgSHR0cEJhY2tlbmRgLlxuICpcbiAqIEluIGFuIGBIdHRwSW50ZXJjZXB0b3JgLCB0aGUgYEh0dHBIYW5kbGVyYCBwYXJhbWV0ZXIgaXMgdGhlIG5leHQgaW50ZXJjZXB0b3IgaW4gdGhlIGNoYWluLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICogQGFic3RyYWN0XG4gKi9cbnZhciBIdHRwSGFuZGxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cEhhbmRsZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gcmVxXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlID0gZnVuY3Rpb24gKHJlcSkgeyB9O1xuICAgIHJldHVybiBIdHRwSGFuZGxlcjtcbn0oKSk7XG4vKipcbiAqIEEgZmluYWwgYEh0dHBIYW5kbGVyYCB3aGljaCB3aWxsIGRpc3BhdGNoIHRoZSByZXF1ZXN0IHZpYSBicm93c2VyIEhUVFAgQVBJcyB0byBhIGJhY2tlbmQuXG4gKlxuICogSW50ZXJjZXB0b3JzIHNpdCBiZXR3ZWVuIHRoZSBgSHR0cENsaWVudGAgaW50ZXJmYWNlIGFuZCB0aGUgYEh0dHBCYWNrZW5kYC5cbiAqXG4gKiBXaGVuIGluamVjdGVkLCBgSHR0cEJhY2tlbmRgIGRpc3BhdGNoZXMgcmVxdWVzdHMgZGlyZWN0bHkgdG8gdGhlIGJhY2tlbmQsIHdpdGhvdXQgZ29pbmdcbiAqIHRocm91Z2ggdGhlIGludGVyY2VwdG9yIGNoYWluLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICogQGFic3RyYWN0XG4gKi9cbnZhciBIdHRwQmFja2VuZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cEJhY2tlbmQoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gcmVxXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwQmFja2VuZC5wcm90b3R5cGUuaGFuZGxlID0gZnVuY3Rpb24gKHJlcSkgeyB9O1xuICAgIHJldHVybiBIdHRwQmFja2VuZDtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEEgYEh0dHBQYXJhbWV0ZXJDb2RlY2AgdGhhdCB1c2VzIGBlbmNvZGVVUklDb21wb25lbnRgIGFuZCBgZGVjb2RlVVJJQ29tcG9uZW50YCB0b1xuICogc2VyaWFsaXplIGFuZCBwYXJzZSBVUkwgcGFyYW1ldGVyIGtleXMgYW5kIHZhbHVlcy5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqL1xudmFyIEh0dHBVcmxFbmNvZGluZ0NvZGVjID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwVXJsRW5jb2RpbmdDb2RlYygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwVXJsRW5jb2RpbmdDb2RlYy5wcm90b3R5cGUuZW5jb2RlS2V5ID0gZnVuY3Rpb24gKGspIHsgcmV0dXJuIHN0YW5kYXJkRW5jb2Rpbmcoayk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwVXJsRW5jb2RpbmdDb2RlYy5wcm90b3R5cGUuZW5jb2RlVmFsdWUgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RhbmRhcmRFbmNvZGluZyh2KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGtcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBVcmxFbmNvZGluZ0NvZGVjLnByb3RvdHlwZS5kZWNvZGVLZXkgPSBmdW5jdGlvbiAoaykgeyByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGspOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFVybEVuY29kaW5nQ29kZWMucHJvdG90eXBlLmRlY29kZVZhbHVlID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh2KTsgfTtcbiAgICByZXR1cm4gSHR0cFVybEVuY29kaW5nQ29kZWM7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHJhd1BhcmFtc1xuICogQHBhcmFtIHs/fSBjb2RlY1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcGFyYW1QYXJzZXIocmF3UGFyYW1zLCBjb2RlYykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcCQkMSA9IG5ldyBNYXAoKTtcbiAgICBpZiAocmF3UGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1zID0gcmF3UGFyYW1zLnNwbGl0KCcmJyk7XG4gICAgICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXFJZHggPSBwYXJhbS5pbmRleE9mKCc9Jyk7XG4gICAgICAgICAgICB2YXIgX2EgPSBlcUlkeCA9PSAtMSA/XG4gICAgICAgICAgICAgICAgW2NvZGVjLmRlY29kZUtleShwYXJhbSksICcnXSA6XG4gICAgICAgICAgICAgICAgW2NvZGVjLmRlY29kZUtleShwYXJhbS5zbGljZSgwLCBlcUlkeCkpLCBjb2RlYy5kZWNvZGVWYWx1ZShwYXJhbS5zbGljZShlcUlkeCArIDEpKV0sIGtleSA9IF9hWzBdLCB2YWwgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpc3QgPSBtYXAkJDEuZ2V0KGtleSkgfHwgW107XG4gICAgICAgICAgICBsaXN0LnB1c2godmFsKTtcbiAgICAgICAgICAgIG1hcCQkMS5zZXQoa2V5LCBsaXN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtYXAkJDE7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3RhbmRhcmRFbmNvZGluZyh2KSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2KVxuICAgICAgICAucmVwbGFjZSgvJTQwL2dpLCAnQCcpXG4gICAgICAgIC5yZXBsYWNlKC8lM0EvZ2ksICc6JylcbiAgICAgICAgLnJlcGxhY2UoLyUyNC9naSwgJyQnKVxuICAgICAgICAucmVwbGFjZSgvJTJDL2dpLCAnLCcpXG4gICAgICAgIC5yZXBsYWNlKC8lM0IvZ2ksICc7JylcbiAgICAgICAgLnJlcGxhY2UoLyUyQi9naSwgJysnKVxuICAgICAgICAucmVwbGFjZSgvJTNEL2dpLCAnPScpXG4gICAgICAgIC5yZXBsYWNlKC8lM0YvZ2ksICc/JylcbiAgICAgICAgLnJlcGxhY2UoLyUyRi9naSwgJy8nKTtcbn1cbi8qKlxuICogQW4gSFRUUCByZXF1ZXN0L3Jlc3BvbnNlIGJvZHkgdGhhdCByZXByZXNlbnRzIHNlcmlhbGl6ZWQgcGFyYW1ldGVycyxcbiAqIHBlciB0aGUgTUlNRSB0eXBlIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgaW1tdWF0YWJsZSAtIGFsbCBtdXRhdGlvbiBvcGVyYXRpb25zIHJldHVybiBhIG5ldyBpbnN0YW5jZS5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqL1xudmFyIEh0dHBQYXJhbXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIdHRwUGFyYW1zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy51cGRhdGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbG9uZUZyb20gPSBudWxsO1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBvcHRpb25zLmVuY29kZXIgfHwgbmV3IEh0dHBVcmxFbmNvZGluZ0NvZGVjKCk7XG4gICAgICAgIHRoaXMubWFwID0gISFvcHRpb25zLmZyb21TdHJpbmcgPyBwYXJhbVBhcnNlcihvcHRpb25zLmZyb21TdHJpbmcsIHRoaXMuZW5jb2RlcikgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBib2R5IGhhcyBvbmUgb3IgbW9yZSB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXIgbmFtZS5cbiAgICAgKiBAcGFyYW0gez99IHBhcmFtXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwUGFyYW1zLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHJldHVybiAoKHRoaXMubWFwKSkuaGFzKHBhcmFtKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlyc3QgdmFsdWUgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXIgbmFtZSwgb3IgYG51bGxgIGlmIGl0J3Mgbm90IHByZXNlbnQuXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFBhcmFtcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXMgPSAoKHRoaXMubWFwKSkuZ2V0KHBhcmFtKTtcbiAgICAgICAgcmV0dXJuICEhcmVzID8gcmVzWzBdIDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWUsIG9yIGBudWxsYCBpZiBpdCdzIG5vdCBwcmVzZW50LlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBQYXJhbXMucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgcmV0dXJuICgodGhpcy5tYXApKS5nZXQocGFyYW0pIHx8IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgZm9yIHRoaXMgYm9keS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBQYXJhbXMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSgvKiogQHR5cGUgez99ICovICgodGhpcy5tYXApKS5rZXlzKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGJvZHkgd2l0aCBhbiBhcHBlbmRlZCB2YWx1ZSBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwUGFyYW1zLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAocGFyYW0sIHZhbHVlKSB7IHJldHVybiB0aGlzLmNsb25lKHsgcGFyYW06IHBhcmFtLCB2YWx1ZTogdmFsdWUsIG9wOiAnYScgfSk7IH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGJvZHkgd2l0aCBhIG5ldyB2YWx1ZSBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwUGFyYW1zLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocGFyYW0sIHZhbHVlKSB7IHJldHVybiB0aGlzLmNsb25lKHsgcGFyYW06IHBhcmFtLCB2YWx1ZTogdmFsdWUsIG9wOiAncycgfSk7IH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGJvZHkgd2l0aCBlaXRoZXIgdGhlIGdpdmVuIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyXG4gICAgICogcmVtb3ZlZCwgaWYgYSB2YWx1ZSBpcyBnaXZlbiwgb3IgYWxsIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciByZW1vdmVkXG4gICAgICogaWYgbm90LlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFBhcmFtcy5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHBhcmFtLCB2YWx1ZSkgeyByZXR1cm4gdGhpcy5jbG9uZSh7IHBhcmFtOiBwYXJhbSwgdmFsdWU6IHZhbHVlLCBvcDogJ2QnIH0pOyB9O1xuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgYm9keSB0byBhbiBlbmNvZGVkIHN0cmluZywgd2hlcmUga2V5LXZhbHVlIHBhaXJzIChzZXBhcmF0ZWQgYnkgYD1gKSBhcmVcbiAgICAgKiBzZXBhcmF0ZWQgYnkgYCZgcy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBQYXJhbXMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cygpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVLZXkgPSBfdGhpcy5lbmNvZGVyLmVuY29kZUtleShrZXkpO1xuICAgICAgICAgICAgcmV0dXJuICgoKChfdGhpcy5tYXApKS5nZXQoa2V5KSkpLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGVLZXkgKyAnPScgKyBfdGhpcy5lbmNvZGVyLmVuY29kZVZhbHVlKHZhbHVlKTsgfSlcbiAgICAgICAgICAgICAgICAuam9pbignJicpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJyYnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdXBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwUGFyYW1zLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvbmUgPSBuZXcgSHR0cFBhcmFtcyh7IGVuY29kZXI6IHRoaXMuZW5jb2RlciB9KTtcbiAgICAgICAgY2xvbmUuY2xvbmVGcm9tID0gdGhpcy5jbG9uZUZyb20gfHwgdGhpcztcbiAgICAgICAgY2xvbmUudXBkYXRlcyA9ICh0aGlzLnVwZGF0ZXMgfHwgW10pLmNvbmNhdChbdXBkYXRlXSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFBhcmFtcy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMubWFwID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jbG9uZUZyb20gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvbmVGcm9tLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xvbmVGcm9tLmtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICgoX3RoaXMubWFwKSkuc2V0KGtleSwgLyoqIEB0eXBlIHs/fSAqLyAoKCgoKChfdGhpcy5jbG9uZUZyb20pKS5tYXApKS5nZXQoa2V5KSkpKTsgfSk7IC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICgodGhpcy51cGRhdGVzKSkuZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh1cGRhdGUub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZSA9ICh1cGRhdGUub3AgPT09ICdhJyA/ICgoX3RoaXMubWFwKSkuZ2V0KHVwZGF0ZS5wYXJhbSkgOiB1bmRlZmluZWQpIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZS5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKCh1cGRhdGUudmFsdWUpKSk7IC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICgoX3RoaXMubWFwKSkuc2V0KHVwZGF0ZS5wYXJhbSwgYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlXzEgPSAoKF90aGlzLm1hcCkpLmdldCh1cGRhdGUucGFyYW0pIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkeCA9IGJhc2VfMS5pbmRleE9mKHVwZGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZV8xLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZV8xLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfdGhpcy5tYXApKS5zZXQodXBkYXRlLnBhcmFtLCBiYXNlXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfdGhpcy5tYXApKS5kZWxldGUodXBkYXRlLnBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF90aGlzLm1hcCkpLmRlbGV0ZSh1cGRhdGUucGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jbG9uZUZyb20gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSHR0cFBhcmFtcztcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEltbXV0YWJsZSBzZXQgb2YgSHR0cCBoZWFkZXJzLCB3aXRoIGxhenkgcGFyc2luZy5cbiAqIFxcQGV4cGVyaW1lbnRhbFxuICovXG52YXIgSHR0cEhlYWRlcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IGhlYWRlcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIdHRwSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBtYXAgb2YgbG93ZXJjYXNlZCBoZWFkZXIgbmFtZXMgdG8gdGhlIG5vcm1hbGl6ZWRcbiAgICAgICAgICogZm9ybSBvZiB0aGUgbmFtZSAodGhlIGZvcm0gc2VlbiBmaXJzdCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZWROYW1lcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFF1ZXVlZCB1cGRhdGVzIHRvIGJlIG1hdGVyaWFsaXplZCB0aGUgbmV4dCBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGF6eVVwZGF0ZSA9IG51bGw7XG4gICAgICAgIGlmICghaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBoZWFkZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5sYXp5SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oZWFkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbGluZS5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbGluZS5zbGljZShpbmRleCArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1heWJlU2V0Tm9ybWFsaXplZE5hbWUobmFtZSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5oZWFkZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGVhZGVycy5nZXQoa2V5KS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhlYWRlcnMuc2V0KGtleSwgW3ZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxhenlJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gaGVhZGVyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhlYWRlcnMuc2V0KGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1heWJlU2V0Tm9ybWFsaXplZE5hbWUobmFtZSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIGV4aXN0ZW5jZSBvZiBoZWFkZXIgYnkgZ2l2ZW4gbmFtZS5cbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVycy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgZmlyc3QgaGVhZGVyIHRoYXQgbWF0Y2hlcyBnaXZlbiBuYW1lLlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZXMgPSB0aGlzLmhlYWRlcnMuZ2V0KG5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCA+IDAgPyB2YWx1ZXNbMF0gOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZXMgb2YgdGhlIGhlYWRlcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5ub3JtYWxpemVkTmFtZXMudmFsdWVzKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsaXN0IG9mIGhlYWRlciB2YWx1ZXMgZm9yIGEgZ2l2ZW4gbmFtZS5cbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBIZWFkZXJzLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVycy5nZXQobmFtZS50b0xvd2VyQ2FzZSgpKSB8fCBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSwgb3A6ICdhJyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIG9wOiAncycgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cEhlYWRlcnMucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSwgb3A6ICdkJyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gbGNOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVycy5wcm90b3R5cGUubWF5YmVTZXROb3JtYWxpemVkTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBsY05hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5vcm1hbGl6ZWROYW1lcy5oYXMobGNOYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkTmFtZXMuc2V0KGxjTmFtZSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cEhlYWRlcnMucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghIXRoaXMubGF6eUluaXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhenlJbml0IGluc3RhbmNlb2YgSHR0cEhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvcHlGcm9tKHRoaXMubGF6eUluaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXp5SW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYXp5SW5pdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoISF0aGlzLmxhenlVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhenlVcGRhdGUuZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlKSB7IHJldHVybiBfdGhpcy5hcHBseVVwZGF0ZSh1cGRhdGUpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhenlVcGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG90aGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVycy5wcm90b3R5cGUuY29weUZyb20gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgb3RoZXIuaW5pdCgpO1xuICAgICAgICBBcnJheS5mcm9tKG90aGVyLmhlYWRlcnMua2V5cygpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIF90aGlzLmhlYWRlcnMuc2V0KGtleSwgLyoqIEB0eXBlIHs/fSAqLyAoKG90aGVyLmhlYWRlcnMuZ2V0KGtleSkpKSk7XG4gICAgICAgICAgICBfdGhpcy5ub3JtYWxpemVkTmFtZXMuc2V0KGtleSwgLyoqIEB0eXBlIHs/fSAqLyAoKG90aGVyLm5vcm1hbGl6ZWROYW1lcy5nZXQoa2V5KSkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVwZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cEhlYWRlcnMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9uZSA9IG5ldyBIdHRwSGVhZGVycygpO1xuICAgICAgICBjbG9uZS5sYXp5SW5pdCA9XG4gICAgICAgICAgICAoISF0aGlzLmxhenlJbml0ICYmIHRoaXMubGF6eUluaXQgaW5zdGFuY2VvZiBIdHRwSGVhZGVycykgPyB0aGlzLmxhenlJbml0IDogdGhpcztcbiAgICAgICAgY2xvbmUubGF6eVVwZGF0ZSA9ICh0aGlzLmxhenlVcGRhdGUgfHwgW10pLmNvbmNhdChbdXBkYXRlXSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdXBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVycy5wcm90b3R5cGUuYXBwbHlVcGRhdGUgPSBmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleSA9IHVwZGF0ZS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHN3aXRjaCAodXBkYXRlLm9wKSB7XG4gICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gKCh1cGRhdGUudmFsdWUpKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1heWJlU2V0Tm9ybWFsaXplZE5hbWUodXBkYXRlLm5hbWUsIGtleSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZSA9ICh1cGRhdGUub3AgPT09ICdhJyA/IHRoaXMuaGVhZGVycy5nZXQoa2V5KSA6IHVuZGVmaW5lZCkgfHwgW107XG4gICAgICAgICAgICAgICAgYmFzZS5wdXNoLmFwcGx5KGJhc2UsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KGtleSwgYmFzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b0RlbGV0ZV8xID0gKHVwZGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0b0RlbGV0ZV8xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkTmFtZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleGlzdGluZyA9IHRoaXMuaGVhZGVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nID0gZXhpc3RpbmcuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdG9EZWxldGVfMS5pbmRleE9mKHZhbHVlKSA9PT0gLTE7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWROYW1lcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoa2V5LCBleGlzdGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5ub3JtYWxpemVkTmFtZXMua2V5cygpKVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZm4oLyoqIEB0eXBlIHs/fSAqLyAoKF90aGlzLm5vcm1hbGl6ZWROYW1lcy5nZXQoa2V5KSkpLCAvKiogQHR5cGUgez99ICovICgoX3RoaXMuaGVhZGVycy5nZXQoa2V5KSkpKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSHR0cEhlYWRlcnM7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgZ2l2ZW4gSFRUUCBtZXRob2QgbWF5IGluY2x1ZGUgYSBib2R5LlxuICogQHBhcmFtIHs/fSBtZXRob2RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG1pZ2h0SGF2ZUJvZHkobWV0aG9kKSB7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgY2FzZSAnREVMRVRFJzpcbiAgICAgICAgY2FzZSAnR0VUJzpcbiAgICAgICAgY2FzZSAnSEVBRCc6XG4gICAgICAgIGNhc2UgJ09QVElPTlMnOlxuICAgICAgICBjYXNlICdKU09OUCc6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vKipcbiAqIFNhZmVseSBhc3NlcnQgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIuXG4gKlxuICogSW4gc29tZSBleGVjdXRpb24gZW52aXJvbm1lbnRzIEFycmF5QnVmZmVyIGlzIG5vdCBkZWZpbmVkLlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59XG4vKipcbiAqIFNhZmVseSBhc3NlcnQgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBCbG9iLlxuICpcbiAqIEluIHNvbWUgZXhlY3V0aW9uIGVudmlyb25tZW50cyBCbG9iIGlzIG5vdCBkZWZpbmVkLlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEJsb2I7XG59XG4vKipcbiAqIFNhZmVseSBhc3NlcnQgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBGb3JtRGF0YSBpbnN0YW5jZS5cbiAqXG4gKiBJbiBzb21lIGV4ZWN1dGlvbiBlbnZpcm9ubWVudHMgRm9ybURhdGEgaXMgbm90IGRlZmluZWQuXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBGb3JtRGF0YTtcbn1cbi8qKlxuICogQW4gb3V0Z29pbmcgSFRUUCByZXF1ZXN0IHdpdGggYW4gb3B0aW9uYWwgdHlwZWQgYm9keS5cbiAqXG4gKiBgSHR0cFJlcXVlc3RgIHJlcHJlc2VudHMgYW4gb3V0Z29pbmcgcmVxdWVzdCwgaW5jbHVkaW5nIFVSTCwgbWV0aG9kLFxuICogaGVhZGVycywgYm9keSwgYW5kIG90aGVyIHJlcXVlc3QgY29uZmlndXJhdGlvbiBvcHRpb25zLiBJbnN0YW5jZXMgc2hvdWxkIGJlXG4gKiBhc3N1bWVkIHRvIGJlIGltbXV0YWJsZS4gVG8gbW9kaWZ5IGEgYEh0dHBSZXF1ZXN0YCwgdGhlIGBjbG9uZWBcbiAqIG1ldGhvZCBzaG91bGQgYmUgdXNlZC5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqL1xudmFyIEh0dHBSZXF1ZXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gdGhpcmRcbiAgICAgKiBAcGFyYW0gez89fSBmb3VydGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIdHRwUmVxdWVzdChtZXRob2QsIHVybCwgdGhpcmQsIGZvdXJ0aCkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZXF1ZXN0IGJvZHksIG9yIGBudWxsYCBpZiBvbmUgaXNuJ3Qgc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBCb2RpZXMgYXJlIG5vdCBlbmZvcmNlZCB0byBiZSBpbW11dGFibGUsIGFzIHRoZXkgY2FuIGluY2x1ZGUgYSByZWZlcmVuY2UgdG8gYW55XG4gICAgICAgICAqIHVzZXItZGVmaW5lZCBkYXRhIHR5cGUuIEhvd2V2ZXIsIGludGVyY2VwdG9ycyBzaG91bGQgdGFrZSBjYXJlIHRvIHByZXNlcnZlXG4gICAgICAgICAqIGlkZW1wb3RlbmNlIGJ5IHRyZWF0aW5nIHRoZW0gYXMgc3VjaC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm9keSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgcmVxdWVzdCBzaG91bGQgYmUgbWFkZSBpbiBhIHdheSB0aGF0IGV4cG9zZXMgcHJvZ3Jlc3MgZXZlbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQcm9ncmVzcyBldmVudHMgYXJlIGV4cGVuc2l2ZSAoY2hhbmdlIGRldGVjdGlvbiBydW5zIG9uIGVhY2ggZXZlbnQpIGFuZCBzb1xuICAgICAgICAgKiB0aGV5IHNob3VsZCBvbmx5IGJlIHJlcXVlc3RlZCBpZiB0aGUgY29uc3VtZXIgaW50ZW5kcyB0byBtb25pdG9yIHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlcG9ydFByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgcmVxdWVzdCBzaG91bGQgYmUgc2VudCB3aXRoIG91dGdvaW5nIGNyZWRlbnRpYWxzIChjb29raWVzKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXhwZWN0ZWQgcmVzcG9uc2UgdHlwZSBvZiB0aGUgc2VydmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIHVzZWQgdG8gcGFyc2UgdGhlIHJlc3BvbnNlIGFwcHJvcHJpYXRlbHkgYmVmb3JlIHJldHVybmluZyBpdCB0b1xuICAgICAgICAgKiB0aGUgcmVxdWVzdGVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIC8vIE5leHQsIG5lZWQgdG8gZmlndXJlIG91dCB3aGljaCBhcmd1bWVudCBob2xkcyB0aGUgSHR0cFJlcXVlc3RJbml0XG4gICAgICAgIC8vIG9wdGlvbnMsIGlmIGFueS5cbiAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgYSBib2R5IGFyZ3VtZW50IGlzIGV4cGVjdGVkLiBUaGUgb25seSB2YWxpZCB3YXkgdG8gb21pdFxuICAgICAgICAvLyB0aGUgYm9keSBhcmd1bWVudCBpcyB0byB1c2UgYSBrbm93biBuby1ib2R5IG1ldGhvZCBsaWtlIEdFVC5cbiAgICAgICAgaWYgKG1pZ2h0SGF2ZUJvZHkodGhpcy5tZXRob2QpIHx8ICEhZm91cnRoKSB7XG4gICAgICAgICAgICAvLyBCb2R5IGlzIHRoZSB0aGlyZCBhcmd1bWVudCwgb3B0aW9ucyBhcmUgdGhlIGZvdXJ0aC5cbiAgICAgICAgICAgIHRoaXMuYm9keSA9IHRoaXJkIHx8IG51bGw7XG4gICAgICAgICAgICBvcHRpb25zID0gZm91cnRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gYm9keSByZXF1aXJlZCwgb3B0aW9ucyBhcmUgdGhlIHRoaXJkIGFyZ3VtZW50LiBUaGUgYm9keSBzdGF5cyBudWxsLlxuICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXJkO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG9wdGlvbnMgaGF2ZSBiZWVuIHBhc3NlZCwgaW50ZXJwcmV0IHRoZW0uXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgcmVwb3J0UHJvZ3Jlc3MgYW5kIHdpdGhDcmVkZW50aWFscy5cbiAgICAgICAgICAgIHRoaXMucmVwb3J0UHJvZ3Jlc3MgPSAhIW9wdGlvbnMucmVwb3J0UHJvZ3Jlc3M7XG4gICAgICAgICAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9ICEhb3B0aW9ucy53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0IHJlc3BvbnNlIHR5cGUgb2YgJ2pzb24nIGlmIG9uZSBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgIGlmICghIW9wdGlvbnMucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIGhlYWRlcnMgaWYgdGhleSdyZSBwcm92aWRlZC5cbiAgICAgICAgICAgIGlmICghIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghIW9wdGlvbnMucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBvcHRpb25zLnBhcmFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBoZWFkZXJzIGhhdmUgYmVlbiBwYXNzZWQgaW4sIGNvbnN0cnVjdCBhIG5ldyBIdHRwSGVhZGVycyBpbnN0YW5jZS5cbiAgICAgICAgaWYgKCF0aGlzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIdHRwSGVhZGVycygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIHBhcmFtZXRlcnMgaGF2ZSBiZWVuIHBhc3NlZCBpbiwgY29uc3RydWN0IGEgbmV3IEh0dHBVcmxFbmNvZGVkUGFyYW1zIGluc3RhbmNlLlxuICAgICAgICBpZiAoIXRoaXMucGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG5ldyBIdHRwUGFyYW1zKCk7XG4gICAgICAgICAgICB0aGlzLnVybFdpdGhQYXJhbXMgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIHBhcmFtZXRlcnMgdG8gYSBzdHJpbmcgaW4gcHJlcGFyYXRpb24gZm9yIGluY2x1c2lvbiBpbiB0aGUgVVJMLlxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIHBhcmFtZXRlcnMsIHRoZSB2aXNpYmxlIFVSTCBpcyBqdXN0IHRoZSBVUkwgZ2l2ZW4gYXQgY3JlYXRpb24gdGltZS5cbiAgICAgICAgICAgICAgICB0aGlzLnVybFdpdGhQYXJhbXMgPSB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEb2VzIHRoZSBVUkwgYWxyZWFkeSBoYXZlIHF1ZXJ5IHBhcmFtZXRlcnM/IExvb2sgZm9yICc/Jy5cbiAgICAgICAgICAgICAgICB2YXIgcUlkeCA9IHVybC5pbmRleE9mKCc/Jyk7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIDMgY2FzZXMgdG8gaGFuZGxlOlxuICAgICAgICAgICAgICAgIC8vIDEpIE5vIGV4aXN0aW5nIHBhcmFtZXRlcnMgLT4gYXBwZW5kICc/JyBmb2xsb3dlZCBieSBwYXJhbXMuXG4gICAgICAgICAgICAgICAgLy8gMikgJz8nIGV4aXN0cyBhbmQgaXMgZm9sbG93ZWQgYnkgZXhpc3RpbmcgcXVlcnkgc3RyaW5nIC0+XG4gICAgICAgICAgICAgICAgLy8gICAgYXBwZW5kICcmJyBmb2xsb3dlZCBieSBwYXJhbXMuXG4gICAgICAgICAgICAgICAgLy8gMykgJz8nIGV4aXN0cyBhdCB0aGUgZW5kIG9mIHRoZSB1cmwgLT4gYXBwZW5kIHBhcmFtcyBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGJhc2ljYWxseSBhbW91bnRzIHRvIGRldGVybWluaW5nIHRoZSBjaGFyYWN0ZXIsIGlmIGFueSwgd2l0aFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHRvIGpvaW4gdGhlIFVSTCBhbmQgcGFyYW1ldGVycy5cbiAgICAgICAgICAgICAgICB2YXIgc2VwID0gcUlkeCA9PT0gLTEgPyAnPycgOiAocUlkeCA8IHVybC5sZW5ndGggLSAxID8gJyYnIDogJycpO1xuICAgICAgICAgICAgICAgIHRoaXMudXJsV2l0aFBhcmFtcyA9IHVybCArIHNlcCArIHBhcmFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gdGhlIGZyZWUtZm9ybSBib2R5IGludG8gYSBzZXJpYWxpemVkIGZvcm1hdCBzdWl0YWJsZSBmb3JcbiAgICAgKiB0cmFuc21pc3Npb24gdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZXJpYWxpemVCb2R5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJZiBubyBib2R5IGlzIHByZXNlbnQsIG5vIG5lZWQgdG8gc2VyaWFsaXplIGl0LlxuICAgICAgICBpZiAodGhpcy5ib2R5ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBib2R5IGlzIGFscmVhZHkgaW4gYSBzZXJpYWxpemVkIGZvcm0uIElmIHNvLFxuICAgICAgICAvLyBpdCBjYW4ganVzdCBiZSByZXR1cm5lZCBkaXJlY3RseS5cbiAgICAgICAgaWYgKGlzQXJyYXlCdWZmZXIodGhpcy5ib2R5KSB8fCBpc0Jsb2IodGhpcy5ib2R5KSB8fCBpc0Zvcm1EYXRhKHRoaXMuYm9keSkgfHxcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGJvZHkgaXMgYW4gaW5zdGFuY2Ugb2YgSHR0cFVybEVuY29kZWRQYXJhbXMuXG4gICAgICAgIGlmICh0aGlzLmJvZHkgaW5zdGFuY2VvZiBIdHRwUGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgYm9keSBpcyBhbiBvYmplY3Qgb3IgYXJyYXksIGFuZCBzZXJpYWxpemUgd2l0aCBKU09OIGlmIHNvLlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuYm9keSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHRoaXMuYm9keSA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMuYm9keSkpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGwgYmFjayBvbiB0b1N0cmluZygpIGZvciBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAgIHJldHVybiAoKHRoaXMuYm9keSkpLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGFtaW5lIHRoZSBib2R5IGFuZCBhdHRlbXB0IHRvIGluZmVyIGFuIGFwcHJvcHJpYXRlIE1JTUUgdHlwZVxuICAgICAqIGZvciBpdC5cbiAgICAgKlxuICAgICAqIElmIG5vIHN1Y2ggdHlwZSBjYW4gYmUgaW5mZXJyZWQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGBudWxsYC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5kZXRlY3RDb250ZW50VHlwZUhlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQW4gZW1wdHkgYm9keSBoYXMgbm8gY29udGVudCB0eXBlLlxuICAgICAgICBpZiAodGhpcy5ib2R5ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3JtRGF0YSBib2RpZXMgcmVseSBvbiB0aGUgYnJvd3NlcidzIGNvbnRlbnQgdHlwZSBhc3NpZ25tZW50LlxuICAgICAgICBpZiAoaXNGb3JtRGF0YSh0aGlzLmJvZHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBCbG9icyB1c3VhbGx5IGhhdmUgdGhlaXIgb3duIGNvbnRlbnQgdHlwZS4gSWYgaXQgZG9lc24ndCwgdGhlblxuICAgICAgICAvLyBubyB0eXBlIGNhbiBiZSBpbmZlcnJlZC5cbiAgICAgICAgaWYgKGlzQmxvYih0aGlzLmJvZHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnR5cGUgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBidWZmZXJzIGhhdmUgdW5rbm93biBjb250ZW50cyBhbmQgdGh1cyBubyB0eXBlIGNhbiBiZSBpbmZlcnJlZC5cbiAgICAgICAgaWYgKGlzQXJyYXlCdWZmZXIodGhpcy5ib2R5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVjaG5pY2FsbHksIHN0cmluZ3MgY291bGQgYmUgYSBmb3JtIG9mIEpTT04gZGF0YSwgYnV0IGl0J3Mgc2FmZSBlbm91Z2hcbiAgICAgICAgLy8gdG8gYXNzdW1lIHRoZXkncmUgcGxhaW4gc3RyaW5ncy5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RleHQvcGxhaW4nO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBIdHRwVXJsRW5jb2RlZFBhcmFtc2AgaGFzIGl0cyBvd24gY29udGVudC10eXBlLlxuICAgICAgICBpZiAodGhpcy5ib2R5IGluc3RhbmNlb2YgSHR0cFBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlzLCBvYmplY3RzLCBhbmQgbnVtYmVycyB3aWxsIGJlIGVuY29kZWQgYXMgSlNPTi5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmJvZHkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB0aGlzLmJvZHkgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMuYm9keSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gdHlwZSBjb3VsZCBiZSBpbmZlcnJlZC5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSB1cGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZSA9PT0gdm9pZCAwKSB7IHVwZGF0ZSA9IHt9OyB9XG4gICAgICAgIC8vIEZvciBtZXRob2QsIHVybCwgYW5kIHJlc3BvbnNlVHlwZSwgdGFrZSB0aGUgY3VycmVudCB2YWx1ZSB1bmxlc3NcbiAgICAgICAgLy8gaXQgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgdXBkYXRlIGhhc2guXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1ldGhvZCA9IHVwZGF0ZS5tZXRob2QgfHwgdGhpcy5tZXRob2Q7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVybCA9IHVwZGF0ZS51cmwgfHwgdGhpcy51cmw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3BvbnNlVHlwZSA9IHVwZGF0ZS5yZXNwb25zZVR5cGUgfHwgdGhpcy5yZXNwb25zZVR5cGU7XG4gICAgICAgIC8vIFRoZSBib2R5IGlzIHNvbWV3aGF0IHNwZWNpYWwgLSBhIGBudWxsYCB2YWx1ZSBpbiB1cGRhdGUuYm9keSBtZWFuc1xuICAgICAgICAvLyB3aGF0ZXZlciBjdXJyZW50IGJvZHkgaXMgcHJlc2VudCBpcyBiZWluZyBvdmVycmlkZGVuIHdpdGggYW4gZW1wdHlcbiAgICAgICAgLy8gYm9keSwgd2hlcmVhcyBhbiBgdW5kZWZpbmVkYCB2YWx1ZSBpbiB1cGRhdGUuYm9keSBpbXBsaWVzIG5vXG4gICAgICAgIC8vIG92ZXJyaWRlLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBib2R5ID0gKHVwZGF0ZS5ib2R5ICE9PSB1bmRlZmluZWQpID8gdXBkYXRlLmJvZHkgOiB0aGlzLmJvZHk7XG4gICAgICAgIC8vIENhcmVmdWxseSBoYW5kbGUgdGhlIGJvb2xlYW4gb3B0aW9ucyB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW5cbiAgICAgICAgLy8gYGZhbHNlYCBhbmQgYHVuZGVmaW5lZGAgaW4gdGhlIHVwZGF0ZSBhcmdzLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3aXRoQ3JlZGVudGlhbHMgPSAodXBkYXRlLndpdGhDcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkKSA/IHVwZGF0ZS53aXRoQ3JlZGVudGlhbHMgOiB0aGlzLndpdGhDcmVkZW50aWFscztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVwb3J0UHJvZ3Jlc3MgPSAodXBkYXRlLnJlcG9ydFByb2dyZXNzICE9PSB1bmRlZmluZWQpID8gdXBkYXRlLnJlcG9ydFByb2dyZXNzIDogdGhpcy5yZXBvcnRQcm9ncmVzcztcbiAgICAgICAgLy8gSGVhZGVycyBhbmQgcGFyYW1zIG1heSBiZSBhcHBlbmRlZCB0byBpZiBgc2V0SGVhZGVyc2Agb3JcbiAgICAgICAgLy8gYHNldFBhcmFtc2AgYXJlIHVzZWQuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhlYWRlcnMgPSB1cGRhdGUuaGVhZGVycyB8fCB0aGlzLmhlYWRlcnM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtcyA9IHVwZGF0ZS5wYXJhbXMgfHwgdGhpcy5wYXJhbXM7XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGNhbGxlciBoYXMgYXNrZWQgdG8gYWRkIGhlYWRlcnMuXG4gICAgICAgIGlmICh1cGRhdGUuc2V0SGVhZGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBTZXQgZXZlcnkgcmVxdWVzdGVkIGhlYWRlci5cbiAgICAgICAgICAgIGhlYWRlcnMgPVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHVwZGF0ZS5zZXRIZWFkZXJzKVxuICAgICAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChoZWFkZXJzLCBuYW1lKSB7IHJldHVybiBoZWFkZXJzLnNldChuYW1lLCAvKiogQHR5cGUgez99ICovICgodXBkYXRlLnNldEhlYWRlcnMpKVtuYW1lXSk7IH0sIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGNhbGxlciBoYXMgYXNrZWQgdG8gc2V0IHBhcmFtcy5cbiAgICAgICAgaWYgKHVwZGF0ZS5zZXRQYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIFNldCBldmVyeSByZXF1ZXN0ZWQgcGFyYW0uXG4gICAgICAgICAgICBwYXJhbXMgPSBPYmplY3Qua2V5cyh1cGRhdGUuc2V0UGFyYW1zKVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHBhcmFtcywgcGFyYW0pIHsgcmV0dXJuIHBhcmFtcy5zZXQocGFyYW0sIC8qKiBAdHlwZSB7P30gKi8gKCh1cGRhdGUuc2V0UGFyYW1zKSlbcGFyYW1dKTsgfSwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5hbGx5LCBjb25zdHJ1Y3QgdGhlIG5ldyBIdHRwUmVxdWVzdCB1c2luZyB0aGUgcGllY2VzIGZyb20gYWJvdmUuXG4gICAgICAgIHJldHVybiBuZXcgSHR0cFJlcXVlc3QobWV0aG9kLCB1cmwsIGJvZHksIHtcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLCBoZWFkZXJzOiBoZWFkZXJzLCByZXBvcnRQcm9ncmVzczogcmVwb3J0UHJvZ3Jlc3MsIHJlc3BvbnNlVHlwZTogcmVzcG9uc2VUeXBlLCB3aXRoQ3JlZGVudGlhbHM6IHdpdGhDcmVkZW50aWFscyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSHR0cFJlcXVlc3Q7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEh0dHBFdmVudFR5cGUgPSB7fTtcbkh0dHBFdmVudFR5cGUuU2VudCA9IDA7XG5IdHRwRXZlbnRUeXBlLlVwbG9hZFByb2dyZXNzID0gMTtcbkh0dHBFdmVudFR5cGUuUmVzcG9uc2VIZWFkZXIgPSAyO1xuSHR0cEV2ZW50VHlwZS5Eb3dubG9hZFByb2dyZXNzID0gMztcbkh0dHBFdmVudFR5cGUuUmVzcG9uc2UgPSA0O1xuSHR0cEV2ZW50VHlwZS5Vc2VyID0gNTtcbkh0dHBFdmVudFR5cGVbSHR0cEV2ZW50VHlwZS5TZW50XSA9IFwiU2VudFwiO1xuSHR0cEV2ZW50VHlwZVtIdHRwRXZlbnRUeXBlLlVwbG9hZFByb2dyZXNzXSA9IFwiVXBsb2FkUHJvZ3Jlc3NcIjtcbkh0dHBFdmVudFR5cGVbSHR0cEV2ZW50VHlwZS5SZXNwb25zZUhlYWRlcl0gPSBcIlJlc3BvbnNlSGVhZGVyXCI7XG5IdHRwRXZlbnRUeXBlW0h0dHBFdmVudFR5cGUuRG93bmxvYWRQcm9ncmVzc10gPSBcIkRvd25sb2FkUHJvZ3Jlc3NcIjtcbkh0dHBFdmVudFR5cGVbSHR0cEV2ZW50VHlwZS5SZXNwb25zZV0gPSBcIlJlc3BvbnNlXCI7XG5IdHRwRXZlbnRUeXBlW0h0dHBFdmVudFR5cGUuVXNlcl0gPSBcIlVzZXJcIjtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYm90aCBgSHR0cFJlc3BvbnNlYCBhbmQgYEh0dHBIZWFkZXJSZXNwb25zZWAuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEh0dHBSZXNwb25zZUJhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFN1cGVyLWNvbnN0cnVjdG9yIGZvciBhbGwgcmVzcG9uc2VzLlxuICAgICAqXG4gICAgICogVGhlIHNpbmdsZSBwYXJhbWV0ZXIgYWNjZXB0ZWQgaXMgYW4gaW5pdGlhbGl6YXRpb24gaGFzaC4gQW55IHByb3BlcnRpZXNcbiAgICAgKiBvZiB0aGUgcmVzcG9uc2UgcGFzc2VkIHRoZXJlIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7P30gaW5pdFxuICAgICAqIEBwYXJhbSB7Pz19IGRlZmF1bHRTdGF0dXNcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0U3RhdHVzVGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEh0dHBSZXNwb25zZUJhc2UoaW5pdCwgZGVmYXVsdFN0YXR1cywgZGVmYXVsdFN0YXR1c1RleHQpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRTdGF0dXMgPT09IHZvaWQgMCkgeyBkZWZhdWx0U3RhdHVzID0gMjAwOyB9XG4gICAgICAgIGlmIChkZWZhdWx0U3RhdHVzVGV4dCA9PT0gdm9pZCAwKSB7IGRlZmF1bHRTdGF0dXNUZXh0ID0gJ09LJzsgfVxuICAgICAgICAvLyBJZiB0aGUgaGFzaCBoYXMgdmFsdWVzIHBhc3NlZCwgdXNlIHRoZW0gdG8gaW5pdGlhbGl6ZSB0aGUgcmVzcG9uc2UuXG4gICAgICAgIC8vIE90aGVyd2lzZSB1c2UgdGhlIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICB0aGlzLmhlYWRlcnMgPSBpbml0LmhlYWRlcnMgfHwgbmV3IEh0dHBIZWFkZXJzKCk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gaW5pdC5zdGF0dXMgIT09IHVuZGVmaW5lZCA/IGluaXQuc3RhdHVzIDogZGVmYXVsdFN0YXR1cztcbiAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gaW5pdC5zdGF0dXNUZXh0IHx8IGRlZmF1bHRTdGF0dXNUZXh0O1xuICAgICAgICB0aGlzLnVybCA9IGluaXQudXJsIHx8IG51bGw7XG4gICAgICAgIC8vIENhY2hlIHRoZSBvayB2YWx1ZSB0byBhdm9pZCBkZWZpbmluZyBhIGdldHRlci5cbiAgICAgICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMDtcbiAgICB9XG4gICAgcmV0dXJuIEh0dHBSZXNwb25zZUJhc2U7XG59KCkpO1xuLyoqXG4gKiBBIHBhcnRpYWwgSFRUUCByZXNwb25zZSB3aGljaCBvbmx5IGluY2x1ZGVzIHRoZSBzdGF0dXMgYW5kIGhlYWRlciBkYXRhLFxuICogYnV0IG5vIHJlc3BvbnNlIGJvZHkuXG4gKlxuICogYEh0dHBIZWFkZXJSZXNwb25zZWAgaXMgYSBgSHR0cEV2ZW50YCBhdmFpbGFibGUgb24gdGhlIHJlc3BvbnNlXG4gKiBldmVudCBzdHJlYW0sIG9ubHkgd2hlbiBwcm9ncmVzcyBldmVudHMgYXJlIHJlcXVlc3RlZC5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqL1xudmFyIEh0dHBIZWFkZXJSZXNwb25zZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSHR0cEhlYWRlclJlc3BvbnNlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBgSHR0cEhlYWRlclJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Pz19IGluaXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIdHRwSGVhZGVyUmVzcG9uc2UoaW5pdCkge1xuICAgICAgICBpZiAoaW5pdCA9PT0gdm9pZCAwKSB7IGluaXQgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gSHR0cEV2ZW50VHlwZS5SZXNwb25zZUhlYWRlcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3B5IHRoaXMgYEh0dHBIZWFkZXJSZXNwb25zZWAsIG92ZXJyaWRpbmcgaXRzIGNvbnRlbnRzIHdpdGggdGhlXG4gICAgICogZ2l2ZW4gcGFyYW1ldGVyIGhhc2guXG4gICAgICogQHBhcmFtIHs/PX0gdXBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVyUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlID09PSB2b2lkIDApIHsgdXBkYXRlID0ge307IH1cbiAgICAgICAgLy8gUGVyZm9ybSBhIHN0cmFpZ2h0Zm9yd2FyZCBpbml0aWFsaXphdGlvbiBvZiB0aGUgbmV3IEh0dHBIZWFkZXJSZXNwb25zZSxcbiAgICAgICAgLy8gb3ZlcnJpZGluZyB0aGUgY3VycmVudCBwYXJhbWV0ZXJzIHdpdGggbmV3IG9uZXMgaWYgZ2l2ZW4uXG4gICAgICAgIHJldHVybiBuZXcgSHR0cEhlYWRlclJlc3BvbnNlKHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHVwZGF0ZS5oZWFkZXJzIHx8IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1czogdXBkYXRlLnN0YXR1cyAhPT0gdW5kZWZpbmVkID8gdXBkYXRlLnN0YXR1cyA6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogdXBkYXRlLnN0YXR1c1RleHQgfHwgdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgdXJsOiB1cGRhdGUudXJsIHx8IHRoaXMudXJsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSHR0cEhlYWRlclJlc3BvbnNlO1xufShIdHRwUmVzcG9uc2VCYXNlKSk7XG4vKipcbiAqIEEgZnVsbCBIVFRQIHJlc3BvbnNlLCBpbmNsdWRpbmcgYSB0eXBlZCByZXNwb25zZSBib2R5ICh3aGljaCBtYXkgYmUgYG51bGxgXG4gKiBpZiBvbmUgd2FzIG5vdCByZXR1cm5lZCkuXG4gKlxuICogYEh0dHBSZXNwb25zZWAgaXMgYSBgSHR0cEV2ZW50YCBhdmFpbGFibGUgb24gdGhlIHJlc3BvbnNlIGV2ZW50XG4gKiBzdHJlYW0uXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBIdHRwUmVzcG9uc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEh0dHBSZXNwb25zZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYEh0dHBSZXNwb25zZWAuXG4gICAgICogQHBhcmFtIHs/PX0gaW5pdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEh0dHBSZXNwb25zZShpbml0KSB7XG4gICAgICAgIGlmIChpbml0ID09PSB2b2lkIDApIHsgaW5pdCA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBIdHRwRXZlbnRUeXBlLlJlc3BvbnNlO1xuICAgICAgICBfdGhpcy5ib2R5ID0gaW5pdC5ib2R5IHx8IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gdXBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlID09PSB2b2lkIDApIHsgdXBkYXRlID0ge307IH1cbiAgICAgICAgcmV0dXJuIG5ldyBIdHRwUmVzcG9uc2Uoe1xuICAgICAgICAgICAgYm9keTogKHVwZGF0ZS5ib2R5ICE9PSB1bmRlZmluZWQpID8gdXBkYXRlLmJvZHkgOiB0aGlzLmJvZHksXG4gICAgICAgICAgICBoZWFkZXJzOiB1cGRhdGUuaGVhZGVycyB8fCB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzdGF0dXM6ICh1cGRhdGUuc3RhdHVzICE9PSB1bmRlZmluZWQpID8gdXBkYXRlLnN0YXR1cyA6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogdXBkYXRlLnN0YXR1c1RleHQgfHwgdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgdXJsOiB1cGRhdGUudXJsIHx8IHRoaXMudXJsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSHR0cFJlc3BvbnNlO1xufShIdHRwUmVzcG9uc2VCYXNlKSk7XG4vKipcbiAqIEEgcmVzcG9uc2UgdGhhdCByZXByZXNlbnRzIGFuIGVycm9yIG9yIGZhaWx1cmUsIGVpdGhlciBmcm9tIGFcbiAqIG5vbi1zdWNjZXNzZnVsIEhUVFAgc3RhdHVzLCBhbiBlcnJvciB3aGlsZSBleGVjdXRpbmcgdGhlIHJlcXVlc3QsXG4gKiBvciBzb21lIG90aGVyIGZhaWx1cmUgd2hpY2ggb2NjdXJyZWQgZHVyaW5nIHRoZSBwYXJzaW5nIG9mIHRoZSByZXNwb25zZS5cbiAqXG4gKiBBbnkgZXJyb3IgcmV0dXJuZWQgb24gdGhlIGBPYnNlcnZhYmxlYCByZXNwb25zZSBzdHJlYW0gd2lsbCBiZVxuICogd3JhcHBlZCBpbiBhbiBgSHR0cEVycm9yUmVzcG9uc2VgIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBjb250ZXh0IGFib3V0XG4gKiB0aGUgc3RhdGUgb2YgdGhlIEhUVFAgbGF5ZXIgd2hlbiB0aGUgZXJyb3Igb2NjdXJyZWQuIFRoZSBlcnJvciBwcm9wZXJ0eVxuICogd2lsbCBjb250YWluIGVpdGhlciBhIHdyYXBwZWQgRXJyb3Igb2JqZWN0IG9yIHRoZSBlcnJvciByZXNwb25zZSByZXR1cm5lZFxuICogZnJvbSB0aGUgc2VydmVyLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICovXG52YXIgSHR0cEVycm9yUmVzcG9uc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEh0dHBFcnJvclJlc3BvbnNlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5pdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEh0dHBFcnJvclJlc3BvbnNlKGluaXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gXG4gICAgICAgIC8vIEluaXRpYWxpemUgd2l0aCBhIGRlZmF1bHQgc3RhdHVzIG9mIDAgLyBVbmtub3duIEVycm9yLlxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBpbml0LCAwLCAnVW5rbm93biBFcnJvcicpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSAnSHR0cEVycm9yUmVzcG9uc2UnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXJyb3JzIGFyZSBuZXZlciBva2F5LCBldmVuIHdoZW4gdGhlIHN0YXR1cyBjb2RlIGlzIGluIHRoZSAyeHggc3VjY2VzcyByYW5nZS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLm9rID0gZmFsc2U7XG4gICAgICAgIC8vIElmIHRoZSByZXNwb25zZSB3YXMgc3VjY2Vzc2Z1bCwgdGhlbiB0aGlzIHdhcyBhIHBhcnNlIGVycm9yLiBPdGhlcndpc2UsIGl0IHdhc1xuICAgICAgICAvLyBhIHByb3RvY29sLWxldmVsIGZhaWx1cmUgb2Ygc29tZSBzb3J0LiBFaXRoZXIgdGhlIHJlcXVlc3QgZmFpbGVkIGluIHRyYW5zaXRcbiAgICAgICAgLy8gb3IgdGhlIHNlcnZlciByZXR1cm5lZCBhbiB1bnN1Y2Nlc3NmdWwgc3RhdHVzIGNvZGUuXG4gICAgICAgIGlmIChfdGhpcy5zdGF0dXMgPj0gMjAwICYmIF90aGlzLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgX3RoaXMubWVzc2FnZSA9IFwiSHR0cCBmYWlsdXJlIGR1cmluZyBwYXJzaW5nIGZvciBcIiArIChpbml0LnVybCB8fCAnKHVua25vd24gdXJsKScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMubWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgXCJIdHRwIGZhaWx1cmUgcmVzcG9uc2UgZm9yIFwiICsgKGluaXQudXJsIHx8ICcodW5rbm93biB1cmwpJykgKyBcIjogXCIgKyBpbml0LnN0YXR1cyArIFwiIFwiICsgaW5pdC5zdGF0dXNUZXh0O1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmVycm9yID0gaW5pdC5lcnJvciB8fCBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIdHRwRXJyb3JSZXNwb25zZTtcbn0oSHR0cFJlc3BvbnNlQmFzZSkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDb25zdHJ1Y3QgYW4gaW5zdGFuY2Ugb2YgYEh0dHBSZXF1ZXN0T3B0aW9uczxUPmAgZnJvbSBhIHNvdXJjZSBgSHR0cE1ldGhvZE9wdGlvbnNgIGFuZFxuICogdGhlIGdpdmVuIGBib2R5YC4gQmFzaWNhbGx5LCB0aGlzIGNsb25lcyB0aGUgb2JqZWN0IGFuZCBhZGRzIHRoZSBib2R5LlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICogQHBhcmFtIHs/fSBib2R5XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhZGRCb2R5KG9wdGlvbnMsIGJvZHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMsXG4gICAgICAgIG9ic2VydmU6IG9wdGlvbnMub2JzZXJ2ZSxcbiAgICAgICAgcGFyYW1zOiBvcHRpb25zLnBhcmFtcyxcbiAgICAgICAgcmVwb3J0UHJvZ3Jlc3M6IG9wdGlvbnMucmVwb3J0UHJvZ3Jlc3MsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogb3B0aW9ucy5yZXNwb25zZVR5cGUsXG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogb3B0aW9ucy53aXRoQ3JlZGVudGlhbHMsXG4gICAgfTtcbn1cbi8qKlxuICogUGVyZm9ybSBIVFRQIHJlcXVlc3RzLlxuICpcbiAqIGBIdHRwQ2xpZW50YCBpcyBhdmFpbGFibGUgYXMgYW4gaW5qZWN0YWJsZSBjbGFzcywgd2l0aCBtZXRob2RzIHRvIHBlcmZvcm0gSFRUUCByZXF1ZXN0cy5cbiAqIEVhY2ggcmVxdWVzdCBtZXRob2QgaGFzIG11bHRpcGxlIHNpZ25hdHVyZXMsIGFuZCB0aGUgcmV0dXJuIHR5cGUgdmFyaWVzIGFjY29yZGluZyB0byB3aGljaFxuICogc2lnbmF0dXJlIGlzIGNhbGxlZCAobWFpbmx5IHRoZSB2YWx1ZXMgb2YgYG9ic2VydmVgIGFuZCBgcmVzcG9uc2VUeXBlYCkuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBIdHRwQ2xpZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGhhbmRsZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIdHRwQ2xpZW50KGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgZm9yIGEgcGFydGljdWxhciBIVFRQIHJlcXVlc3QgdGhhdCwgd2hlbiBzdWJzY3JpYmVkLFxuICAgICAqIGZpcmVzIHRoZSByZXF1ZXN0IHRocm91Z2ggdGhlIGNoYWluIG9mIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzIGFuZCBvbiB0byB0aGVcbiAgICAgKiBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIGluIG9uZSBvZiB0d28gd2F5cy4gRWl0aGVyIGFuIGBIdHRwUmVxdWVzdGBcbiAgICAgKiBpbnN0YW5jZSBjYW4gYmUgcGFzc2VkIGRpcmVjdGx5IGFzIHRoZSBvbmx5IHBhcmFtZXRlciwgb3IgYSBtZXRob2QgY2FuIGJlXG4gICAgICogcGFzc2VkIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIsIGEgc3RyaW5nIFVSTCBhcyB0aGUgc2Vjb25kLCBhbmQgYW5cbiAgICAgKiBvcHRpb25zIGhhc2ggYXMgdGhlIHRoaXJkLlxuICAgICAqXG4gICAgICogSWYgYSBgSHR0cFJlcXVlc3RgIG9iamVjdCBpcyBwYXNzZWQgZGlyZWN0bHksIGFuIGBPYnNlcnZhYmxlYCBvZiB0aGVcbiAgICAgKiByYXcgYEh0dHBFdmVudGAgc3RyZWFtIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBJZiBhIHJlcXVlc3QgaXMgaW5zdGVhZCBidWlsdCBieSBwcm92aWRpbmcgYSBVUkwsIHRoZSBvcHRpb25zIG9iamVjdFxuICAgICAqIGRldGVybWluZXMgdGhlIHJldHVybiB0eXBlIG9mIGByZXF1ZXN0KClgLiBJbiBhZGRpdGlvbiB0byBjb25maWd1cmluZ1xuICAgICAqIHJlcXVlc3QgcGFyYW1ldGVycyBzdWNoIGFzIHRoZSBvdXRnb2luZyBoZWFkZXJzIGFuZC9vciB0aGUgYm9keSwgdGhlIG9wdGlvbnNcbiAgICAgKiBoYXNoIHNwZWNpZmllcyB0d28ga2V5IHBpZWNlcyBvZiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVxdWVzdDogdGhlXG4gICAgICogYHJlc3BvbnNlVHlwZWAgYW5kIHdoYXQgdG8gYG9ic2VydmVgLlxuICAgICAqXG4gICAgICogVGhlIGByZXNwb25zZVR5cGVgIHZhbHVlIGRldGVybWluZXMgaG93IGEgc3VjY2Vzc2Z1bCByZXNwb25zZSBib2R5IHdpbGwgYmVcbiAgICAgKiBwYXJzZWQuIElmIGByZXNwb25zZVR5cGVgIGlzIHRoZSBkZWZhdWx0IGBqc29uYCwgYSB0eXBlIGludGVyZmFjZSBmb3IgdGhlXG4gICAgICogcmVzdWx0aW5nIG9iamVjdCBtYXkgYmUgcGFzc2VkIGFzIGEgdHlwZSBwYXJhbWV0ZXIgdG8gYHJlcXVlc3QoKWAuXG4gICAgICpcbiAgICAgKiBUaGUgYG9ic2VydmVgIHZhbHVlIGRldGVybWluZXMgdGhlIHJldHVybiB0eXBlIG9mIGByZXF1ZXN0KClgLCBiYXNlZCBvbiB3aGF0XG4gICAgICogdGhlIGNvbnN1bWVyIGlzIGludGVyZXN0ZWQgaW4gb2JzZXJ2aW5nLiBBIHZhbHVlIG9mIGBldmVudHNgIHdpbGwgcmV0dXJuIGFuXG4gICAgICogYE9ic2VydmFibGU8SHR0cEV2ZW50PmAgcmVwcmVzZW50aW5nIHRoZSByYXcgYEh0dHBFdmVudGAgc3RyZWFtLFxuICAgICAqIGluY2x1ZGluZyBwcm9ncmVzcyBldmVudHMgYnkgZGVmYXVsdC4gQSB2YWx1ZSBvZiBgcmVzcG9uc2VgIHdpbGwgcmV0dXJuIGFuXG4gICAgICogYE9ic2VydmFibGU8SHR0cFJlc3BvbnNlPFQ+PmAgd2hlcmUgdGhlIGBUYCBwYXJhbWV0ZXIgb2YgYEh0dHBSZXNwb25zZWBcbiAgICAgKiBkZXBlbmRzIG9uIHRoZSBgcmVzcG9uc2VUeXBlYCBhbmQgYW55IG9wdGlvbmFsbHkgcHJvdmlkZWQgdHlwZSBwYXJhbWV0ZXIuXG4gICAgICogQSB2YWx1ZSBvZiBgYm9keWAgd2lsbCByZXR1cm4gYW4gYE9ic2VydmFibGU8VD5gIHdpdGggdGhlIHNhbWUgYFRgIGJvZHkgdHlwZS5cbiAgICAgKiBAcGFyYW0gez99IGZpcnN0XG4gICAgICogQHBhcmFtIHs/PX0gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cENsaWVudC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChmaXJzdCwgdXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcTtcbiAgICAgICAgLy8gRmlyc3RseSwgY2hlY2sgd2hldGhlciB0aGUgcHJpbWFyeSBhcmd1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBgSHR0cFJlcXVlc3RgLlxuICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBIdHRwUmVxdWVzdCkge1xuICAgICAgICAgICAgLy8gSXQgaXMuIFRoZSBvdGhlciBhcmd1bWVudHMgbXVzdCBiZSB1bmRlZmluZWQgKHBlciB0aGUgc2lnbmF0dXJlcykgYW5kIGNhbiBiZVxuICAgICAgICAgICAgLy8gaWdub3JlZC5cbiAgICAgICAgICAgIHJlcSA9IChmaXJzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJdCdzIGEgc3RyaW5nLCBzbyBpdCByZXByZXNlbnRzIGEgVVJMLiBDb25zdHJ1Y3QgYSByZXF1ZXN0IGJhc2VkIG9uIGl0LFxuICAgICAgICAgICAgLy8gYW5kIGluY29ycG9yYXRlIHRoZSByZW1haW5pbmcgYXJndW1lbnRzIChhc3N1bWluZyBHRVQgdW5sZXNzIGEgbWV0aG9kIGlzXG4gICAgICAgICAgICAvLyBwcm92aWRlZC5cbiAgICAgICAgICAgIHJlcSA9IG5ldyBIdHRwUmVxdWVzdChmaXJzdCwgLyoqIEB0eXBlIHs/fSAqLyAoKHVybCkpLCBvcHRpb25zLmJvZHkgfHwgbnVsbCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IG9wdGlvbnMucGFyYW1zLFxuICAgICAgICAgICAgICAgIHJlcG9ydFByb2dyZXNzOiBvcHRpb25zLnJlcG9ydFByb2dyZXNzLFxuICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIEpTT04gaXMgYXNzdW1lZCB0byBiZSByZXR1cm5lZCBmb3IgYWxsIGNhbGxzLlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogb3B0aW9ucy5yZXNwb25zZVR5cGUgfHwgJ2pzb24nLFxuICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogb3B0aW9ucy53aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGFydCB3aXRoIGFuIE9ic2VydmFibGUub2YoKSB0aGUgaW5pdGlhbCByZXF1ZXN0LCBhbmQgcnVuIHRoZSBoYW5kbGVyICh3aGljaFxuICAgICAgICAvLyBpbmNsdWRlcyBhbGwgaW50ZXJjZXB0b3JzKSBpbnNpZGUgYSBjb25jYXRNYXAoKS4gVGhpcyB3YXksIHRoZSBoYW5kbGVyIHJ1bnNcbiAgICAgICAgLy8gaW5zaWRlIGFuIE9ic2VydmFibGUgY2hhaW4sIHdoaWNoIGNhdXNlcyBpbnRlcmNlcHRvcnMgdG8gYmUgcmUtcnVuIG9uIGV2ZXJ5XG4gICAgICAgIC8vIHN1YnNjcmlwdGlvbiAodGhpcyBhbHNvIG1ha2VzIHJldHJpZXMgcmUtcnVuIHRoZSBoYW5kbGVyLCBpbmNsdWRpbmcgaW50ZXJjZXB0b3JzKS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnRzJCA9IHJ4anNfb3BlcmF0b3JfY29uY2F0TWFwLmNvbmNhdE1hcC5jYWxsKHJ4anNfb2JzZXJ2YWJsZV9vZi5vZihyZXEpLCBmdW5jdGlvbiAocmVxKSB7IHJldHVybiBfdGhpcy5oYW5kbGVyLmhhbmRsZShyZXEpOyB9KTtcbiAgICAgICAgLy8gSWYgY29taW5nIHZpYSB0aGUgQVBJIHNpZ25hdHVyZSB3aGljaCBhY2NlcHRzIGEgcHJldmlvdXNseSBjb25zdHJ1Y3RlZCBIdHRwUmVxdWVzdCxcbiAgICAgICAgLy8gdGhlIG9ubHkgb3B0aW9uIGlzIHRvIGdldCB0aGUgZXZlbnQgc3RyZWFtLiBPdGhlcndpc2UsIHJldHVybiB0aGUgZXZlbnQgc3RyZWFtIGlmXG4gICAgICAgIC8vIHRoYXQgaXMgd2hhdCB3YXMgcmVxdWVzdGVkLlxuICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBIdHRwUmVxdWVzdCB8fCBvcHRpb25zLm9ic2VydmUgPT09ICdldmVudHMnKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRzJDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgcmVxdWVzdGVkIHN0cmVhbSBjb250YWlucyBlaXRoZXIgdGhlIGZ1bGwgcmVzcG9uc2Ugb3IgdGhlIGJvZHkuIEluIGVpdGhlclxuICAgICAgICAvLyBjYXNlLCB0aGUgZmlyc3Qgc3RlcCBpcyB0byBmaWx0ZXIgdGhlIGV2ZW50IHN0cmVhbSB0byBleHRyYWN0IGEgc3RyZWFtIG9mXG4gICAgICAgIC8vIHJlc3BvbnNlcyhzKS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzJCA9IHJ4anNfb3BlcmF0b3JfZmlsdGVyLmZpbHRlci5jYWxsKGV2ZW50cyQsIGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQgaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2U7IH0pO1xuICAgICAgICAvLyBEZWNpZGUgd2hpY2ggc3RyZWFtIHRvIHJldHVybi5cbiAgICAgICAgc3dpdGNoIChvcHRpb25zLm9ic2VydmUgfHwgJ2JvZHknKSB7XG4gICAgICAgICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVxdWVzdGVkIHN0cmVhbSBpcyB0aGUgYm9keS4gTWFwIHRoZSByZXNwb25zZSBzdHJlYW0gdG8gdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgLy8gYm9keS4gVGhpcyBjb3VsZCBiZSBkb25lIG1vcmUgc2ltcGx5LCBidXQgYSBtaXNiZWhhdmluZyBpbnRlcmNlcHRvciBtaWdodFxuICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0aGUgcmVzcG9uc2UgYm9keSBpbnRvIGEgZGlmZmVyZW50IGZvcm1hdCBhbmQgaWdub3JlIHRoZSByZXF1ZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyByZXNwb25zZVR5cGUuIEd1YXJkIGFnYWluc3QgdGhpcyBieSB2YWxpZGF0aW5nIHRoYXQgdGhlIHJlc3BvbnNlIGlzIG9mIHRoZVxuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3RlZCB0eXBlLlxuICAgICAgICAgICAgICAgIHN3aXRjaCAocmVxLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhcnJheWJ1ZmZlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqc19vcGVyYXRvcl9tYXAubWFwLmNhbGwocmVzJCwgZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIGJvZHkgaXMgYW4gQXJyYXlCdWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5ib2R5ICE9PSBudWxsICYmICEocmVzLmJvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSBpcyBub3QgYW4gQXJyYXlCdWZmZXIuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdibG9iJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzX29wZXJhdG9yX21hcC5tYXAuY2FsbChyZXMkLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgYm9keSBpcyBhIEJsb2IuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5ib2R5ICE9PSBudWxsICYmICEocmVzLmJvZHkgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGlzIG5vdCBhIEJsb2IuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzX29wZXJhdG9yX21hcC5tYXAuY2FsbChyZXMkLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgYm9keSBpcyBhIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmJvZHkgIT09IG51bGwgJiYgdHlwZW9mIHJlcy5ib2R5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGlzIG5vdCBhIHN0cmluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gdmFsaWRhdGlvbiBuZWVkZWQgZm9yIEpTT04gcmVzcG9uc2VzLCBhcyB0aGV5IGNhbiBiZSBvZiBhbnkgdHlwZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzX29wZXJhdG9yX21hcC5tYXAuY2FsbChyZXMkLCBmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMuYm9keTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncmVzcG9uc2UnOlxuICAgICAgICAgICAgICAgIC8vIFRoZSByZXNwb25zZSBzdHJlYW0gd2FzIHJlcXVlc3RlZCBkaXJlY3RseSwgc28gcmV0dXJuIGl0LlxuICAgICAgICAgICAgICAgIHJldHVybiByZXMkO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IG5ldyBmdXR1cmUgb2JzZXJ2ZSB0eXBlcyBiZWluZyBhZGRlZC5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlYWNoYWJsZTogdW5oYW5kbGVkIG9ic2VydmUgdHlwZSBcIiArIG9wdGlvbnMub2JzZXJ2ZSArIFwifVwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIERFTEVURSByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgZGVsZXRlKClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwQ2xpZW50LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ0RFTEVURScsIHVybCwgLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIEdFVCByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgZ2V0KClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwQ2xpZW50LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ0dFVCcsIHVybCwgLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIEhFQUQgcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYGhlYWQoKWAncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBDbGllbnQucHJvdG90eXBlLmhlYWQgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ0hFQUQnLCB1cmwsIC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgYSByZXF1ZXN0XG4gICAgICogd2l0aCB0aGUgc3BlY2lhbCBtZXRob2QgYEpTT05QYCB0byBiZSBkaXNwYXRjaGVkIHZpYSB0aGUgaW50ZXJjZXB0b3IgcGlwZWxpbmUuXG4gICAgICpcbiAgICAgKiBBIHN1aXRhYmxlIGludGVyY2VwdG9yIG11c3QgYmUgaW5zdGFsbGVkIChlLmcuIHZpYSB0aGUgYEh0dHBDbGllbnRKc29ucE1vZHVsZWApLlxuICAgICAqIElmIG5vIHN1Y2ggaW50ZXJjZXB0b3IgaXMgcmVhY2hlZCwgdGhlbiB0aGUgYEpTT05QYCByZXF1ZXN0IHdpbGwgbGlrZWx5IGJlXG4gICAgICogcmVqZWN0ZWQgYnkgdGhlIGNvbmZpZ3VyZWQgYmFja2VuZC5cbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1BhcmFtXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwQ2xpZW50LnByb3RvdHlwZS5qc29ucCA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrUGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnSlNPTlAnLCB1cmwsIHtcbiAgICAgICAgICAgIHBhcmFtczogbmV3IEh0dHBQYXJhbXMoKS5hcHBlbmQoY2FsbGJhY2tQYXJhbSwgJ0pTT05QX0NBTExCQUNLJyksXG4gICAgICAgICAgICBvYnNlcnZlOiAnYm9keScsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIHRoZSBjb25maWd1cmVkXG4gICAgICogT1BUSU9OUyByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgb3B0aW9ucygpYCdzIHJldHVybiB0eXBlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cENsaWVudC5wcm90b3R5cGUub3B0aW9ucyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnT1BUSU9OUycsIHVybCwgLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIFBBVENIIHJlcXVlc3QgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlci4gU2VlIHRoZSBpbmRpdmlkdWFsIG92ZXJsb2FkcyBmb3JcbiAgICAgKiBkZXRhaWxzIG9mIGBwYXRjaCgpYCdzIHJldHVybiB0eXBlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/fSBib2R5XG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cENsaWVudC5wcm90b3R5cGUucGF0Y2ggPSBmdW5jdGlvbiAodXJsLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ1BBVENIJywgdXJsLCBhZGRCb2R5KG9wdGlvbnMsIGJvZHkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBQT1NUIHJlcXVlc3QgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlci4gU2VlIHRoZSBpbmRpdmlkdWFsIG92ZXJsb2FkcyBmb3JcbiAgICAgKiBkZXRhaWxzIG9mIGBwb3N0KClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez99IGJvZHlcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwQ2xpZW50LnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKHVybCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdQT1NUJywgdXJsLCBhZGRCb2R5KG9wdGlvbnMsIGJvZHkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBQT1NUIHJlcXVlc3QgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlci4gU2VlIHRoZSBpbmRpdmlkdWFsIG92ZXJsb2FkcyBmb3JcbiAgICAgKiBkZXRhaWxzIG9mIGBwb3N0KClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez99IGJvZHlcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwQ2xpZW50LnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAodXJsLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ1BVVCcsIHVybCwgYWRkQm9keShvcHRpb25zLCBib2R5KSk7XG4gICAgfTtcbiAgICByZXR1cm4gSHR0cENsaWVudDtcbn0oKSk7XG5IdHRwQ2xpZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkh0dHBDbGllbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBIdHRwSGFuZGxlciwgfSxcbl07IH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIGBIdHRwSGFuZGxlcmAgd2hpY2ggYXBwbGllcyBhbiBgSHR0cEludGVyY2VwdG9yYCB0byBhbiBgSHR0cFJlcXVlc3RgLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICovXG52YXIgSHR0cEludGVyY2VwdG9ySGFuZGxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuZXh0XG4gICAgICogQHBhcmFtIHs/fSBpbnRlcmNlcHRvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEh0dHBJbnRlcmNlcHRvckhhbmRsZXIobmV4dCwgaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvciA9IGludGVyY2VwdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cEludGVyY2VwdG9ySGFuZGxlci5wcm90b3R5cGUuaGFuZGxlID0gZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcmNlcHRvci5pbnRlcmNlcHQocmVxLCB0aGlzLm5leHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEh0dHBJbnRlcmNlcHRvckhhbmRsZXI7XG59KCkpO1xuLyoqXG4gKiBBIG11bHRpLXByb3ZpZGVyIHRva2VuIHdoaWNoIHJlcHJlc2VudHMgdGhlIGFycmF5IG9mIGBIdHRwSW50ZXJjZXB0b3JgcyB0aGF0XG4gKiBhcmUgcmVnaXN0ZXJlZC5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqL1xudmFyIEhUVFBfSU5URVJDRVBUT1JTID0gbmV3IF9hbmd1bGFyX2NvcmUuSW5qZWN0aW9uVG9rZW4oJ0hUVFBfSU5URVJDRVBUT1JTJyk7XG52YXIgTm9vcEludGVyY2VwdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb29wSW50ZXJjZXB0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxXG4gICAgICogQHBhcmFtIHs/fSBuZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wSW50ZXJjZXB0b3IucHJvdG90eXBlLmludGVyY2VwdCA9IGZ1bmN0aW9uIChyZXEsIG5leHQpIHtcbiAgICAgICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcSk7XG4gICAgfTtcbiAgICByZXR1cm4gTm9vcEludGVyY2VwdG9yO1xufSgpKTtcbk5vb3BJbnRlcmNlcHRvci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5Ob29wSW50ZXJjZXB0b3IuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIEV2ZXJ5IHJlcXVlc3QgbWFkZSB0aHJvdWdoIEpTT05QIG5lZWRzIGEgY2FsbGJhY2sgbmFtZSB0aGF0J3MgdW5pcXVlIGFjcm9zcyB0aGVcbi8vIHdob2xlIHBhZ2UuIEVhY2ggcmVxdWVzdCBpcyBhc3NpZ25lZCBhbiBpZCBhbmQgdGhlIGNhbGxiYWNrIG5hbWUgaXMgY29uc3RydWN0ZWRcbi8vIGZyb20gdGhhdC4gVGhlIG5leHQgaWQgdG8gYmUgYXNzaWduZWQgaXMgdHJhY2tlZCBpbiBhIGdsb2JhbCB2YXJpYWJsZSBoZXJlIHRoYXRcbi8vIGlzIHNoYXJlZCBhbW9uZyBhbGwgYXBwbGljYXRpb25zIG9uIHRoZSBwYWdlLlxudmFyIG5leHRSZXF1ZXN0SWQgPSAwO1xuLy8gRXJyb3IgdGV4dCBnaXZlbiB3aGVuIGEgSlNPTlAgc2NyaXB0IGlzIGluamVjdGVkLCBidXQgZG9lc24ndCBpbnZva2UgdGhlIGNhbGxiYWNrXG4vLyBwYXNzZWQgaW4gaXRzIFVSTC5cbnZhciBKU09OUF9FUlJfTk9fQ0FMTEJBQ0sgPSAnSlNPTlAgaW5qZWN0ZWQgc2NyaXB0IGRpZCBub3QgaW52b2tlIGNhbGxiYWNrLic7XG4vLyBFcnJvciB0ZXh0IGdpdmVuIHdoZW4gYSByZXF1ZXN0IGlzIHBhc3NlZCB0byB0aGUgSnNvbnBDbGllbnRCYWNrZW5kIHRoYXQgZG9lc24ndFxuLy8gaGF2ZSBhIHJlcXVlc3QgbWV0aG9kIEpTT05QLlxudmFyIEpTT05QX0VSUl9XUk9OR19NRVRIT0QgPSAnSlNPTlAgcmVxdWVzdHMgbXVzdCB1c2UgSlNPTlAgcmVxdWVzdCBtZXRob2QuJztcbnZhciBKU09OUF9FUlJfV1JPTkdfUkVTUE9OU0VfVFlQRSA9ICdKU09OUCByZXF1ZXN0cyBtdXN0IHVzZSBKc29uIHJlc3BvbnNlIHR5cGUuJztcbi8qKlxuICogREkgdG9rZW4vYWJzdHJhY3QgdHlwZSByZXByZXNlbnRpbmcgYSBtYXAgb2YgSlNPTlAgY2FsbGJhY2tzLlxuICpcbiAqIEluIHRoZSBicm93c2VyLCB0aGlzIHNob3VsZCBhbHdheXMgYmUgdGhlIGB3aW5kb3dgIG9iamVjdC5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgSnNvbnBDYWxsYmFja0NvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpzb25wQ2FsbGJhY2tDb250ZXh0KCkge1xuICAgIH1cbiAgICByZXR1cm4gSnNvbnBDYWxsYmFja0NvbnRleHQ7XG59KCkpO1xuLyoqXG4gKiBgSHR0cEJhY2tlbmRgIHRoYXQgb25seSBwcm9jZXNzZXMgYEh0dHBSZXF1ZXN0YCB3aXRoIHRoZSBKU09OUCBtZXRob2QsXG4gKiBieSBwZXJmb3JtaW5nIEpTT05QIHN0eWxlIHJlcXVlc3RzLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICovXG52YXIgSnNvbnBDbGllbnRCYWNrZW5kID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrTWFwXG4gICAgICogQHBhcmFtIHs/fSBkb2N1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEpzb25wQ2xpZW50QmFja2VuZChjYWxsYmFja01hcCwgZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja01hcCA9IGNhbGxiYWNrTWFwO1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgbmV4dCBjYWxsYmFjayBtZXRob2QsIGJ5IGluY3JlbWVudGluZyB0aGUgZ2xvYmFsIGBuZXh0UmVxdWVzdElkYC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEpzb25wQ2xpZW50QmFja2VuZC5wcm90b3R5cGUubmV4dENhbGxiYWNrID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJuZ19qc29ucF9jYWxsYmFja19cIiArIG5leHRSZXF1ZXN0SWQrKzsgfTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgSlNPTlAgcmVxdWVzdCBhbmQgcmV0dXJuIGFuIGV2ZW50IHN0cmVhbSBvZiB0aGUgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0gez99IHJlcVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSnNvbnBDbGllbnRCYWNrZW5kLnByb3RvdHlwZS5oYW5kbGUgPSBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIEZpcnN0bHksIGNoZWNrIGJvdGggdGhlIG1ldGhvZCBhbmQgcmVzcG9uc2UgdHlwZS4gSWYgZWl0aGVyIGRvZXNuJ3QgbWF0Y2hcbiAgICAgICAgLy8gdGhlbiB0aGUgcmVxdWVzdCB3YXMgaW1wcm9wZXJseSByb3V0ZWQgaGVyZSBhbmQgY2Fubm90IGJlIGhhbmRsZWQuXG4gICAgICAgIGlmIChyZXEubWV0aG9kICE9PSAnSlNPTlAnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTlBfRVJSX1dST05HX01FVEhPRCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVxLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTlBfRVJSX1dST05HX1JFU1BPTlNFX1RZUEUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBoYXBwZW5zIGluc2lkZSB0aGUgT2JzZXJ2YWJsZSBib3VuZGFyeS5cbiAgICAgICAgcmV0dXJuIG5ldyByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBzdGVwIHRvIG1ha2UgYSByZXF1ZXN0IGlzIHRvIGdlbmVyYXRlIHRoZSBjYWxsYmFjayBuYW1lLCBhbmQgcmVwbGFjZSB0aGVcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIHBsYWNlaG9sZGVyIGluIHRoZSBVUkwgd2l0aCB0aGUgbmFtZS4gQ2FyZSBoYXMgdG8gYmUgdGFrZW4gaGVyZSB0byBlbnN1cmVcbiAgICAgICAgICAgIC8vIGEgdHJhaWxpbmcgJiwgaWYgbWF0Y2hlZCwgZ2V0cyBpbnNlcnRlZCBiYWNrIGludG8gdGhlIFVSTCBpbiB0aGUgY29ycmVjdCBwbGFjZS5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhbGxiYWNrID0gX3RoaXMubmV4dENhbGxiYWNrKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmwgPSByZXEudXJsV2l0aFBhcmFtcy5yZXBsYWNlKC89SlNPTlBfQ0FMTEJBQ0soJnwkKS8sIFwiPVwiICsgY2FsbGJhY2sgKyBcIiQxXCIpO1xuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSA8c2NyaXB0PiB0YWcgYW5kIHBvaW50IGl0IGF0IHRoZSBVUkwuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlID0gX3RoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICBub2RlLnNyYyA9IHVybDtcbiAgICAgICAgICAgIC8vIEEgSlNPTlAgcmVxdWVzdCByZXF1aXJlcyB3YWl0aW5nIGZvciBtdWx0aXBsZSBjYWxsYmFja3MuIFRoZXNlIHZhcmlhYmxlc1xuICAgICAgICAgICAgLy8gYXJlIGNsb3NlZCBvdmVyIGFuZCB0cmFjayBzdGF0ZSBhY3Jvc3MgdGhvc2UgY2FsbGJhY2tzLlxuICAgICAgICAgICAgLy8gVGhlIHJlc3BvbnNlIG9iamVjdCwgaWYgb25lIGhhcyBiZWVuIHJlY2VpdmVkLCBvciBudWxsIG90aGVyd2lzZS5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvZHkgPSBudWxsO1xuICAgICAgICAgICAgLy8gV2hldGhlciB0aGUgcmVzcG9uc2UgY2FsbGJhY2sgaGFzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFdoZXRoZXIgdGhlIHJlcXVlc3QgaGFzIGJlZW4gY2FuY2VsbGVkIChhbmQgdGh1cyBhbnkgb3RoZXIgY2FsbGJhY2tzKVxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgcmVzcG9uc2UgY2FsbGJhY2sgaW4gdGhpcy5jYWxsYmFja01hcCAod2hpY2ggd2lsbCBiZSB0aGUgd2luZG93XG4gICAgICAgICAgICAvLyBvYmplY3QgaW4gdGhlIGJyb3dzZXIuIFRoZSBzY3JpcHQgYmVpbmcgbG9hZGVkIHZpYSB0aGUgPHNjcmlwdD4gdGFnIHdpbGxcbiAgICAgICAgICAgIC8vIGV2ZW50dWFsbHkgY2FsbCB0aGlzIGNhbGxiYWNrLlxuICAgICAgICAgICAgX3RoaXMuY2FsbGJhY2tNYXBbY2FsbGJhY2tdID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRhIGhhcyBiZWVuIHJlY2VpdmVkIGZyb20gdGhlIEpTT05QIHNjcmlwdC4gRmlyc3RseSwgZGVsZXRlIHRoaXMgY2FsbGJhY2suXG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLmNhbGxiYWNrTWFwW2NhbGxiYWNrXTtcbiAgICAgICAgICAgICAgICAvLyBOZXh0LCBtYWtlIHN1cmUgdGhlIHJlcXVlc3Qgd2Fzbid0IGNhbmNlbGxlZCBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNldCBzdGF0ZSB0byBpbmRpY2F0ZSBkYXRhIHdhcyByZWNlaXZlZC5cbiAgICAgICAgICAgICAgICBib2R5ID0gZGF0YTtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gY2xlYW51cCgpIGlzIGEgdXRpbGl0eSBjbG9zdXJlIHRoYXQgcmVtb3ZlcyB0aGUgPHNjcmlwdD4gZnJvbSB0aGUgcGFnZSBhbmRcbiAgICAgICAgICAgIC8vIHRoZSByZXNwb25zZSBjYWxsYmFjayBmcm9tIHRoZSB3aW5kb3cuIFRoaXMgbG9naWMgaXMgdXNlZCBpbiBib3RoIHRoZVxuICAgICAgICAgICAgLy8gc3VjY2VzcywgZXJyb3IsIGFuZCBjYW5jZWxsYXRpb24gcGF0aHMsIHNvIGl0J3MgZXh0cmFjdGVkIG91dCBmb3IgY29udmVuaWVuY2UuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgPHNjcmlwdD4gdGFnIGlmIGl0J3Mgc3RpbGwgb24gdGhlIHBhZ2UuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgcmVzcG9uc2UgY2FsbGJhY2sgZnJvbSB0aGUgY2FsbGJhY2tNYXAgKHdpbmRvdyBvYmplY3QgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gYnJvd3NlcikuXG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLmNhbGxiYWNrTWFwW2NhbGxiYWNrXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBvbkxvYWQoKSBpcyB0aGUgc3VjY2VzcyBjYWxsYmFjayB3aGljaCBydW5zIGFmdGVyIHRoZSByZXNwb25zZSBjYWxsYmFja1xuICAgICAgICAgICAgLy8gaWYgdGhlIEpTT05QIHNjcmlwdCBsb2FkcyBzdWNjZXNzZnVsbHkuIFRoZSBldmVudCBpdHNlbGYgaXMgdW5pbXBvcnRhbnQuXG4gICAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgd2VudCB3cm9uZywgb25Mb2FkKCkgbWF5IHJ1biB3aXRob3V0IHRoZSByZXNwb25zZSBjYWxsYmFja1xuICAgICAgICAgICAgLy8gaGF2aW5nIGJlZW4gaW52b2tlZC5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9uTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIHJlcXVlc3QgaGFzIGJlZW4gY2FuY2VsbGVkLlxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDbGVhbnVwIHRoZSBwYWdlLlxuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSByZXNwb25zZSBjYWxsYmFjayBoYXMgcnVuLlxuICAgICAgICAgICAgICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgaGFzbid0LCBzb21ldGhpbmcgd2VudCB3cm9uZyB3aXRoIHRoZSByZXF1ZXN0LiBSZXR1cm4gYW4gZXJyb3IgdmlhXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBPYnNlcnZhYmxlIGVycm9yIHBhdGguIEFsbCBKU09OUCBlcnJvcnMgaGF2ZSBzdGF0dXMgMC5cbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmV3IEh0dHBFcnJvclJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogJ0pTT05QIEVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoSlNPTlBfRVJSX05PX0NBTExCQUNLKSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MuIGJvZHkgZWl0aGVyIGNvbnRhaW5zIHRoZSByZXNwb25zZSBib2R5IG9yIG51bGwgaWYgbm9uZSB3YXNcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5lZC5cbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KG5ldyBIdHRwUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogJ09LJywgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIENvbXBsZXRlIHRoZSBzdHJlYW0sIHRoZSByZXNwb3NuZSBpcyBvdmVyLlxuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gb25FcnJvcigpIGlzIHRoZSBlcnJvciBjYWxsYmFjaywgd2hpY2ggcnVucyBpZiB0aGUgc2NyaXB0IHJldHVybmVkIGdlbmVyYXRlc1xuICAgICAgICAgICAgLy8gYSBKYXZhc2NyaXB0IGVycm9yLiBJdCBlbWl0cyB0aGUgZXJyb3IgdmlhIHRoZSBPYnNlcnZhYmxlIGVycm9yIGNoYW5uZWwgYXNcbiAgICAgICAgICAgIC8vIGEgSHR0cEVycm9yUmVzcG9uc2UuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3Qgd2FzIGFscmVhZHkgY2FuY2VsbGVkLCBubyBuZWVkIHRvIGVtaXQgYW55dGhpbmcuXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAvLyBXcmFwIHRoZSBlcnJvciBpbiBhIEh0dHBFcnJvclJlc3BvbnNlLlxuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKG5ldyBIdHRwRXJyb3JSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiAnSlNPTlAgRXJyb3InLCB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGJvdGggdGhlIHN1Y2Nlc3MgKGxvYWQpIGFuZCBlcnJvciBldmVudHMgb24gdGhlIDxzY3JpcHQ+IHRhZyxcbiAgICAgICAgICAgIC8vIGFuZCBhZGQgaXQgdG8gdGhlIHBhZ2UuXG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgX3RoaXMuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0IGhhcyBub3cgYmVlbiBzdWNjZXNzZnVsbHkgc2VudC5cbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoeyB0eXBlOiBIdHRwRXZlbnRUeXBlLlNlbnQgfSk7XG4gICAgICAgICAgICAvLyBDYW5jZWxsYXRpb24gaGFuZGxlci5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgdGhlIGNhbmNlbGxhdGlvbiBzbyBldmVudCBsaXN0ZW5lcnMgd29uJ3QgZG8gYW55dGhpbmcgZXZlbiBpZiBhbHJlYWR5IHNjaGVkdWxlZC5cbiAgICAgICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzIHNvIHRoZXkgd29uJ3QgcnVuIGlmIHRoZSBldmVudHMgbGF0ZXIgZmlyZS5cbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBBbmQgZmluYWxseSwgY2xlYW4gdXAgdGhlIHBhZ2UuXG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSnNvbnBDbGllbnRCYWNrZW5kO1xufSgpKTtcbkpzb25wQ2xpZW50QmFja2VuZC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5Kc29ucENsaWVudEJhY2tlbmQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBKc29ucENhbGxiYWNrQ29udGV4dCwgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb21tb24uRE9DVU1FTlQsXSB9LF0gfSxcbl07IH07XG4vKipcbiAqIEFuIGBIdHRwSW50ZXJjZXB0b3JgIHdoaWNoIGlkZW50aWZpZXMgcmVxdWVzdHMgd2l0aCB0aGUgbWV0aG9kIEpTT05QIGFuZFxuICogc2hpZnRzIHRoZW0gdG8gdGhlIGBKc29ucENsaWVudEJhY2tlbmRgLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICovXG52YXIgSnNvbnBJbnRlcmNlcHRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBqc29ucFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEpzb25wSW50ZXJjZXB0b3IoanNvbnApIHtcbiAgICAgICAgdGhpcy5qc29ucCA9IGpzb25wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcVxuICAgICAqIEBwYXJhbSB7P30gbmV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSnNvbnBJbnRlcmNlcHRvci5wcm90b3R5cGUuaW50ZXJjZXB0ID0gZnVuY3Rpb24gKHJlcSwgbmV4dCkge1xuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gJ0pTT05QJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuanNvbnAuaGFuZGxlKC8qKiBAdHlwZSB7P30gKi8gKHJlcSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaCBmb3Igbm9ybWFsIEhUVFAgcmVxdWVzdHMuXG4gICAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEpO1xuICAgIH07XG4gICAgcmV0dXJuIEpzb25wSW50ZXJjZXB0b3I7XG59KCkpO1xuSnNvbnBJbnRlcmNlcHRvci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5Kc29ucEludGVyY2VwdG9yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogSnNvbnBDbGllbnRCYWNrZW5kLCB9LFxuXTsgfTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBYU1NJX1BSRUZJWCA9IC9eXFwpXFxdXFx9Jyw/XFxuLztcbi8qKlxuICogRGV0ZXJtaW5lIGFuIGFwcHJvcHJpYXRlIFVSTCBmb3IgdGhlIHJlc3BvbnNlLCBieSBjaGVja2luZyBlaXRoZXJcbiAqIFhNTEh0dHBSZXF1ZXN0LnJlc3BvbnNlVVJMIG9yIHRoZSBYLVJlcXVlc3QtVVJMIGhlYWRlci5cbiAqIEBwYXJhbSB7P30geGhyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRSZXNwb25zZVVybCh4aHIpIHtcbiAgICBpZiAoJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgJiYgeGhyLnJlc3BvbnNlVVJMKSB7XG4gICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VVUkw7XG4gICAgfVxuICAgIGlmICgvXlgtUmVxdWVzdC1VUkw6L20udGVzdCh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB7XG4gICAgICAgIHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIGBYTUxIdHRwUmVxdWVzdGAgY29uc3RydWN0b3IuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIFhockZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhockZhY3RvcnkoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGhyRmFjdG9yeS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIFhockZhY3Rvcnk7XG59KCkpO1xuLyoqXG4gKiBBIGZhY3RvcnkgZm9yIFxcQHtsaW5rIEh0dHBYaHJCYWNrZW5kfSB0aGF0IHVzZXMgdGhlIGBYTUxIdHRwUmVxdWVzdGAgYnJvd3NlciBBUEkuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBCcm93c2VyWGhyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VyWGhyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJyb3dzZXJYaHIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKChuZXcgWE1MSHR0cFJlcXVlc3QoKSkpOyB9O1xuICAgIHJldHVybiBCcm93c2VyWGhyO1xufSgpKTtcbkJyb3dzZXJYaHIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuQnJvd3Nlclhoci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBBbiBgSHR0cEJhY2tlbmRgIHdoaWNoIHVzZXMgdGhlIFhNTEh0dHBSZXF1ZXN0IEFQSSB0byBzZW5kXG4gKiByZXF1ZXN0cyB0byBhIGJhY2tlbmQgc2VydmVyLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICovXG52YXIgSHR0cFhockJhY2tlbmQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30geGhyRmFjdG9yeVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEh0dHBYaHJCYWNrZW5kKHhockZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy54aHJGYWN0b3J5ID0geGhyRmFjdG9yeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIHJlcXVlc3QgYW5kIHJldHVybiBhIHN0cmVhbSBvZiByZXNwb25zZSBldmVudHMuXG4gICAgICogQHBhcmFtIHs/fSByZXFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBYaHJCYWNrZW5kLnByb3RvdHlwZS5oYW5kbGUgPSBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFF1aWNrIGNoZWNrIHRvIGdpdmUgYSBiZXR0ZXIgZXJyb3IgbWVzc2FnZSB3aGVuIGEgdXNlciBhdHRlbXB0cyB0byB1c2VcbiAgICAgICAgLy8gSHR0cENsaWVudC5qc29ucCgpIHdpdGhvdXQgaW5zdGFsbGluZyB0aGUgSnNvbnBDbGllbnRNb2R1bGVcbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09ICdKU09OUCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBjb25zdHJ1Y3QgSnNvbnAgcmVxdWVzdCB3aXRob3V0IEpzb25wQ2xpZW50TW9kdWxlIGluc3RhbGxlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXZlcnl0aGluZyBoYXBwZW5zIG9uIE9ic2VydmFibGUgc3Vic2NyaXB0aW9uLlxuICAgICAgICByZXR1cm4gbmV3IHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgLy8gU3RhcnQgYnkgc2V0dGluZyB1cCB0aGUgWEhSIG9iamVjdCB3aXRoIHJlcXVlc3QgbWV0aG9kLCBVUkwsIGFuZCB3aXRoQ3JlZGVudGlhbHMgZmxhZy5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHhociA9IF90aGlzLnhockZhY3RvcnkuYnVpbGQoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKHJlcS5tZXRob2QsIHJlcS51cmxXaXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGlmICghIXJlcS53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBhbGwgdGhlIHJlcXVlc3RlZCBoZWFkZXJzLlxuICAgICAgICAgICAgcmVxLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSwgdmFsdWVzKSB7IHJldHVybiB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZXMuam9pbignLCcpKTsgfSk7XG4gICAgICAgICAgICAvLyBBZGQgYW4gQWNjZXB0IGhlYWRlciBpZiBvbmUgaXNuJ3QgcHJlc2VudCBhbHJlYWR5LlxuICAgICAgICAgICAgaWYgKCFyZXEuaGVhZGVycy5oYXMoJ0FjY2VwdCcpKSB7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF1dG8tZGV0ZWN0IHRoZSBDb250ZW50LVR5cGUgaGVhZGVyIGlmIG9uZSBpc24ndCBwcmVzZW50IGFscmVhZHkuXG4gICAgICAgICAgICBpZiAoIXJlcS5oZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRlY3RlZFR5cGUgPSByZXEuZGV0ZWN0Q29udGVudFR5cGVIZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGltZXMgQ29udGVudC1UeXBlIGRldGVjdGlvbiBmYWlscy5cbiAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0ZWRUeXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCBkZXRlY3RlZFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB0aGUgcmVzcG9uc2VUeXBlIGlmIG9uZSB3YXMgcmVxdWVzdGVkLlxuICAgICAgICAgICAgaWYgKHJlcS5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gKHJlcS5yZXNwb25zZVR5cGUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgdGhlIHJlcXVlc3QgYm9keSBpZiBvbmUgaXMgcHJlc2VudC4gSWYgbm90LCB0aGlzIHdpbGwgYmUgc2V0IHRvIG51bGwuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXFCb2R5ID0gcmVxLnNlcmlhbGl6ZUJvZHkoKTtcbiAgICAgICAgICAgIC8vIElmIHByb2dyZXNzIGV2ZW50cyBhcmUgZW5hYmxlZCwgcmVzcG9uc2UgaGVhZGVycyB3aWxsIGJlIGRlbGl2ZXJlZFxuICAgICAgICAgICAgLy8gaW4gdHdvIGV2ZW50cyAtIHRoZSBIdHRwSGVhZGVyUmVzcG9uc2UgZXZlbnQgYW5kIHRoZSBmdWxsIEh0dHBSZXNwb25zZVxuICAgICAgICAgICAgLy8gZXZlbnQuIEhvd2V2ZXIsIHNpbmNlIHJlc3BvbnNlIGhlYWRlcnMgZG9uJ3QgY2hhbmdlIGluIGJldHdlZW4gdGhlc2VcbiAgICAgICAgICAgIC8vIHR3byBldmVudHMsIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBwYXJzZSB0aGVtIHR3aWNlLiBTbyBoZWFkZXJSZXNwb25zZVxuICAgICAgICAgICAgLy8gY2FjaGVzIHRoZSBkYXRhIGV4dHJhY3RlZCBmcm9tIHRoZSByZXNwb25zZSB3aGVuZXZlciBpdCdzIGZpcnN0IHBhcnNlZCxcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSBwYXJzaW5nIGlzbid0IGR1cGxpY2F0ZWQuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoZWFkZXJSZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBwYXJ0aWFsRnJvbVhociBleHRyYWN0cyB0aGUgSHR0cEhlYWRlclJlc3BvbnNlIGZyb20gdGhlIGN1cnJlbnQgWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgICAgIC8vIHN0YXRlLCBhbmQgbWVtb2l6ZXMgaXQgaW50byBoZWFkZXJSZXNwb25zZS5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRpYWxGcm9tWGhyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJSZXNwb25zZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlYWQgc3RhdHVzIGFuZCBub3JtYWxpemUgYW4gSUU5IGJ1ZyAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MCkuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdHVzID0geGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXM7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdHVzVGV4dCA9IHhoci5zdGF0dXNUZXh0IHx8ICdPSyc7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgaGVhZGVycyBmcm9tIFhNTEh0dHBSZXF1ZXN0IC0gdGhpcyBzdGVwIGlzIGxhenkuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGVhZGVycyA9IG5ldyBIdHRwSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAgICAgICAgICAgICAgIC8vIFJlYWQgdGhlIHJlc3BvbnNlIFVSTCBmcm9tIHRoZSBYTUxIdHRwUmVzcG9uc2UgaW5zdGFuY2UgYW5kIGZhbGwgYmFjayBvbiB0aGVcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IFVSTC5cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmwgPSBnZXRSZXNwb25zZVVybCh4aHIpIHx8IHJlcS51cmw7XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBIdHRwSGVhZGVyUmVzcG9uc2UgYW5kIG1lbW9pemUgaXQuXG4gICAgICAgICAgICAgICAgaGVhZGVyUmVzcG9uc2UgPSBuZXcgSHR0cEhlYWRlclJlc3BvbnNlKHsgaGVhZGVyczogaGVhZGVycywgc3RhdHVzOiBzdGF0dXMsIHN0YXR1c1RleHQ6IHN0YXR1c1RleHQsIHVybDogdXJsIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJSZXNwb25zZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBOZXh0LCBhIGZldyBjbG9zdXJlcyBhcmUgZGVmaW5lZCBmb3IgdGhlIHZhcmlvdXMgZXZlbnRzIHdoaWNoIFhNTEh0dHBSZXF1ZXN0IGNhblxuICAgICAgICAgICAgLy8gZW1pdC4gVGhpcyBhbGxvd3MgdGhlbSB0byBiZSB1bnJlZ2lzdGVyZWQgYXMgZXZlbnQgbGlzdGVuZXJzIGxhdGVyLlxuICAgICAgICAgICAgLy8gRmlyc3QgdXAgaXMgdGhlIGxvYWQgZXZlbnQsIHdoaWNoIHJlcHJlc2VudHMgYSByZXNwb25zZSBiZWluZyBmdWxseSBhdmFpbGFibGUuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVhZCByZXNwb25zZSBzdGF0ZSBmcm9tIHRoZSBtZW1vaXplZCBwYXJ0aWFsIGRhdGEuXG4gICAgICAgICAgICAgICAgdmFyIF9hID0gcGFydGlhbEZyb21YaHIoKSwgaGVhZGVycyA9IF9hLmhlYWRlcnMsIHN0YXR1cyA9IF9hLnN0YXR1cywgc3RhdHVzVGV4dCA9IF9hLnN0YXR1c1RleHQsIHVybCA9IF9hLnVybDtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYm9keSB3aWxsIGJlIHJlYWQgb3V0IGlmIHByZXNlbnQuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9keSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gMjA0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBYTUxIdHRwUmVxdWVzdC5yZXNwb25zZSBpZiBzZXQsIHJlc3BvbnNlVGV4dCBvdGhlcndpc2UuXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSAodHlwZW9mIHhoci5yZXNwb25zZSA9PT0gJ3VuZGVmaW5lZCcpID8geGhyLnJlc3BvbnNlVGV4dCA6IHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgYSBjb21tb24gWFNTSSBwcmVmaXggZnJvbSBzdHJpbmcgcmVzcG9uc2VzLlxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXRlcm1pbmUgaWYgdGhpcyBiZWhhdmlvciBzaG91bGQgYmUgb3B0aW9uYWwgYW5kIG1vdmVkIHRvIGFuIGludGVyY2VwdG9yLlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gYm9keS5yZXBsYWNlKFhTU0lfUFJFRklYLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsaXplIGFub3RoZXIgcG90ZW50aWFsIGJ1ZyAodGhpcyBvbmUgY29tZXMgZnJvbSBDT1JTKS5cbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9ICEhYm9keSA/IDIwMCA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9rIGRldGVybWluZXMgd2hldGhlciB0aGUgcmVzcG9uc2Ugd2lsbCBiZSB0cmFuc21pdHRlZCBvbiB0aGUgZXZlbnQgb3JcbiAgICAgICAgICAgICAgICAvLyBlcnJvciBjaGFubmVsLiBVbnN1Y2Nlc3NmdWwgc3RhdHVzIGNvZGVzIChub3QgMnh4KSB3aWxsIGFsd2F5cyBiZSBlcnJvcnMsXG4gICAgICAgICAgICAgICAgLy8gYnV0IGEgc3VjY2Vzc2Z1bCBzdGF0dXMgY29kZSBjYW4gc3RpbGwgcmVzdWx0IGluIGFuIGVycm9yIGlmIHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgLy8gYXNrZWQgZm9yIEpTT04gZGF0YSBhbmQgdGhlIGJvZHkgY2Fubm90IGJlIHBhcnNlZCBhcyBzdWNoLlxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9rID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgYm9keSBuZWVkcyB0byBiZSBwYXJzZWQgYXMgSlNPTiAoaW4gbWFueSBjYXNlcyB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIC8vIHdpbGwgaGF2ZSBkb25lIHRoYXQgYWxyZWFkeSkuXG4gICAgICAgICAgICAgICAgaWYgKG9rICYmIHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJyAmJiByZXEucmVzcG9uc2VUeXBlID09PSAnanNvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0aGUgcGFyc2UuIElmIGl0IGZhaWxzLCBhIHBhcnNlIGVycm9yIHNob3VsZCBiZSBkZWxpdmVyZWQgdG8gdGhlIHVzZXIuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV2ZW4gdGhvdWdoIHRoZSByZXNwb25zZSBzdGF0dXMgd2FzIDJ4eCwgdGhpcyBpcyBzdGlsbCBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9rID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcGFyc2UgZXJyb3IgY29udGFpbnMgdGhlIHRleHQgb2YgdGhlIGJvZHkgdGhhdCBmYWlsZWQgdG8gcGFyc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gKHsgZXJyb3I6IGVycm9yLCB0ZXh0OiBib2R5IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvaykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgaXMgZGVsaXZlcmVkIG9uIHRoZSBldmVudCBzdHJlYW0uXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQobmV3IEh0dHBSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZnVsbCBib2R5IGhhcyBiZWVuIHJlY2VpdmVkIGFuZCBkZWxpdmVyZWQsIG5vIGZ1cnRoZXIgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFyZSBwb3NzaWJsZS4gVGhpcyByZXF1ZXN0IGlzIGNvbXBsZXRlLlxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5zdWNjZXNzZnVsIHJlcXVlc3QgaXMgZGVsaXZlcmVkIG9uIHRoZSBlcnJvciBjaGFubmVsLlxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihuZXcgSHR0cEVycm9yUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGVycm9yIGluIHRoaXMgY2FzZSBpcyB0aGUgcmVzcG9uc2UgYm9keSAoZXJyb3IgZnJvbSB0aGUgc2VydmVyKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBUaGUgb25FcnJvciBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiBzb21ldGhpbmcgZ29lcyB3cm9uZyBhdCB0aGUgbmV0d29yayBsZXZlbC5cbiAgICAgICAgICAgIC8vIENvbm5lY3Rpb24gdGltZW91dCwgRE5TIGVycm9yLCBvZmZsaW5lLCBldGMuIFRoZXNlIGFyZSBhY3R1YWwgZXJyb3JzLCBhbmQgYXJlXG4gICAgICAgICAgICAvLyB0cmFuc21pdHRlZCBvbiB0aGUgZXJyb3IgY2hhbm5lbC5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXMgPSBuZXcgSHR0cEVycm9yUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCB8fCAnVW5rbm93biBFcnJvcicsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IocmVzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBUaGUgc2VudEhlYWRlcnMgZmxhZyB0cmFja3Mgd2hldGhlciB0aGUgSHR0cFJlc3BvbnNlSGVhZGVycyBldmVudFxuICAgICAgICAgICAgLy8gaGFzIGJlZW4gc2VudCBvbiB0aGUgc3RyZWFtLiBUaGlzIGlzIG5lY2Vzc2FyeSB0byB0cmFjayBpZiBwcm9ncmVzc1xuICAgICAgICAgICAgLy8gaXMgZW5hYmxlZCBzaW5jZSB0aGUgZXZlbnQgd2lsbCBiZSBzZW50IG9uIG9ubHkgdGhlIGZpcnN0IGRvd25sb2FkXG4gICAgICAgICAgICAvLyBwcm9nZXJzcyBldmVudC5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbnRIZWFkZXJzID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUaGUgZG93bmxvYWQgcHJvZ3Jlc3MgZXZlbnQgaGFuZGxlciwgd2hpY2ggaXMgb25seSByZWdpc3RlcmVkIGlmXG4gICAgICAgICAgICAvLyBwcm9ncmVzcyBldmVudHMgYXJlIGVuYWJsZWQuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbkRvd25Qcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIEh0dHBSZXNwb25zZUhlYWRlcnMgZXZlbnQgaWYgaXQgaGFzbid0IGJlZW4gc2VudCBhbHJlYWR5LlxuICAgICAgICAgICAgICAgIGlmICghc2VudEhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChwYXJ0aWFsRnJvbVhocigpKTtcbiAgICAgICAgICAgICAgICAgICAgc2VudEhlYWRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTdGFydCBidWlsZGluZyB0aGUgZG93bmxvYWQgcHJvZ3Jlc3MgZXZlbnQgdG8gZGVsaXZlciBvbiB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAvLyBldmVudCBzdHJlYW0uXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvZ3Jlc3NFdmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSHR0cEV2ZW50VHlwZS5Eb3dubG9hZFByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IGV2ZW50LmxvYWRlZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSBldmVudCBpZiBpdCdzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0V2ZW50LnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IHdhcyBmb3IgdGV4dCBjb250ZW50IGFuZCBhIHBhcnRpYWwgcmVzcG9uc2UgaXNcbiAgICAgICAgICAgICAgICAvLyBhdmFpbGFibGUgb24gWE1MSHR0cFJlcXVlc3QsIGluY2x1ZGUgaXQgaW4gdGhlIHByb2dyZXNzIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gdG8gYWxsb3cgZm9yIHN0cmVhbWluZyByZWFkcy5cbiAgICAgICAgICAgICAgICBpZiAocmVxLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnICYmICEheGhyLnJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0V2ZW50LnBhcnRpYWxUZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSwgZmlyZSB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChwcm9ncmVzc0V2ZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBUaGUgdXBsb2FkIHByb2dyZXNzIGV2ZW50IGhhbmRsZXIsIHdoaWNoIGlzIG9ubHkgcmVnaXN0ZXJlZCBpZlxuICAgICAgICAgICAgLy8gcHJvZ3Jlc3MgZXZlbnRzIGFyZSBlbmFibGVkLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb25VcFByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVXBsb2FkIHByb2dyZXNzIGV2ZW50cyBhcmUgc2ltcGxlci4gQmVnaW4gYnVpbGRpbmcgdGhlIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgLy8gZXZlbnQuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEh0dHBFdmVudFR5cGUuVXBsb2FkUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZDogZXZlbnQubG9hZGVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyBiZWluZyB1cGxvYWRlZCBpcyBhdmFpbGFibGUsIGluY2x1ZGVcbiAgICAgICAgICAgICAgICAvLyBpdC5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcy50b3RhbCA9IGV2ZW50LnRvdGFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZW5kIHRoZSBldmVudC5cbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHByb2dyZXNzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCByZWdpc3RlciBmb3IgbG9hZCBhbmQgZXJyb3IgZXZlbnRzLlxuICAgICAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgICAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAvLyBQcm9ncmVzcyBldmVudHMgYXJlIG9ubHkgZW5hYmxlZCBpZiByZXF1ZXN0ZWQuXG4gICAgICAgICAgICBpZiAocmVxLnJlcG9ydFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gRG93bmxvYWQgcHJvZ3Jlc3MgaXMgYWx3YXlzIGVuYWJsZWQgaWYgcmVxdWVzdGVkLlxuICAgICAgICAgICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIG9uRG93blByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAvLyBVcGxvYWQgcHJvZ3Jlc3MgZGVwZW5kcyBvbiB3aGV0aGVyIHRoZXJlIGlzIGEgYm9keSB0byB1cGxvYWQuXG4gICAgICAgICAgICAgICAgaWYgKHJlcUJvZHkgIT09IG51bGwgJiYgeGhyLnVwbG9hZCkge1xuICAgICAgICAgICAgICAgICAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgb25VcFByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXJlIHRoZSByZXF1ZXN0LCBhbmQgbm90aWZ5IHRoZSBldmVudCBzdHJlYW0gdGhhdCBpdCB3YXMgZmlyZWQuXG4gICAgICAgICAgICB4aHIuc2VuZChyZXFCb2R5KTtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoeyB0eXBlOiBIdHRwRXZlbnRUeXBlLlNlbnQgfSk7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSByZXR1cm4gZnJvbSB0aGUgT2JzZXJ2YWJsZSBmdW5jdGlvbiwgd2hpY2ggaXMgdGhlXG4gICAgICAgICAgICAvLyByZXF1ZXN0IGNhbmNlbGxhdGlvbiBoYW5kbGVyLlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBPbiBhIGNhbmNlbGxhdGlvbiwgcmVtb3ZlIGFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgICAgICAgICB4aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICB4aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5yZXBvcnRQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB4aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBvbkRvd25Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXFCb2R5ICE9PSBudWxsICYmIHhoci51cGxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci51cGxvYWQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBvblVwUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIGFib3J0IHRoZSBpbi1mbGlnaHQgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEh0dHBYaHJCYWNrZW5kO1xufSgpKTtcbkh0dHBYaHJCYWNrZW5kLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkh0dHBYaHJCYWNrZW5kLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogWGhyRmFjdG9yeSwgfSxcbl07IH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgWFNSRl9DT09LSUVfTkFNRSA9IG5ldyBfYW5ndWxhcl9jb3JlLkluamVjdGlvblRva2VuKCdYU1JGX0NPT0tJRV9OQU1FJyk7XG52YXIgWFNSRl9IRUFERVJfTkFNRSA9IG5ldyBfYW5ndWxhcl9jb3JlLkluamVjdGlvblRva2VuKCdYU1JGX0hFQURFUl9OQU1FJyk7XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBYU1JGIHRva2VuIHRvIHVzZSB3aXRoIHRoZSBuZXh0IG91dGdvaW5nIHJlcXVlc3QuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEh0dHBYc3JmVG9rZW5FeHRyYWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0dHBYc3JmVG9rZW5FeHRyYWN0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgWFNSRiB0b2tlbiB0byB1c2Ugd2l0aCBhbiBvdXRnb2luZyByZXF1ZXN0LlxuICAgICAqXG4gICAgICogV2lsbCBiZSBjYWxsZWQgZm9yIGV2ZXJ5IHJlcXVlc3QsIHNvIHRoZSB0b2tlbiBtYXkgY2hhbmdlIGJldHdlZW4gcmVxdWVzdHMuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwWHNyZlRva2VuRXh0cmFjdG9yLnByb3RvdHlwZS5nZXRUb2tlbiA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gSHR0cFhzcmZUb2tlbkV4dHJhY3Rvcjtcbn0oKSk7XG4vKipcbiAqIGBIdHRwWHNyZlRva2VuRXh0cmFjdG9yYCB3aGljaCByZXRyaWV2ZXMgdGhlIHRva2VuIGZyb20gYSBjb29raWUuXG4gKi9cbnZhciBIdHRwWHNyZkNvb2tpZUV4dHJhY3RvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkb2NcbiAgICAgKiBAcGFyYW0gez99IHBsYXRmb3JtXG4gICAgICogQHBhcmFtIHs/fSBjb29raWVOYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gSHR0cFhzcmZDb29raWVFeHRyYWN0b3IoZG9jLCBwbGF0Zm9ybSwgY29va2llTmFtZSkge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICB0aGlzLmNvb2tpZU5hbWUgPSBjb29raWVOYW1lO1xuICAgICAgICB0aGlzLmxhc3RDb29raWVTdHJpbmcgPSAnJztcbiAgICAgICAgdGhpcy5sYXN0VG9rZW4gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyc2VDb3VudCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFhzcmZDb29raWVFeHRyYWN0b3IucHJvdG90eXBlLmdldFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybSA9PT0gJ3NlcnZlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvb2tpZVN0cmluZyA9IHRoaXMuZG9jLmNvb2tpZSB8fCAnJztcbiAgICAgICAgaWYgKGNvb2tpZVN0cmluZyAhPT0gdGhpcy5sYXN0Q29va2llU3RyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlQ291bnQrKztcbiAgICAgICAgICAgIHRoaXMubGFzdFRva2VuID0gX2FuZ3VsYXJfY29tbW9uLsm1cGFyc2VDb29raWVWYWx1ZShjb29raWVTdHJpbmcsIHRoaXMuY29va2llTmFtZSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb29raWVTdHJpbmcgPSBjb29raWVTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFRva2VuO1xuICAgIH07XG4gICAgcmV0dXJuIEh0dHBYc3JmQ29va2llRXh0cmFjdG9yO1xufSgpKTtcbkh0dHBYc3JmQ29va2llRXh0cmFjdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkh0dHBYc3JmQ29va2llRXh0cmFjdG9yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvbW1vbi5ET0NVTUVOVCxdIH0sXSB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuUExBVEZPUk1fSUQsXSB9LF0gfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtYU1JGX0NPT0tJRV9OQU1FLF0gfSxdIH0sXG5dOyB9O1xuLyoqXG4gKiBgSHR0cEludGVyY2VwdG9yYCB3aGljaCBhZGRzIGFuIFhTUkYgdG9rZW4gdG8gZWxpZ2libGUgb3V0Z29pbmcgcmVxdWVzdHMuXG4gKi9cbnZhciBIdHRwWHNyZkludGVyY2VwdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2VuU2VydmljZVxuICAgICAqIEBwYXJhbSB7P30gaGVhZGVyTmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEh0dHBYc3JmSW50ZXJjZXB0b3IodG9rZW5TZXJ2aWNlLCBoZWFkZXJOYW1lKSB7XG4gICAgICAgIHRoaXMudG9rZW5TZXJ2aWNlID0gdG9rZW5TZXJ2aWNlO1xuICAgICAgICB0aGlzLmhlYWRlck5hbWUgPSBoZWFkZXJOYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcVxuICAgICAqIEBwYXJhbSB7P30gbmV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFhzcmZJbnRlcmNlcHRvci5wcm90b3R5cGUuaW50ZXJjZXB0ID0gZnVuY3Rpb24gKHJlcSwgbmV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsY1VybCA9IHJlcS51cmwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gU2tpcCBib3RoIG5vbi1tdXRhdGluZyByZXF1ZXN0cyBhbmQgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgLy8gTm9uLW11dGF0aW5nIHJlcXVlc3RzIGRvbid0IHJlcXVpcmUgYSB0b2tlbiwgYW5kIGFic29sdXRlIFVSTHMgcmVxdWlyZSBzcGVjaWFsIGhhbmRsaW5nXG4gICAgICAgIC8vIGFueXdheSBhcyB0aGUgY29va2llIHNldFxuICAgICAgICAvLyBvbiBvdXIgb3JpZ2luIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgdG9rZW4gZXhwZWN0ZWQgYnkgYW5vdGhlciBvcmlnaW4uXG4gICAgICAgIGlmIChyZXEubWV0aG9kID09PSAnR0VUJyB8fCByZXEubWV0aG9kID09PSAnSEVBRCcgfHwgbGNVcmwuc3RhcnRzV2l0aCgnaHR0cDovLycpIHx8XG4gICAgICAgICAgICBsY1VybC5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbiA9IHRoaXMudG9rZW5TZXJ2aWNlLmdldFRva2VuKCk7XG4gICAgICAgIC8vIEJlIGNhcmVmdWwgbm90IHRvIG92ZXJ3cml0ZSBhbiBleGlzdGluZyBoZWFkZXIgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICAgICAgaWYgKHRva2VuICE9PSBudWxsICYmICFyZXEuaGVhZGVycy5oYXModGhpcy5oZWFkZXJOYW1lKSkge1xuICAgICAgICAgICAgcmVxID0gcmVxLmNsb25lKHsgaGVhZGVyczogcmVxLmhlYWRlcnMuc2V0KHRoaXMuaGVhZGVyTmFtZSwgdG9rZW4pIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEpO1xuICAgIH07XG4gICAgcmV0dXJuIEh0dHBYc3JmSW50ZXJjZXB0b3I7XG59KCkpO1xuSHR0cFhzcmZJbnRlcmNlcHRvci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5IdHRwWHNyZkludGVyY2VwdG9yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogSHR0cFhzcmZUb2tlbkV4dHJhY3RvciwgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtYU1JGX0hFQURFUl9OQU1FLF0gfSxdIH0sXG5dOyB9O1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIGBIdHRwSGFuZGxlcmAgdGhhdCBhcHBsaWVzIGEgYnVuY2ggb2YgYEh0dHBJbnRlcmNlcHRvcmBzXG4gKiB0byBhIHJlcXVlc3QgYmVmb3JlIHBhc3NpbmcgaXQgdG8gdGhlIGdpdmVuIGBIdHRwQmFja2VuZGAuXG4gKlxuICogTWVhbnQgdG8gYmUgdXNlZCBhcyBhIGZhY3RvcnkgZnVuY3Rpb24gd2l0aGluIGBIdHRwQ2xpZW50TW9kdWxlYC5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqIEBwYXJhbSB7P30gYmFja2VuZFxuICogQHBhcmFtIHs/PX0gaW50ZXJjZXB0b3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpbnRlcmNlcHRpbmdIYW5kbGVyKGJhY2tlbmQsIGludGVyY2VwdG9ycykge1xuICAgIGlmIChpbnRlcmNlcHRvcnMgPT09IHZvaWQgMCkgeyBpbnRlcmNlcHRvcnMgPSBbXTsgfVxuICAgIGlmICghaW50ZXJjZXB0b3JzKSB7XG4gICAgICAgIHJldHVybiBiYWNrZW5kO1xuICAgIH1cbiAgICByZXR1cm4gaW50ZXJjZXB0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChuZXh0LCBpbnRlcmNlcHRvcikgeyByZXR1cm4gbmV3IEh0dHBJbnRlcmNlcHRvckhhbmRsZXIobmV4dCwgaW50ZXJjZXB0b3IpOyB9LCBiYWNrZW5kKTtcbn1cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hlcmUgdG8gc3RvcmUgSlNPTlAgY2FsbGJhY2tzLlxuICpcbiAqIE9yZGluYXJpbHkgSlNPTlAgY2FsbGJhY2tzIGFyZSBzdG9yZWQgb24gdGhlIGB3aW5kb3dgIG9iamVjdCwgYnV0IHRoaXMgbWF5IG5vdCBleGlzdFxuICogaW4gdGVzdCBlbnZpcm9ubWVudHMuIEluIHRoYXQgY2FzZSwgY2FsbGJhY2tzIGFyZSBzdG9yZWQgb24gYW4gYW5vbnltb3VzIG9iamVjdCBpbnN0ZWFkLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24ganNvbnBDYWxsYmFja0NvbnRleHQoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn1cbi8qKlxuICogYE5nTW9kdWxlYCB3aGljaCBhZGRzIFhTUkYgcHJvdGVjdGlvbiBzdXBwb3J0IHRvIG91dGdvaW5nIHJlcXVlc3RzLlxuICpcbiAqIFByb3ZpZGVkIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgYSBjb29raWUtYmFzZWQgWFNSRiBwcm90ZWN0aW9uIHN5c3RlbSwgdGhpc1xuICogbW9kdWxlIGNhbiBiZSB1c2VkIGRpcmVjdGx5IHRvIGNvbmZpZ3VyZSBYU1JGIHByb3RlY3Rpb24gd2l0aCB0aGUgY29ycmVjdFxuICogY29va2llIGFuZCBoZWFkZXIgbmFtZXMuXG4gKlxuICogSWYgbm8gc3VjaCBuYW1lcyBhcmUgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGlzIHRvIHVzZSBgWC1YU1JGLVRPS0VOYCBmb3JcbiAqIHRoZSBoZWFkZXIgbmFtZSBhbmQgYFhTUkYtVE9LRU5gIGZvciB0aGUgY29va2llIG5hbWUuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBIdHRwQ2xpZW50WHNyZk1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cENsaWVudFhzcmZNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdGhlIGRlZmF1bHQgWFNSRiBwcm90ZWN0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cENsaWVudFhzcmZNb2R1bGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBIdHRwQ2xpZW50WHNyZk1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogSHR0cFhzcmZJbnRlcmNlcHRvciwgdXNlQ2xhc3M6IE5vb3BJbnRlcmNlcHRvciB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZSBYU1JGIHByb3RlY3Rpb24gdG8gdXNlIHRoZSBnaXZlbiBjb29raWUgbmFtZSBvciBoZWFkZXIgbmFtZSxcbiAgICAgKiBvciB0aGUgZGVmYXVsdCBuYW1lcyAoYXMgZGVzY3JpYmVkIGFib3ZlKSBpZiBub3QgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cENsaWVudFhzcmZNb2R1bGUud2l0aE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEh0dHBDbGllbnRYc3JmTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb29raWVOYW1lID8geyBwcm92aWRlOiBYU1JGX0NPT0tJRV9OQU1FLCB1c2VWYWx1ZTogb3B0aW9ucy5jb29raWVOYW1lIH0gOiBbXSxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlck5hbWUgPyB7IHByb3ZpZGU6IFhTUkZfSEVBREVSX05BTUUsIHVzZVZhbHVlOiBvcHRpb25zLmhlYWRlck5hbWUgfSA6IFtdLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBIdHRwQ2xpZW50WHNyZk1vZHVsZTtcbn0oKSk7XG5IdHRwQ2xpZW50WHNyZk1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgSHR0cFhzcmZJbnRlcmNlcHRvcixcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBIVFRQX0lOVEVSQ0VQVE9SUywgdXNlRXhpc3Rpbmc6IEh0dHBYc3JmSW50ZXJjZXB0b3IsIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogSHR0cFhzcmZUb2tlbkV4dHJhY3RvciwgdXNlQ2xhc3M6IEh0dHBYc3JmQ29va2llRXh0cmFjdG9yIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogWFNSRl9DT09LSUVfTkFNRSwgdXNlVmFsdWU6ICdYU1JGLVRPS0VOJyB9LFxuICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IFhTUkZfSEVBREVSX05BTUUsIHVzZVZhbHVlOiAnWC1YU1JGLVRPS0VOJyB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkh0dHBDbGllbnRYc3JmTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIGBOZ01vZHVsZWAgd2hpY2ggcHJvdmlkZXMgdGhlIGBIdHRwQ2xpZW50YCBhbmQgYXNzb2NpYXRlZCBzZXJ2aWNlcy5cbiAqXG4gKiBJbnRlcmNlcHRvcnMgY2FuIGJlIGFkZGVkIHRvIHRoZSBjaGFpbiBiZWhpbmQgYEh0dHBDbGllbnRgIGJ5IGJpbmRpbmcgdGhlbVxuICogdG8gdGhlIG11bHRpcHJvdmlkZXIgZm9yIGBIVFRQX0lOVEVSQ0VQVE9SU2AuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBIdHRwQ2xpZW50TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwQ2xpZW50TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gSHR0cENsaWVudE1vZHVsZTtcbn0oKSk7XG5IdHRwQ2xpZW50TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgSHR0cENsaWVudFhzcmZNb2R1bGUud2l0aE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIEh0dHBDbGllbnQsXG4gICAgICAgICAgICAgICAgICAgIC8vIEh0dHBIYW5kbGVyIGlzIHRoZSBiYWNrZW5kICsgaW50ZXJjZXB0b3JzIGFuZCBpcyBjb25zdHJ1Y3RlZFxuICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyB0aGUgaW50ZXJjZXB0aW5nSGFuZGxlciBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBIdHRwSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGludGVyY2VwdGluZ0hhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzOiBbSHR0cEJhY2tlbmQsIFtuZXcgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpLCBuZXcgX2FuZ3VsYXJfY29yZS5JbmplY3QoSFRUUF9JTlRFUkNFUFRPUlMpXV0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIEh0dHBYaHJCYWNrZW5kLFxuICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEh0dHBCYWNrZW5kLCB1c2VFeGlzdGluZzogSHR0cFhockJhY2tlbmQgfSxcbiAgICAgICAgICAgICAgICAgICAgQnJvd3NlclhocixcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBYaHJGYWN0b3J5LCB1c2VFeGlzdGluZzogQnJvd3NlclhociB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkh0dHBDbGllbnRNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogYE5nTW9kdWxlYCB3aGljaCBlbmFibGVzIEpTT05QIHN1cHBvcnQgaW4gYEh0dHBDbGllbnRgLlxuICpcbiAqIFdpdGhvdXQgdGhpcyBtb2R1bGUsIEpzb25wIHJlcXVlc3RzIHdpbGwgcmVhY2ggdGhlIGJhY2tlbmRcbiAqIHdpdGggbWV0aG9kIEpTT05QLCB3aGVyZSB0aGV5J2xsIGJlIHJlamVjdGVkLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICovXG52YXIgSHR0cENsaWVudEpzb25wTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwQ2xpZW50SnNvbnBNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBIdHRwQ2xpZW50SnNvbnBNb2R1bGU7XG59KCkpO1xuSHR0cENsaWVudEpzb25wTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBKc29ucENsaWVudEJhY2tlbmQsXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogSnNvbnBDYWxsYmFja0NvbnRleHQsIHVzZUZhY3Rvcnk6IGpzb25wQ2FsbGJhY2tDb250ZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogSFRUUF9JTlRFUkNFUFRPUlMsIHVzZUNsYXNzOiBKc29ucEludGVyY2VwdG9yLCBtdWx0aTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkh0dHBDbGllbnRKc29ucE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuXG5leHBvcnRzLkh0dHBCYWNrZW5kID0gSHR0cEJhY2tlbmQ7XG5leHBvcnRzLkh0dHBIYW5kbGVyID0gSHR0cEhhbmRsZXI7XG5leHBvcnRzLkh0dHBDbGllbnQgPSBIdHRwQ2xpZW50O1xuZXhwb3J0cy5IdHRwSGVhZGVycyA9IEh0dHBIZWFkZXJzO1xuZXhwb3J0cy5IVFRQX0lOVEVSQ0VQVE9SUyA9IEhUVFBfSU5URVJDRVBUT1JTO1xuZXhwb3J0cy5Kc29ucENsaWVudEJhY2tlbmQgPSBKc29ucENsaWVudEJhY2tlbmQ7XG5leHBvcnRzLkpzb25wSW50ZXJjZXB0b3IgPSBKc29ucEludGVyY2VwdG9yO1xuZXhwb3J0cy5IdHRwQ2xpZW50SnNvbnBNb2R1bGUgPSBIdHRwQ2xpZW50SnNvbnBNb2R1bGU7XG5leHBvcnRzLkh0dHBDbGllbnRNb2R1bGUgPSBIdHRwQ2xpZW50TW9kdWxlO1xuZXhwb3J0cy5IdHRwQ2xpZW50WHNyZk1vZHVsZSA9IEh0dHBDbGllbnRYc3JmTW9kdWxlO1xuZXhwb3J0cy7JtWludGVyY2VwdGluZ0hhbmRsZXIgPSBpbnRlcmNlcHRpbmdIYW5kbGVyO1xuZXhwb3J0cy5IdHRwUGFyYW1zID0gSHR0cFBhcmFtcztcbmV4cG9ydHMuSHR0cFVybEVuY29kaW5nQ29kZWMgPSBIdHRwVXJsRW5jb2RpbmdDb2RlYztcbmV4cG9ydHMuSHR0cFJlcXVlc3QgPSBIdHRwUmVxdWVzdDtcbmV4cG9ydHMuSHR0cEVycm9yUmVzcG9uc2UgPSBIdHRwRXJyb3JSZXNwb25zZTtcbmV4cG9ydHMuSHR0cEV2ZW50VHlwZSA9IEh0dHBFdmVudFR5cGU7XG5leHBvcnRzLkh0dHBIZWFkZXJSZXNwb25zZSA9IEh0dHBIZWFkZXJSZXNwb25zZTtcbmV4cG9ydHMuSHR0cFJlc3BvbnNlID0gSHR0cFJlc3BvbnNlO1xuZXhwb3J0cy5IdHRwUmVzcG9uc2VCYXNlID0gSHR0cFJlc3BvbnNlQmFzZTtcbmV4cG9ydHMuSHR0cFhockJhY2tlbmQgPSBIdHRwWGhyQmFja2VuZDtcbmV4cG9ydHMuWGhyRmFjdG9yeSA9IFhockZhY3Rvcnk7XG5leHBvcnRzLkh0dHBYc3JmVG9rZW5FeHRyYWN0b3IgPSBIdHRwWHNyZlRva2VuRXh0cmFjdG9yO1xuZXhwb3J0cy7JtWEgPSBOb29wSW50ZXJjZXB0b3I7XG5leHBvcnRzLsm1YiA9IEpzb25wQ2FsbGJhY2tDb250ZXh0O1xuZXhwb3J0cy7JtWMgPSBqc29ucENhbGxiYWNrQ29udGV4dDtcbmV4cG9ydHMuybVkID0gQnJvd3NlclhocjtcbmV4cG9ydHMuybVnID0gSHR0cFhzcmZDb29raWVFeHRyYWN0b3I7XG5leHBvcnRzLsm1aCA9IEh0dHBYc3JmSW50ZXJjZXB0b3I7XG5leHBvcnRzLsm1ZSA9IFhTUkZfQ09PS0lFX05BTUU7XG5leHBvcnRzLsm1ZiA9IFhTUkZfSEVBREVSX05BTUU7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24taHR0cC51bWQuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGFuZ3VsYXIvY29tbW9uL2J1bmRsZXMvY29tbW9uLWh0dHAudW1kLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb25maXJtU2VydmljZSB9IGZyb20gJ0BzZXJ2aWNlcy9mcm9udGVuZC9jb25maXJtLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBBbGVydFNlcnZpY2UgfSBmcm9tICdAc2VydmljZXMvZnJvbnRlbmQvYWxlcnQuc2VydmljZSc7XHJcbmltcG9ydCB7IEFjdGl2YXRlZFJvdXRlLCBOYXZpZ2F0aW9uRW5kLCBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdhcHAnLFxyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vYXBwLmNvbXBvbmVudC5odG1sJyksXHJcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2FwcC5jb21wb25lbnQuY3NzJyldXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XHJcbiAgICByb3V0ZSQ6IFN1YnNjcmlwdGlvblxyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5yb3V0ZSQudW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucm91dGUkID0gdGhpcy5yb3V0ZXIuZXZlbnRzLnN1YnNjcmliZSgoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghKGV2dCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJvdXRlcjogUm91dGVyKSB7XHJcblxyXG4gICAgfVxyXG5cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL2FwcC9hcHAuY29tcG9uZW50LnRzIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdodXJlLWVycm9yJyxcclxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2Vycm9yLmNvbXBvbmVudC5odG1sJylcclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBFcnJvckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCkgeyB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL2FwcC9lbmQtdXNlci9lcnJvci9lcnJvci5jb21wb25lbnQudHMiLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBIb3ZlckVmZmVjdCB9IGZyb20gJy4vaG92ZXJFZmZlY3QuZGlyZWN0aXZlJztcclxuaW1wb3J0IHsgUmlwcGxlRGlyZWN0aXZlIH0gZnJvbSAnQGRpcmVjdGl2ZXMvcmlwcGxlLmRpcmVjdGl2ZSc7XHJcbmltcG9ydCB7IENsaWNrT3V0c2lkZURpcmVjdGl2ZSB9IGZyb20gJ0BkaXJlY3RpdmVzL2NsaWNrT3V0c2lkZS5kaXJlY3RpdmUnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICAgIGRlY2xhcmF0aW9uczogW0hvdmVyRWZmZWN0LCBDbGlja091dHNpZGVEaXJlY3RpdmUsIFJpcHBsZURpcmVjdGl2ZV0sXHJcbiAgICBpbXBvcnRzOiBbIENvbW1vbk1vZHVsZSBdLFxyXG4gICAgZXhwb3J0czogW0hvdmVyRWZmZWN0LCBDbGlja091dHNpZGVEaXJlY3RpdmUsIFJpcHBsZURpcmVjdGl2ZV0sXHJcbiAgICBwcm92aWRlcnM6IFtdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgRGlyZWN0aXZlTW9kdWxlIHt9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZGlyZWN0aXZlcy9kaXJlY3RpdmUubW9kdWxlLnRzIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgTGltaXRUZXh0UGlwZSB9IGZyb20gJ0BzaGFyZWQvcGlwZXMvbGltaXQtdGV4dC5waXBlJztcclxuXHJcbkBOZ01vZHVsZSh7XHJcbiAgICBkZWNsYXJhdGlvbnM6IFtMaW1pdFRleHRQaXBlXSxcclxuICAgIGltcG9ydHM6IFsgQ29tbW9uTW9kdWxlIF0sXHJcbiAgICBleHBvcnRzOiBbTGltaXRUZXh0UGlwZV0sXHJcbiAgICBwcm92aWRlcnM6IFtdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgUGlwZU1vZHVsZSB7fVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3BpcGVzL3BpcGUubW9kdWxlLnRzIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgTG9jYWxTZXJ2aWNlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxyXG4gICAgZ2V0R3VpZCgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlcklkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2VydmljZXMvYmFja2VuZC9sb2NhbC5zZXJ2aWNlLnRzIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgRGF0YVNlcnZpY2Uge1xyXG4gICAgcHVibGljIGRhdGE6IGFueVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2VydmljZXMvZnJvbnRlbmQvZGF0YS5zZXJ2aWNlLnRzIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIElucHV0LCBFdmVudEVtaXR0ZXIsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBEcm9wZG93bkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL2Ryb3Bkb3duSXRlbS9kcm9wZG93bkl0ZW0uY29tcG9uZW50JztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdodXJlLWRyb3Bkb3duJyxcclxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2Ryb3Bkb3duLmNvbXBvbmVudC5odG1sJyksXHJcbiAgICBzdHlsZXM6W3JlcXVpcmUoJy4vZHJvcGRvd24uY29tcG9uZW50LnNjc3MnKV1cclxufSlcclxuZXhwb3J0IGNsYXNzIERyb3Bkb3duQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcclxuICAgICAvLyBjaGFuZ2UgcmV0dXJuIERyb3Bkb3duSXRlbUNvbXBvbmVudCA9PiB0aGlzLnZhbHVlIHRvIGdldCB2YWx1ZVxyXG4gICAgIEBPdXRwdXQoKSBjaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcclxuICAgICBASW5wdXQoKSBwbGFjZWhvbGRlciA9IFwiSGVsbG9cIlxyXG4gICAgIC8vIGlzQWN0aXZhdGVkID0gdHJ1ZSA9PiBkcm9wZG93biBzaG93IGl0ZW1zXHJcbiAgICAgaXNBY3RpdmF0ZWQgPSBmYWxzZTtcclxuICAgICBpdGVtczogRHJvcGRvd25JdGVtQ29tcG9uZW50W10gPSBbXTtcclxuICAgICBzZWxlY3RlZEl0ZW06IGFueTtcclxuICAgICBjb25zdHJ1Y3RvcigpIHsgfVxyXG4gICAgIGFkZEl0ZW0oaXRlbTogRHJvcGRvd25JdGVtQ29tcG9uZW50KSB7XHJcbiAgICAgICAgIHRoaXMuaXRlbXMucHVzaChpdGVtKTtcclxuICAgICB9XHJcbiAgICAgc2VsZWN0SXRlbUVtaXQoaXRlbTogRHJvcGRvd25JdGVtQ29tcG9uZW50KSB7XHJcbiAgICAgICAgIHRoaXMuc2VsZWN0SXRlbShpdGVtKTtcclxuICAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdChpdGVtKTtcclxuICAgICAgICAgdGhpcy5pc0FjdGl2YXRlZCA9IGZhbHNlO1xyXG4gICAgIH1cclxuICAgICBzZWxlY3RJdGVtKGl0ZW06IERyb3Bkb3duSXRlbUNvbXBvbmVudCkge1xyXG4gICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goaSA9PiBpLmlzU2VsZWN0ZWQgPSBmYWxzZSk7XHJcbiAgICAgICAgIGl0ZW0uaXNTZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBpdGVtLnRleHQ7XHJcbiAgICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcclxuICAgICB9XHJcbiAgICAgbmdPbkluaXQoKSB7IH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2Ryb3Bkb3duL2Ryb3Bkb3duLmNvbXBvbmVudC50cyIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBUYWJDb21wb25lbnQgfSBmcm9tICcuL3RhYi90YWIuY29tcG9uZW50JztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdodXJlLXRhYmJlZCcsXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi90YWJiZWQuY29tcG9uZW50Lmh0bWwnKVxyXG59KVxyXG5leHBvcnQgY2xhc3MgVGFiYmVkQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcclxuICAgIEBJbnB1dCgpIGhlaWdodDogbnVtYmVyID0gMzAwO1xyXG4gICAgdGFiczogVGFiQ29tcG9uZW50W10gPSBbXVxyXG4gICAgY29uc3RydWN0b3IoKSB7IH1cclxuICAgIGFkZFRhYih0YWI6IFRhYkNvbXBvbmVudCkge1xyXG4gICAgICAgIHRoaXMudGFicy5wdXNoKHRhYik7XHJcbiAgICB9XHJcbiAgICBzZWxlY3RUYWIodGFiOiBUYWJDb21wb25lbnQpIHtcclxuICAgICAgICB0aGlzLnRhYnMuZm9yRWFjaCh0ID0+IHQuaXNBY3RpdmF0ZWQgPSBmYWxzZSk7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0YWIuaXNBY3RpdmF0ZWQgPSB0cnVlLCAyNTApXHJcbiAgICB9XHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL3RhYmJlZC90YWJiZWQuY29tcG9uZW50LnRzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9rZW5pemVyID0gcmVxdWlyZSgnLi4vdG9rZW5pemVyJyksXG4gICAgSFRNTCA9IHJlcXVpcmUoJy4vaHRtbCcpO1xuXG4vL0FsaWFzZXNcbnZhciAkID0gSFRNTC5UQUdfTkFNRVMsXG4gICAgTlMgPSBIVE1MLk5BTUVTUEFDRVMsXG4gICAgQVRUUlMgPSBIVE1MLkFUVFJTO1xuXG5cbi8vTUlNRSB0eXBlc1xudmFyIE1JTUVfVFlQRVMgPSB7XG4gICAgVEVYVF9IVE1MOiAndGV4dC9odG1sJyxcbiAgICBBUFBMSUNBVElPTl9YTUw6ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnXG59O1xuXG4vL0F0dHJpYnV0ZXNcbnZhciBERUZJTklUSU9OX1VSTF9BVFRSID0gJ2RlZmluaXRpb251cmwnLFxuICAgIEFESlVTVEVEX0RFRklOSVRJT05fVVJMX0FUVFIgPSAnZGVmaW5pdGlvblVSTCcsXG4gICAgU1ZHX0FUVFJTX0FESlVTVE1FTlRfTUFQID0ge1xuICAgICAgICAnYXR0cmlidXRlbmFtZSc6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgICAgICAgJ2F0dHJpYnV0ZXR5cGUnOiAnYXR0cmlidXRlVHlwZScsXG4gICAgICAgICdiYXNlZnJlcXVlbmN5JzogJ2Jhc2VGcmVxdWVuY3knLFxuICAgICAgICAnYmFzZXByb2ZpbGUnOiAnYmFzZVByb2ZpbGUnLFxuICAgICAgICAnY2FsY21vZGUnOiAnY2FsY01vZGUnLFxuICAgICAgICAnY2xpcHBhdGh1bml0cyc6ICdjbGlwUGF0aFVuaXRzJyxcbiAgICAgICAgJ2RpZmZ1c2Vjb25zdGFudCc6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICAgICAgICAnZWRnZW1vZGUnOiAnZWRnZU1vZGUnLFxuICAgICAgICAnZmlsdGVydW5pdHMnOiAnZmlsdGVyVW5pdHMnLFxuICAgICAgICAnZ2x5cGhyZWYnOiAnZ2x5cGhSZWYnLFxuICAgICAgICAnZ3JhZGllbnR0cmFuc2Zvcm0nOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICAgICAgICAnZ3JhZGllbnR1bml0cyc6ICdncmFkaWVudFVuaXRzJyxcbiAgICAgICAgJ2tlcm5lbG1hdHJpeCc6ICdrZXJuZWxNYXRyaXgnLFxuICAgICAgICAna2VybmVsdW5pdGxlbmd0aCc6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAgICAgICAgJ2tleXBvaW50cyc6ICdrZXlQb2ludHMnLFxuICAgICAgICAna2V5c3BsaW5lcyc6ICdrZXlTcGxpbmVzJyxcbiAgICAgICAgJ2tleXRpbWVzJzogJ2tleVRpbWVzJyxcbiAgICAgICAgJ2xlbmd0aGFkanVzdCc6ICdsZW5ndGhBZGp1c3QnLFxuICAgICAgICAnbGltaXRpbmdjb25lYW5nbGUnOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICAgICAgICAnbWFya2VyaGVpZ2h0JzogJ21hcmtlckhlaWdodCcsXG4gICAgICAgICdtYXJrZXJ1bml0cyc6ICdtYXJrZXJVbml0cycsXG4gICAgICAgICdtYXJrZXJ3aWR0aCc6ICdtYXJrZXJXaWR0aCcsXG4gICAgICAgICdtYXNrY29udGVudHVuaXRzJzogJ21hc2tDb250ZW50VW5pdHMnLFxuICAgICAgICAnbWFza3VuaXRzJzogJ21hc2tVbml0cycsXG4gICAgICAgICdudW1vY3RhdmVzJzogJ251bU9jdGF2ZXMnLFxuICAgICAgICAncGF0aGxlbmd0aCc6ICdwYXRoTGVuZ3RoJyxcbiAgICAgICAgJ3BhdHRlcm5jb250ZW50dW5pdHMnOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gICAgICAgICdwYXR0ZXJudHJhbnNmb3JtJzogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICAgICAgICAncGF0dGVybnVuaXRzJzogJ3BhdHRlcm5Vbml0cycsXG4gICAgICAgICdwb2ludHNhdHgnOiAncG9pbnRzQXRYJyxcbiAgICAgICAgJ3BvaW50c2F0eSc6ICdwb2ludHNBdFknLFxuICAgICAgICAncG9pbnRzYXR6JzogJ3BvaW50c0F0WicsXG4gICAgICAgICdwcmVzZXJ2ZWFscGhhJzogJ3ByZXNlcnZlQWxwaGEnLFxuICAgICAgICAncHJlc2VydmVhc3BlY3RyYXRpbyc6ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgICAgICAgJ3ByaW1pdGl2ZXVuaXRzJzogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgICAgICAgJ3JlZngnOiAncmVmWCcsXG4gICAgICAgICdyZWZ5JzogJ3JlZlknLFxuICAgICAgICAncmVwZWF0Y291bnQnOiAncmVwZWF0Q291bnQnLFxuICAgICAgICAncmVwZWF0ZHVyJzogJ3JlcGVhdER1cicsXG4gICAgICAgICdyZXF1aXJlZGV4dGVuc2lvbnMnOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgICAgICAgJ3JlcXVpcmVkZmVhdHVyZXMnOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gICAgICAgICdzcGVjdWxhcmNvbnN0YW50JzogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICAgICAgICAnc3BlY3VsYXJleHBvbmVudCc6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgICAgICAgJ3NwcmVhZG1ldGhvZCc6ICdzcHJlYWRNZXRob2QnLFxuICAgICAgICAnc3RhcnRvZmZzZXQnOiAnc3RhcnRPZmZzZXQnLFxuICAgICAgICAnc3RkZGV2aWF0aW9uJzogJ3N0ZERldmlhdGlvbicsXG4gICAgICAgICdzdGl0Y2h0aWxlcyc6ICdzdGl0Y2hUaWxlcycsXG4gICAgICAgICdzdXJmYWNlc2NhbGUnOiAnc3VyZmFjZVNjYWxlJyxcbiAgICAgICAgJ3N5c3RlbWxhbmd1YWdlJzogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgICAgICAgJ3RhYmxldmFsdWVzJzogJ3RhYmxlVmFsdWVzJyxcbiAgICAgICAgJ3RhcmdldHgnOiAndGFyZ2V0WCcsXG4gICAgICAgICd0YXJnZXR5JzogJ3RhcmdldFknLFxuICAgICAgICAndGV4dGxlbmd0aCc6ICd0ZXh0TGVuZ3RoJyxcbiAgICAgICAgJ3ZpZXdib3gnOiAndmlld0JveCcsXG4gICAgICAgICd2aWV3dGFyZ2V0JzogJ3ZpZXdUYXJnZXQnLFxuICAgICAgICAneGNoYW5uZWxzZWxlY3Rvcic6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgICAgICAgJ3ljaGFubmVsc2VsZWN0b3InOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gICAgICAgICd6b29tYW5kcGFuJzogJ3pvb21BbmRQYW4nXG4gICAgfSxcbiAgICBYTUxfQVRUUlNfQURKVVNUTUVOVF9NQVAgPSB7XG4gICAgICAgICd4bGluazphY3R1YXRlJzoge3ByZWZpeDogJ3hsaW5rJywgbmFtZTogJ2FjdHVhdGUnLCBuYW1lc3BhY2U6IE5TLlhMSU5LfSxcbiAgICAgICAgJ3hsaW5rOmFyY3JvbGUnOiB7cHJlZml4OiAneGxpbmsnLCBuYW1lOiAnYXJjcm9sZScsIG5hbWVzcGFjZTogTlMuWExJTkt9LFxuICAgICAgICAneGxpbms6aHJlZic6IHtwcmVmaXg6ICd4bGluaycsIG5hbWU6ICdocmVmJywgbmFtZXNwYWNlOiBOUy5YTElOS30sXG4gICAgICAgICd4bGluazpyb2xlJzoge3ByZWZpeDogJ3hsaW5rJywgbmFtZTogJ3JvbGUnLCBuYW1lc3BhY2U6IE5TLlhMSU5LfSxcbiAgICAgICAgJ3hsaW5rOnNob3cnOiB7cHJlZml4OiAneGxpbmsnLCBuYW1lOiAnc2hvdycsIG5hbWVzcGFjZTogTlMuWExJTkt9LFxuICAgICAgICAneGxpbms6dGl0bGUnOiB7cHJlZml4OiAneGxpbmsnLCBuYW1lOiAndGl0bGUnLCBuYW1lc3BhY2U6IE5TLlhMSU5LfSxcbiAgICAgICAgJ3hsaW5rOnR5cGUnOiB7cHJlZml4OiAneGxpbmsnLCBuYW1lOiAndHlwZScsIG5hbWVzcGFjZTogTlMuWExJTkt9LFxuICAgICAgICAneG1sOmJhc2UnOiB7cHJlZml4OiAneG1sJywgbmFtZTogJ2Jhc2UnLCBuYW1lc3BhY2U6IE5TLlhNTH0sXG4gICAgICAgICd4bWw6bGFuZyc6IHtwcmVmaXg6ICd4bWwnLCBuYW1lOiAnbGFuZycsIG5hbWVzcGFjZTogTlMuWE1MfSxcbiAgICAgICAgJ3htbDpzcGFjZSc6IHtwcmVmaXg6ICd4bWwnLCBuYW1lOiAnc3BhY2UnLCBuYW1lc3BhY2U6IE5TLlhNTH0sXG4gICAgICAgICd4bWxucyc6IHtwcmVmaXg6ICcnLCBuYW1lOiAneG1sbnMnLCBuYW1lc3BhY2U6IE5TLlhNTE5TfSxcbiAgICAgICAgJ3htbG5zOnhsaW5rJzoge3ByZWZpeDogJ3htbG5zJywgbmFtZTogJ3hsaW5rJywgbmFtZXNwYWNlOiBOUy5YTUxOU31cblxuICAgIH07XG5cbi8vU1ZHIHRhZyBuYW1lcyBhZGp1c3RtZW50IG1hcFxudmFyIFNWR19UQUdfTkFNRVNfQURKVVNUTUVOVF9NQVAgPSBleHBvcnRzLlNWR19UQUdfTkFNRVNfQURKVVNUTUVOVF9NQVAgPSB7XG4gICAgJ2FsdGdseXBoJzogJ2FsdEdseXBoJyxcbiAgICAnYWx0Z2x5cGhkZWYnOiAnYWx0R2x5cGhEZWYnLFxuICAgICdhbHRnbHlwaGl0ZW0nOiAnYWx0R2x5cGhJdGVtJyxcbiAgICAnYW5pbWF0ZWNvbG9yJzogJ2FuaW1hdGVDb2xvcicsXG4gICAgJ2FuaW1hdGVtb3Rpb24nOiAnYW5pbWF0ZU1vdGlvbicsXG4gICAgJ2FuaW1hdGV0cmFuc2Zvcm0nOiAnYW5pbWF0ZVRyYW5zZm9ybScsXG4gICAgJ2NsaXBwYXRoJzogJ2NsaXBQYXRoJyxcbiAgICAnZmVibGVuZCc6ICdmZUJsZW5kJyxcbiAgICAnZmVjb2xvcm1hdHJpeCc6ICdmZUNvbG9yTWF0cml4JyxcbiAgICAnZmVjb21wb25lbnR0cmFuc2Zlcic6ICdmZUNvbXBvbmVudFRyYW5zZmVyJyxcbiAgICAnZmVjb21wb3NpdGUnOiAnZmVDb21wb3NpdGUnLFxuICAgICdmZWNvbnZvbHZlbWF0cml4JzogJ2ZlQ29udm9sdmVNYXRyaXgnLFxuICAgICdmZWRpZmZ1c2VsaWdodGluZyc6ICdmZURpZmZ1c2VMaWdodGluZycsXG4gICAgJ2ZlZGlzcGxhY2VtZW50bWFwJzogJ2ZlRGlzcGxhY2VtZW50TWFwJyxcbiAgICAnZmVkaXN0YW50bGlnaHQnOiAnZmVEaXN0YW50TGlnaHQnLFxuICAgICdmZWZsb29kJzogJ2ZlRmxvb2QnLFxuICAgICdmZWZ1bmNhJzogJ2ZlRnVuY0EnLFxuICAgICdmZWZ1bmNiJzogJ2ZlRnVuY0InLFxuICAgICdmZWZ1bmNnJzogJ2ZlRnVuY0cnLFxuICAgICdmZWZ1bmNyJzogJ2ZlRnVuY1InLFxuICAgICdmZWdhdXNzaWFuYmx1cic6ICdmZUdhdXNzaWFuQmx1cicsXG4gICAgJ2ZlaW1hZ2UnOiAnZmVJbWFnZScsXG4gICAgJ2ZlbWVyZ2UnOiAnZmVNZXJnZScsXG4gICAgJ2ZlbWVyZ2Vub2RlJzogJ2ZlTWVyZ2VOb2RlJyxcbiAgICAnZmVtb3JwaG9sb2d5JzogJ2ZlTW9ycGhvbG9neScsXG4gICAgJ2Zlb2Zmc2V0JzogJ2ZlT2Zmc2V0JyxcbiAgICAnZmVwb2ludGxpZ2h0JzogJ2ZlUG9pbnRMaWdodCcsXG4gICAgJ2Zlc3BlY3VsYXJsaWdodGluZyc6ICdmZVNwZWN1bGFyTGlnaHRpbmcnLFxuICAgICdmZXNwb3RsaWdodCc6ICdmZVNwb3RMaWdodCcsXG4gICAgJ2ZldGlsZSc6ICdmZVRpbGUnLFxuICAgICdmZXR1cmJ1bGVuY2UnOiAnZmVUdXJidWxlbmNlJyxcbiAgICAnZm9yZWlnbm9iamVjdCc6ICdmb3JlaWduT2JqZWN0JyxcbiAgICAnZ2x5cGhyZWYnOiAnZ2x5cGhSZWYnLFxuICAgICdsaW5lYXJncmFkaWVudCc6ICdsaW5lYXJHcmFkaWVudCcsXG4gICAgJ3JhZGlhbGdyYWRpZW50JzogJ3JhZGlhbEdyYWRpZW50JyxcbiAgICAndGV4dHBhdGgnOiAndGV4dFBhdGgnXG59O1xuXG4vL1RhZ3MgdGhhdCBjYXVzZXMgZXhpdCBmcm9tIGZvcmVpZ24gY29udGVudFxudmFyIEVYSVRTX0ZPUkVJR05fQ09OVEVOVCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbkVYSVRTX0ZPUkVJR05fQ09OVEVOVFskLkJdID0gdHJ1ZTtcbkVYSVRTX0ZPUkVJR05fQ09OVEVOVFskLkJJR10gPSB0cnVlO1xuRVhJVFNfRk9SRUlHTl9DT05URU5UWyQuQkxPQ0tRVU9URV0gPSB0cnVlO1xuRVhJVFNfRk9SRUlHTl9DT05URU5UWyQuQk9EWV0gPSB0cnVlO1xuRVhJVFNfRk9SRUlHTl9DT05URU5UWyQuQlJdID0gdHJ1ZTtcbkVYSVRTX0ZPUkVJR05fQ09OVEVOVFskLkNFTlRFUl0gPSB0cnVlO1xuRVhJVFNfRk9SRUlHTl9DT05URU5UWyQuQ09ERV0gPSB0cnVlO1xuRVhJVFNfRk9SRUlHTl9DT05URU5UWyQuRERdID0gdHJ1ZTtcbkVYSVRTX0ZPUkVJR05fQ09OVEVOVFskLkRJVl0gPSB0cnVlO1xuRVhJVFNfRk9SRUlHTl9DT05URU5UWyQuRExdID0gdHJ1ZTtcbkVYSVRTX0ZPUkVJR05fQ09OVEVOVFskLkRUXSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5FTV0gPSB0cnVlO1xuRVhJVFNfRk9SRUlHTl9DT05URU5UWyQuRU1CRURdID0gdHJ1ZTtcbkVYSVRTX0ZPUkVJR05fQ09OVEVOVFskLkgxXSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5IMl0gPSB0cnVlO1xuRVhJVFNfRk9SRUlHTl9DT05URU5UWyQuSDNdID0gdHJ1ZTtcbkVYSVRTX0ZPUkVJR05fQ09OVEVOVFskLkg0XSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5INV0gPSB0cnVlO1xuRVhJVFNfRk9SRUlHTl9DT05URU5UWyQuSDZdID0gdHJ1ZTtcbkVYSVRTX0ZPUkVJR05fQ09OVEVOVFskLkhFQURdID0gdHJ1ZTtcbkVYSVRTX0ZPUkVJR05fQ09OVEVOVFskLkhSXSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5JXSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5JTUddID0gdHJ1ZTtcbkVYSVRTX0ZPUkVJR05fQ09OVEVOVFskLkxJXSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5MSVNUSU5HXSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5NRU5VXSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5NRVRBXSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5OT0JSXSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5PTF0gPSB0cnVlO1xuRVhJVFNfRk9SRUlHTl9DT05URU5UWyQuUF0gPSB0cnVlO1xuRVhJVFNfRk9SRUlHTl9DT05URU5UWyQuUFJFXSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5SVUJZXSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5TXSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5TTUFMTF0gPSB0cnVlO1xuRVhJVFNfRk9SRUlHTl9DT05URU5UWyQuU1BBTl0gPSB0cnVlO1xuRVhJVFNfRk9SRUlHTl9DT05URU5UWyQuU1RST05HXSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5TVFJJS0VdID0gdHJ1ZTtcbkVYSVRTX0ZPUkVJR05fQ09OVEVOVFskLlNVQl0gPSB0cnVlO1xuRVhJVFNfRk9SRUlHTl9DT05URU5UWyQuU1VQXSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5UQUJMRV0gPSB0cnVlO1xuRVhJVFNfRk9SRUlHTl9DT05URU5UWyQuVFRdID0gdHJ1ZTtcbkVYSVRTX0ZPUkVJR05fQ09OVEVOVFskLlVdID0gdHJ1ZTtcbkVYSVRTX0ZPUkVJR05fQ09OVEVOVFskLlVMXSA9IHRydWU7XG5FWElUU19GT1JFSUdOX0NPTlRFTlRbJC5WQVJdID0gdHJ1ZTtcblxuLy9DaGVjayBleGl0IGZyb20gZm9yZWlnbiBjb250ZW50XG5leHBvcnRzLmNhdXNlc0V4aXQgPSBmdW5jdGlvbiAoc3RhcnRUYWdUb2tlbikge1xuICAgIHZhciB0biA9IHN0YXJ0VGFnVG9rZW4udGFnTmFtZTtcbiAgICB2YXIgaXNGb250V2l0aEF0dHJzID0gdG4gPT09ICQuRk9OVCAmJiAoVG9rZW5pemVyLmdldFRva2VuQXR0cihzdGFydFRhZ1Rva2VuLCBBVFRSUy5DT0xPUikgIT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVG9rZW5pemVyLmdldFRva2VuQXR0cihzdGFydFRhZ1Rva2VuLCBBVFRSUy5TSVpFKSAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUb2tlbml6ZXIuZ2V0VG9rZW5BdHRyKHN0YXJ0VGFnVG9rZW4sIEFUVFJTLkZBQ0UpICE9PSBudWxsKTtcblxuICAgIHJldHVybiBpc0ZvbnRXaXRoQXR0cnMgPyB0cnVlIDogRVhJVFNfRk9SRUlHTl9DT05URU5UW3RuXTtcbn07XG5cbi8vVG9rZW4gYWRqdXN0bWVudHNcbmV4cG9ydHMuYWRqdXN0VG9rZW5NYXRoTUxBdHRycyA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW4uYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRva2VuLmF0dHJzW2ldLm5hbWUgPT09IERFRklOSVRJT05fVVJMX0FUVFIpIHtcbiAgICAgICAgICAgIHRva2VuLmF0dHJzW2ldLm5hbWUgPSBBREpVU1RFRF9ERUZJTklUSU9OX1VSTF9BVFRSO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnRzLmFkanVzdFRva2VuU1ZHQXR0cnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2VuLmF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhZGp1c3RlZEF0dHJOYW1lID0gU1ZHX0FUVFJTX0FESlVTVE1FTlRfTUFQW3Rva2VuLmF0dHJzW2ldLm5hbWVdO1xuXG4gICAgICAgIGlmIChhZGp1c3RlZEF0dHJOYW1lKVxuICAgICAgICAgICAgdG9rZW4uYXR0cnNbaV0ubmFtZSA9IGFkanVzdGVkQXR0ck5hbWU7XG4gICAgfVxufTtcblxuZXhwb3J0cy5hZGp1c3RUb2tlblhNTEF0dHJzID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbi5hdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYWRqdXN0ZWRBdHRyRW50cnkgPSBYTUxfQVRUUlNfQURKVVNUTUVOVF9NQVBbdG9rZW4uYXR0cnNbaV0ubmFtZV07XG5cbiAgICAgICAgaWYgKGFkanVzdGVkQXR0ckVudHJ5KSB7XG4gICAgICAgICAgICB0b2tlbi5hdHRyc1tpXS5wcmVmaXggPSBhZGp1c3RlZEF0dHJFbnRyeS5wcmVmaXg7XG4gICAgICAgICAgICB0b2tlbi5hdHRyc1tpXS5uYW1lID0gYWRqdXN0ZWRBdHRyRW50cnkubmFtZTtcbiAgICAgICAgICAgIHRva2VuLmF0dHJzW2ldLm5hbWVzcGFjZSA9IGFkanVzdGVkQXR0ckVudHJ5Lm5hbWVzcGFjZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydHMuYWRqdXN0VG9rZW5TVkdUYWdOYW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgdmFyIGFkanVzdGVkVGFnTmFtZSA9IFNWR19UQUdfTkFNRVNfQURKVVNUTUVOVF9NQVBbdG9rZW4udGFnTmFtZV07XG5cbiAgICBpZiAoYWRqdXN0ZWRUYWdOYW1lKVxuICAgICAgICB0b2tlbi50YWdOYW1lID0gYWRqdXN0ZWRUYWdOYW1lO1xufTtcblxuLy9JbnRlZ3JhdGlvbiBwb2ludHNcbmZ1bmN0aW9uIGlzTWF0aE1MVGV4dEludGVncmF0aW9uUG9pbnQodG4sIG5zKSB7XG4gICAgcmV0dXJuIG5zID09PSBOUy5NQVRITUwgJiYgKHRuID09PSAkLk1JIHx8IHRuID09PSAkLk1PIHx8IHRuID09PSAkLk1OIHx8IHRuID09PSAkLk1TIHx8IHRuID09PSAkLk1URVhUKTtcbn1cblxuZnVuY3Rpb24gaXNIdG1sSW50ZWdyYXRpb25Qb2ludCh0biwgbnMsIGF0dHJzKSB7XG4gICAgaWYgKG5zID09PSBOUy5NQVRITUwgJiYgdG4gPT09ICQuQU5OT1RBVElPTl9YTUwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGF0dHJzW2ldLm5hbWUgPT09IEFUVFJTLkVOQ09ESU5HKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbaV0udmFsdWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gTUlNRV9UWVBFUy5URVhUX0hUTUwgfHwgdmFsdWUgPT09IE1JTUVfVFlQRVMuQVBQTElDQVRJT05fWE1MO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5zID09PSBOUy5TVkcgJiYgKHRuID09PSAkLkZPUkVJR05fT0JKRUNUIHx8IHRuID09PSAkLkRFU0MgfHwgdG4gPT09ICQuVElUTEUpO1xufVxuXG5leHBvcnRzLmlzSW50ZWdyYXRpb25Qb2ludCA9IGZ1bmN0aW9uICh0biwgbnMsIGF0dHJzLCBmb3JlaWduTlMpIHtcbiAgICBpZiAoKCFmb3JlaWduTlMgfHwgZm9yZWlnbk5TID09PSBOUy5IVE1MKSAmJiBpc0h0bWxJbnRlZ3JhdGlvblBvaW50KHRuLCBucywgYXR0cnMpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGlmICgoIWZvcmVpZ25OUyB8fCBmb3JlaWduTlMgPT09IE5TLk1BVEhNTCkgJiYgaXNNYXRoTUxUZXh0SW50ZWdyYXRpb25Qb2ludCh0biwgbnMpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFyc2U1L2xpYi9jb21tb24vZm9yZWlnbl9jb250ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9rZW5pemVyID0gcmVxdWlyZSgnLi4vdG9rZW5pemVyJyksXG4gICAgT3BlbkVsZW1lbnRTdGFjayA9IHJlcXVpcmUoJy4vb3Blbl9lbGVtZW50X3N0YWNrJyksXG4gICAgRm9ybWF0dGluZ0VsZW1lbnRMaXN0ID0gcmVxdWlyZSgnLi9mb3JtYXR0aW5nX2VsZW1lbnRfbGlzdCcpLFxuICAgIGxvY2F0aW9uSW5mb01peGluID0gcmVxdWlyZSgnLi4vbG9jYXRpb25faW5mby9wYXJzZXJfbWl4aW4nKSxcbiAgICBkZWZhdWx0VHJlZUFkYXB0ZXIgPSByZXF1aXJlKCcuLi90cmVlX2FkYXB0ZXJzL2RlZmF1bHQnKSxcbiAgICBkb2N0eXBlID0gcmVxdWlyZSgnLi4vY29tbW9uL2RvY3R5cGUnKSxcbiAgICBmb3JlaWduQ29udGVudCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9mb3JlaWduX2NvbnRlbnQnKSxcbiAgICBtZXJnZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9jb21tb24vbWVyZ2Vfb3B0aW9ucycpLFxuICAgIFVOSUNPREUgPSByZXF1aXJlKCcuLi9jb21tb24vdW5pY29kZScpLFxuICAgIEhUTUwgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbCcpO1xuXG4vL0FsaWFzZXNcbnZhciAkID0gSFRNTC5UQUdfTkFNRVMsXG4gICAgTlMgPSBIVE1MLk5BTUVTUEFDRVMsXG4gICAgQVRUUlMgPSBIVE1MLkFUVFJTO1xuXG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGxvY2F0aW9uSW5mbzogZmFsc2UsXG4gICAgdHJlZUFkYXB0ZXI6IGRlZmF1bHRUcmVlQWRhcHRlclxufTtcblxuLy9NaXNjIGNvbnN0YW50c1xudmFyIEhJRERFTl9JTlBVVF9UWVBFID0gJ2hpZGRlbic7XG5cbi8vQWRvcHRpb24gYWdlbmN5IGxvb3BzIGl0ZXJhdGlvbiBjb3VudFxudmFyIEFBX09VVEVSX0xPT1BfSVRFUiA9IDgsXG4gICAgQUFfSU5ORVJfTE9PUF9JVEVSID0gMztcblxuLy9JbnNlcnRpb24gbW9kZXNcbnZhciBJTklUSUFMX01PREUgPSAnSU5JVElBTF9NT0RFJyxcbiAgICBCRUZPUkVfSFRNTF9NT0RFID0gJ0JFRk9SRV9IVE1MX01PREUnLFxuICAgIEJFRk9SRV9IRUFEX01PREUgPSAnQkVGT1JFX0hFQURfTU9ERScsXG4gICAgSU5fSEVBRF9NT0RFID0gJ0lOX0hFQURfTU9ERScsXG4gICAgQUZURVJfSEVBRF9NT0RFID0gJ0FGVEVSX0hFQURfTU9ERScsXG4gICAgSU5fQk9EWV9NT0RFID0gJ0lOX0JPRFlfTU9ERScsXG4gICAgVEVYVF9NT0RFID0gJ1RFWFRfTU9ERScsXG4gICAgSU5fVEFCTEVfTU9ERSA9ICdJTl9UQUJMRV9NT0RFJyxcbiAgICBJTl9UQUJMRV9URVhUX01PREUgPSAnSU5fVEFCTEVfVEVYVF9NT0RFJyxcbiAgICBJTl9DQVBUSU9OX01PREUgPSAnSU5fQ0FQVElPTl9NT0RFJyxcbiAgICBJTl9DT0xVTU5fR1JPVVBfTU9ERSA9ICdJTl9DT0xVTU5fR1JPVVBfTU9ERScsXG4gICAgSU5fVEFCTEVfQk9EWV9NT0RFID0gJ0lOX1RBQkxFX0JPRFlfTU9ERScsXG4gICAgSU5fUk9XX01PREUgPSAnSU5fUk9XX01PREUnLFxuICAgIElOX0NFTExfTU9ERSA9ICdJTl9DRUxMX01PREUnLFxuICAgIElOX1NFTEVDVF9NT0RFID0gJ0lOX1NFTEVDVF9NT0RFJyxcbiAgICBJTl9TRUxFQ1RfSU5fVEFCTEVfTU9ERSA9ICdJTl9TRUxFQ1RfSU5fVEFCTEVfTU9ERScsXG4gICAgSU5fVEVNUExBVEVfTU9ERSA9ICdJTl9URU1QTEFURV9NT0RFJyxcbiAgICBBRlRFUl9CT0RZX01PREUgPSAnQUZURVJfQk9EWV9NT0RFJyxcbiAgICBJTl9GUkFNRVNFVF9NT0RFID0gJ0lOX0ZSQU1FU0VUX01PREUnLFxuICAgIEFGVEVSX0ZSQU1FU0VUX01PREUgPSAnQUZURVJfRlJBTUVTRVRfTU9ERScsXG4gICAgQUZURVJfQUZURVJfQk9EWV9NT0RFID0gJ0FGVEVSX0FGVEVSX0JPRFlfTU9ERScsXG4gICAgQUZURVJfQUZURVJfRlJBTUVTRVRfTU9ERSA9ICdBRlRFUl9BRlRFUl9GUkFNRVNFVF9NT0RFJztcblxuLy9JbnNlcnRpb24gbW9kZSByZXNldCBtYXBcbnZhciBJTlNFUlRJT05fTU9ERV9SRVNFVF9NQVAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5JTlNFUlRJT05fTU9ERV9SRVNFVF9NQVBbJC5UUl0gPSBJTl9ST1dfTU9ERTtcbklOU0VSVElPTl9NT0RFX1JFU0VUX01BUFskLlRCT0RZXSA9XG5JTlNFUlRJT05fTU9ERV9SRVNFVF9NQVBbJC5USEVBRF0gPVxuSU5TRVJUSU9OX01PREVfUkVTRVRfTUFQWyQuVEZPT1RdID0gSU5fVEFCTEVfQk9EWV9NT0RFO1xuSU5TRVJUSU9OX01PREVfUkVTRVRfTUFQWyQuQ0FQVElPTl0gPSBJTl9DQVBUSU9OX01PREU7XG5JTlNFUlRJT05fTU9ERV9SRVNFVF9NQVBbJC5DT0xHUk9VUF0gPSBJTl9DT0xVTU5fR1JPVVBfTU9ERTtcbklOU0VSVElPTl9NT0RFX1JFU0VUX01BUFskLlRBQkxFXSA9IElOX1RBQkxFX01PREU7XG5JTlNFUlRJT05fTU9ERV9SRVNFVF9NQVBbJC5CT0RZXSA9IElOX0JPRFlfTU9ERTtcbklOU0VSVElPTl9NT0RFX1JFU0VUX01BUFskLkZSQU1FU0VUXSA9IElOX0ZSQU1FU0VUX01PREU7XG5cbi8vVGVtcGxhdGUgaW5zZXJ0aW9uIG1vZGUgc3dpdGNoIG1hcFxudmFyIFRFTVBMQVRFX0lOU0VSVElPTl9NT0RFX1NXSVRDSF9NQVAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5URU1QTEFURV9JTlNFUlRJT05fTU9ERV9TV0lUQ0hfTUFQWyQuQ0FQVElPTl0gPVxuVEVNUExBVEVfSU5TRVJUSU9OX01PREVfU1dJVENIX01BUFskLkNPTEdST1VQXSA9XG5URU1QTEFURV9JTlNFUlRJT05fTU9ERV9TV0lUQ0hfTUFQWyQuVEJPRFldID1cblRFTVBMQVRFX0lOU0VSVElPTl9NT0RFX1NXSVRDSF9NQVBbJC5URk9PVF0gPVxuVEVNUExBVEVfSU5TRVJUSU9OX01PREVfU1dJVENIX01BUFskLlRIRUFEXSA9IElOX1RBQkxFX01PREU7XG5URU1QTEFURV9JTlNFUlRJT05fTU9ERV9TV0lUQ0hfTUFQWyQuQ09MXSA9IElOX0NPTFVNTl9HUk9VUF9NT0RFO1xuVEVNUExBVEVfSU5TRVJUSU9OX01PREVfU1dJVENIX01BUFskLlRSXSA9IElOX1RBQkxFX0JPRFlfTU9ERTtcblRFTVBMQVRFX0lOU0VSVElPTl9NT0RFX1NXSVRDSF9NQVBbJC5URF0gPVxuVEVNUExBVEVfSU5TRVJUSU9OX01PREVfU1dJVENIX01BUFskLlRIXSA9IElOX1JPV19NT0RFO1xuXG4vL1Rva2VuIGhhbmRsZXJzIG1hcCBmb3IgaW5zZXJ0aW9uIG1vZGVzXG52YXIgXyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbl9bSU5JVElBTF9NT0RFXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5fW0lOSVRJQUxfTU9ERV1bVG9rZW5pemVyLkNIQVJBQ1RFUl9UT0tFTl0gPVxuX1tJTklUSUFMX01PREVdW1Rva2VuaXplci5OVUxMX0NIQVJBQ1RFUl9UT0tFTl0gPSB0b2tlbkluSW5pdGlhbE1vZGU7XG5fW0lOSVRJQUxfTU9ERV1bVG9rZW5pemVyLldISVRFU1BBQ0VfQ0hBUkFDVEVSX1RPS0VOXSA9IGlnbm9yZVRva2VuO1xuX1tJTklUSUFMX01PREVdW1Rva2VuaXplci5DT01NRU5UX1RPS0VOXSA9IGFwcGVuZENvbW1lbnQ7XG5fW0lOSVRJQUxfTU9ERV1bVG9rZW5pemVyLkRPQ1RZUEVfVE9LRU5dID0gZG9jdHlwZUluSW5pdGlhbE1vZGU7XG5fW0lOSVRJQUxfTU9ERV1bVG9rZW5pemVyLlNUQVJUX1RBR19UT0tFTl0gPVxuX1tJTklUSUFMX01PREVdW1Rva2VuaXplci5FTkRfVEFHX1RPS0VOXSA9XG5fW0lOSVRJQUxfTU9ERV1bVG9rZW5pemVyLkVPRl9UT0tFTl0gPSB0b2tlbkluSW5pdGlhbE1vZGU7XG5cbl9bQkVGT1JFX0hUTUxfTU9ERV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuX1tCRUZPUkVfSFRNTF9NT0RFXVtUb2tlbml6ZXIuQ0hBUkFDVEVSX1RPS0VOXSA9XG5fW0JFRk9SRV9IVE1MX01PREVdW1Rva2VuaXplci5OVUxMX0NIQVJBQ1RFUl9UT0tFTl0gPSB0b2tlbkJlZm9yZUh0bWw7XG5fW0JFRk9SRV9IVE1MX01PREVdW1Rva2VuaXplci5XSElURVNQQUNFX0NIQVJBQ1RFUl9UT0tFTl0gPSBpZ25vcmVUb2tlbjtcbl9bQkVGT1JFX0hUTUxfTU9ERV1bVG9rZW5pemVyLkNPTU1FTlRfVE9LRU5dID0gYXBwZW5kQ29tbWVudDtcbl9bQkVGT1JFX0hUTUxfTU9ERV1bVG9rZW5pemVyLkRPQ1RZUEVfVE9LRU5dID0gaWdub3JlVG9rZW47XG5fW0JFRk9SRV9IVE1MX01PREVdW1Rva2VuaXplci5TVEFSVF9UQUdfVE9LRU5dID0gc3RhcnRUYWdCZWZvcmVIdG1sO1xuX1tCRUZPUkVfSFRNTF9NT0RFXVtUb2tlbml6ZXIuRU5EX1RBR19UT0tFTl0gPSBlbmRUYWdCZWZvcmVIdG1sO1xuX1tCRUZPUkVfSFRNTF9NT0RFXVtUb2tlbml6ZXIuRU9GX1RPS0VOXSA9IHRva2VuQmVmb3JlSHRtbDtcblxuX1tCRUZPUkVfSEVBRF9NT0RFXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5fW0JFRk9SRV9IRUFEX01PREVdW1Rva2VuaXplci5DSEFSQUNURVJfVE9LRU5dID1cbl9bQkVGT1JFX0hFQURfTU9ERV1bVG9rZW5pemVyLk5VTExfQ0hBUkFDVEVSX1RPS0VOXSA9IHRva2VuQmVmb3JlSGVhZDtcbl9bQkVGT1JFX0hFQURfTU9ERV1bVG9rZW5pemVyLldISVRFU1BBQ0VfQ0hBUkFDVEVSX1RPS0VOXSA9IGlnbm9yZVRva2VuO1xuX1tCRUZPUkVfSEVBRF9NT0RFXVtUb2tlbml6ZXIuQ09NTUVOVF9UT0tFTl0gPSBhcHBlbmRDb21tZW50O1xuX1tCRUZPUkVfSEVBRF9NT0RFXVtUb2tlbml6ZXIuRE9DVFlQRV9UT0tFTl0gPSBpZ25vcmVUb2tlbjtcbl9bQkVGT1JFX0hFQURfTU9ERV1bVG9rZW5pemVyLlNUQVJUX1RBR19UT0tFTl0gPSBzdGFydFRhZ0JlZm9yZUhlYWQ7XG5fW0JFRk9SRV9IRUFEX01PREVdW1Rva2VuaXplci5FTkRfVEFHX1RPS0VOXSA9IGVuZFRhZ0JlZm9yZUhlYWQ7XG5fW0JFRk9SRV9IRUFEX01PREVdW1Rva2VuaXplci5FT0ZfVE9LRU5dID0gdG9rZW5CZWZvcmVIZWFkO1xuXG5fW0lOX0hFQURfTU9ERV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuX1tJTl9IRUFEX01PREVdW1Rva2VuaXplci5DSEFSQUNURVJfVE9LRU5dID1cbl9bSU5fSEVBRF9NT0RFXVtUb2tlbml6ZXIuTlVMTF9DSEFSQUNURVJfVE9LRU5dID0gdG9rZW5JbkhlYWQ7XG5fW0lOX0hFQURfTU9ERV1bVG9rZW5pemVyLldISVRFU1BBQ0VfQ0hBUkFDVEVSX1RPS0VOXSA9IGluc2VydENoYXJhY3RlcnM7XG5fW0lOX0hFQURfTU9ERV1bVG9rZW5pemVyLkNPTU1FTlRfVE9LRU5dID0gYXBwZW5kQ29tbWVudDtcbl9bSU5fSEVBRF9NT0RFXVtUb2tlbml6ZXIuRE9DVFlQRV9UT0tFTl0gPSBpZ25vcmVUb2tlbjtcbl9bSU5fSEVBRF9NT0RFXVtUb2tlbml6ZXIuU1RBUlRfVEFHX1RPS0VOXSA9IHN0YXJ0VGFnSW5IZWFkO1xuX1tJTl9IRUFEX01PREVdW1Rva2VuaXplci5FTkRfVEFHX1RPS0VOXSA9IGVuZFRhZ0luSGVhZDtcbl9bSU5fSEVBRF9NT0RFXVtUb2tlbml6ZXIuRU9GX1RPS0VOXSA9IHRva2VuSW5IZWFkO1xuXG5fW0FGVEVSX0hFQURfTU9ERV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuX1tBRlRFUl9IRUFEX01PREVdW1Rva2VuaXplci5DSEFSQUNURVJfVE9LRU5dID1cbl9bQUZURVJfSEVBRF9NT0RFXVtUb2tlbml6ZXIuTlVMTF9DSEFSQUNURVJfVE9LRU5dID0gdG9rZW5BZnRlckhlYWQ7XG5fW0FGVEVSX0hFQURfTU9ERV1bVG9rZW5pemVyLldISVRFU1BBQ0VfQ0hBUkFDVEVSX1RPS0VOXSA9IGluc2VydENoYXJhY3RlcnM7XG5fW0FGVEVSX0hFQURfTU9ERV1bVG9rZW5pemVyLkNPTU1FTlRfVE9LRU5dID0gYXBwZW5kQ29tbWVudDtcbl9bQUZURVJfSEVBRF9NT0RFXVtUb2tlbml6ZXIuRE9DVFlQRV9UT0tFTl0gPSBpZ25vcmVUb2tlbjtcbl9bQUZURVJfSEVBRF9NT0RFXVtUb2tlbml6ZXIuU1RBUlRfVEFHX1RPS0VOXSA9IHN0YXJ0VGFnQWZ0ZXJIZWFkO1xuX1tBRlRFUl9IRUFEX01PREVdW1Rva2VuaXplci5FTkRfVEFHX1RPS0VOXSA9IGVuZFRhZ0FmdGVySGVhZDtcbl9bQUZURVJfSEVBRF9NT0RFXVtUb2tlbml6ZXIuRU9GX1RPS0VOXSA9IHRva2VuQWZ0ZXJIZWFkO1xuXG5fW0lOX0JPRFlfTU9ERV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuX1tJTl9CT0RZX01PREVdW1Rva2VuaXplci5DSEFSQUNURVJfVE9LRU5dID0gY2hhcmFjdGVySW5Cb2R5O1xuX1tJTl9CT0RZX01PREVdW1Rva2VuaXplci5OVUxMX0NIQVJBQ1RFUl9UT0tFTl0gPSBpZ25vcmVUb2tlbjtcbl9bSU5fQk9EWV9NT0RFXVtUb2tlbml6ZXIuV0hJVEVTUEFDRV9DSEFSQUNURVJfVE9LRU5dID0gd2hpdGVzcGFjZUNoYXJhY3RlckluQm9keTtcbl9bSU5fQk9EWV9NT0RFXVtUb2tlbml6ZXIuQ09NTUVOVF9UT0tFTl0gPSBhcHBlbmRDb21tZW50O1xuX1tJTl9CT0RZX01PREVdW1Rva2VuaXplci5ET0NUWVBFX1RPS0VOXSA9IGlnbm9yZVRva2VuO1xuX1tJTl9CT0RZX01PREVdW1Rva2VuaXplci5TVEFSVF9UQUdfVE9LRU5dID0gc3RhcnRUYWdJbkJvZHk7XG5fW0lOX0JPRFlfTU9ERV1bVG9rZW5pemVyLkVORF9UQUdfVE9LRU5dID0gZW5kVGFnSW5Cb2R5O1xuX1tJTl9CT0RZX01PREVdW1Rva2VuaXplci5FT0ZfVE9LRU5dID0gZW9mSW5Cb2R5O1xuXG5fW1RFWFRfTU9ERV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuX1tURVhUX01PREVdW1Rva2VuaXplci5DSEFSQUNURVJfVE9LRU5dID1cbl9bVEVYVF9NT0RFXVtUb2tlbml6ZXIuTlVMTF9DSEFSQUNURVJfVE9LRU5dID1cbl9bVEVYVF9NT0RFXVtUb2tlbml6ZXIuV0hJVEVTUEFDRV9DSEFSQUNURVJfVE9LRU5dID0gaW5zZXJ0Q2hhcmFjdGVycztcbl9bVEVYVF9NT0RFXVtUb2tlbml6ZXIuQ09NTUVOVF9UT0tFTl0gPVxuX1tURVhUX01PREVdW1Rva2VuaXplci5ET0NUWVBFX1RPS0VOXSA9XG5fW1RFWFRfTU9ERV1bVG9rZW5pemVyLlNUQVJUX1RBR19UT0tFTl0gPSBpZ25vcmVUb2tlbjtcbl9bVEVYVF9NT0RFXVtUb2tlbml6ZXIuRU5EX1RBR19UT0tFTl0gPSBlbmRUYWdJblRleHQ7XG5fW1RFWFRfTU9ERV1bVG9rZW5pemVyLkVPRl9UT0tFTl0gPSBlb2ZJblRleHQ7XG5cbl9bSU5fVEFCTEVfTU9ERV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuX1tJTl9UQUJMRV9NT0RFXVtUb2tlbml6ZXIuQ0hBUkFDVEVSX1RPS0VOXSA9XG5fW0lOX1RBQkxFX01PREVdW1Rva2VuaXplci5OVUxMX0NIQVJBQ1RFUl9UT0tFTl0gPVxuX1tJTl9UQUJMRV9NT0RFXVtUb2tlbml6ZXIuV0hJVEVTUEFDRV9DSEFSQUNURVJfVE9LRU5dID0gY2hhcmFjdGVySW5UYWJsZTtcbl9bSU5fVEFCTEVfTU9ERV1bVG9rZW5pemVyLkNPTU1FTlRfVE9LRU5dID0gYXBwZW5kQ29tbWVudDtcbl9bSU5fVEFCTEVfTU9ERV1bVG9rZW5pemVyLkRPQ1RZUEVfVE9LRU5dID0gaWdub3JlVG9rZW47XG5fW0lOX1RBQkxFX01PREVdW1Rva2VuaXplci5TVEFSVF9UQUdfVE9LRU5dID0gc3RhcnRUYWdJblRhYmxlO1xuX1tJTl9UQUJMRV9NT0RFXVtUb2tlbml6ZXIuRU5EX1RBR19UT0tFTl0gPSBlbmRUYWdJblRhYmxlO1xuX1tJTl9UQUJMRV9NT0RFXVtUb2tlbml6ZXIuRU9GX1RPS0VOXSA9IGVvZkluQm9keTtcblxuX1tJTl9UQUJMRV9URVhUX01PREVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbl9bSU5fVEFCTEVfVEVYVF9NT0RFXVtUb2tlbml6ZXIuQ0hBUkFDVEVSX1RPS0VOXSA9IGNoYXJhY3RlckluVGFibGVUZXh0O1xuX1tJTl9UQUJMRV9URVhUX01PREVdW1Rva2VuaXplci5OVUxMX0NIQVJBQ1RFUl9UT0tFTl0gPSBpZ25vcmVUb2tlbjtcbl9bSU5fVEFCTEVfVEVYVF9NT0RFXVtUb2tlbml6ZXIuV0hJVEVTUEFDRV9DSEFSQUNURVJfVE9LRU5dID0gd2hpdGVzcGFjZUNoYXJhY3RlckluVGFibGVUZXh0O1xuX1tJTl9UQUJMRV9URVhUX01PREVdW1Rva2VuaXplci5DT01NRU5UX1RPS0VOXSA9XG5fW0lOX1RBQkxFX1RFWFRfTU9ERV1bVG9rZW5pemVyLkRPQ1RZUEVfVE9LRU5dID1cbl9bSU5fVEFCTEVfVEVYVF9NT0RFXVtUb2tlbml6ZXIuU1RBUlRfVEFHX1RPS0VOXSA9XG5fW0lOX1RBQkxFX1RFWFRfTU9ERV1bVG9rZW5pemVyLkVORF9UQUdfVE9LRU5dID1cbl9bSU5fVEFCTEVfVEVYVF9NT0RFXVtUb2tlbml6ZXIuRU9GX1RPS0VOXSA9IHRva2VuSW5UYWJsZVRleHQ7XG5cbl9bSU5fQ0FQVElPTl9NT0RFXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5fW0lOX0NBUFRJT05fTU9ERV1bVG9rZW5pemVyLkNIQVJBQ1RFUl9UT0tFTl0gPSBjaGFyYWN0ZXJJbkJvZHk7XG5fW0lOX0NBUFRJT05fTU9ERV1bVG9rZW5pemVyLk5VTExfQ0hBUkFDVEVSX1RPS0VOXSA9IGlnbm9yZVRva2VuO1xuX1tJTl9DQVBUSU9OX01PREVdW1Rva2VuaXplci5XSElURVNQQUNFX0NIQVJBQ1RFUl9UT0tFTl0gPSB3aGl0ZXNwYWNlQ2hhcmFjdGVySW5Cb2R5O1xuX1tJTl9DQVBUSU9OX01PREVdW1Rva2VuaXplci5DT01NRU5UX1RPS0VOXSA9IGFwcGVuZENvbW1lbnQ7XG5fW0lOX0NBUFRJT05fTU9ERV1bVG9rZW5pemVyLkRPQ1RZUEVfVE9LRU5dID0gaWdub3JlVG9rZW47XG5fW0lOX0NBUFRJT05fTU9ERV1bVG9rZW5pemVyLlNUQVJUX1RBR19UT0tFTl0gPSBzdGFydFRhZ0luQ2FwdGlvbjtcbl9bSU5fQ0FQVElPTl9NT0RFXVtUb2tlbml6ZXIuRU5EX1RBR19UT0tFTl0gPSBlbmRUYWdJbkNhcHRpb247XG5fW0lOX0NBUFRJT05fTU9ERV1bVG9rZW5pemVyLkVPRl9UT0tFTl0gPSBlb2ZJbkJvZHk7XG5cbl9bSU5fQ09MVU1OX0dST1VQX01PREVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbl9bSU5fQ09MVU1OX0dST1VQX01PREVdW1Rva2VuaXplci5DSEFSQUNURVJfVE9LRU5dID1cbl9bSU5fQ09MVU1OX0dST1VQX01PREVdW1Rva2VuaXplci5OVUxMX0NIQVJBQ1RFUl9UT0tFTl0gPSB0b2tlbkluQ29sdW1uR3JvdXA7XG5fW0lOX0NPTFVNTl9HUk9VUF9NT0RFXVtUb2tlbml6ZXIuV0hJVEVTUEFDRV9DSEFSQUNURVJfVE9LRU5dID0gaW5zZXJ0Q2hhcmFjdGVycztcbl9bSU5fQ09MVU1OX0dST1VQX01PREVdW1Rva2VuaXplci5DT01NRU5UX1RPS0VOXSA9IGFwcGVuZENvbW1lbnQ7XG5fW0lOX0NPTFVNTl9HUk9VUF9NT0RFXVtUb2tlbml6ZXIuRE9DVFlQRV9UT0tFTl0gPSBpZ25vcmVUb2tlbjtcbl9bSU5fQ09MVU1OX0dST1VQX01PREVdW1Rva2VuaXplci5TVEFSVF9UQUdfVE9LRU5dID0gc3RhcnRUYWdJbkNvbHVtbkdyb3VwO1xuX1tJTl9DT0xVTU5fR1JPVVBfTU9ERV1bVG9rZW5pemVyLkVORF9UQUdfVE9LRU5dID0gZW5kVGFnSW5Db2x1bW5Hcm91cDtcbl9bSU5fQ09MVU1OX0dST1VQX01PREVdW1Rva2VuaXplci5FT0ZfVE9LRU5dID0gZW9mSW5Cb2R5O1xuXG5fW0lOX1RBQkxFX0JPRFlfTU9ERV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuX1tJTl9UQUJMRV9CT0RZX01PREVdW1Rva2VuaXplci5DSEFSQUNURVJfVE9LRU5dID1cbl9bSU5fVEFCTEVfQk9EWV9NT0RFXVtUb2tlbml6ZXIuTlVMTF9DSEFSQUNURVJfVE9LRU5dID1cbl9bSU5fVEFCTEVfQk9EWV9NT0RFXVtUb2tlbml6ZXIuV0hJVEVTUEFDRV9DSEFSQUNURVJfVE9LRU5dID0gY2hhcmFjdGVySW5UYWJsZTtcbl9bSU5fVEFCTEVfQk9EWV9NT0RFXVtUb2tlbml6ZXIuQ09NTUVOVF9UT0tFTl0gPSBhcHBlbmRDb21tZW50O1xuX1tJTl9UQUJMRV9CT0RZX01PREVdW1Rva2VuaXplci5ET0NUWVBFX1RPS0VOXSA9IGlnbm9yZVRva2VuO1xuX1tJTl9UQUJMRV9CT0RZX01PREVdW1Rva2VuaXplci5TVEFSVF9UQUdfVE9LRU5dID0gc3RhcnRUYWdJblRhYmxlQm9keTtcbl9bSU5fVEFCTEVfQk9EWV9NT0RFXVtUb2tlbml6ZXIuRU5EX1RBR19UT0tFTl0gPSBlbmRUYWdJblRhYmxlQm9keTtcbl9bSU5fVEFCTEVfQk9EWV9NT0RFXVtUb2tlbml6ZXIuRU9GX1RPS0VOXSA9IGVvZkluQm9keTtcblxuX1tJTl9ST1dfTU9ERV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuX1tJTl9ST1dfTU9ERV1bVG9rZW5pemVyLkNIQVJBQ1RFUl9UT0tFTl0gPVxuX1tJTl9ST1dfTU9ERV1bVG9rZW5pemVyLk5VTExfQ0hBUkFDVEVSX1RPS0VOXSA9XG5fW0lOX1JPV19NT0RFXVtUb2tlbml6ZXIuV0hJVEVTUEFDRV9DSEFSQUNURVJfVE9LRU5dID0gY2hhcmFjdGVySW5UYWJsZTtcbl9bSU5fUk9XX01PREVdW1Rva2VuaXplci5DT01NRU5UX1RPS0VOXSA9IGFwcGVuZENvbW1lbnQ7XG5fW0lOX1JPV19NT0RFXVtUb2tlbml6ZXIuRE9DVFlQRV9UT0tFTl0gPSBpZ25vcmVUb2tlbjtcbl9bSU5fUk9XX01PREVdW1Rva2VuaXplci5TVEFSVF9UQUdfVE9LRU5dID0gc3RhcnRUYWdJblJvdztcbl9bSU5fUk9XX01PREVdW1Rva2VuaXplci5FTkRfVEFHX1RPS0VOXSA9IGVuZFRhZ0luUm93O1xuX1tJTl9ST1dfTU9ERV1bVG9rZW5pemVyLkVPRl9UT0tFTl0gPSBlb2ZJbkJvZHk7XG5cbl9bSU5fQ0VMTF9NT0RFXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5fW0lOX0NFTExfTU9ERV1bVG9rZW5pemVyLkNIQVJBQ1RFUl9UT0tFTl0gPSBjaGFyYWN0ZXJJbkJvZHk7XG5fW0lOX0NFTExfTU9ERV1bVG9rZW5pemVyLk5VTExfQ0hBUkFDVEVSX1RPS0VOXSA9IGlnbm9yZVRva2VuO1xuX1tJTl9DRUxMX01PREVdW1Rva2VuaXplci5XSElURVNQQUNFX0NIQVJBQ1RFUl9UT0tFTl0gPSB3aGl0ZXNwYWNlQ2hhcmFjdGVySW5Cb2R5O1xuX1tJTl9DRUxMX01PREVdW1Rva2VuaXplci5DT01NRU5UX1RPS0VOXSA9IGFwcGVuZENvbW1lbnQ7XG5fW0lOX0NFTExfTU9ERV1bVG9rZW5pemVyLkRPQ1RZUEVfVE9LRU5dID0gaWdub3JlVG9rZW47XG5fW0lOX0NFTExfTU9ERV1bVG9rZW5pemVyLlNUQVJUX1RBR19UT0tFTl0gPSBzdGFydFRhZ0luQ2VsbDtcbl9bSU5fQ0VMTF9NT0RFXVtUb2tlbml6ZXIuRU5EX1RBR19UT0tFTl0gPSBlbmRUYWdJbkNlbGw7XG5fW0lOX0NFTExfTU9ERV1bVG9rZW5pemVyLkVPRl9UT0tFTl0gPSBlb2ZJbkJvZHk7XG5cbl9bSU5fU0VMRUNUX01PREVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbl9bSU5fU0VMRUNUX01PREVdW1Rva2VuaXplci5DSEFSQUNURVJfVE9LRU5dID0gaW5zZXJ0Q2hhcmFjdGVycztcbl9bSU5fU0VMRUNUX01PREVdW1Rva2VuaXplci5OVUxMX0NIQVJBQ1RFUl9UT0tFTl0gPSBpZ25vcmVUb2tlbjtcbl9bSU5fU0VMRUNUX01PREVdW1Rva2VuaXplci5XSElURVNQQUNFX0NIQVJBQ1RFUl9UT0tFTl0gPSBpbnNlcnRDaGFyYWN0ZXJzO1xuX1tJTl9TRUxFQ1RfTU9ERV1bVG9rZW5pemVyLkNPTU1FTlRfVE9LRU5dID0gYXBwZW5kQ29tbWVudDtcbl9bSU5fU0VMRUNUX01PREVdW1Rva2VuaXplci5ET0NUWVBFX1RPS0VOXSA9IGlnbm9yZVRva2VuO1xuX1tJTl9TRUxFQ1RfTU9ERV1bVG9rZW5pemVyLlNUQVJUX1RBR19UT0tFTl0gPSBzdGFydFRhZ0luU2VsZWN0O1xuX1tJTl9TRUxFQ1RfTU9ERV1bVG9rZW5pemVyLkVORF9UQUdfVE9LRU5dID0gZW5kVGFnSW5TZWxlY3Q7XG5fW0lOX1NFTEVDVF9NT0RFXVtUb2tlbml6ZXIuRU9GX1RPS0VOXSA9IGVvZkluQm9keTtcblxuX1tJTl9TRUxFQ1RfSU5fVEFCTEVfTU9ERV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuX1tJTl9TRUxFQ1RfSU5fVEFCTEVfTU9ERV1bVG9rZW5pemVyLkNIQVJBQ1RFUl9UT0tFTl0gPSBpbnNlcnRDaGFyYWN0ZXJzO1xuX1tJTl9TRUxFQ1RfSU5fVEFCTEVfTU9ERV1bVG9rZW5pemVyLk5VTExfQ0hBUkFDVEVSX1RPS0VOXSA9IGlnbm9yZVRva2VuO1xuX1tJTl9TRUxFQ1RfSU5fVEFCTEVfTU9ERV1bVG9rZW5pemVyLldISVRFU1BBQ0VfQ0hBUkFDVEVSX1RPS0VOXSA9IGluc2VydENoYXJhY3RlcnM7XG5fW0lOX1NFTEVDVF9JTl9UQUJMRV9NT0RFXVtUb2tlbml6ZXIuQ09NTUVOVF9UT0tFTl0gPSBhcHBlbmRDb21tZW50O1xuX1tJTl9TRUxFQ1RfSU5fVEFCTEVfTU9ERV1bVG9rZW5pemVyLkRPQ1RZUEVfVE9LRU5dID0gaWdub3JlVG9rZW47XG5fW0lOX1NFTEVDVF9JTl9UQUJMRV9NT0RFXVtUb2tlbml6ZXIuU1RBUlRfVEFHX1RPS0VOXSA9IHN0YXJ0VGFnSW5TZWxlY3RJblRhYmxlO1xuX1tJTl9TRUxFQ1RfSU5fVEFCTEVfTU9ERV1bVG9rZW5pemVyLkVORF9UQUdfVE9LRU5dID0gZW5kVGFnSW5TZWxlY3RJblRhYmxlO1xuX1tJTl9TRUxFQ1RfSU5fVEFCTEVfTU9ERV1bVG9rZW5pemVyLkVPRl9UT0tFTl0gPSBlb2ZJbkJvZHk7XG5cbl9bSU5fVEVNUExBVEVfTU9ERV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuX1tJTl9URU1QTEFURV9NT0RFXVtUb2tlbml6ZXIuQ0hBUkFDVEVSX1RPS0VOXSA9IGNoYXJhY3RlckluQm9keTtcbl9bSU5fVEVNUExBVEVfTU9ERV1bVG9rZW5pemVyLk5VTExfQ0hBUkFDVEVSX1RPS0VOXSA9IGlnbm9yZVRva2VuO1xuX1tJTl9URU1QTEFURV9NT0RFXVtUb2tlbml6ZXIuV0hJVEVTUEFDRV9DSEFSQUNURVJfVE9LRU5dID0gd2hpdGVzcGFjZUNoYXJhY3RlckluQm9keTtcbl9bSU5fVEVNUExBVEVfTU9ERV1bVG9rZW5pemVyLkNPTU1FTlRfVE9LRU5dID0gYXBwZW5kQ29tbWVudDtcbl9bSU5fVEVNUExBVEVfTU9ERV1bVG9rZW5pemVyLkRPQ1RZUEVfVE9LRU5dID0gaWdub3JlVG9rZW47XG5fW0lOX1RFTVBMQVRFX01PREVdW1Rva2VuaXplci5TVEFSVF9UQUdfVE9LRU5dID0gc3RhcnRUYWdJblRlbXBsYXRlO1xuX1tJTl9URU1QTEFURV9NT0RFXVtUb2tlbml6ZXIuRU5EX1RBR19UT0tFTl0gPSBlbmRUYWdJblRlbXBsYXRlO1xuX1tJTl9URU1QTEFURV9NT0RFXVtUb2tlbml6ZXIuRU9GX1RPS0VOXSA9IGVvZkluVGVtcGxhdGU7XG5cbl9bQUZURVJfQk9EWV9NT0RFXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5fW0FGVEVSX0JPRFlfTU9ERV1bVG9rZW5pemVyLkNIQVJBQ1RFUl9UT0tFTl0gPVxuX1tBRlRFUl9CT0RZX01PREVdW1Rva2VuaXplci5OVUxMX0NIQVJBQ1RFUl9UT0tFTl0gPSB0b2tlbkFmdGVyQm9keTtcbl9bQUZURVJfQk9EWV9NT0RFXVtUb2tlbml6ZXIuV0hJVEVTUEFDRV9DSEFSQUNURVJfVE9LRU5dID0gd2hpdGVzcGFjZUNoYXJhY3RlckluQm9keTtcbl9bQUZURVJfQk9EWV9NT0RFXVtUb2tlbml6ZXIuQ09NTUVOVF9UT0tFTl0gPSBhcHBlbmRDb21tZW50VG9Sb290SHRtbEVsZW1lbnQ7XG5fW0FGVEVSX0JPRFlfTU9ERV1bVG9rZW5pemVyLkRPQ1RZUEVfVE9LRU5dID0gaWdub3JlVG9rZW47XG5fW0FGVEVSX0JPRFlfTU9ERV1bVG9rZW5pemVyLlNUQVJUX1RBR19UT0tFTl0gPSBzdGFydFRhZ0FmdGVyQm9keTtcbl9bQUZURVJfQk9EWV9NT0RFXVtUb2tlbml6ZXIuRU5EX1RBR19UT0tFTl0gPSBlbmRUYWdBZnRlckJvZHk7XG5fW0FGVEVSX0JPRFlfTU9ERV1bVG9rZW5pemVyLkVPRl9UT0tFTl0gPSBzdG9wUGFyc2luZztcblxuX1tJTl9GUkFNRVNFVF9NT0RFXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5fW0lOX0ZSQU1FU0VUX01PREVdW1Rva2VuaXplci5DSEFSQUNURVJfVE9LRU5dID1cbl9bSU5fRlJBTUVTRVRfTU9ERV1bVG9rZW5pemVyLk5VTExfQ0hBUkFDVEVSX1RPS0VOXSA9IGlnbm9yZVRva2VuO1xuX1tJTl9GUkFNRVNFVF9NT0RFXVtUb2tlbml6ZXIuV0hJVEVTUEFDRV9DSEFSQUNURVJfVE9LRU5dID0gaW5zZXJ0Q2hhcmFjdGVycztcbl9bSU5fRlJBTUVTRVRfTU9ERV1bVG9rZW5pemVyLkNPTU1FTlRfVE9LRU5dID0gYXBwZW5kQ29tbWVudDtcbl9bSU5fRlJBTUVTRVRfTU9ERV1bVG9rZW5pemVyLkRPQ1RZUEVfVE9LRU5dID0gaWdub3JlVG9rZW47XG5fW0lOX0ZSQU1FU0VUX01PREVdW1Rva2VuaXplci5TVEFSVF9UQUdfVE9LRU5dID0gc3RhcnRUYWdJbkZyYW1lc2V0O1xuX1tJTl9GUkFNRVNFVF9NT0RFXVtUb2tlbml6ZXIuRU5EX1RBR19UT0tFTl0gPSBlbmRUYWdJbkZyYW1lc2V0O1xuX1tJTl9GUkFNRVNFVF9NT0RFXVtUb2tlbml6ZXIuRU9GX1RPS0VOXSA9IHN0b3BQYXJzaW5nO1xuXG5fW0FGVEVSX0ZSQU1FU0VUX01PREVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbl9bQUZURVJfRlJBTUVTRVRfTU9ERV1bVG9rZW5pemVyLkNIQVJBQ1RFUl9UT0tFTl0gPVxuX1tBRlRFUl9GUkFNRVNFVF9NT0RFXVtUb2tlbml6ZXIuTlVMTF9DSEFSQUNURVJfVE9LRU5dID0gaWdub3JlVG9rZW47XG5fW0FGVEVSX0ZSQU1FU0VUX01PREVdW1Rva2VuaXplci5XSElURVNQQUNFX0NIQVJBQ1RFUl9UT0tFTl0gPSBpbnNlcnRDaGFyYWN0ZXJzO1xuX1tBRlRFUl9GUkFNRVNFVF9NT0RFXVtUb2tlbml6ZXIuQ09NTUVOVF9UT0tFTl0gPSBhcHBlbmRDb21tZW50O1xuX1tBRlRFUl9GUkFNRVNFVF9NT0RFXVtUb2tlbml6ZXIuRE9DVFlQRV9UT0tFTl0gPSBpZ25vcmVUb2tlbjtcbl9bQUZURVJfRlJBTUVTRVRfTU9ERV1bVG9rZW5pemVyLlNUQVJUX1RBR19UT0tFTl0gPSBzdGFydFRhZ0FmdGVyRnJhbWVzZXQ7XG5fW0FGVEVSX0ZSQU1FU0VUX01PREVdW1Rva2VuaXplci5FTkRfVEFHX1RPS0VOXSA9IGVuZFRhZ0FmdGVyRnJhbWVzZXQ7XG5fW0FGVEVSX0ZSQU1FU0VUX01PREVdW1Rva2VuaXplci5FT0ZfVE9LRU5dID0gc3RvcFBhcnNpbmc7XG5cbl9bQUZURVJfQUZURVJfQk9EWV9NT0RFXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5fW0FGVEVSX0FGVEVSX0JPRFlfTU9ERV1bVG9rZW5pemVyLkNIQVJBQ1RFUl9UT0tFTl0gPSB0b2tlbkFmdGVyQWZ0ZXJCb2R5O1xuX1tBRlRFUl9BRlRFUl9CT0RZX01PREVdW1Rva2VuaXplci5OVUxMX0NIQVJBQ1RFUl9UT0tFTl0gPSB0b2tlbkFmdGVyQWZ0ZXJCb2R5O1xuX1tBRlRFUl9BRlRFUl9CT0RZX01PREVdW1Rva2VuaXplci5XSElURVNQQUNFX0NIQVJBQ1RFUl9UT0tFTl0gPSB3aGl0ZXNwYWNlQ2hhcmFjdGVySW5Cb2R5O1xuX1tBRlRFUl9BRlRFUl9CT0RZX01PREVdW1Rva2VuaXplci5DT01NRU5UX1RPS0VOXSA9IGFwcGVuZENvbW1lbnRUb0RvY3VtZW50O1xuX1tBRlRFUl9BRlRFUl9CT0RZX01PREVdW1Rva2VuaXplci5ET0NUWVBFX1RPS0VOXSA9IGlnbm9yZVRva2VuO1xuX1tBRlRFUl9BRlRFUl9CT0RZX01PREVdW1Rva2VuaXplci5TVEFSVF9UQUdfVE9LRU5dID0gc3RhcnRUYWdBZnRlckFmdGVyQm9keTtcbl9bQUZURVJfQUZURVJfQk9EWV9NT0RFXVtUb2tlbml6ZXIuRU5EX1RBR19UT0tFTl0gPSB0b2tlbkFmdGVyQWZ0ZXJCb2R5O1xuX1tBRlRFUl9BRlRFUl9CT0RZX01PREVdW1Rva2VuaXplci5FT0ZfVE9LRU5dID0gc3RvcFBhcnNpbmc7XG5cbl9bQUZURVJfQUZURVJfRlJBTUVTRVRfTU9ERV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuX1tBRlRFUl9BRlRFUl9GUkFNRVNFVF9NT0RFXVtUb2tlbml6ZXIuQ0hBUkFDVEVSX1RPS0VOXSA9XG5fW0FGVEVSX0FGVEVSX0ZSQU1FU0VUX01PREVdW1Rva2VuaXplci5OVUxMX0NIQVJBQ1RFUl9UT0tFTl0gPSBpZ25vcmVUb2tlbjtcbl9bQUZURVJfQUZURVJfRlJBTUVTRVRfTU9ERV1bVG9rZW5pemVyLldISVRFU1BBQ0VfQ0hBUkFDVEVSX1RPS0VOXSA9IHdoaXRlc3BhY2VDaGFyYWN0ZXJJbkJvZHk7XG5fW0FGVEVSX0FGVEVSX0ZSQU1FU0VUX01PREVdW1Rva2VuaXplci5DT01NRU5UX1RPS0VOXSA9IGFwcGVuZENvbW1lbnRUb0RvY3VtZW50O1xuX1tBRlRFUl9BRlRFUl9GUkFNRVNFVF9NT0RFXVtUb2tlbml6ZXIuRE9DVFlQRV9UT0tFTl0gPSBpZ25vcmVUb2tlbjtcbl9bQUZURVJfQUZURVJfRlJBTUVTRVRfTU9ERV1bVG9rZW5pemVyLlNUQVJUX1RBR19UT0tFTl0gPSBzdGFydFRhZ0FmdGVyQWZ0ZXJGcmFtZXNldDtcbl9bQUZURVJfQUZURVJfRlJBTUVTRVRfTU9ERV1bVG9rZW5pemVyLkVORF9UQUdfVE9LRU5dID0gaWdub3JlVG9rZW47XG5fW0FGVEVSX0FGVEVSX0ZSQU1FU0VUX01PREVdW1Rva2VuaXplci5FT0ZfVE9LRU5dID0gc3RvcFBhcnNpbmc7XG5cblxuLy9QYXJzZXJcbnZhciBQYXJzZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnRyZWVBZGFwdGVyID0gdGhpcy5vcHRpb25zLnRyZWVBZGFwdGVyO1xuICAgIHRoaXMucGVuZGluZ1NjcmlwdCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9uSW5mbylcbiAgICAgICAgbG9jYXRpb25JbmZvTWl4aW4uYXNzaWduKHRoaXMpO1xufTtcblxuLy8gQVBJXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGh0bWwpIHtcbiAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLnRyZWVBZGFwdGVyLmNyZWF0ZURvY3VtZW50KCk7XG5cbiAgICB0aGlzLl9ib290c3RyYXAoZG9jdW1lbnQsIG51bGwpO1xuICAgIHRoaXMudG9rZW5pemVyLndyaXRlKGh0bWwsIHRydWUpO1xuICAgIHRoaXMuX3J1blBhcnNpbmdMb29wKG51bGwpO1xuXG4gICAgcmV0dXJuIGRvY3VtZW50O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZyYWdtZW50ID0gZnVuY3Rpb24gKGh0bWwsIGZyYWdtZW50Q29udGV4dCkge1xuICAgIC8vTk9URTogdXNlIDx0ZW1wbGF0ZT4gZWxlbWVudCBhcyBhIGZyYWdtZW50IGNvbnRleHQgaWYgY29udGV4dCBlbGVtZW50IHdhcyBub3QgcHJvdmlkZWQsXG4gICAgLy9zbyB3ZSB3aWxsIHBhcnNlIGluIFwiZm9yZ2l2aW5nXCIgbWFubmVyXG4gICAgaWYgKCFmcmFnbWVudENvbnRleHQpXG4gICAgICAgIGZyYWdtZW50Q29udGV4dCA9IHRoaXMudHJlZUFkYXB0ZXIuY3JlYXRlRWxlbWVudCgkLlRFTVBMQVRFLCBOUy5IVE1MLCBbXSk7XG5cbiAgICAvL05PVEU6IGNyZWF0ZSBmYWtlIGVsZW1lbnQgd2hpY2ggd2lsbCBiZSB1c2VkIGFzICdkb2N1bWVudCcgZm9yIGZyYWdtZW50IHBhcnNpbmcuXG4gICAgLy9UaGlzIGlzIGltcG9ydGFudCBmb3IganNkb20gdGhlcmUgJ2RvY3VtZW50JyBjYW4ndCBiZSByZWNyZWF0ZWQsIHRoZXJlZm9yZVxuICAgIC8vZnJhZ21lbnQgcGFyc2luZyBjYXVzZXMgbWVzc2luZyBvZiB0aGUgbWFpbiBgZG9jdW1lbnRgLlxuICAgIHZhciBkb2N1bWVudE1vY2sgPSB0aGlzLnRyZWVBZGFwdGVyLmNyZWF0ZUVsZW1lbnQoJ2RvY3VtZW50bW9jaycsIE5TLkhUTUwsIFtdKTtcblxuICAgIHRoaXMuX2Jvb3RzdHJhcChkb2N1bWVudE1vY2ssIGZyYWdtZW50Q29udGV4dCk7XG5cbiAgICBpZiAodGhpcy50cmVlQWRhcHRlci5nZXRUYWdOYW1lKGZyYWdtZW50Q29udGV4dCkgPT09ICQuVEVNUExBVEUpXG4gICAgICAgIHRoaXMuX3B1c2hUbXBsSW5zZXJ0aW9uTW9kZShJTl9URU1QTEFURV9NT0RFKTtcblxuICAgIHRoaXMuX2luaXRUb2tlbml6ZXJGb3JGcmFnbWVudFBhcnNpbmcoKTtcbiAgICB0aGlzLl9pbnNlcnRGYWtlUm9vdEVsZW1lbnQoKTtcbiAgICB0aGlzLl9yZXNldEluc2VydGlvbk1vZGUoKTtcbiAgICB0aGlzLl9maW5kRm9ybUluRnJhZ21lbnRDb250ZXh0KCk7XG4gICAgdGhpcy50b2tlbml6ZXIud3JpdGUoaHRtbCwgdHJ1ZSk7XG4gICAgdGhpcy5fcnVuUGFyc2luZ0xvb3AobnVsbCk7XG5cbiAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLnRyZWVBZGFwdGVyLmdldEZpcnN0Q2hpbGQoZG9jdW1lbnRNb2NrKSxcbiAgICAgICAgZnJhZ21lbnQgPSB0aGlzLnRyZWVBZGFwdGVyLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIHRoaXMuX2Fkb3B0Tm9kZXMocm9vdEVsZW1lbnQsIGZyYWdtZW50KTtcblxuICAgIHJldHVybiBmcmFnbWVudDtcbn07XG5cbi8vQm9vdHN0cmFwIHBhcnNlclxuUGFyc2VyLnByb3RvdHlwZS5fYm9vdHN0cmFwID0gZnVuY3Rpb24gKGRvY3VtZW50LCBmcmFnbWVudENvbnRleHQpIHtcbiAgICB0aGlzLnRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIodGhpcy5vcHRpb25zKTtcblxuICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5pbnNlcnRpb25Nb2RlID0gSU5JVElBTF9NT0RFO1xuICAgIHRoaXMub3JpZ2luYWxJbnNlcnRpb25Nb2RlID0gJyc7XG5cbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5mcmFnbWVudENvbnRleHQgPSBmcmFnbWVudENvbnRleHQ7XG5cbiAgICB0aGlzLmhlYWRFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmZvcm1FbGVtZW50ID0gbnVsbDtcblxuICAgIHRoaXMub3BlbkVsZW1lbnRzID0gbmV3IE9wZW5FbGVtZW50U3RhY2sodGhpcy5kb2N1bWVudCwgdGhpcy50cmVlQWRhcHRlcik7XG4gICAgdGhpcy5hY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMgPSBuZXcgRm9ybWF0dGluZ0VsZW1lbnRMaXN0KHRoaXMudHJlZUFkYXB0ZXIpO1xuXG4gICAgdGhpcy50bXBsSW5zZXJ0aW9uTW9kZVN0YWNrID0gW107XG4gICAgdGhpcy50bXBsSW5zZXJ0aW9uTW9kZVN0YWNrVG9wID0gLTE7XG4gICAgdGhpcy5jdXJyZW50VG1wbEluc2VydGlvbk1vZGUgPSBudWxsO1xuXG4gICAgdGhpcy5wZW5kaW5nQ2hhcmFjdGVyVG9rZW5zID0gW107XG4gICAgdGhpcy5oYXNOb25XaGl0ZXNwYWNlUGVuZGluZ0NoYXJhY3RlclRva2VuID0gZmFsc2U7XG5cbiAgICB0aGlzLmZyYW1lc2V0T2sgPSB0cnVlO1xuICAgIHRoaXMuc2tpcE5leHROZXdMaW5lID0gZmFsc2U7XG4gICAgdGhpcy5mb3N0ZXJQYXJlbnRpbmdFbmFibGVkID0gZmFsc2U7XG59O1xuXG4vL1BhcnNpbmcgbG9vcFxuUGFyc2VyLnByb3RvdHlwZS5fcnVuUGFyc2luZ0xvb3AgID0gZnVuY3Rpb24gKHNjcmlwdEhhbmRsZXIpIHtcbiAgICB3aGlsZSAoIXRoaXMuc3RvcHBlZCkge1xuICAgICAgICB0aGlzLl9zZXR1cFRva2VuaXplckNEQVRBTW9kZSgpO1xuXG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG9rZW5pemVyLmdldE5leHRUb2tlbigpO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbml6ZXIuSElCRVJOQVRJT05fVE9LRU4pXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBpZiAodGhpcy5za2lwTmV4dE5ld0xpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuc2tpcE5leHROZXdMaW5lID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbml6ZXIuV0hJVEVTUEFDRV9DSEFSQUNURVJfVE9LRU4gJiYgdG9rZW4uY2hhcnNbMF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmNoYXJzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB0b2tlbi5jaGFycyA9IHRva2VuLmNoYXJzLnN1YnN0cigxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NJbnB1dFRva2VuKHRva2VuKTtcblxuICAgICAgICBpZiAoc2NyaXB0SGFuZGxlciAmJiB0aGlzLnBlbmRpbmdTY3JpcHQpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnJ1blBhcnNpbmdMb29wRm9yQ3VycmVudENodW5rID0gZnVuY3Rpb24gKHdyaXRlQ2FsbGJhY2ssIHNjcmlwdEhhbmRsZXIpIHtcbiAgICB0aGlzLl9ydW5QYXJzaW5nTG9vcChzY3JpcHRIYW5kbGVyKTtcblxuICAgIGlmIChzY3JpcHRIYW5kbGVyICYmIHRoaXMucGVuZGluZ1NjcmlwdCkge1xuICAgICAgICB2YXIgc2NyaXB0ID0gdGhpcy5wZW5kaW5nU2NyaXB0O1xuXG4gICAgICAgIHRoaXMucGVuZGluZ1NjcmlwdCA9IG51bGw7XG5cbiAgICAgICAgc2NyaXB0SGFuZGxlcihzY3JpcHQpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAod3JpdGVDYWxsYmFjaylcbiAgICAgICAgd3JpdGVDYWxsYmFjaygpO1xufTtcblxuLy9UZXh0IHBhcnNpbmdcblBhcnNlci5wcm90b3R5cGUuX3NldHVwVG9rZW5pemVyQ0RBVEFNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5fZ2V0QWRqdXN0ZWRDdXJyZW50RWxlbWVudCgpO1xuXG4gICAgdGhpcy50b2tlbml6ZXIuYWxsb3dDREFUQSA9IGN1cnJlbnQgJiYgY3VycmVudCAhPT0gdGhpcy5kb2N1bWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVBZGFwdGVyLmdldE5hbWVzcGFjZVVSSShjdXJyZW50KSAhPT0gTlMuSFRNTCAmJiAhdGhpcy5faXNJbnRlZ3JhdGlvblBvaW50KGN1cnJlbnQpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5fc3dpdGNoVG9UZXh0UGFyc2luZyA9IGZ1bmN0aW9uIChjdXJyZW50VG9rZW4sIG5leHRUb2tlbml6ZXJTdGF0ZSkge1xuICAgIHRoaXMuX2luc2VydEVsZW1lbnQoY3VycmVudFRva2VuLCBOUy5IVE1MKTtcbiAgICB0aGlzLnRva2VuaXplci5zdGF0ZSA9IG5leHRUb2tlbml6ZXJTdGF0ZTtcbiAgICB0aGlzLm9yaWdpbmFsSW5zZXJ0aW9uTW9kZSA9IHRoaXMuaW5zZXJ0aW9uTW9kZTtcbiAgICB0aGlzLmluc2VydGlvbk1vZGUgPSBURVhUX01PREU7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnN3aXRjaFRvUGxhaW50ZXh0UGFyc2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmluc2VydGlvbk1vZGUgPSBURVhUX01PREU7XG4gICAgdGhpcy5vcmlnaW5hbEluc2VydGlvbk1vZGUgPSBJTl9CT0RZX01PREU7XG4gICAgdGhpcy50b2tlbml6ZXIuc3RhdGUgPSBUb2tlbml6ZXIuTU9ERS5QTEFJTlRFWFQ7XG59O1xuXG4vL0ZyYWdtZW50IHBhcnNpbmdcblBhcnNlci5wcm90b3R5cGUuX2dldEFkanVzdGVkQ3VycmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3BlbkVsZW1lbnRzLnN0YWNrVG9wID09PSAwICYmIHRoaXMuZnJhZ21lbnRDb250ZXh0ID9cbiAgICAgICAgdGhpcy5mcmFnbWVudENvbnRleHQgOlxuICAgICAgICB0aGlzLm9wZW5FbGVtZW50cy5jdXJyZW50O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5fZmluZEZvcm1JbkZyYWdtZW50Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuZnJhZ21lbnRDb250ZXh0O1xuXG4gICAgZG8ge1xuICAgICAgICBpZiAodGhpcy50cmVlQWRhcHRlci5nZXRUYWdOYW1lKG5vZGUpID09PSAkLkZPUk0pIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUVsZW1lbnQgPSBub2RlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gdGhpcy50cmVlQWRhcHRlci5nZXRQYXJlbnROb2RlKG5vZGUpO1xuICAgIH0gd2hpbGUgKG5vZGUpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5faW5pdFRva2VuaXplckZvckZyYWdtZW50UGFyc2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50cmVlQWRhcHRlci5nZXROYW1lc3BhY2VVUkkodGhpcy5mcmFnbWVudENvbnRleHQpID09PSBOUy5IVE1MKSB7XG4gICAgICAgIHZhciB0biA9IHRoaXMudHJlZUFkYXB0ZXIuZ2V0VGFnTmFtZSh0aGlzLmZyYWdtZW50Q29udGV4dCk7XG5cbiAgICAgICAgaWYgKHRuID09PSAkLlRJVExFIHx8IHRuID09PSAkLlRFWFRBUkVBKVxuICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuc3RhdGUgPSBUb2tlbml6ZXIuTU9ERS5SQ0RBVEE7XG5cbiAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuU1RZTEUgfHwgdG4gPT09ICQuWE1QIHx8IHRuID09PSAkLklGUkFNRSB8fFxuICAgICAgICAgICAgICAgICB0biA9PT0gJC5OT0VNQkVEIHx8IHRuID09PSAkLk5PRlJBTUVTIHx8IHRuID09PSAkLk5PU0NSSVBUKVxuICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuc3RhdGUgPSBUb2tlbml6ZXIuTU9ERS5SQVdURVhUO1xuXG4gICAgICAgIGVsc2UgaWYgKHRuID09PSAkLlNDUklQVClcbiAgICAgICAgICAgIHRoaXMudG9rZW5pemVyLnN0YXRlID0gVG9rZW5pemVyLk1PREUuU0NSSVBUX0RBVEE7XG5cbiAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuUExBSU5URVhUKVxuICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuc3RhdGUgPSBUb2tlbml6ZXIuTU9ERS5QTEFJTlRFWFQ7XG4gICAgfVxufTtcblxuLy9UcmVlIG11dGF0aW9uXG5QYXJzZXIucHJvdG90eXBlLl9zZXREb2N1bWVudFR5cGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICB0aGlzLnRyZWVBZGFwdGVyLnNldERvY3VtZW50VHlwZSh0aGlzLmRvY3VtZW50LCB0b2tlbi5uYW1lLCB0b2tlbi5wdWJsaWNJZCwgdG9rZW4uc3lzdGVtSWQpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5fYXR0YWNoRWxlbWVudFRvVHJlZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuX3Nob3VsZEZvc3RlclBhcmVudE9uSW5zZXJ0aW9uKCkpXG4gICAgICAgIHRoaXMuX2Zvc3RlclBhcmVudEVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMub3BlbkVsZW1lbnRzLmN1cnJlbnRUbXBsQ29udGVudCB8fCB0aGlzLm9wZW5FbGVtZW50cy5jdXJyZW50O1xuXG4gICAgICAgIHRoaXMudHJlZUFkYXB0ZXIuYXBwZW5kQ2hpbGQocGFyZW50LCBlbGVtZW50KTtcbiAgICB9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLl9hcHBlbmRFbGVtZW50ID0gZnVuY3Rpb24gKHRva2VuLCBuYW1lc3BhY2VVUkkpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMudHJlZUFkYXB0ZXIuY3JlYXRlRWxlbWVudCh0b2tlbi50YWdOYW1lLCBuYW1lc3BhY2VVUkksIHRva2VuLmF0dHJzKTtcblxuICAgIHRoaXMuX2F0dGFjaEVsZW1lbnRUb1RyZWUoZWxlbWVudCk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLl9pbnNlcnRFbGVtZW50ID0gZnVuY3Rpb24gKHRva2VuLCBuYW1lc3BhY2VVUkkpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMudHJlZUFkYXB0ZXIuY3JlYXRlRWxlbWVudCh0b2tlbi50YWdOYW1lLCBuYW1lc3BhY2VVUkksIHRva2VuLmF0dHJzKTtcblxuICAgIHRoaXMuX2F0dGFjaEVsZW1lbnRUb1RyZWUoZWxlbWVudCk7XG4gICAgdGhpcy5vcGVuRWxlbWVudHMucHVzaChlbGVtZW50KTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuX2luc2VydEZha2VFbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMudHJlZUFkYXB0ZXIuY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBOUy5IVE1MLCBbXSk7XG5cbiAgICB0aGlzLl9hdHRhY2hFbGVtZW50VG9UcmVlKGVsZW1lbnQpO1xuICAgIHRoaXMub3BlbkVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLl9pbnNlcnRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIHZhciB0bXBsID0gdGhpcy50cmVlQWRhcHRlci5jcmVhdGVFbGVtZW50KHRva2VuLnRhZ05hbWUsIE5TLkhUTUwsIHRva2VuLmF0dHJzKSxcbiAgICAgICAgY29udGVudCA9IHRoaXMudHJlZUFkYXB0ZXIuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgdGhpcy50cmVlQWRhcHRlci5zZXRUZW1wbGF0ZUNvbnRlbnQodG1wbCwgY29udGVudCk7XG4gICAgdGhpcy5fYXR0YWNoRWxlbWVudFRvVHJlZSh0bXBsKTtcbiAgICB0aGlzLm9wZW5FbGVtZW50cy5wdXNoKHRtcGwpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5faW5zZXJ0RmFrZVJvb3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy50cmVlQWRhcHRlci5jcmVhdGVFbGVtZW50KCQuSFRNTCwgTlMuSFRNTCwgW10pO1xuXG4gICAgdGhpcy50cmVlQWRhcHRlci5hcHBlbmRDaGlsZCh0aGlzLm9wZW5FbGVtZW50cy5jdXJyZW50LCBlbGVtZW50KTtcbiAgICB0aGlzLm9wZW5FbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5fYXBwZW5kQ29tbWVudE5vZGUgPSBmdW5jdGlvbiAodG9rZW4sIHBhcmVudCkge1xuICAgIHZhciBjb21tZW50Tm9kZSA9IHRoaXMudHJlZUFkYXB0ZXIuY3JlYXRlQ29tbWVudE5vZGUodG9rZW4uZGF0YSk7XG5cbiAgICB0aGlzLnRyZWVBZGFwdGVyLmFwcGVuZENoaWxkKHBhcmVudCwgY29tbWVudE5vZGUpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5faW5zZXJ0Q2hhcmFjdGVycyA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGlmICh0aGlzLl9zaG91bGRGb3N0ZXJQYXJlbnRPbkluc2VydGlvbigpKVxuICAgICAgICB0aGlzLl9mb3N0ZXJQYXJlbnRUZXh0KHRva2VuLmNoYXJzKTtcblxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5vcGVuRWxlbWVudHMuY3VycmVudFRtcGxDb250ZW50IHx8IHRoaXMub3BlbkVsZW1lbnRzLmN1cnJlbnQ7XG5cbiAgICAgICAgdGhpcy50cmVlQWRhcHRlci5pbnNlcnRUZXh0KHBhcmVudCwgdG9rZW4uY2hhcnMpO1xuICAgIH1cbn07XG5cblBhcnNlci5wcm90b3R5cGUuX2Fkb3B0Tm9kZXMgPSBmdW5jdGlvbiAoZG9ub3IsIHJlY2lwaWVudCkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMudHJlZUFkYXB0ZXIuZ2V0Rmlyc3RDaGlsZChkb25vcik7XG5cbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIHRoaXMudHJlZUFkYXB0ZXIuZGV0YWNoTm9kZShjaGlsZCk7XG4gICAgICAgIHRoaXMudHJlZUFkYXB0ZXIuYXBwZW5kQ2hpbGQocmVjaXBpZW50LCBjaGlsZCk7XG4gICAgfVxufTtcblxuLy9Ub2tlbiBwcm9jZXNzaW5nXG5QYXJzZXIucHJvdG90eXBlLl9zaG91bGRQcm9jZXNzVG9rZW5JbkZvcmVpZ25Db250ZW50ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9nZXRBZGp1c3RlZEN1cnJlbnRFbGVtZW50KCk7XG5cbiAgICBpZiAoIWN1cnJlbnQgfHwgY3VycmVudCA9PT0gdGhpcy5kb2N1bWVudClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIG5zID0gdGhpcy50cmVlQWRhcHRlci5nZXROYW1lc3BhY2VVUkkoY3VycmVudCk7XG5cbiAgICBpZiAobnMgPT09IE5TLkhUTUwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGlmICh0aGlzLnRyZWVBZGFwdGVyLmdldFRhZ05hbWUoY3VycmVudCkgPT09ICQuQU5OT1RBVElPTl9YTUwgJiYgbnMgPT09IE5TLk1BVEhNTCAmJlxuICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbml6ZXIuU1RBUlRfVEFHX1RPS0VOICYmIHRva2VuLnRhZ05hbWUgPT09ICQuU1ZHKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgaXNDaGFyYWN0ZXJUb2tlbiA9IHRva2VuLnR5cGUgPT09IFRva2VuaXplci5DSEFSQUNURVJfVE9LRU4gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuaXplci5OVUxMX0NIQVJBQ1RFUl9UT0tFTiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW5pemVyLldISVRFU1BBQ0VfQ0hBUkFDVEVSX1RPS0VOLFxuICAgICAgICBpc01hdGhNTFRleHRTdGFydFRhZyA9IHRva2VuLnR5cGUgPT09IFRva2VuaXplci5TVEFSVF9UQUdfVE9LRU4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi50YWdOYW1lICE9PSAkLk1HTFlQSCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnRhZ05hbWUgIT09ICQuTUFMSUdOTUFSSztcblxuICAgIGlmICgoaXNNYXRoTUxUZXh0U3RhcnRUYWcgfHwgaXNDaGFyYWN0ZXJUb2tlbikgJiYgdGhpcy5faXNJbnRlZ3JhdGlvblBvaW50KGN1cnJlbnQsIE5TLk1BVEhNTCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGlmICgodG9rZW4udHlwZSA9PT0gVG9rZW5pemVyLlNUQVJUX1RBR19UT0tFTiB8fCBpc0NoYXJhY3RlclRva2VuKSAmJiB0aGlzLl9pc0ludGVncmF0aW9uUG9pbnQoY3VycmVudCwgTlMuSFRNTCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiB0b2tlbi50eXBlICE9PSBUb2tlbml6ZXIuRU9GX1RPS0VOO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5fcHJvY2Vzc1Rva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgX1t0aGlzLmluc2VydGlvbk1vZGVdW3Rva2VuLnR5cGVdKHRoaXMsIHRva2VuKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuX3Byb2Nlc3NUb2tlbkluQm9keU1vZGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBfW0lOX0JPRFlfTU9ERV1bdG9rZW4udHlwZV0odGhpcywgdG9rZW4pO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5fcHJvY2Vzc1Rva2VuSW5Gb3JlaWduQ29udGVudCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbml6ZXIuQ0hBUkFDVEVSX1RPS0VOKVxuICAgICAgICBjaGFyYWN0ZXJJbkZvcmVpZ25Db250ZW50KHRoaXMsIHRva2VuKTtcblxuICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuaXplci5OVUxMX0NIQVJBQ1RFUl9UT0tFTilcbiAgICAgICAgbnVsbENoYXJhY3RlckluRm9yZWlnbkNvbnRlbnQodGhpcywgdG9rZW4pO1xuXG4gICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5pemVyLldISVRFU1BBQ0VfQ0hBUkFDVEVSX1RPS0VOKVxuICAgICAgICBpbnNlcnRDaGFyYWN0ZXJzKHRoaXMsIHRva2VuKTtcblxuICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuaXplci5DT01NRU5UX1RPS0VOKVxuICAgICAgICBhcHBlbmRDb21tZW50KHRoaXMsIHRva2VuKTtcblxuICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuaXplci5TVEFSVF9UQUdfVE9LRU4pXG4gICAgICAgIHN0YXJ0VGFnSW5Gb3JlaWduQ29udGVudCh0aGlzLCB0b2tlbik7XG5cbiAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSBUb2tlbml6ZXIuRU5EX1RBR19UT0tFTilcbiAgICAgICAgZW5kVGFnSW5Gb3JlaWduQ29udGVudCh0aGlzLCB0b2tlbik7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLl9wcm9jZXNzSW5wdXRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGlmICh0aGlzLl9zaG91bGRQcm9jZXNzVG9rZW5JbkZvcmVpZ25Db250ZW50KHRva2VuKSlcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1Rva2VuSW5Gb3JlaWduQ29udGVudCh0b2tlbik7XG5cbiAgICBlbHNlXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NUb2tlbih0b2tlbik7XG59O1xuXG4vL0ludGVncmF0aW9uIHBvaW50c1xuUGFyc2VyLnByb3RvdHlwZS5faXNJbnRlZ3JhdGlvblBvaW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGZvcmVpZ25OUykge1xuICAgIHZhciB0biA9IHRoaXMudHJlZUFkYXB0ZXIuZ2V0VGFnTmFtZShlbGVtZW50KSxcbiAgICAgICAgbnMgPSB0aGlzLnRyZWVBZGFwdGVyLmdldE5hbWVzcGFjZVVSSShlbGVtZW50KSxcbiAgICAgICAgYXR0cnMgPSB0aGlzLnRyZWVBZGFwdGVyLmdldEF0dHJMaXN0KGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGZvcmVpZ25Db250ZW50LmlzSW50ZWdyYXRpb25Qb2ludCh0biwgbnMsIGF0dHJzLCBmb3JlaWduTlMpO1xufTtcblxuLy9BY3RpdmUgZm9ybWF0dGluZyBlbGVtZW50cyByZWNvbnN0cnVjdGlvblxuUGFyc2VyLnByb3RvdHlwZS5fcmVjb25zdHJ1Y3RBY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpc3RMZW5ndGggPSB0aGlzLmFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cy5sZW5ndGg7XG5cbiAgICBpZiAobGlzdExlbmd0aCkge1xuICAgICAgICB2YXIgdW5vcGVuSWR4ID0gbGlzdExlbmd0aCxcbiAgICAgICAgICAgIGVudHJ5ID0gbnVsbDtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICB1bm9wZW5JZHgtLTtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5hY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMuZW50cmllc1t1bm9wZW5JZHhdO1xuXG4gICAgICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gRm9ybWF0dGluZ0VsZW1lbnRMaXN0Lk1BUktFUl9FTlRSWSB8fCB0aGlzLm9wZW5FbGVtZW50cy5jb250YWlucyhlbnRyeS5lbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHVub3BlbklkeCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICh1bm9wZW5JZHggPiAwKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gdW5vcGVuSWR4OyBpIDwgbGlzdExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuYWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLmVudHJpZXNbaV07XG4gICAgICAgICAgICB0aGlzLl9pbnNlcnRFbGVtZW50KGVudHJ5LnRva2VuLCB0aGlzLnRyZWVBZGFwdGVyLmdldE5hbWVzcGFjZVVSSShlbnRyeS5lbGVtZW50KSk7XG4gICAgICAgICAgICBlbnRyeS5lbGVtZW50ID0gdGhpcy5vcGVuRWxlbWVudHMuY3VycmVudDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vQ2xvc2UgZWxlbWVudHNcblBhcnNlci5wcm90b3R5cGUuX2Nsb3NlVGFibGVDZWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub3BlbkVsZW1lbnRzLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3MoKTtcbiAgICB0aGlzLm9wZW5FbGVtZW50cy5wb3BVbnRpbFRhYmxlQ2VsbFBvcHBlZCgpO1xuICAgIHRoaXMuYWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLmNsZWFyVG9MYXN0TWFya2VyKCk7XG4gICAgdGhpcy5pbnNlcnRpb25Nb2RlID0gSU5fUk9XX01PREU7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLl9jbG9zZVBFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub3BlbkVsZW1lbnRzLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3NXaXRoRXhjbHVzaW9uKCQuUCk7XG4gICAgdGhpcy5vcGVuRWxlbWVudHMucG9wVW50aWxUYWdOYW1lUG9wcGVkKCQuUCk7XG59O1xuXG4vL0luc2VydGlvbiBtb2Rlc1xuUGFyc2VyLnByb3RvdHlwZS5fcmVzZXRJbnNlcnRpb25Nb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLm9wZW5FbGVtZW50cy5zdGFja1RvcCwgbGFzdCA9IGZhbHNlOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMub3BlbkVsZW1lbnRzLml0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBsYXN0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRDb250ZXh0KVxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmZyYWdtZW50Q29udGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0biA9IHRoaXMudHJlZUFkYXB0ZXIuZ2V0VGFnTmFtZShlbGVtZW50KSxcbiAgICAgICAgICAgIG5ld0luc2VydGlvbk1vZGUgPSBJTlNFUlRJT05fTU9ERV9SRVNFVF9NQVBbdG5dO1xuXG4gICAgICAgIGlmIChuZXdJbnNlcnRpb25Nb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydGlvbk1vZGUgPSBuZXdJbnNlcnRpb25Nb2RlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmICghbGFzdCAmJiAodG4gPT09ICQuVEQgfHwgdG4gPT09ICQuVEgpKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydGlvbk1vZGUgPSBJTl9DRUxMX01PREU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKCFsYXN0ICYmIHRuID09PSAkLkhFQUQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0aW9uTW9kZSA9IElOX0hFQURfTU9ERTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuU0VMRUNUKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldEluc2VydGlvbk1vZGVGb3JTZWxlY3QoaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKHRuID09PSAkLlRFTVBMQVRFKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydGlvbk1vZGUgPSB0aGlzLmN1cnJlbnRUbXBsSW5zZXJ0aW9uTW9kZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuSFRNTCkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRpb25Nb2RlID0gdGhpcy5oZWFkRWxlbWVudCA/IEFGVEVSX0hFQURfTU9ERSA6IEJFRk9SRV9IRUFEX01PREU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0aW9uTW9kZSA9IElOX0JPRFlfTU9ERTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUGFyc2VyLnByb3RvdHlwZS5fcmVzZXRJbnNlcnRpb25Nb2RlRm9yU2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdElkeCkge1xuICAgIGlmIChzZWxlY3RJZHggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBzZWxlY3RJZHggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB0aGlzLm9wZW5FbGVtZW50cy5pdGVtc1tpXSxcbiAgICAgICAgICAgICAgICB0biA9IHRoaXMudHJlZUFkYXB0ZXIuZ2V0VGFnTmFtZShhbmNlc3Rvcik7XG5cbiAgICAgICAgICAgIGlmICh0biA9PT0gJC5URU1QTEFURSlcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuVEFCTEUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydGlvbk1vZGUgPSBJTl9TRUxFQ1RfSU5fVEFCTEVfTU9ERTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluc2VydGlvbk1vZGUgPSBJTl9TRUxFQ1RfTU9ERTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuX3B1c2hUbXBsSW5zZXJ0aW9uTW9kZSA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgdGhpcy50bXBsSW5zZXJ0aW9uTW9kZVN0YWNrLnB1c2gobW9kZSk7XG4gICAgdGhpcy50bXBsSW5zZXJ0aW9uTW9kZVN0YWNrVG9wKys7XG4gICAgdGhpcy5jdXJyZW50VG1wbEluc2VydGlvbk1vZGUgPSBtb2RlO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5fcG9wVG1wbEluc2VydGlvbk1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50bXBsSW5zZXJ0aW9uTW9kZVN0YWNrLnBvcCgpO1xuICAgIHRoaXMudG1wbEluc2VydGlvbk1vZGVTdGFja1RvcC0tO1xuICAgIHRoaXMuY3VycmVudFRtcGxJbnNlcnRpb25Nb2RlID0gdGhpcy50bXBsSW5zZXJ0aW9uTW9kZVN0YWNrW3RoaXMudG1wbEluc2VydGlvbk1vZGVTdGFja1RvcF07XG59O1xuXG4vL0Zvc3RlciBwYXJlbnRpbmdcblBhcnNlci5wcm90b3R5cGUuX2lzRWxlbWVudENhdXNlc0Zvc3RlclBhcmVudGluZyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIHRuID0gdGhpcy50cmVlQWRhcHRlci5nZXRUYWdOYW1lKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIHRuID09PSAkLlRBQkxFIHx8IHRuID09PSAkLlRCT0RZIHx8IHRuID09PSAkLlRGT09UIHx8IHRuID09PSAkLlRIRUFEIHx8IHRuID09PSAkLlRSO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5fc2hvdWxkRm9zdGVyUGFyZW50T25JbnNlcnRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9zdGVyUGFyZW50aW5nRW5hYmxlZCAmJiB0aGlzLl9pc0VsZW1lbnRDYXVzZXNGb3N0ZXJQYXJlbnRpbmcodGhpcy5vcGVuRWxlbWVudHMuY3VycmVudCk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLl9maW5kRm9zdGVyUGFyZW50aW5nTG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxvY2F0aW9uID0ge1xuICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgIGJlZm9yZUVsZW1lbnQ6IG51bGxcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMub3BlbkVsZW1lbnRzLnN0YWNrVG9wOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgb3BlbkVsZW1lbnQgPSB0aGlzLm9wZW5FbGVtZW50cy5pdGVtc1tpXSxcbiAgICAgICAgICAgIHRuID0gdGhpcy50cmVlQWRhcHRlci5nZXRUYWdOYW1lKG9wZW5FbGVtZW50KSxcbiAgICAgICAgICAgIG5zID0gdGhpcy50cmVlQWRhcHRlci5nZXROYW1lc3BhY2VVUkkob3BlbkVsZW1lbnQpO1xuXG4gICAgICAgIGlmICh0biA9PT0gJC5URU1QTEFURSAmJiBucyA9PT0gTlMuSFRNTCkge1xuICAgICAgICAgICAgbG9jYXRpb24ucGFyZW50ID0gdGhpcy50cmVlQWRhcHRlci5nZXRUZW1wbGF0ZUNvbnRlbnQob3BlbkVsZW1lbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5UQUJMRSkge1xuICAgICAgICAgICAgbG9jYXRpb24ucGFyZW50ID0gdGhpcy50cmVlQWRhcHRlci5nZXRQYXJlbnROb2RlKG9wZW5FbGVtZW50KTtcblxuICAgICAgICAgICAgaWYgKGxvY2F0aW9uLnBhcmVudClcbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5iZWZvcmVFbGVtZW50ID0gb3BlbkVsZW1lbnQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbG9jYXRpb24ucGFyZW50ID0gdGhpcy5vcGVuRWxlbWVudHMuaXRlbXNbaSAtIDFdO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbG9jYXRpb24ucGFyZW50KVxuICAgICAgICBsb2NhdGlvbi5wYXJlbnQgPSB0aGlzLm9wZW5FbGVtZW50cy5pdGVtc1swXTtcblxuICAgIHJldHVybiBsb2NhdGlvbjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuX2Zvc3RlclBhcmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuX2ZpbmRGb3N0ZXJQYXJlbnRpbmdMb2NhdGlvbigpO1xuXG4gICAgaWYgKGxvY2F0aW9uLmJlZm9yZUVsZW1lbnQpXG4gICAgICAgIHRoaXMudHJlZUFkYXB0ZXIuaW5zZXJ0QmVmb3JlKGxvY2F0aW9uLnBhcmVudCwgZWxlbWVudCwgbG9jYXRpb24uYmVmb3JlRWxlbWVudCk7XG4gICAgZWxzZVxuICAgICAgICB0aGlzLnRyZWVBZGFwdGVyLmFwcGVuZENoaWxkKGxvY2F0aW9uLnBhcmVudCwgZWxlbWVudCk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLl9mb3N0ZXJQYXJlbnRUZXh0ID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5fZmluZEZvc3RlclBhcmVudGluZ0xvY2F0aW9uKCk7XG5cbiAgICBpZiAobG9jYXRpb24uYmVmb3JlRWxlbWVudClcbiAgICAgICAgdGhpcy50cmVlQWRhcHRlci5pbnNlcnRUZXh0QmVmb3JlKGxvY2F0aW9uLnBhcmVudCwgY2hhcnMsIGxvY2F0aW9uLmJlZm9yZUVsZW1lbnQpO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy50cmVlQWRhcHRlci5pbnNlcnRUZXh0KGxvY2F0aW9uLnBhcmVudCwgY2hhcnMpO1xufTtcblxuLy9TcGVjaWFsIGVsZW1lbnRzXG5QYXJzZXIucHJvdG90eXBlLl9pc1NwZWNpYWxFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB2YXIgdG4gPSB0aGlzLnRyZWVBZGFwdGVyLmdldFRhZ05hbWUoZWxlbWVudCksXG4gICAgICAgIG5zID0gdGhpcy50cmVlQWRhcHRlci5nZXROYW1lc3BhY2VVUkkoZWxlbWVudCk7XG5cbiAgICByZXR1cm4gSFRNTC5TUEVDSUFMX0VMRU1FTlRTW25zXVt0bl07XG59O1xuXG4vL0Fkb3B0aW9uIGFnZW5jeSBhbGdvcml0aG1cbi8vKHNlZTogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdHJlZS1jb25zdHJ1Y3Rpb24uaHRtbCNhZG9wdGlvbkFnZW5jeSlcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vU3RlcHMgNS04IG9mIHRoZSBhbGdvcml0aG1cbmZ1bmN0aW9uIGFhT2J0YWluRm9ybWF0dGluZ0VsZW1lbnRFbnRyeShwLCB0b2tlbikge1xuICAgIHZhciBmb3JtYXR0aW5nRWxlbWVudEVudHJ5ID0gcC5hY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMuZ2V0RWxlbWVudEVudHJ5SW5TY29wZVdpdGhUYWdOYW1lKHRva2VuLnRhZ05hbWUpO1xuXG4gICAgaWYgKGZvcm1hdHRpbmdFbGVtZW50RW50cnkpIHtcbiAgICAgICAgaWYgKCFwLm9wZW5FbGVtZW50cy5jb250YWlucyhmb3JtYXR0aW5nRWxlbWVudEVudHJ5LmVsZW1lbnQpKSB7XG4gICAgICAgICAgICBwLmFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cy5yZW1vdmVFbnRyeShmb3JtYXR0aW5nRWxlbWVudEVudHJ5KTtcbiAgICAgICAgICAgIGZvcm1hdHRpbmdFbGVtZW50RW50cnkgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAoIXAub3BlbkVsZW1lbnRzLmhhc0luU2NvcGUodG9rZW4udGFnTmFtZSkpXG4gICAgICAgICAgICBmb3JtYXR0aW5nRWxlbWVudEVudHJ5ID0gbnVsbDtcbiAgICB9XG5cbiAgICBlbHNlXG4gICAgICAgIGdlbmVyaWNFbmRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgcmV0dXJuIGZvcm1hdHRpbmdFbGVtZW50RW50cnk7XG59XG5cbi8vU3RlcHMgOSBhbmQgMTAgb2YgdGhlIGFsZ29yaXRobVxuZnVuY3Rpb24gYWFPYnRhaW5GdXJ0aGVzdEJsb2NrKHAsIGZvcm1hdHRpbmdFbGVtZW50RW50cnkpIHtcbiAgICB2YXIgZnVydGhlc3RCbG9jayA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gcC5vcGVuRWxlbWVudHMuc3RhY2tUb3A7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gcC5vcGVuRWxlbWVudHMuaXRlbXNbaV07XG5cbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IGZvcm1hdHRpbmdFbGVtZW50RW50cnkuZWxlbWVudClcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGlmIChwLl9pc1NwZWNpYWxFbGVtZW50KGVsZW1lbnQpKVxuICAgICAgICAgICAgZnVydGhlc3RCbG9jayA9IGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgaWYgKCFmdXJ0aGVzdEJsb2NrKSB7XG4gICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcFVudGlsRWxlbWVudFBvcHBlZChmb3JtYXR0aW5nRWxlbWVudEVudHJ5LmVsZW1lbnQpO1xuICAgICAgICBwLmFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cy5yZW1vdmVFbnRyeShmb3JtYXR0aW5nRWxlbWVudEVudHJ5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVydGhlc3RCbG9jaztcbn1cblxuLy9TdGVwIDEzIG9mIHRoZSBhbGdvcml0aG1cbmZ1bmN0aW9uIGFhSW5uZXJMb29wKHAsIGZ1cnRoZXN0QmxvY2ssIGZvcm1hdHRpbmdFbGVtZW50KSB7XG4gICAgdmFyIGxhc3RFbGVtZW50ID0gZnVydGhlc3RCbG9jayxcbiAgICAgICAgbmV4dEVsZW1lbnQgPSBwLm9wZW5FbGVtZW50cy5nZXRDb21tb25BbmNlc3RvcihmdXJ0aGVzdEJsb2NrKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBlbGVtZW50ID0gbmV4dEVsZW1lbnQ7IGVsZW1lbnQgIT09IGZvcm1hdHRpbmdFbGVtZW50OyBpKyssIGVsZW1lbnQgPSBuZXh0RWxlbWVudCkge1xuICAgICAgICAvL05PVEU6IHN0b3JlIG5leHQgZWxlbWVudCBmb3IgdGhlIG5leHQgbG9vcCBpdGVyYXRpb24gKGl0IG1heSBiZSBkZWxldGVkIGZyb20gdGhlIHN0YWNrIGJ5IHN0ZXAgOS41KVxuICAgICAgICBuZXh0RWxlbWVudCA9IHAub3BlbkVsZW1lbnRzLmdldENvbW1vbkFuY2VzdG9yKGVsZW1lbnQpO1xuXG4gICAgICAgIHZhciBlbGVtZW50RW50cnkgPSBwLmFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cy5nZXRFbGVtZW50RW50cnkoZWxlbWVudCksXG4gICAgICAgICAgICBjb3VudGVyT3ZlcmZsb3cgPSBlbGVtZW50RW50cnkgJiYgaSA+PSBBQV9JTk5FUl9MT09QX0lURVIsXG4gICAgICAgICAgICBzaG91bGRSZW1vdmVGcm9tT3BlbkVsZW1lbnRzID0gIWVsZW1lbnRFbnRyeSB8fCBjb3VudGVyT3ZlcmZsb3c7XG5cbiAgICAgICAgaWYgKHNob3VsZFJlbW92ZUZyb21PcGVuRWxlbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChjb3VudGVyT3ZlcmZsb3cpXG4gICAgICAgICAgICAgICAgcC5hY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucmVtb3ZlRW50cnkoZWxlbWVudEVudHJ5KTtcblxuICAgICAgICAgICAgcC5vcGVuRWxlbWVudHMucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gYWFSZWNyZWF0ZUVsZW1lbnRGcm9tRW50cnkocCwgZWxlbWVudEVudHJ5KTtcblxuICAgICAgICAgICAgaWYgKGxhc3RFbGVtZW50ID09PSBmdXJ0aGVzdEJsb2NrKVxuICAgICAgICAgICAgICAgIHAuYWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLmJvb2ttYXJrID0gZWxlbWVudEVudHJ5O1xuXG4gICAgICAgICAgICBwLnRyZWVBZGFwdGVyLmRldGFjaE5vZGUobGFzdEVsZW1lbnQpO1xuICAgICAgICAgICAgcC50cmVlQWRhcHRlci5hcHBlbmRDaGlsZChlbGVtZW50LCBsYXN0RWxlbWVudCk7XG4gICAgICAgICAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdEVsZW1lbnQ7XG59XG5cbi8vU3RlcCAxMy43IG9mIHRoZSBhbGdvcml0aG1cbmZ1bmN0aW9uIGFhUmVjcmVhdGVFbGVtZW50RnJvbUVudHJ5KHAsIGVsZW1lbnRFbnRyeSkge1xuICAgIHZhciBucyA9IHAudHJlZUFkYXB0ZXIuZ2V0TmFtZXNwYWNlVVJJKGVsZW1lbnRFbnRyeS5lbGVtZW50KSxcbiAgICAgICAgbmV3RWxlbWVudCA9IHAudHJlZUFkYXB0ZXIuY3JlYXRlRWxlbWVudChlbGVtZW50RW50cnkudG9rZW4udGFnTmFtZSwgbnMsIGVsZW1lbnRFbnRyeS50b2tlbi5hdHRycyk7XG5cbiAgICBwLm9wZW5FbGVtZW50cy5yZXBsYWNlKGVsZW1lbnRFbnRyeS5lbGVtZW50LCBuZXdFbGVtZW50KTtcbiAgICBlbGVtZW50RW50cnkuZWxlbWVudCA9IG5ld0VsZW1lbnQ7XG5cbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxuLy9TdGVwIDE0IG9mIHRoZSBhbGdvcml0aG1cbmZ1bmN0aW9uIGFhSW5zZXJ0TGFzdE5vZGVJbkNvbW1vbkFuY2VzdG9yKHAsIGNvbW1vbkFuY2VzdG9yLCBsYXN0RWxlbWVudCkge1xuICAgIGlmIChwLl9pc0VsZW1lbnRDYXVzZXNGb3N0ZXJQYXJlbnRpbmcoY29tbW9uQW5jZXN0b3IpKVxuICAgICAgICBwLl9mb3N0ZXJQYXJlbnRFbGVtZW50KGxhc3RFbGVtZW50KTtcblxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdG4gPSBwLnRyZWVBZGFwdGVyLmdldFRhZ05hbWUoY29tbW9uQW5jZXN0b3IpLFxuICAgICAgICAgICAgbnMgPSBwLnRyZWVBZGFwdGVyLmdldE5hbWVzcGFjZVVSSShjb21tb25BbmNlc3Rvcik7XG5cbiAgICAgICAgaWYgKHRuID09PSAkLlRFTVBMQVRFICYmIG5zID09PSBOUy5IVE1MKVxuICAgICAgICAgICAgY29tbW9uQW5jZXN0b3IgPSBwLnRyZWVBZGFwdGVyLmdldFRlbXBsYXRlQ29udGVudChjb21tb25BbmNlc3Rvcik7XG5cbiAgICAgICAgcC50cmVlQWRhcHRlci5hcHBlbmRDaGlsZChjb21tb25BbmNlc3RvciwgbGFzdEVsZW1lbnQpO1xuICAgIH1cbn1cblxuLy9TdGVwcyAxNS0xOSBvZiB0aGUgYWxnb3JpdGhtXG5mdW5jdGlvbiBhYVJlcGxhY2VGb3JtYXR0aW5nRWxlbWVudChwLCBmdXJ0aGVzdEJsb2NrLCBmb3JtYXR0aW5nRWxlbWVudEVudHJ5KSB7XG4gICAgdmFyIG5zID0gcC50cmVlQWRhcHRlci5nZXROYW1lc3BhY2VVUkkoZm9ybWF0dGluZ0VsZW1lbnRFbnRyeS5lbGVtZW50KSxcbiAgICAgICAgdG9rZW4gPSBmb3JtYXR0aW5nRWxlbWVudEVudHJ5LnRva2VuLFxuICAgICAgICBuZXdFbGVtZW50ID0gcC50cmVlQWRhcHRlci5jcmVhdGVFbGVtZW50KHRva2VuLnRhZ05hbWUsIG5zLCB0b2tlbi5hdHRycyk7XG5cbiAgICBwLl9hZG9wdE5vZGVzKGZ1cnRoZXN0QmxvY2ssIG5ld0VsZW1lbnQpO1xuICAgIHAudHJlZUFkYXB0ZXIuYXBwZW5kQ2hpbGQoZnVydGhlc3RCbG9jaywgbmV3RWxlbWVudCk7XG5cbiAgICBwLmFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cy5pbnNlcnRFbGVtZW50QWZ0ZXJCb29rbWFyayhuZXdFbGVtZW50LCBmb3JtYXR0aW5nRWxlbWVudEVudHJ5LnRva2VuKTtcbiAgICBwLmFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cy5yZW1vdmVFbnRyeShmb3JtYXR0aW5nRWxlbWVudEVudHJ5KTtcblxuICAgIHAub3BlbkVsZW1lbnRzLnJlbW92ZShmb3JtYXR0aW5nRWxlbWVudEVudHJ5LmVsZW1lbnQpO1xuICAgIHAub3BlbkVsZW1lbnRzLmluc2VydEFmdGVyKGZ1cnRoZXN0QmxvY2ssIG5ld0VsZW1lbnQpO1xufVxuXG4vL0FsZ29yaXRobSBlbnRyeSBwb2ludFxuZnVuY3Rpb24gY2FsbEFkb3B0aW9uQWdlbmN5KHAsIHRva2VuKSB7XG4gICAgdmFyIGZvcm1hdHRpbmdFbGVtZW50RW50cnk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IEFBX09VVEVSX0xPT1BfSVRFUjsgaSsrKSB7XG4gICAgICAgIGZvcm1hdHRpbmdFbGVtZW50RW50cnkgPSBhYU9idGFpbkZvcm1hdHRpbmdFbGVtZW50RW50cnkocCwgdG9rZW4sIGZvcm1hdHRpbmdFbGVtZW50RW50cnkpO1xuXG4gICAgICAgIGlmICghZm9ybWF0dGluZ0VsZW1lbnRFbnRyeSlcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIHZhciBmdXJ0aGVzdEJsb2NrID0gYWFPYnRhaW5GdXJ0aGVzdEJsb2NrKHAsIGZvcm1hdHRpbmdFbGVtZW50RW50cnkpO1xuXG4gICAgICAgIGlmICghZnVydGhlc3RCbG9jaylcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIHAuYWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLmJvb2ttYXJrID0gZm9ybWF0dGluZ0VsZW1lbnRFbnRyeTtcblxuICAgICAgICB2YXIgbGFzdEVsZW1lbnQgPSBhYUlubmVyTG9vcChwLCBmdXJ0aGVzdEJsb2NrLCBmb3JtYXR0aW5nRWxlbWVudEVudHJ5LmVsZW1lbnQpLFxuICAgICAgICAgICAgY29tbW9uQW5jZXN0b3IgPSBwLm9wZW5FbGVtZW50cy5nZXRDb21tb25BbmNlc3Rvcihmb3JtYXR0aW5nRWxlbWVudEVudHJ5LmVsZW1lbnQpO1xuXG4gICAgICAgIHAudHJlZUFkYXB0ZXIuZGV0YWNoTm9kZShsYXN0RWxlbWVudCk7XG4gICAgICAgIGFhSW5zZXJ0TGFzdE5vZGVJbkNvbW1vbkFuY2VzdG9yKHAsIGNvbW1vbkFuY2VzdG9yLCBsYXN0RWxlbWVudCk7XG4gICAgICAgIGFhUmVwbGFjZUZvcm1hdHRpbmdFbGVtZW50KHAsIGZ1cnRoZXN0QmxvY2ssIGZvcm1hdHRpbmdFbGVtZW50RW50cnkpO1xuICAgIH1cbn1cblxuXG4vL0dlbmVyaWMgdG9rZW4gaGFuZGxlcnNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpZ25vcmVUb2tlbigpIHtcbiAgICAvL05PVEU6IGRvIG5vdGhpbmcgPSlcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ29tbWVudChwLCB0b2tlbikge1xuICAgIHAuX2FwcGVuZENvbW1lbnROb2RlKHRva2VuLCBwLm9wZW5FbGVtZW50cy5jdXJyZW50VG1wbENvbnRlbnQgfHwgcC5vcGVuRWxlbWVudHMuY3VycmVudCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENvbW1lbnRUb1Jvb3RIdG1sRWxlbWVudChwLCB0b2tlbikge1xuICAgIHAuX2FwcGVuZENvbW1lbnROb2RlKHRva2VuLCBwLm9wZW5FbGVtZW50cy5pdGVtc1swXSk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENvbW1lbnRUb0RvY3VtZW50KHAsIHRva2VuKSB7XG4gICAgcC5fYXBwZW5kQ29tbWVudE5vZGUodG9rZW4sIHAuZG9jdW1lbnQpO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRDaGFyYWN0ZXJzKHAsIHRva2VuKSB7XG4gICAgcC5faW5zZXJ0Q2hhcmFjdGVycyh0b2tlbik7XG59XG5cbmZ1bmN0aW9uIHN0b3BQYXJzaW5nKHApIHtcbiAgICBwLnN0b3BwZWQgPSB0cnVlO1xufVxuXG4vLzEyLjIuNS40LjEgVGhlIFwiaW5pdGlhbFwiIGluc2VydGlvbiBtb2RlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZG9jdHlwZUluSW5pdGlhbE1vZGUocCwgdG9rZW4pIHtcbiAgICBwLl9zZXREb2N1bWVudFR5cGUodG9rZW4pO1xuXG4gICAgdmFyIG1vZGUgPSB0b2tlbi5mb3JjZVF1aXJrcyA/XG4gICAgICAgIEhUTUwuRE9DVU1FTlRfTU9ERS5RVUlSS1MgOlxuICAgICAgICBkb2N0eXBlLmdldERvY3VtZW50TW9kZSh0b2tlbi5uYW1lLCB0b2tlbi5wdWJsaWNJZCwgdG9rZW4uc3lzdGVtSWQpO1xuXG4gICAgcC50cmVlQWRhcHRlci5zZXREb2N1bWVudE1vZGUocC5kb2N1bWVudCwgbW9kZSk7XG5cbiAgICBwLmluc2VydGlvbk1vZGUgPSBCRUZPUkVfSFRNTF9NT0RFO1xufVxuXG5mdW5jdGlvbiB0b2tlbkluSW5pdGlhbE1vZGUocCwgdG9rZW4pIHtcbiAgICBwLnRyZWVBZGFwdGVyLnNldERvY3VtZW50TW9kZShwLmRvY3VtZW50LCBIVE1MLkRPQ1VNRU5UX01PREUuUVVJUktTKTtcbiAgICBwLmluc2VydGlvbk1vZGUgPSBCRUZPUkVfSFRNTF9NT0RFO1xuICAgIHAuX3Byb2Nlc3NUb2tlbih0b2tlbik7XG59XG5cblxuLy8xMi4yLjUuNC4yIFRoZSBcImJlZm9yZSBodG1sXCIgaW5zZXJ0aW9uIG1vZGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzdGFydFRhZ0JlZm9yZUh0bWwocCwgdG9rZW4pIHtcbiAgICBpZiAodG9rZW4udGFnTmFtZSA9PT0gJC5IVE1MKSB7XG4gICAgICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xuICAgICAgICBwLmluc2VydGlvbk1vZGUgPSBCRUZPUkVfSEVBRF9NT0RFO1xuICAgIH1cblxuICAgIGVsc2VcbiAgICAgICAgdG9rZW5CZWZvcmVIdG1sKHAsIHRva2VuKTtcbn1cblxuZnVuY3Rpb24gZW5kVGFnQmVmb3JlSHRtbChwLCB0b2tlbikge1xuICAgIHZhciB0biA9IHRva2VuLnRhZ05hbWU7XG5cbiAgICBpZiAodG4gPT09ICQuSFRNTCB8fCB0biA9PT0gJC5IRUFEIHx8IHRuID09PSAkLkJPRFkgfHwgdG4gPT09ICQuQlIpXG4gICAgICAgIHRva2VuQmVmb3JlSHRtbChwLCB0b2tlbik7XG59XG5cbmZ1bmN0aW9uIHRva2VuQmVmb3JlSHRtbChwLCB0b2tlbikge1xuICAgIHAuX2luc2VydEZha2VSb290RWxlbWVudCgpO1xuICAgIHAuaW5zZXJ0aW9uTW9kZSA9IEJFRk9SRV9IRUFEX01PREU7XG4gICAgcC5fcHJvY2Vzc1Rva2VuKHRva2VuKTtcbn1cblxuXG4vLzEyLjIuNS40LjMgVGhlIFwiYmVmb3JlIGhlYWRcIiBpbnNlcnRpb24gbW9kZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHN0YXJ0VGFnQmVmb3JlSGVhZChwLCB0b2tlbikge1xuICAgIHZhciB0biA9IHRva2VuLnRhZ05hbWU7XG5cbiAgICBpZiAodG4gPT09ICQuSFRNTClcbiAgICAgICAgc3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgZWxzZSBpZiAodG4gPT09ICQuSEVBRCkge1xuICAgICAgICBwLl9pbnNlcnRFbGVtZW50KHRva2VuLCBOUy5IVE1MKTtcbiAgICAgICAgcC5oZWFkRWxlbWVudCA9IHAub3BlbkVsZW1lbnRzLmN1cnJlbnQ7XG4gICAgICAgIHAuaW5zZXJ0aW9uTW9kZSA9IElOX0hFQURfTU9ERTtcbiAgICB9XG5cbiAgICBlbHNlXG4gICAgICAgIHRva2VuQmVmb3JlSGVhZChwLCB0b2tlbik7XG59XG5cbmZ1bmN0aW9uIGVuZFRhZ0JlZm9yZUhlYWQocCwgdG9rZW4pIHtcbiAgICB2YXIgdG4gPSB0b2tlbi50YWdOYW1lO1xuXG4gICAgaWYgKHRuID09PSAkLkhFQUQgfHwgdG4gPT09ICQuQk9EWSB8fCB0biA9PT0gJC5IVE1MIHx8IHRuID09PSAkLkJSKVxuICAgICAgICB0b2tlbkJlZm9yZUhlYWQocCwgdG9rZW4pO1xufVxuXG5mdW5jdGlvbiB0b2tlbkJlZm9yZUhlYWQocCwgdG9rZW4pIHtcbiAgICBwLl9pbnNlcnRGYWtlRWxlbWVudCgkLkhFQUQpO1xuICAgIHAuaGVhZEVsZW1lbnQgPSBwLm9wZW5FbGVtZW50cy5jdXJyZW50O1xuICAgIHAuaW5zZXJ0aW9uTW9kZSA9IElOX0hFQURfTU9ERTtcbiAgICBwLl9wcm9jZXNzVG9rZW4odG9rZW4pO1xufVxuXG5cbi8vMTIuMi41LjQuNCBUaGUgXCJpbiBoZWFkXCIgaW5zZXJ0aW9uIG1vZGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzdGFydFRhZ0luSGVhZChwLCB0b2tlbikge1xuICAgIHZhciB0biA9IHRva2VuLnRhZ05hbWU7XG5cbiAgICBpZiAodG4gPT09ICQuSFRNTClcbiAgICAgICAgc3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgZWxzZSBpZiAodG4gPT09ICQuQkFTRSB8fCB0biA9PT0gJC5CQVNFRk9OVCB8fCB0biA9PT0gJC5CR1NPVU5EIHx8IHRuID09PSAkLkxJTksgfHwgdG4gPT09ICQuTUVUQSlcbiAgICAgICAgcC5fYXBwZW5kRWxlbWVudCh0b2tlbiwgTlMuSFRNTCk7XG5cbiAgICBlbHNlIGlmICh0biA9PT0gJC5USVRMRSlcbiAgICAgICAgcC5fc3dpdGNoVG9UZXh0UGFyc2luZyh0b2tlbiwgVG9rZW5pemVyLk1PREUuUkNEQVRBKTtcblxuICAgIC8vTk9URTogaGVyZSB3ZSBhc3N1bWUgdGhhdCB3ZSBhbHdheXMgYWN0IGFzIGFuIGludGVyYWN0aXZlIHVzZXIgYWdlbnQgd2l0aCBlbmFibGVkIHNjcmlwdGluZywgc28gd2UgcGFyc2VcbiAgICAvLzxub3NjcmlwdD4gYXMgYSByYXd0ZXh0LlxuICAgIGVsc2UgaWYgKHRuID09PSAkLk5PU0NSSVBUIHx8IHRuID09PSAkLk5PRlJBTUVTIHx8IHRuID09PSAkLlNUWUxFKVxuICAgICAgICBwLl9zd2l0Y2hUb1RleHRQYXJzaW5nKHRva2VuLCBUb2tlbml6ZXIuTU9ERS5SQVdURVhUKTtcblxuICAgIGVsc2UgaWYgKHRuID09PSAkLlNDUklQVClcbiAgICAgICAgcC5fc3dpdGNoVG9UZXh0UGFyc2luZyh0b2tlbiwgVG9rZW5pemVyLk1PREUuU0NSSVBUX0RBVEEpO1xuXG4gICAgZWxzZSBpZiAodG4gPT09ICQuVEVNUExBVEUpIHtcbiAgICAgICAgcC5faW5zZXJ0VGVtcGxhdGUodG9rZW4sIE5TLkhUTUwpO1xuICAgICAgICBwLmFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cy5pbnNlcnRNYXJrZXIoKTtcbiAgICAgICAgcC5mcmFtZXNldE9rID0gZmFsc2U7XG4gICAgICAgIHAuaW5zZXJ0aW9uTW9kZSA9IElOX1RFTVBMQVRFX01PREU7XG4gICAgICAgIHAuX3B1c2hUbXBsSW5zZXJ0aW9uTW9kZShJTl9URU1QTEFURV9NT0RFKTtcbiAgICB9XG5cbiAgICBlbHNlIGlmICh0biAhPT0gJC5IRUFEKVxuICAgICAgICB0b2tlbkluSGVhZChwLCB0b2tlbik7XG59XG5cbmZ1bmN0aW9uIGVuZFRhZ0luSGVhZChwLCB0b2tlbikge1xuICAgIHZhciB0biA9IHRva2VuLnRhZ05hbWU7XG5cbiAgICBpZiAodG4gPT09ICQuSEVBRCkge1xuICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3AoKTtcbiAgICAgICAgcC5pbnNlcnRpb25Nb2RlID0gQUZURVJfSEVBRF9NT0RFO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKHRuID09PSAkLkJPRFkgfHwgdG4gPT09ICQuQlIgfHwgdG4gPT09ICQuSFRNTClcbiAgICAgICAgdG9rZW5JbkhlYWQocCwgdG9rZW4pO1xuXG4gICAgZWxzZSBpZiAodG4gPT09ICQuVEVNUExBVEUgJiYgcC5vcGVuRWxlbWVudHMudG1wbENvdW50ID4gMCkge1xuICAgICAgICBwLm9wZW5FbGVtZW50cy5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKCk7XG4gICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcFVudGlsVGFnTmFtZVBvcHBlZCgkLlRFTVBMQVRFKTtcbiAgICAgICAgcC5hY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMuY2xlYXJUb0xhc3RNYXJrZXIoKTtcbiAgICAgICAgcC5fcG9wVG1wbEluc2VydGlvbk1vZGUoKTtcbiAgICAgICAgcC5fcmVzZXRJbnNlcnRpb25Nb2RlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b2tlbkluSGVhZChwLCB0b2tlbikge1xuICAgIHAub3BlbkVsZW1lbnRzLnBvcCgpO1xuICAgIHAuaW5zZXJ0aW9uTW9kZSA9IEFGVEVSX0hFQURfTU9ERTtcbiAgICBwLl9wcm9jZXNzVG9rZW4odG9rZW4pO1xufVxuXG5cbi8vMTIuMi41LjQuNiBUaGUgXCJhZnRlciBoZWFkXCIgaW5zZXJ0aW9uIG1vZGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzdGFydFRhZ0FmdGVySGVhZChwLCB0b2tlbikge1xuICAgIHZhciB0biA9IHRva2VuLnRhZ05hbWU7XG5cbiAgICBpZiAodG4gPT09ICQuSFRNTClcbiAgICAgICAgc3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgZWxzZSBpZiAodG4gPT09ICQuQk9EWSkge1xuICAgICAgICBwLl9pbnNlcnRFbGVtZW50KHRva2VuLCBOUy5IVE1MKTtcbiAgICAgICAgcC5mcmFtZXNldE9rID0gZmFsc2U7XG4gICAgICAgIHAuaW5zZXJ0aW9uTW9kZSA9IElOX0JPRFlfTU9ERTtcbiAgICB9XG5cbiAgICBlbHNlIGlmICh0biA9PT0gJC5GUkFNRVNFVCkge1xuICAgICAgICBwLl9pbnNlcnRFbGVtZW50KHRva2VuLCBOUy5IVE1MKTtcbiAgICAgICAgcC5pbnNlcnRpb25Nb2RlID0gSU5fRlJBTUVTRVRfTU9ERTtcbiAgICB9XG5cbiAgICBlbHNlIGlmICh0biA9PT0gJC5CQVNFIHx8IHRuID09PSAkLkJBU0VGT05UIHx8IHRuID09PSAkLkJHU09VTkQgfHwgdG4gPT09ICQuTElOSyB8fCB0biA9PT0gJC5NRVRBIHx8XG4gICAgICAgICAgICAgdG4gPT09ICQuTk9GUkFNRVMgfHwgdG4gPT09ICQuU0NSSVBUIHx8IHRuID09PSAkLlNUWUxFIHx8IHRuID09PSAkLlRFTVBMQVRFIHx8IHRuID09PSAkLlRJVExFKSB7XG4gICAgICAgIHAub3BlbkVsZW1lbnRzLnB1c2gocC5oZWFkRWxlbWVudCk7XG4gICAgICAgIHN0YXJ0VGFnSW5IZWFkKHAsIHRva2VuKTtcbiAgICAgICAgcC5vcGVuRWxlbWVudHMucmVtb3ZlKHAuaGVhZEVsZW1lbnQpO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKHRuICE9PSAkLkhFQUQpXG4gICAgICAgIHRva2VuQWZ0ZXJIZWFkKHAsIHRva2VuKTtcbn1cblxuZnVuY3Rpb24gZW5kVGFnQWZ0ZXJIZWFkKHAsIHRva2VuKSB7XG4gICAgdmFyIHRuID0gdG9rZW4udGFnTmFtZTtcblxuICAgIGlmICh0biA9PT0gJC5CT0RZIHx8IHRuID09PSAkLkhUTUwgfHwgdG4gPT09ICQuQlIpXG4gICAgICAgIHRva2VuQWZ0ZXJIZWFkKHAsIHRva2VuKTtcblxuICAgIGVsc2UgaWYgKHRuID09PSAkLlRFTVBMQVRFKVxuICAgICAgICBlbmRUYWdJbkhlYWQocCwgdG9rZW4pO1xufVxuXG5mdW5jdGlvbiB0b2tlbkFmdGVySGVhZChwLCB0b2tlbikge1xuICAgIHAuX2luc2VydEZha2VFbGVtZW50KCQuQk9EWSk7XG4gICAgcC5pbnNlcnRpb25Nb2RlID0gSU5fQk9EWV9NT0RFO1xuICAgIHAuX3Byb2Nlc3NUb2tlbih0b2tlbik7XG59XG5cblxuLy8xMi4yLjUuNC43IFRoZSBcImluIGJvZHlcIiBpbnNlcnRpb24gbW9kZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHdoaXRlc3BhY2VDaGFyYWN0ZXJJbkJvZHkocCwgdG9rZW4pIHtcbiAgICBwLl9yZWNvbnN0cnVjdEFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cygpO1xuICAgIHAuX2luc2VydENoYXJhY3RlcnModG9rZW4pO1xufVxuXG5mdW5jdGlvbiBjaGFyYWN0ZXJJbkJvZHkocCwgdG9rZW4pIHtcbiAgICBwLl9yZWNvbnN0cnVjdEFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cygpO1xuICAgIHAuX2luc2VydENoYXJhY3RlcnModG9rZW4pO1xuICAgIHAuZnJhbWVzZXRPayA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBodG1sU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICBpZiAocC5vcGVuRWxlbWVudHMudG1wbENvdW50ID09PSAwKVxuICAgICAgICBwLnRyZWVBZGFwdGVyLmFkb3B0QXR0cmlidXRlcyhwLm9wZW5FbGVtZW50cy5pdGVtc1swXSwgdG9rZW4uYXR0cnMpO1xufVxuXG5mdW5jdGlvbiBib2R5U3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICB2YXIgYm9keUVsZW1lbnQgPSBwLm9wZW5FbGVtZW50cy50cnlQZWVrUHJvcGVybHlOZXN0ZWRCb2R5RWxlbWVudCgpO1xuXG4gICAgaWYgKGJvZHlFbGVtZW50ICYmIHAub3BlbkVsZW1lbnRzLnRtcGxDb3VudCA9PT0gMCkge1xuICAgICAgICBwLmZyYW1lc2V0T2sgPSBmYWxzZTtcbiAgICAgICAgcC50cmVlQWRhcHRlci5hZG9wdEF0dHJpYnV0ZXMoYm9keUVsZW1lbnQsIHRva2VuLmF0dHJzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZyYW1lc2V0U3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICB2YXIgYm9keUVsZW1lbnQgPSBwLm9wZW5FbGVtZW50cy50cnlQZWVrUHJvcGVybHlOZXN0ZWRCb2R5RWxlbWVudCgpO1xuXG4gICAgaWYgKHAuZnJhbWVzZXRPayAmJiBib2R5RWxlbWVudCkge1xuICAgICAgICBwLnRyZWVBZGFwdGVyLmRldGFjaE5vZGUoYm9keUVsZW1lbnQpO1xuICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3BBbGxVcFRvSHRtbEVsZW1lbnQoKTtcbiAgICAgICAgcC5faW5zZXJ0RWxlbWVudCh0b2tlbiwgTlMuSFRNTCk7XG4gICAgICAgIHAuaW5zZXJ0aW9uTW9kZSA9IElOX0ZSQU1FU0VUX01PREU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRyZXNzU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICBpZiAocC5vcGVuRWxlbWVudHMuaGFzSW5CdXR0b25TY29wZSgkLlApKVxuICAgICAgICBwLl9jbG9zZVBFbGVtZW50KCk7XG5cbiAgICBwLl9pbnNlcnRFbGVtZW50KHRva2VuLCBOUy5IVE1MKTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyZWRIZWFkZXJTdGFydFRhZ0luQm9keShwLCB0b2tlbikge1xuICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJbkJ1dHRvblNjb3BlKCQuUCkpXG4gICAgICAgIHAuX2Nsb3NlUEVsZW1lbnQoKTtcblxuICAgIHZhciB0biA9IHAub3BlbkVsZW1lbnRzLmN1cnJlbnRUYWdOYW1lO1xuXG4gICAgaWYgKHRuID09PSAkLkgxIHx8IHRuID09PSAkLkgyIHx8IHRuID09PSAkLkgzIHx8IHRuID09PSAkLkg0IHx8IHRuID09PSAkLkg1IHx8IHRuID09PSAkLkg2KVxuICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3AoKTtcblxuICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xufVxuXG5mdW5jdGlvbiBwcmVTdGFydFRhZ0luQm9keShwLCB0b2tlbikge1xuICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJbkJ1dHRvblNjb3BlKCQuUCkpXG4gICAgICAgIHAuX2Nsb3NlUEVsZW1lbnQoKTtcblxuICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xuICAgIC8vTk9URTogSWYgdGhlIG5leHQgdG9rZW4gaXMgYSBVKzAwMEEgTElORSBGRUVEIChMRikgY2hhcmFjdGVyIHRva2VuLCB0aGVuIGlnbm9yZSB0aGF0IHRva2VuIGFuZCBtb3ZlXG4gICAgLy9vbiB0byB0aGUgbmV4dCBvbmUuIChOZXdsaW5lcyBhdCB0aGUgc3RhcnQgb2YgcHJlIGJsb2NrcyBhcmUgaWdub3JlZCBhcyBhbiBhdXRob3JpbmcgY29udmVuaWVuY2UuKVxuICAgIHAuc2tpcE5leHROZXdMaW5lID0gdHJ1ZTtcbiAgICBwLmZyYW1lc2V0T2sgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZm9ybVN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKSB7XG4gICAgdmFyIGluVGVtcGxhdGUgPSBwLm9wZW5FbGVtZW50cy50bXBsQ291bnQgPiAwO1xuXG4gICAgaWYgKCFwLmZvcm1FbGVtZW50IHx8IGluVGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKHAub3BlbkVsZW1lbnRzLmhhc0luQnV0dG9uU2NvcGUoJC5QKSlcbiAgICAgICAgICAgIHAuX2Nsb3NlUEVsZW1lbnQoKTtcblxuICAgICAgICBwLl9pbnNlcnRFbGVtZW50KHRva2VuLCBOUy5IVE1MKTtcblxuICAgICAgICBpZiAoIWluVGVtcGxhdGUpXG4gICAgICAgICAgICBwLmZvcm1FbGVtZW50ID0gcC5vcGVuRWxlbWVudHMuY3VycmVudDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxpc3RJdGVtU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICBwLmZyYW1lc2V0T2sgPSBmYWxzZTtcblxuICAgIHZhciB0biA9IHRva2VuLnRhZ05hbWU7XG5cbiAgICBmb3IgKHZhciBpID0gcC5vcGVuRWxlbWVudHMuc3RhY2tUb3A7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gcC5vcGVuRWxlbWVudHMuaXRlbXNbaV0sXG4gICAgICAgICAgICBlbGVtZW50VG4gPSBwLnRyZWVBZGFwdGVyLmdldFRhZ05hbWUoZWxlbWVudCksXG4gICAgICAgICAgICBjbG9zZVRuID0gbnVsbDtcblxuICAgICAgICBpZiAodG4gPT09ICQuTEkgJiYgZWxlbWVudFRuID09PSAkLkxJKVxuICAgICAgICAgICAgY2xvc2VUbiA9ICQuTEk7XG5cbiAgICAgICAgZWxzZSBpZiAoKHRuID09PSAkLkREIHx8IHRuID09PSAkLkRUKSAmJiAoZWxlbWVudFRuID09PSAkLkREIHx8IGVsZW1lbnRUbiA9PT0gJC5EVCkpXG4gICAgICAgICAgICBjbG9zZVRuID0gZWxlbWVudFRuO1xuXG4gICAgICAgIGlmIChjbG9zZVRuKSB7XG4gICAgICAgICAgICBwLm9wZW5FbGVtZW50cy5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzV2l0aEV4Y2x1c2lvbihjbG9zZVRuKTtcbiAgICAgICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcFVudGlsVGFnTmFtZVBvcHBlZChjbG9zZVRuKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnRUbiAhPT0gJC5BRERSRVNTICYmIGVsZW1lbnRUbiAhPT0gJC5ESVYgJiYgZWxlbWVudFRuICE9PSAkLlAgJiYgcC5faXNTcGVjaWFsRWxlbWVudChlbGVtZW50KSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJbkJ1dHRvblNjb3BlKCQuUCkpXG4gICAgICAgIHAuX2Nsb3NlUEVsZW1lbnQoKTtcblxuICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xufVxuXG5mdW5jdGlvbiBwbGFpbnRleHRTdGFydFRhZ0luQm9keShwLCB0b2tlbikge1xuICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJbkJ1dHRvblNjb3BlKCQuUCkpXG4gICAgICAgIHAuX2Nsb3NlUEVsZW1lbnQoKTtcblxuICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xuICAgIHAudG9rZW5pemVyLnN0YXRlID0gVG9rZW5pemVyLk1PREUuUExBSU5URVhUO1xufVxuXG5mdW5jdGlvbiBidXR0b25TdGFydFRhZ0luQm9keShwLCB0b2tlbikge1xuICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJblNjb3BlKCQuQlVUVE9OKSkge1xuICAgICAgICBwLm9wZW5FbGVtZW50cy5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKCk7XG4gICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcFVudGlsVGFnTmFtZVBvcHBlZCgkLkJVVFRPTik7XG4gICAgfVxuXG4gICAgcC5fcmVjb25zdHJ1Y3RBY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMoKTtcbiAgICBwLl9pbnNlcnRFbGVtZW50KHRva2VuLCBOUy5IVE1MKTtcbiAgICBwLmZyYW1lc2V0T2sgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYVN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKSB7XG4gICAgdmFyIGFjdGl2ZUVsZW1lbnRFbnRyeSA9IHAuYWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLmdldEVsZW1lbnRFbnRyeUluU2NvcGVXaXRoVGFnTmFtZSgkLkEpO1xuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnRFbnRyeSkge1xuICAgICAgICBjYWxsQWRvcHRpb25BZ2VuY3kocCwgdG9rZW4pO1xuICAgICAgICBwLm9wZW5FbGVtZW50cy5yZW1vdmUoYWN0aXZlRWxlbWVudEVudHJ5LmVsZW1lbnQpO1xuICAgICAgICBwLmFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cy5yZW1vdmVFbnRyeShhY3RpdmVFbGVtZW50RW50cnkpO1xuICAgIH1cblxuICAgIHAuX3JlY29uc3RydWN0QWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzKCk7XG4gICAgcC5faW5zZXJ0RWxlbWVudCh0b2tlbiwgTlMuSFRNTCk7XG4gICAgcC5hY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucHVzaEVsZW1lbnQocC5vcGVuRWxlbWVudHMuY3VycmVudCwgdG9rZW4pO1xufVxuXG5mdW5jdGlvbiBiU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICBwLl9yZWNvbnN0cnVjdEFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cygpO1xuICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xuICAgIHAuYWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLnB1c2hFbGVtZW50KHAub3BlbkVsZW1lbnRzLmN1cnJlbnQsIHRva2VuKTtcbn1cblxuZnVuY3Rpb24gbm9iclN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKSB7XG4gICAgcC5fcmVjb25zdHJ1Y3RBY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMoKTtcblxuICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJblNjb3BlKCQuTk9CUikpIHtcbiAgICAgICAgY2FsbEFkb3B0aW9uQWdlbmN5KHAsIHRva2VuKTtcbiAgICAgICAgcC5fcmVjb25zdHJ1Y3RBY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMoKTtcbiAgICB9XG5cbiAgICBwLl9pbnNlcnRFbGVtZW50KHRva2VuLCBOUy5IVE1MKTtcbiAgICBwLmFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cy5wdXNoRWxlbWVudChwLm9wZW5FbGVtZW50cy5jdXJyZW50LCB0b2tlbik7XG59XG5cbmZ1bmN0aW9uIGFwcGxldFN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKSB7XG4gICAgcC5fcmVjb25zdHJ1Y3RBY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMoKTtcbiAgICBwLl9pbnNlcnRFbGVtZW50KHRva2VuLCBOUy5IVE1MKTtcbiAgICBwLmFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cy5pbnNlcnRNYXJrZXIoKTtcbiAgICBwLmZyYW1lc2V0T2sgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdGFibGVTdGFydFRhZ0luQm9keShwLCB0b2tlbikge1xuICAgIGlmIChwLnRyZWVBZGFwdGVyLmdldERvY3VtZW50TW9kZShwLmRvY3VtZW50KSAhPT0gSFRNTC5ET0NVTUVOVF9NT0RFLlFVSVJLUyAmJiBwLm9wZW5FbGVtZW50cy5oYXNJbkJ1dHRvblNjb3BlKCQuUCkpXG4gICAgICAgIHAuX2Nsb3NlUEVsZW1lbnQoKTtcblxuICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xuICAgIHAuZnJhbWVzZXRPayA9IGZhbHNlO1xuICAgIHAuaW5zZXJ0aW9uTW9kZSA9IElOX1RBQkxFX01PREU7XG59XG5cbmZ1bmN0aW9uIGFyZWFTdGFydFRhZ0luQm9keShwLCB0b2tlbikge1xuICAgIHAuX3JlY29uc3RydWN0QWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzKCk7XG4gICAgcC5fYXBwZW5kRWxlbWVudCh0b2tlbiwgTlMuSFRNTCk7XG4gICAgcC5mcmFtZXNldE9rID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlucHV0U3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICBwLl9yZWNvbnN0cnVjdEFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cygpO1xuICAgIHAuX2FwcGVuZEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xuXG4gICAgdmFyIGlucHV0VHlwZSA9IFRva2VuaXplci5nZXRUb2tlbkF0dHIodG9rZW4sIEFUVFJTLlRZUEUpO1xuXG4gICAgaWYgKCFpbnB1dFR5cGUgfHwgaW5wdXRUeXBlLnRvTG93ZXJDYXNlKCkgIT09IEhJRERFTl9JTlBVVF9UWVBFKVxuICAgICAgICBwLmZyYW1lc2V0T2sgPSBmYWxzZTtcblxufVxuXG5mdW5jdGlvbiBwYXJhbVN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKSB7XG4gICAgcC5fYXBwZW5kRWxlbWVudCh0b2tlbiwgTlMuSFRNTCk7XG59XG5cbmZ1bmN0aW9uIGhyU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICBpZiAocC5vcGVuRWxlbWVudHMuaGFzSW5CdXR0b25TY29wZSgkLlApKVxuICAgICAgICBwLl9jbG9zZVBFbGVtZW50KCk7XG5cbiAgICBpZiAocC5vcGVuRWxlbWVudHMuY3VycmVudFRhZ05hbWUgPT09ICQuTUVOVUlURU0pXG4gICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcCgpO1xuXG4gICAgcC5fYXBwZW5kRWxlbWVudCh0b2tlbiwgTlMuSFRNTCk7XG4gICAgcC5mcmFtZXNldE9rID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGltYWdlU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICB0b2tlbi50YWdOYW1lID0gJC5JTUc7XG4gICAgYXJlYVN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcbn1cblxuZnVuY3Rpb24gdGV4dGFyZWFTdGFydFRhZ0luQm9keShwLCB0b2tlbikge1xuICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xuICAgIC8vTk9URTogSWYgdGhlIG5leHQgdG9rZW4gaXMgYSBVKzAwMEEgTElORSBGRUVEIChMRikgY2hhcmFjdGVyIHRva2VuLCB0aGVuIGlnbm9yZSB0aGF0IHRva2VuIGFuZCBtb3ZlXG4gICAgLy9vbiB0byB0aGUgbmV4dCBvbmUuIChOZXdsaW5lcyBhdCB0aGUgc3RhcnQgb2YgdGV4dGFyZWEgZWxlbWVudHMgYXJlIGlnbm9yZWQgYXMgYW4gYXV0aG9yaW5nIGNvbnZlbmllbmNlLilcbiAgICBwLnNraXBOZXh0TmV3TGluZSA9IHRydWU7XG4gICAgcC50b2tlbml6ZXIuc3RhdGUgPSBUb2tlbml6ZXIuTU9ERS5SQ0RBVEE7XG4gICAgcC5vcmlnaW5hbEluc2VydGlvbk1vZGUgPSBwLmluc2VydGlvbk1vZGU7XG4gICAgcC5mcmFtZXNldE9rID0gZmFsc2U7XG4gICAgcC5pbnNlcnRpb25Nb2RlID0gVEVYVF9NT0RFO1xufVxuXG5mdW5jdGlvbiB4bXBTdGFydFRhZ0luQm9keShwLCB0b2tlbikge1xuICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJbkJ1dHRvblNjb3BlKCQuUCkpXG4gICAgICAgIHAuX2Nsb3NlUEVsZW1lbnQoKTtcblxuICAgIHAuX3JlY29uc3RydWN0QWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzKCk7XG4gICAgcC5mcmFtZXNldE9rID0gZmFsc2U7XG4gICAgcC5fc3dpdGNoVG9UZXh0UGFyc2luZyh0b2tlbiwgVG9rZW5pemVyLk1PREUuUkFXVEVYVCk7XG59XG5cbmZ1bmN0aW9uIGlmcmFtZVN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKSB7XG4gICAgcC5mcmFtZXNldE9rID0gZmFsc2U7XG4gICAgcC5fc3dpdGNoVG9UZXh0UGFyc2luZyh0b2tlbiwgVG9rZW5pemVyLk1PREUuUkFXVEVYVCk7XG59XG5cbi8vTk9URTogaGVyZSB3ZSBhc3N1bWUgdGhhdCB3ZSBhbHdheXMgYWN0IGFzIGFuIHVzZXIgYWdlbnQgd2l0aCBlbmFibGVkIHBsdWdpbnMsIHNvIHdlIHBhcnNlXG4vLzxub2VtYmVkPiBhcyBhIHJhd3RleHQuXG5mdW5jdGlvbiBub2VtYmVkU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICBwLl9zd2l0Y2hUb1RleHRQYXJzaW5nKHRva2VuLCBUb2tlbml6ZXIuTU9ERS5SQVdURVhUKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0U3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICBwLl9yZWNvbnN0cnVjdEFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cygpO1xuICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xuICAgIHAuZnJhbWVzZXRPayA9IGZhbHNlO1xuXG4gICAgaWYgKHAuaW5zZXJ0aW9uTW9kZSA9PT0gSU5fVEFCTEVfTU9ERSB8fFxuICAgICAgICBwLmluc2VydGlvbk1vZGUgPT09IElOX0NBUFRJT05fTU9ERSB8fFxuICAgICAgICBwLmluc2VydGlvbk1vZGUgPT09IElOX1RBQkxFX0JPRFlfTU9ERSB8fFxuICAgICAgICBwLmluc2VydGlvbk1vZGUgPT09IElOX1JPV19NT0RFIHx8XG4gICAgICAgIHAuaW5zZXJ0aW9uTW9kZSA9PT0gSU5fQ0VMTF9NT0RFKVxuXG4gICAgICAgIHAuaW5zZXJ0aW9uTW9kZSA9IElOX1NFTEVDVF9JTl9UQUJMRV9NT0RFO1xuXG4gICAgZWxzZVxuICAgICAgICBwLmluc2VydGlvbk1vZGUgPSBJTl9TRUxFQ1RfTU9ERTtcbn1cblxuZnVuY3Rpb24gb3B0Z3JvdXBTdGFydFRhZ0luQm9keShwLCB0b2tlbikge1xuICAgIGlmIChwLm9wZW5FbGVtZW50cy5jdXJyZW50VGFnTmFtZSA9PT0gJC5PUFRJT04pXG4gICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcCgpO1xuXG4gICAgcC5fcmVjb25zdHJ1Y3RBY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMoKTtcbiAgICBwLl9pbnNlcnRFbGVtZW50KHRva2VuLCBOUy5IVE1MKTtcbn1cblxuZnVuY3Rpb24gcmJTdGFydFRhZ0luQm9keShwLCB0b2tlbikge1xuICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJblNjb3BlKCQuUlVCWSkpXG4gICAgICAgIHAub3BlbkVsZW1lbnRzLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3MoKTtcblxuICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xufVxuXG5mdW5jdGlvbiBydFN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKSB7XG4gICAgaWYgKHAub3BlbkVsZW1lbnRzLmhhc0luU2NvcGUoJC5SVUJZKSlcbiAgICAgICAgcC5vcGVuRWxlbWVudHMuZ2VuZXJhdGVJbXBsaWVkRW5kVGFnc1dpdGhFeGNsdXNpb24oJC5SVEMpO1xuXG4gICAgcC5faW5zZXJ0RWxlbWVudCh0b2tlbiwgTlMuSFRNTCk7XG59XG5cbmZ1bmN0aW9uIG1lbnVpdGVtU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICBpZiAocC5vcGVuRWxlbWVudHMuY3VycmVudFRhZ05hbWUgPT09ICQuTUVOVUlURU0pXG4gICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcCgpO1xuXG4gICAgLy8gVE9ETyBuZWVkcyBjbGFyaWZpY2F0aW9uLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL3B1bGwvOTA3L2ZpbGVzI3I3MzUwNTg3N1xuICAgIHAuX3JlY29uc3RydWN0QWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzKCk7XG5cbiAgICBwLl9pbnNlcnRFbGVtZW50KHRva2VuLCBOUy5IVE1MKTtcbn1cblxuZnVuY3Rpb24gbWVudVN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKSB7XG4gICAgaWYgKHAub3BlbkVsZW1lbnRzLmhhc0luQnV0dG9uU2NvcGUoJC5QKSlcbiAgICAgICAgcC5fY2xvc2VQRWxlbWVudCgpO1xuXG4gICAgaWYgKHAub3BlbkVsZW1lbnRzLmN1cnJlbnRUYWdOYW1lID09PSAkLk1FTlVJVEVNKVxuICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3AoKTtcblxuICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xufVxuXG5mdW5jdGlvbiBtYXRoU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICBwLl9yZWNvbnN0cnVjdEFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cygpO1xuXG4gICAgZm9yZWlnbkNvbnRlbnQuYWRqdXN0VG9rZW5NYXRoTUxBdHRycyh0b2tlbik7XG4gICAgZm9yZWlnbkNvbnRlbnQuYWRqdXN0VG9rZW5YTUxBdHRycyh0b2tlbik7XG5cbiAgICBpZiAodG9rZW4uc2VsZkNsb3NpbmcpXG4gICAgICAgIHAuX2FwcGVuZEVsZW1lbnQodG9rZW4sIE5TLk1BVEhNTCk7XG4gICAgZWxzZVxuICAgICAgICBwLl9pbnNlcnRFbGVtZW50KHRva2VuLCBOUy5NQVRITUwpO1xufVxuXG5mdW5jdGlvbiBzdmdTdGFydFRhZ0luQm9keShwLCB0b2tlbikge1xuICAgIHAuX3JlY29uc3RydWN0QWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzKCk7XG5cbiAgICBmb3JlaWduQ29udGVudC5hZGp1c3RUb2tlblNWR0F0dHJzKHRva2VuKTtcbiAgICBmb3JlaWduQ29udGVudC5hZGp1c3RUb2tlblhNTEF0dHJzKHRva2VuKTtcblxuICAgIGlmICh0b2tlbi5zZWxmQ2xvc2luZylcbiAgICAgICAgcC5fYXBwZW5kRWxlbWVudCh0b2tlbiwgTlMuU1ZHKTtcbiAgICBlbHNlXG4gICAgICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIE5TLlNWRyk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyaWNTdGFydFRhZ0luQm9keShwLCB0b2tlbikge1xuICAgIHAuX3JlY29uc3RydWN0QWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzKCk7XG4gICAgcC5faW5zZXJ0RWxlbWVudCh0b2tlbiwgTlMuSFRNTCk7XG59XG5cbi8vT1BUSU1JWkFUSU9OOiBJbnRlZ2VyIGNvbXBhcmlzb25zIGFyZSBsb3ctY29zdCwgc28gd2UgY2FuIHVzZSB2ZXJ5IGZhc3QgdGFnIG5hbWUgbGVuZ3RoIGZpbHRlcnMgaGVyZS5cbi8vSXQncyBmYXN0ZXIgdGhhbiB1c2luZyBkaWN0aW9uYXJ5LlxuZnVuY3Rpb24gc3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICB2YXIgdG4gPSB0b2tlbi50YWdOYW1lO1xuXG4gICAgc3dpdGNoICh0bi5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaWYgKHRuID09PSAkLkkgfHwgdG4gPT09ICQuUyB8fCB0biA9PT0gJC5CIHx8IHRuID09PSAkLlUpXG4gICAgICAgICAgICAgICAgYlN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuUClcbiAgICAgICAgICAgICAgICBhZGRyZXNzU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5BKVxuICAgICAgICAgICAgICAgIGFTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBnZW5lcmljU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAodG4gPT09ICQuREwgfHwgdG4gPT09ICQuT0wgfHwgdG4gPT09ICQuVUwpXG4gICAgICAgICAgICAgICAgYWRkcmVzc1N0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuSDEgfHwgdG4gPT09ICQuSDIgfHwgdG4gPT09ICQuSDMgfHwgdG4gPT09ICQuSDQgfHwgdG4gPT09ICQuSDUgfHwgdG4gPT09ICQuSDYpXG4gICAgICAgICAgICAgICAgbnVtYmVyZWRIZWFkZXJTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLkxJIHx8IHRuID09PSAkLkREIHx8IHRuID09PSAkLkRUKVxuICAgICAgICAgICAgICAgIGxpc3RJdGVtU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5FTSB8fCB0biA9PT0gJC5UVClcbiAgICAgICAgICAgICAgICBiU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5CUilcbiAgICAgICAgICAgICAgICBhcmVhU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5IUilcbiAgICAgICAgICAgICAgICBoclN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuUkIpXG4gICAgICAgICAgICAgICAgcmJTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLlJUIHx8IHRuID09PSAkLlJQKVxuICAgICAgICAgICAgICAgIHJ0U3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biAhPT0gJC5USCAmJiB0biAhPT0gJC5URCAmJiB0biAhPT0gJC5UUilcbiAgICAgICAgICAgICAgICBnZW5lcmljU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBpZiAodG4gPT09ICQuRElWIHx8IHRuID09PSAkLkRJUiB8fCB0biA9PT0gJC5OQVYpXG4gICAgICAgICAgICAgICAgYWRkcmVzc1N0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuUFJFKVxuICAgICAgICAgICAgICAgIHByZVN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuQklHKVxuICAgICAgICAgICAgICAgIGJTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLklNRyB8fCB0biA9PT0gJC5XQlIpXG4gICAgICAgICAgICAgICAgYXJlYVN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuWE1QKVxuICAgICAgICAgICAgICAgIHhtcFN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuU1ZHKVxuICAgICAgICAgICAgICAgIHN2Z1N0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuUlRDKVxuICAgICAgICAgICAgICAgIHJiU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biAhPT0gJC5DT0wpXG4gICAgICAgICAgICAgICAgZ2VuZXJpY1N0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgaWYgKHRuID09PSAkLkhUTUwpXG4gICAgICAgICAgICAgICAgaHRtbFN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuQkFTRSB8fCB0biA9PT0gJC5MSU5LIHx8IHRuID09PSAkLk1FVEEpXG4gICAgICAgICAgICAgICAgc3RhcnRUYWdJbkhlYWQocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5CT0RZKVxuICAgICAgICAgICAgICAgIGJvZHlTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLk1BSU4pXG4gICAgICAgICAgICAgICAgYWRkcmVzc1N0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuRk9STSlcbiAgICAgICAgICAgICAgICBmb3JtU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5DT0RFIHx8IHRuID09PSAkLkZPTlQpXG4gICAgICAgICAgICAgICAgYlN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuTk9CUilcbiAgICAgICAgICAgICAgICBub2JyU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5BUkVBKVxuICAgICAgICAgICAgICAgIGFyZWFTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLk1BVEgpXG4gICAgICAgICAgICAgICAgbWF0aFN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuTUVOVSlcbiAgICAgICAgICAgICAgICBtZW51U3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biAhPT0gJC5IRUFEKVxuICAgICAgICAgICAgICAgIGdlbmVyaWNTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGlmICh0biA9PT0gJC5TVFlMRSB8fCB0biA9PT0gJC5USVRMRSlcbiAgICAgICAgICAgICAgICBzdGFydFRhZ0luSGVhZChwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLkFTSURFKVxuICAgICAgICAgICAgICAgIGFkZHJlc3NTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLlNNQUxMKVxuICAgICAgICAgICAgICAgIGJTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLlRBQkxFKVxuICAgICAgICAgICAgICAgIHRhYmxlU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5FTUJFRClcbiAgICAgICAgICAgICAgICBhcmVhU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5JTlBVVClcbiAgICAgICAgICAgICAgICBpbnB1dFN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuUEFSQU0gfHwgdG4gPT09ICQuVFJBQ0spXG4gICAgICAgICAgICAgICAgcGFyYW1TdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLklNQUdFKVxuICAgICAgICAgICAgICAgIGltYWdlU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biAhPT0gJC5GUkFNRSAmJiB0biAhPT0gJC5UQk9EWSAmJiB0biAhPT0gJC5URk9PVCAmJiB0biAhPT0gJC5USEVBRClcbiAgICAgICAgICAgICAgICBnZW5lcmljU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBpZiAodG4gPT09ICQuU0NSSVBUKVxuICAgICAgICAgICAgICAgIHN0YXJ0VGFnSW5IZWFkKHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuQ0VOVEVSIHx8IHRuID09PSAkLkZJR1VSRSB8fCB0biA9PT0gJC5GT09URVIgfHwgdG4gPT09ICQuSEVBREVSIHx8IHRuID09PSAkLkhHUk9VUClcbiAgICAgICAgICAgICAgICBhZGRyZXNzU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5CVVRUT04pXG4gICAgICAgICAgICAgICAgYnV0dG9uU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5TVFJJS0UgfHwgdG4gPT09ICQuU1RST05HKVxuICAgICAgICAgICAgICAgIGJTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLkFQUExFVCB8fCB0biA9PT0gJC5PQkpFQ1QpXG4gICAgICAgICAgICAgICAgYXBwbGV0U3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5LRVlHRU4pXG4gICAgICAgICAgICAgICAgYXJlYVN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuU09VUkNFKVxuICAgICAgICAgICAgICAgIHBhcmFtU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5JRlJBTUUpXG4gICAgICAgICAgICAgICAgaWZyYW1lU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5TRUxFQ1QpXG4gICAgICAgICAgICAgICAgc2VsZWN0U3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5PUFRJT04pXG4gICAgICAgICAgICAgICAgb3B0Z3JvdXBTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBnZW5lcmljU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBpZiAodG4gPT09ICQuQkdTT1VORClcbiAgICAgICAgICAgICAgICBzdGFydFRhZ0luSGVhZChwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLkRFVEFJTFMgfHwgdG4gPT09ICQuQUREUkVTUyB8fCB0biA9PT0gJC5BUlRJQ0xFIHx8IHRuID09PSAkLlNFQ1RJT04gfHwgdG4gPT09ICQuU1VNTUFSWSlcbiAgICAgICAgICAgICAgICBhZGRyZXNzU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5MSVNUSU5HKVxuICAgICAgICAgICAgICAgIHByZVN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuTUFSUVVFRSlcbiAgICAgICAgICAgICAgICBhcHBsZXRTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLk5PRU1CRUQpXG4gICAgICAgICAgICAgICAgbm9lbWJlZFN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gIT09ICQuQ0FQVElPTilcbiAgICAgICAgICAgICAgICBnZW5lcmljU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBpZiAodG4gPT09ICQuQkFTRUZPTlQpXG4gICAgICAgICAgICAgICAgc3RhcnRUYWdJbkhlYWQocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5NRU5VSVRFTSlcbiAgICAgICAgICAgICAgICBtZW51aXRlbVN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuRlJBTUVTRVQpXG4gICAgICAgICAgICAgICAgZnJhbWVzZXRTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLkZJRUxEU0VUKVxuICAgICAgICAgICAgICAgIGFkZHJlc3NTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLlRFWFRBUkVBKVxuICAgICAgICAgICAgICAgIHRleHRhcmVhU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5URU1QTEFURSlcbiAgICAgICAgICAgICAgICBzdGFydFRhZ0luSGVhZChwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLk5PU0NSSVBUKVxuICAgICAgICAgICAgICAgIG5vZW1iZWRTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLk9QVEdST1VQKVxuICAgICAgICAgICAgICAgIG9wdGdyb3VwU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biAhPT0gJC5DT0xHUk9VUClcbiAgICAgICAgICAgICAgICBnZW5lcmljU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBpZiAodG4gPT09ICQuUExBSU5URVhUKVxuICAgICAgICAgICAgICAgIHBsYWludGV4dFN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGdlbmVyaWNTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBpZiAodG4gPT09ICQuQkxPQ0tRVU9URSB8fCB0biA9PT0gJC5GSUdDQVBUSU9OKVxuICAgICAgICAgICAgICAgIGFkZHJlc3NTdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBnZW5lcmljU3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZ2VuZXJpY1N0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJvZHlFbmRUYWdJbkJvZHkocCkge1xuICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJblNjb3BlKCQuQk9EWSkpXG4gICAgICAgIHAuaW5zZXJ0aW9uTW9kZSA9IEFGVEVSX0JPRFlfTU9ERTtcbn1cblxuZnVuY3Rpb24gaHRtbEVuZFRhZ0luQm9keShwLCB0b2tlbikge1xuICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJblNjb3BlKCQuQk9EWSkpIHtcbiAgICAgICAgcC5pbnNlcnRpb25Nb2RlID0gQUZURVJfQk9EWV9NT0RFO1xuICAgICAgICBwLl9wcm9jZXNzVG9rZW4odG9rZW4pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkcmVzc0VuZFRhZ0luQm9keShwLCB0b2tlbikge1xuICAgIHZhciB0biA9IHRva2VuLnRhZ05hbWU7XG5cbiAgICBpZiAocC5vcGVuRWxlbWVudHMuaGFzSW5TY29wZSh0bikpIHtcbiAgICAgICAgcC5vcGVuRWxlbWVudHMuZ2VuZXJhdGVJbXBsaWVkRW5kVGFncygpO1xuICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3BVbnRpbFRhZ05hbWVQb3BwZWQodG4pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9ybUVuZFRhZ0luQm9keShwKSB7XG4gICAgdmFyIGluVGVtcGxhdGUgPSBwLm9wZW5FbGVtZW50cy50bXBsQ291bnQgPiAwLFxuICAgICAgICBmb3JtRWxlbWVudCA9IHAuZm9ybUVsZW1lbnQ7XG5cbiAgICBpZiAoIWluVGVtcGxhdGUpXG4gICAgICAgIHAuZm9ybUVsZW1lbnQgPSBudWxsO1xuXG4gICAgaWYgKChmb3JtRWxlbWVudCB8fCBpblRlbXBsYXRlKSAmJiBwLm9wZW5FbGVtZW50cy5oYXNJblNjb3BlKCQuRk9STSkpIHtcbiAgICAgICAgcC5vcGVuRWxlbWVudHMuZ2VuZXJhdGVJbXBsaWVkRW5kVGFncygpO1xuXG4gICAgICAgIGlmIChpblRlbXBsYXRlKVxuICAgICAgICAgICAgcC5vcGVuRWxlbWVudHMucG9wVW50aWxUYWdOYW1lUG9wcGVkKCQuRk9STSk7XG5cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcC5vcGVuRWxlbWVudHMucmVtb3ZlKGZvcm1FbGVtZW50KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBFbmRUYWdJbkJvZHkocCkge1xuICAgIGlmICghcC5vcGVuRWxlbWVudHMuaGFzSW5CdXR0b25TY29wZSgkLlApKVxuICAgICAgICBwLl9pbnNlcnRGYWtlRWxlbWVudCgkLlApO1xuXG4gICAgcC5fY2xvc2VQRWxlbWVudCgpO1xufVxuXG5mdW5jdGlvbiBsaUVuZFRhZ0luQm9keShwKSB7XG4gICAgaWYgKHAub3BlbkVsZW1lbnRzLmhhc0luTGlzdEl0ZW1TY29wZSgkLkxJKSkge1xuICAgICAgICBwLm9wZW5FbGVtZW50cy5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzV2l0aEV4Y2x1c2lvbigkLkxJKTtcbiAgICAgICAgcC5vcGVuRWxlbWVudHMucG9wVW50aWxUYWdOYW1lUG9wcGVkKCQuTEkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGRFbmRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICB2YXIgdG4gPSB0b2tlbi50YWdOYW1lO1xuXG4gICAgaWYgKHAub3BlbkVsZW1lbnRzLmhhc0luU2NvcGUodG4pKSB7XG4gICAgICAgIHAub3BlbkVsZW1lbnRzLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3NXaXRoRXhjbHVzaW9uKHRuKTtcbiAgICAgICAgcC5vcGVuRWxlbWVudHMucG9wVW50aWxUYWdOYW1lUG9wcGVkKHRuKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG51bWJlcmVkSGVhZGVyRW5kVGFnSW5Cb2R5KHApIHtcbiAgICBpZiAocC5vcGVuRWxlbWVudHMuaGFzTnVtYmVyZWRIZWFkZXJJblNjb3BlKCkpIHtcbiAgICAgICAgcC5vcGVuRWxlbWVudHMuZ2VuZXJhdGVJbXBsaWVkRW5kVGFncygpO1xuICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3BVbnRpbE51bWJlcmVkSGVhZGVyUG9wcGVkKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcHBsZXRFbmRUYWdJbkJvZHkocCwgdG9rZW4pIHtcbiAgICB2YXIgdG4gPSB0b2tlbi50YWdOYW1lO1xuXG4gICAgaWYgKHAub3BlbkVsZW1lbnRzLmhhc0luU2NvcGUodG4pKSB7XG4gICAgICAgIHAub3BlbkVsZW1lbnRzLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3MoKTtcbiAgICAgICAgcC5vcGVuRWxlbWVudHMucG9wVW50aWxUYWdOYW1lUG9wcGVkKHRuKTtcbiAgICAgICAgcC5hY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMuY2xlYXJUb0xhc3RNYXJrZXIoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJyRW5kVGFnSW5Cb2R5KHApIHtcbiAgICBwLl9yZWNvbnN0cnVjdEFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cygpO1xuICAgIHAuX2luc2VydEZha2VFbGVtZW50KCQuQlIpO1xuICAgIHAub3BlbkVsZW1lbnRzLnBvcCgpO1xuICAgIHAuZnJhbWVzZXRPayA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZW5lcmljRW5kVGFnSW5Cb2R5KHAsIHRva2VuKSB7XG4gICAgdmFyIHRuID0gdG9rZW4udGFnTmFtZTtcblxuICAgIGZvciAodmFyIGkgPSBwLm9wZW5FbGVtZW50cy5zdGFja1RvcDsgaSA+IDA7IGktLSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHAub3BlbkVsZW1lbnRzLml0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChwLnRyZWVBZGFwdGVyLmdldFRhZ05hbWUoZWxlbWVudCkgPT09IHRuKSB7XG4gICAgICAgICAgICBwLm9wZW5FbGVtZW50cy5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzV2l0aEV4Y2x1c2lvbih0bik7XG4gICAgICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3BVbnRpbEVsZW1lbnRQb3BwZWQoZWxlbWVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwLl9pc1NwZWNpYWxFbGVtZW50KGVsZW1lbnQpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuXG4vL09QVElNSVpBVElPTjogSW50ZWdlciBjb21wYXJpc29ucyBhcmUgbG93LWNvc3QsIHNvIHdlIGNhbiB1c2UgdmVyeSBmYXN0IHRhZyBuYW1lIGxlbmd0aCBmaWx0ZXJzIGhlcmUuXG4vL0l0J3MgZmFzdGVyIHRoYW4gdXNpbmcgZGljdGlvbmFyeS5cbmZ1bmN0aW9uIGVuZFRhZ0luQm9keShwLCB0b2tlbikge1xuICAgIHZhciB0biA9IHRva2VuLnRhZ05hbWU7XG5cbiAgICBzd2l0Y2ggKHRuLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpZiAodG4gPT09ICQuQSB8fCB0biA9PT0gJC5CIHx8IHRuID09PSAkLkkgfHwgdG4gPT09ICQuUyB8fCB0biA9PT0gJC5VKVxuICAgICAgICAgICAgICAgIGNhbGxBZG9wdGlvbkFnZW5jeShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLlApXG4gICAgICAgICAgICAgICAgcEVuZFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBnZW5lcmljRW5kVGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKHRuID09PSAkLkRMIHx8IHRuID09PSAkLlVMIHx8IHRuID09PSAkLk9MKVxuICAgICAgICAgICAgICAgIGFkZHJlc3NFbmRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5MSSlcbiAgICAgICAgICAgICAgICBsaUVuZFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLkREIHx8IHRuID09PSAkLkRUKVxuICAgICAgICAgICAgICAgIGRkRW5kVGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuSDEgfHwgdG4gPT09ICQuSDIgfHwgdG4gPT09ICQuSDMgfHwgdG4gPT09ICQuSDQgfHwgdG4gPT09ICQuSDUgfHwgdG4gPT09ICQuSDYpXG4gICAgICAgICAgICAgICAgbnVtYmVyZWRIZWFkZXJFbmRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5CUilcbiAgICAgICAgICAgICAgICBickVuZFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLkVNIHx8IHRuID09PSAkLlRUKVxuICAgICAgICAgICAgICAgIGNhbGxBZG9wdGlvbkFnZW5jeShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBnZW5lcmljRW5kVGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYgKHRuID09PSAkLkJJRylcbiAgICAgICAgICAgICAgICBjYWxsQWRvcHRpb25BZ2VuY3kocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5ESVIgfHwgdG4gPT09ICQuRElWIHx8IHRuID09PSAkLk5BVilcbiAgICAgICAgICAgICAgICBhZGRyZXNzRW5kVGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGdlbmVyaWNFbmRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBpZiAodG4gPT09ICQuQk9EWSlcbiAgICAgICAgICAgICAgICBib2R5RW5kVGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuSFRNTClcbiAgICAgICAgICAgICAgICBodG1sRW5kVGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuRk9STSlcbiAgICAgICAgICAgICAgICBmb3JtRW5kVGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuQ09ERSB8fCB0biA9PT0gJC5GT05UIHx8IHRuID09PSAkLk5PQlIpXG4gICAgICAgICAgICAgICAgY2FsbEFkb3B0aW9uQWdlbmN5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuTUFJTiB8fCB0biA9PT0gJC5NRU5VKVxuICAgICAgICAgICAgICAgIGFkZHJlc3NFbmRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZ2VuZXJpY0VuZFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGlmICh0biA9PT0gJC5BU0lERSlcbiAgICAgICAgICAgICAgICBhZGRyZXNzRW5kVGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuU01BTEwpXG4gICAgICAgICAgICAgICAgY2FsbEFkb3B0aW9uQWdlbmN5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGdlbmVyaWNFbmRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBpZiAodG4gPT09ICQuQ0VOVEVSIHx8IHRuID09PSAkLkZJR1VSRSB8fCB0biA9PT0gJC5GT09URVIgfHwgdG4gPT09ICQuSEVBREVSIHx8IHRuID09PSAkLkhHUk9VUClcbiAgICAgICAgICAgICAgICBhZGRyZXNzRW5kVGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuQVBQTEVUIHx8IHRuID09PSAkLk9CSkVDVClcbiAgICAgICAgICAgICAgICBhcHBsZXRFbmRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5TVFJJS0UgfHwgdG4gPT09ICQuU1RST05HKVxuICAgICAgICAgICAgICAgIGNhbGxBZG9wdGlvbkFnZW5jeShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBnZW5lcmljRW5kVGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgaWYgKHRuID09PSAkLkFERFJFU1MgfHwgdG4gPT09ICQuQVJUSUNMRSB8fCB0biA9PT0gJC5ERVRBSUxTIHx8IHRuID09PSAkLlNFQ1RJT04gfHwgdG4gPT09ICQuU1VNTUFSWSlcbiAgICAgICAgICAgICAgICBhZGRyZXNzRW5kVGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuTUFSUVVFRSlcbiAgICAgICAgICAgICAgICBhcHBsZXRFbmRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZ2VuZXJpY0VuZFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGlmICh0biA9PT0gJC5GSUVMRFNFVClcbiAgICAgICAgICAgICAgICBhZGRyZXNzRW5kVGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuVEVNUExBVEUpXG4gICAgICAgICAgICAgICAgZW5kVGFnSW5IZWFkKHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGdlbmVyaWNFbmRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgaWYgKHRuID09PSAkLkJMT0NLUVVPVEUgfHwgdG4gPT09ICQuRklHQ0FQVElPTilcbiAgICAgICAgICAgICAgICBhZGRyZXNzRW5kVGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGdlbmVyaWNFbmRUYWdJbkJvZHkocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIGdlbmVyaWNFbmRUYWdJbkJvZHkocCwgdG9rZW4pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZW9mSW5Cb2R5KHAsIHRva2VuKSB7XG4gICAgaWYgKHAudG1wbEluc2VydGlvbk1vZGVTdGFja1RvcCA+IC0xKVxuICAgICAgICBlb2ZJblRlbXBsYXRlKHAsIHRva2VuKTtcblxuICAgIGVsc2VcbiAgICAgICAgcC5zdG9wcGVkID0gdHJ1ZTtcbn1cblxuLy8xMi4yLjUuNC44IFRoZSBcInRleHRcIiBpbnNlcnRpb24gbW9kZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGVuZFRhZ0luVGV4dChwLCB0b2tlbikge1xuICAgIGlmICh0b2tlbi50YWdOYW1lID09PSAkLlNDUklQVClcbiAgICAgICAgcC5wZW5kaW5nU2NyaXB0ID0gcC5vcGVuRWxlbWVudHMuY3VycmVudDtcblxuICAgIHAub3BlbkVsZW1lbnRzLnBvcCgpO1xuICAgIHAuaW5zZXJ0aW9uTW9kZSA9IHAub3JpZ2luYWxJbnNlcnRpb25Nb2RlO1xufVxuXG5cbmZ1bmN0aW9uIGVvZkluVGV4dChwLCB0b2tlbikge1xuICAgIHAub3BlbkVsZW1lbnRzLnBvcCgpO1xuICAgIHAuaW5zZXJ0aW9uTW9kZSA9IHAub3JpZ2luYWxJbnNlcnRpb25Nb2RlO1xuICAgIHAuX3Byb2Nlc3NUb2tlbih0b2tlbik7XG59XG5cblxuLy8xMi4yLjUuNC45IFRoZSBcImluIHRhYmxlXCIgaW5zZXJ0aW9uIG1vZGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBjaGFyYWN0ZXJJblRhYmxlKHAsIHRva2VuKSB7XG4gICAgdmFyIGN1clRuID0gcC5vcGVuRWxlbWVudHMuY3VycmVudFRhZ05hbWU7XG5cbiAgICBpZiAoY3VyVG4gPT09ICQuVEFCTEUgfHwgY3VyVG4gPT09ICQuVEJPRFkgfHwgY3VyVG4gPT09ICQuVEZPT1QgfHwgY3VyVG4gPT09ICQuVEhFQUQgfHwgY3VyVG4gPT09ICQuVFIpIHtcbiAgICAgICAgcC5wZW5kaW5nQ2hhcmFjdGVyVG9rZW5zID0gW107XG4gICAgICAgIHAuaGFzTm9uV2hpdGVzcGFjZVBlbmRpbmdDaGFyYWN0ZXJUb2tlbiA9IGZhbHNlO1xuICAgICAgICBwLm9yaWdpbmFsSW5zZXJ0aW9uTW9kZSA9IHAuaW5zZXJ0aW9uTW9kZTtcbiAgICAgICAgcC5pbnNlcnRpb25Nb2RlID0gSU5fVEFCTEVfVEVYVF9NT0RFO1xuICAgICAgICBwLl9wcm9jZXNzVG9rZW4odG9rZW4pO1xuICAgIH1cblxuICAgIGVsc2VcbiAgICAgICAgdG9rZW5JblRhYmxlKHAsIHRva2VuKTtcbn1cblxuZnVuY3Rpb24gY2FwdGlvblN0YXJ0VGFnSW5UYWJsZShwLCB0b2tlbikge1xuICAgIHAub3BlbkVsZW1lbnRzLmNsZWFyQmFja1RvVGFibGVDb250ZXh0KCk7XG4gICAgcC5hY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMuaW5zZXJ0TWFya2VyKCk7XG4gICAgcC5faW5zZXJ0RWxlbWVudCh0b2tlbiwgTlMuSFRNTCk7XG4gICAgcC5pbnNlcnRpb25Nb2RlID0gSU5fQ0FQVElPTl9NT0RFO1xufVxuXG5mdW5jdGlvbiBjb2xncm91cFN0YXJ0VGFnSW5UYWJsZShwLCB0b2tlbikge1xuICAgIHAub3BlbkVsZW1lbnRzLmNsZWFyQmFja1RvVGFibGVDb250ZXh0KCk7XG4gICAgcC5faW5zZXJ0RWxlbWVudCh0b2tlbiwgTlMuSFRNTCk7XG4gICAgcC5pbnNlcnRpb25Nb2RlID0gSU5fQ09MVU1OX0dST1VQX01PREU7XG59XG5cbmZ1bmN0aW9uIGNvbFN0YXJ0VGFnSW5UYWJsZShwLCB0b2tlbikge1xuICAgIHAub3BlbkVsZW1lbnRzLmNsZWFyQmFja1RvVGFibGVDb250ZXh0KCk7XG4gICAgcC5faW5zZXJ0RmFrZUVsZW1lbnQoJC5DT0xHUk9VUCk7XG4gICAgcC5pbnNlcnRpb25Nb2RlID0gSU5fQ09MVU1OX0dST1VQX01PREU7XG4gICAgcC5fcHJvY2Vzc1Rva2VuKHRva2VuKTtcbn1cblxuZnVuY3Rpb24gdGJvZHlTdGFydFRhZ0luVGFibGUocCwgdG9rZW4pIHtcbiAgICBwLm9wZW5FbGVtZW50cy5jbGVhckJhY2tUb1RhYmxlQ29udGV4dCgpO1xuICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xuICAgIHAuaW5zZXJ0aW9uTW9kZSA9IElOX1RBQkxFX0JPRFlfTU9ERTtcbn1cblxuZnVuY3Rpb24gdGRTdGFydFRhZ0luVGFibGUocCwgdG9rZW4pIHtcbiAgICBwLm9wZW5FbGVtZW50cy5jbGVhckJhY2tUb1RhYmxlQ29udGV4dCgpO1xuICAgIHAuX2luc2VydEZha2VFbGVtZW50KCQuVEJPRFkpO1xuICAgIHAuaW5zZXJ0aW9uTW9kZSA9IElOX1RBQkxFX0JPRFlfTU9ERTtcbiAgICBwLl9wcm9jZXNzVG9rZW4odG9rZW4pO1xufVxuXG5mdW5jdGlvbiB0YWJsZVN0YXJ0VGFnSW5UYWJsZShwLCB0b2tlbikge1xuICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJblRhYmxlU2NvcGUoJC5UQUJMRSkpIHtcbiAgICAgICAgcC5vcGVuRWxlbWVudHMucG9wVW50aWxUYWdOYW1lUG9wcGVkKCQuVEFCTEUpO1xuICAgICAgICBwLl9yZXNldEluc2VydGlvbk1vZGUoKTtcbiAgICAgICAgcC5fcHJvY2Vzc1Rva2VuKHRva2VuKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlucHV0U3RhcnRUYWdJblRhYmxlKHAsIHRva2VuKSB7XG4gICAgdmFyIGlucHV0VHlwZSA9IFRva2VuaXplci5nZXRUb2tlbkF0dHIodG9rZW4sIEFUVFJTLlRZUEUpO1xuXG4gICAgaWYgKGlucHV0VHlwZSAmJiBpbnB1dFR5cGUudG9Mb3dlckNhc2UoKSA9PT0gSElEREVOX0lOUFVUX1RZUEUpXG4gICAgICAgIHAuX2FwcGVuZEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xuXG4gICAgZWxzZVxuICAgICAgICB0b2tlbkluVGFibGUocCwgdG9rZW4pO1xufVxuXG5mdW5jdGlvbiBmb3JtU3RhcnRUYWdJblRhYmxlKHAsIHRva2VuKSB7XG4gICAgaWYgKCFwLmZvcm1FbGVtZW50ICYmIHAub3BlbkVsZW1lbnRzLnRtcGxDb3VudCA9PT0gMCkge1xuICAgICAgICBwLl9pbnNlcnRFbGVtZW50KHRva2VuLCBOUy5IVE1MKTtcbiAgICAgICAgcC5mb3JtRWxlbWVudCA9IHAub3BlbkVsZW1lbnRzLmN1cnJlbnQ7XG4gICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRUYWdJblRhYmxlKHAsIHRva2VuKSB7XG4gICAgdmFyIHRuID0gdG9rZW4udGFnTmFtZTtcblxuICAgIHN3aXRjaCAodG4ubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGlmICh0biA9PT0gJC5URCB8fCB0biA9PT0gJC5USCB8fCB0biA9PT0gJC5UUilcbiAgICAgICAgICAgICAgICB0ZFN0YXJ0VGFnSW5UYWJsZShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0b2tlbkluVGFibGUocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBpZiAodG4gPT09ICQuQ09MKVxuICAgICAgICAgICAgICAgIGNvbFN0YXJ0VGFnSW5UYWJsZShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0b2tlbkluVGFibGUocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBpZiAodG4gPT09ICQuRk9STSlcbiAgICAgICAgICAgICAgICBmb3JtU3RhcnRUYWdJblRhYmxlKHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRva2VuSW5UYWJsZShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGlmICh0biA9PT0gJC5UQUJMRSlcbiAgICAgICAgICAgICAgICB0YWJsZVN0YXJ0VGFnSW5UYWJsZShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLlNUWUxFKVxuICAgICAgICAgICAgICAgIHN0YXJ0VGFnSW5IZWFkKHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuVEJPRFkgfHwgdG4gPT09ICQuVEZPT1QgfHwgdG4gPT09ICQuVEhFQUQpXG4gICAgICAgICAgICAgICAgdGJvZHlTdGFydFRhZ0luVGFibGUocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0biA9PT0gJC5JTlBVVClcbiAgICAgICAgICAgICAgICBpbnB1dFN0YXJ0VGFnSW5UYWJsZShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0b2tlbkluVGFibGUocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBpZiAodG4gPT09ICQuU0NSSVBUKVxuICAgICAgICAgICAgICAgIHN0YXJ0VGFnSW5IZWFkKHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRva2VuSW5UYWJsZShwLCB0b2tlbik7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGlmICh0biA9PT0gJC5DQVBUSU9OKVxuICAgICAgICAgICAgICAgIGNhcHRpb25TdGFydFRhZ0luVGFibGUocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdG9rZW5JblRhYmxlKHAsIHRva2VuKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgaWYgKHRuID09PSAkLkNPTEdST1VQKVxuICAgICAgICAgICAgICAgIGNvbGdyb3VwU3RhcnRUYWdJblRhYmxlKHAsIHRva2VuKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuVEVNUExBVEUpXG4gICAgICAgICAgICAgICAgc3RhcnRUYWdJbkhlYWQocCwgdG9rZW4pO1xuXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdG9rZW5JblRhYmxlKHAsIHRva2VuKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRva2VuSW5UYWJsZShwLCB0b2tlbik7XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGVuZFRhZ0luVGFibGUocCwgdG9rZW4pIHtcbiAgICB2YXIgdG4gPSB0b2tlbi50YWdOYW1lO1xuXG4gICAgaWYgKHRuID09PSAkLlRBQkxFKSB7XG4gICAgICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJblRhYmxlU2NvcGUoJC5UQUJMRSkpIHtcbiAgICAgICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcFVudGlsVGFnTmFtZVBvcHBlZCgkLlRBQkxFKTtcbiAgICAgICAgICAgIHAuX3Jlc2V0SW5zZXJ0aW9uTW9kZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZWxzZSBpZiAodG4gPT09ICQuVEVNUExBVEUpXG4gICAgICAgIGVuZFRhZ0luSGVhZChwLCB0b2tlbik7XG5cbiAgICBlbHNlIGlmICh0biAhPT0gJC5CT0RZICYmIHRuICE9PSAkLkNBUFRJT04gJiYgdG4gIT09ICQuQ09MICYmIHRuICE9PSAkLkNPTEdST1VQICYmIHRuICE9PSAkLkhUTUwgJiZcbiAgICAgICAgICAgICB0biAhPT0gJC5UQk9EWSAmJiB0biAhPT0gJC5URCAmJiB0biAhPT0gJC5URk9PVCAmJiB0biAhPT0gJC5USCAmJiB0biAhPT0gJC5USEVBRCAmJiB0biAhPT0gJC5UUilcbiAgICAgICAgdG9rZW5JblRhYmxlKHAsIHRva2VuKTtcbn1cblxuZnVuY3Rpb24gdG9rZW5JblRhYmxlKHAsIHRva2VuKSB7XG4gICAgdmFyIHNhdmVkRm9zdGVyUGFyZW50aW5nU3RhdGUgPSBwLmZvc3RlclBhcmVudGluZ0VuYWJsZWQ7XG5cbiAgICBwLmZvc3RlclBhcmVudGluZ0VuYWJsZWQgPSB0cnVlO1xuICAgIHAuX3Byb2Nlc3NUb2tlbkluQm9keU1vZGUodG9rZW4pO1xuICAgIHAuZm9zdGVyUGFyZW50aW5nRW5hYmxlZCA9IHNhdmVkRm9zdGVyUGFyZW50aW5nU3RhdGU7XG59XG5cblxuLy8xMi4yLjUuNC4xMCBUaGUgXCJpbiB0YWJsZSB0ZXh0XCIgaW5zZXJ0aW9uIG1vZGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiB3aGl0ZXNwYWNlQ2hhcmFjdGVySW5UYWJsZVRleHQocCwgdG9rZW4pIHtcbiAgICBwLnBlbmRpbmdDaGFyYWN0ZXJUb2tlbnMucHVzaCh0b2tlbik7XG59XG5cbmZ1bmN0aW9uIGNoYXJhY3RlckluVGFibGVUZXh0KHAsIHRva2VuKSB7XG4gICAgcC5wZW5kaW5nQ2hhcmFjdGVyVG9rZW5zLnB1c2godG9rZW4pO1xuICAgIHAuaGFzTm9uV2hpdGVzcGFjZVBlbmRpbmdDaGFyYWN0ZXJUb2tlbiA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHRva2VuSW5UYWJsZVRleHQocCwgdG9rZW4pIHtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBpZiAocC5oYXNOb25XaGl0ZXNwYWNlUGVuZGluZ0NoYXJhY3RlclRva2VuKSB7XG4gICAgICAgIGZvciAoOyBpIDwgcC5wZW5kaW5nQ2hhcmFjdGVyVG9rZW5zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdG9rZW5JblRhYmxlKHAsIHAucGVuZGluZ0NoYXJhY3RlclRva2Vuc1tpXSk7XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgcC5wZW5kaW5nQ2hhcmFjdGVyVG9rZW5zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcC5faW5zZXJ0Q2hhcmFjdGVycyhwLnBlbmRpbmdDaGFyYWN0ZXJUb2tlbnNbaV0pO1xuICAgIH1cblxuICAgIHAuaW5zZXJ0aW9uTW9kZSA9IHAub3JpZ2luYWxJbnNlcnRpb25Nb2RlO1xuICAgIHAuX3Byb2Nlc3NUb2tlbih0b2tlbik7XG59XG5cblxuLy8xMi4yLjUuNC4xMSBUaGUgXCJpbiBjYXB0aW9uXCIgaW5zZXJ0aW9uIG1vZGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzdGFydFRhZ0luQ2FwdGlvbihwLCB0b2tlbikge1xuICAgIHZhciB0biA9IHRva2VuLnRhZ05hbWU7XG5cbiAgICBpZiAodG4gPT09ICQuQ0FQVElPTiB8fCB0biA9PT0gJC5DT0wgfHwgdG4gPT09ICQuQ09MR1JPVVAgfHwgdG4gPT09ICQuVEJPRFkgfHxcbiAgICAgICAgdG4gPT09ICQuVEQgfHwgdG4gPT09ICQuVEZPT1QgfHwgdG4gPT09ICQuVEggfHwgdG4gPT09ICQuVEhFQUQgfHwgdG4gPT09ICQuVFIpIHtcbiAgICAgICAgaWYgKHAub3BlbkVsZW1lbnRzLmhhc0luVGFibGVTY29wZSgkLkNBUFRJT04pKSB7XG4gICAgICAgICAgICBwLm9wZW5FbGVtZW50cy5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKCk7XG4gICAgICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3BVbnRpbFRhZ05hbWVQb3BwZWQoJC5DQVBUSU9OKTtcbiAgICAgICAgICAgIHAuYWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLmNsZWFyVG9MYXN0TWFya2VyKCk7XG4gICAgICAgICAgICBwLmluc2VydGlvbk1vZGUgPSBJTl9UQUJMRV9NT0RFO1xuICAgICAgICAgICAgcC5fcHJvY2Vzc1Rva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsc2VcbiAgICAgICAgc3RhcnRUYWdJbkJvZHkocCwgdG9rZW4pO1xufVxuXG5mdW5jdGlvbiBlbmRUYWdJbkNhcHRpb24ocCwgdG9rZW4pIHtcbiAgICB2YXIgdG4gPSB0b2tlbi50YWdOYW1lO1xuXG4gICAgaWYgKHRuID09PSAkLkNBUFRJT04gfHwgdG4gPT09ICQuVEFCTEUpIHtcbiAgICAgICAgaWYgKHAub3BlbkVsZW1lbnRzLmhhc0luVGFibGVTY29wZSgkLkNBUFRJT04pKSB7XG4gICAgICAgICAgICBwLm9wZW5FbGVtZW50cy5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKCk7XG4gICAgICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3BVbnRpbFRhZ05hbWVQb3BwZWQoJC5DQVBUSU9OKTtcbiAgICAgICAgICAgIHAuYWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLmNsZWFyVG9MYXN0TWFya2VyKCk7XG4gICAgICAgICAgICBwLmluc2VydGlvbk1vZGUgPSBJTl9UQUJMRV9NT0RFO1xuXG4gICAgICAgICAgICBpZiAodG4gPT09ICQuVEFCTEUpXG4gICAgICAgICAgICAgICAgcC5fcHJvY2Vzc1Rva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsc2UgaWYgKHRuICE9PSAkLkJPRFkgJiYgdG4gIT09ICQuQ09MICYmIHRuICE9PSAkLkNPTEdST1VQICYmIHRuICE9PSAkLkhUTUwgJiYgdG4gIT09ICQuVEJPRFkgJiZcbiAgICAgICAgICAgICB0biAhPT0gJC5URCAmJiB0biAhPT0gJC5URk9PVCAmJiB0biAhPT0gJC5USCAmJiB0biAhPT0gJC5USEVBRCAmJiB0biAhPT0gJC5UUilcbiAgICAgICAgZW5kVGFnSW5Cb2R5KHAsIHRva2VuKTtcbn1cblxuXG4vLzEyLjIuNS40LjEyIFRoZSBcImluIGNvbHVtbiBncm91cFwiIGluc2VydGlvbiBtb2RlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gc3RhcnRUYWdJbkNvbHVtbkdyb3VwKHAsIHRva2VuKSB7XG4gICAgdmFyIHRuID0gdG9rZW4udGFnTmFtZTtcblxuICAgIGlmICh0biA9PT0gJC5IVE1MKVxuICAgICAgICBzdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICBlbHNlIGlmICh0biA9PT0gJC5DT0wpXG4gICAgICAgIHAuX2FwcGVuZEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xuXG4gICAgZWxzZSBpZiAodG4gPT09ICQuVEVNUExBVEUpXG4gICAgICAgIHN0YXJ0VGFnSW5IZWFkKHAsIHRva2VuKTtcblxuICAgIGVsc2VcbiAgICAgICAgdG9rZW5JbkNvbHVtbkdyb3VwKHAsIHRva2VuKTtcbn1cblxuZnVuY3Rpb24gZW5kVGFnSW5Db2x1bW5Hcm91cChwLCB0b2tlbikge1xuICAgIHZhciB0biA9IHRva2VuLnRhZ05hbWU7XG5cbiAgICBpZiAodG4gPT09ICQuQ09MR1JPVVApIHtcbiAgICAgICAgaWYgKHAub3BlbkVsZW1lbnRzLmN1cnJlbnRUYWdOYW1lID09PSAkLkNPTEdST1VQKSB7XG4gICAgICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIHAuaW5zZXJ0aW9uTW9kZSA9IElOX1RBQkxFX01PREU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbHNlIGlmICh0biA9PT0gJC5URU1QTEFURSlcbiAgICAgICAgZW5kVGFnSW5IZWFkKHAsIHRva2VuKTtcblxuICAgIGVsc2UgaWYgKHRuICE9PSAkLkNPTClcbiAgICAgICAgdG9rZW5JbkNvbHVtbkdyb3VwKHAsIHRva2VuKTtcbn1cblxuZnVuY3Rpb24gdG9rZW5JbkNvbHVtbkdyb3VwKHAsIHRva2VuKSB7XG4gICAgaWYgKHAub3BlbkVsZW1lbnRzLmN1cnJlbnRUYWdOYW1lID09PSAkLkNPTEdST1VQKSB7XG4gICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcCgpO1xuICAgICAgICBwLmluc2VydGlvbk1vZGUgPSBJTl9UQUJMRV9NT0RFO1xuICAgICAgICBwLl9wcm9jZXNzVG9rZW4odG9rZW4pO1xuICAgIH1cbn1cblxuLy8xMi4yLjUuNC4xMyBUaGUgXCJpbiB0YWJsZSBib2R5XCIgaW5zZXJ0aW9uIG1vZGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzdGFydFRhZ0luVGFibGVCb2R5KHAsIHRva2VuKSB7XG4gICAgdmFyIHRuID0gdG9rZW4udGFnTmFtZTtcblxuICAgIGlmICh0biA9PT0gJC5UUikge1xuICAgICAgICBwLm9wZW5FbGVtZW50cy5jbGVhckJhY2tUb1RhYmxlQm9keUNvbnRleHQoKTtcbiAgICAgICAgcC5faW5zZXJ0RWxlbWVudCh0b2tlbiwgTlMuSFRNTCk7XG4gICAgICAgIHAuaW5zZXJ0aW9uTW9kZSA9IElOX1JPV19NT0RFO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKHRuID09PSAkLlRIIHx8IHRuID09PSAkLlREKSB7XG4gICAgICAgIHAub3BlbkVsZW1lbnRzLmNsZWFyQmFja1RvVGFibGVCb2R5Q29udGV4dCgpO1xuICAgICAgICBwLl9pbnNlcnRGYWtlRWxlbWVudCgkLlRSKTtcbiAgICAgICAgcC5pbnNlcnRpb25Nb2RlID0gSU5fUk9XX01PREU7XG4gICAgICAgIHAuX3Byb2Nlc3NUb2tlbih0b2tlbik7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAodG4gPT09ICQuQ0FQVElPTiB8fCB0biA9PT0gJC5DT0wgfHwgdG4gPT09ICQuQ09MR1JPVVAgfHxcbiAgICAgICAgICAgICB0biA9PT0gJC5UQk9EWSB8fCB0biA9PT0gJC5URk9PVCB8fCB0biA9PT0gJC5USEVBRCkge1xuXG4gICAgICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNUYWJsZUJvZHlDb250ZXh0SW5UYWJsZVNjb3BlKCkpIHtcbiAgICAgICAgICAgIHAub3BlbkVsZW1lbnRzLmNsZWFyQmFja1RvVGFibGVCb2R5Q29udGV4dCgpO1xuICAgICAgICAgICAgcC5vcGVuRWxlbWVudHMucG9wKCk7XG4gICAgICAgICAgICBwLmluc2VydGlvbk1vZGUgPSBJTl9UQUJMRV9NT0RFO1xuICAgICAgICAgICAgcC5fcHJvY2Vzc1Rva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsc2VcbiAgICAgICAgc3RhcnRUYWdJblRhYmxlKHAsIHRva2VuKTtcbn1cblxuZnVuY3Rpb24gZW5kVGFnSW5UYWJsZUJvZHkocCwgdG9rZW4pIHtcbiAgICB2YXIgdG4gPSB0b2tlbi50YWdOYW1lO1xuXG4gICAgaWYgKHRuID09PSAkLlRCT0RZIHx8IHRuID09PSAkLlRGT09UIHx8IHRuID09PSAkLlRIRUFEKSB7XG4gICAgICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJblRhYmxlU2NvcGUodG4pKSB7XG4gICAgICAgICAgICBwLm9wZW5FbGVtZW50cy5jbGVhckJhY2tUb1RhYmxlQm9keUNvbnRleHQoKTtcbiAgICAgICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcCgpO1xuICAgICAgICAgICAgcC5pbnNlcnRpb25Nb2RlID0gSU5fVEFCTEVfTU9ERTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsc2UgaWYgKHRuID09PSAkLlRBQkxFKSB7XG4gICAgICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNUYWJsZUJvZHlDb250ZXh0SW5UYWJsZVNjb3BlKCkpIHtcbiAgICAgICAgICAgIHAub3BlbkVsZW1lbnRzLmNsZWFyQmFja1RvVGFibGVCb2R5Q29udGV4dCgpO1xuICAgICAgICAgICAgcC5vcGVuRWxlbWVudHMucG9wKCk7XG4gICAgICAgICAgICBwLmluc2VydGlvbk1vZGUgPSBJTl9UQUJMRV9NT0RFO1xuICAgICAgICAgICAgcC5fcHJvY2Vzc1Rva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsc2UgaWYgKHRuICE9PSAkLkJPRFkgJiYgdG4gIT09ICQuQ0FQVElPTiAmJiB0biAhPT0gJC5DT0wgJiYgdG4gIT09ICQuQ09MR1JPVVAgfHxcbiAgICAgICAgICAgICB0biAhPT0gJC5IVE1MICYmIHRuICE9PSAkLlREICYmIHRuICE9PSAkLlRIICYmIHRuICE9PSAkLlRSKVxuICAgICAgICBlbmRUYWdJblRhYmxlKHAsIHRva2VuKTtcbn1cblxuLy8xMi4yLjUuNC4xNCBUaGUgXCJpbiByb3dcIiBpbnNlcnRpb24gbW9kZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHN0YXJ0VGFnSW5Sb3cocCwgdG9rZW4pIHtcbiAgICB2YXIgdG4gPSB0b2tlbi50YWdOYW1lO1xuXG4gICAgaWYgKHRuID09PSAkLlRIIHx8IHRuID09PSAkLlREKSB7XG4gICAgICAgIHAub3BlbkVsZW1lbnRzLmNsZWFyQmFja1RvVGFibGVSb3dDb250ZXh0KCk7XG4gICAgICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xuICAgICAgICBwLmluc2VydGlvbk1vZGUgPSBJTl9DRUxMX01PREU7XG4gICAgICAgIHAuYWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLmluc2VydE1hcmtlcigpO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKHRuID09PSAkLkNBUFRJT04gfHwgdG4gPT09ICQuQ09MIHx8IHRuID09PSAkLkNPTEdST1VQIHx8IHRuID09PSAkLlRCT0RZIHx8XG4gICAgICAgICAgICAgdG4gPT09ICQuVEZPT1QgfHwgdG4gPT09ICQuVEhFQUQgfHwgdG4gPT09ICQuVFIpIHtcbiAgICAgICAgaWYgKHAub3BlbkVsZW1lbnRzLmhhc0luVGFibGVTY29wZSgkLlRSKSkge1xuICAgICAgICAgICAgcC5vcGVuRWxlbWVudHMuY2xlYXJCYWNrVG9UYWJsZVJvd0NvbnRleHQoKTtcbiAgICAgICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcCgpO1xuICAgICAgICAgICAgcC5pbnNlcnRpb25Nb2RlID0gSU5fVEFCTEVfQk9EWV9NT0RFO1xuICAgICAgICAgICAgcC5fcHJvY2Vzc1Rva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsc2VcbiAgICAgICAgc3RhcnRUYWdJblRhYmxlKHAsIHRva2VuKTtcbn1cblxuZnVuY3Rpb24gZW5kVGFnSW5Sb3cocCwgdG9rZW4pIHtcbiAgICB2YXIgdG4gPSB0b2tlbi50YWdOYW1lO1xuXG4gICAgaWYgKHRuID09PSAkLlRSKSB7XG4gICAgICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJblRhYmxlU2NvcGUoJC5UUikpIHtcbiAgICAgICAgICAgIHAub3BlbkVsZW1lbnRzLmNsZWFyQmFja1RvVGFibGVSb3dDb250ZXh0KCk7XG4gICAgICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIHAuaW5zZXJ0aW9uTW9kZSA9IElOX1RBQkxFX0JPRFlfTU9ERTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsc2UgaWYgKHRuID09PSAkLlRBQkxFKSB7XG4gICAgICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJblRhYmxlU2NvcGUoJC5UUikpIHtcbiAgICAgICAgICAgIHAub3BlbkVsZW1lbnRzLmNsZWFyQmFja1RvVGFibGVSb3dDb250ZXh0KCk7XG4gICAgICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIHAuaW5zZXJ0aW9uTW9kZSA9IElOX1RBQkxFX0JPRFlfTU9ERTtcbiAgICAgICAgICAgIHAuX3Byb2Nlc3NUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbHNlIGlmICh0biA9PT0gJC5UQk9EWSB8fCB0biA9PT0gJC5URk9PVCB8fCB0biA9PT0gJC5USEVBRCkge1xuICAgICAgICBpZiAocC5vcGVuRWxlbWVudHMuaGFzSW5UYWJsZVNjb3BlKHRuKSB8fCBwLm9wZW5FbGVtZW50cy5oYXNJblRhYmxlU2NvcGUoJC5UUikpIHtcbiAgICAgICAgICAgIHAub3BlbkVsZW1lbnRzLmNsZWFyQmFja1RvVGFibGVSb3dDb250ZXh0KCk7XG4gICAgICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIHAuaW5zZXJ0aW9uTW9kZSA9IElOX1RBQkxFX0JPRFlfTU9ERTtcbiAgICAgICAgICAgIHAuX3Byb2Nlc3NUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbHNlIGlmICh0biAhPT0gJC5CT0RZICYmIHRuICE9PSAkLkNBUFRJT04gJiYgdG4gIT09ICQuQ09MICYmIHRuICE9PSAkLkNPTEdST1VQIHx8XG4gICAgICAgICAgICAgdG4gIT09ICQuSFRNTCAmJiB0biAhPT0gJC5URCAmJiB0biAhPT0gJC5USClcbiAgICAgICAgZW5kVGFnSW5UYWJsZShwLCB0b2tlbik7XG59XG5cblxuLy8xMi4yLjUuNC4xNSBUaGUgXCJpbiBjZWxsXCIgaW5zZXJ0aW9uIG1vZGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzdGFydFRhZ0luQ2VsbChwLCB0b2tlbikge1xuICAgIHZhciB0biA9IHRva2VuLnRhZ05hbWU7XG5cbiAgICBpZiAodG4gPT09ICQuQ0FQVElPTiB8fCB0biA9PT0gJC5DT0wgfHwgdG4gPT09ICQuQ09MR1JPVVAgfHwgdG4gPT09ICQuVEJPRFkgfHxcbiAgICAgICAgdG4gPT09ICQuVEQgfHwgdG4gPT09ICQuVEZPT1QgfHwgdG4gPT09ICQuVEggfHwgdG4gPT09ICQuVEhFQUQgfHwgdG4gPT09ICQuVFIpIHtcblxuICAgICAgICBpZiAocC5vcGVuRWxlbWVudHMuaGFzSW5UYWJsZVNjb3BlKCQuVEQpIHx8IHAub3BlbkVsZW1lbnRzLmhhc0luVGFibGVTY29wZSgkLlRIKSkge1xuICAgICAgICAgICAgcC5fY2xvc2VUYWJsZUNlbGwoKTtcbiAgICAgICAgICAgIHAuX3Byb2Nlc3NUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbHNlXG4gICAgICAgIHN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcbn1cblxuZnVuY3Rpb24gZW5kVGFnSW5DZWxsKHAsIHRva2VuKSB7XG4gICAgdmFyIHRuID0gdG9rZW4udGFnTmFtZTtcblxuICAgIGlmICh0biA9PT0gJC5URCB8fCB0biA9PT0gJC5USCkge1xuICAgICAgICBpZiAocC5vcGVuRWxlbWVudHMuaGFzSW5UYWJsZVNjb3BlKHRuKSkge1xuICAgICAgICAgICAgcC5vcGVuRWxlbWVudHMuZ2VuZXJhdGVJbXBsaWVkRW5kVGFncygpO1xuICAgICAgICAgICAgcC5vcGVuRWxlbWVudHMucG9wVW50aWxUYWdOYW1lUG9wcGVkKHRuKTtcbiAgICAgICAgICAgIHAuYWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLmNsZWFyVG9MYXN0TWFya2VyKCk7XG4gICAgICAgICAgICBwLmluc2VydGlvbk1vZGUgPSBJTl9ST1dfTU9ERTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsc2UgaWYgKHRuID09PSAkLlRBQkxFIHx8IHRuID09PSAkLlRCT0RZIHx8IHRuID09PSAkLlRGT09UIHx8IHRuID09PSAkLlRIRUFEIHx8IHRuID09PSAkLlRSKSB7XG4gICAgICAgIGlmIChwLm9wZW5FbGVtZW50cy5oYXNJblRhYmxlU2NvcGUodG4pKSB7XG4gICAgICAgICAgICBwLl9jbG9zZVRhYmxlQ2VsbCgpO1xuICAgICAgICAgICAgcC5fcHJvY2Vzc1Rva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsc2UgaWYgKHRuICE9PSAkLkJPRFkgJiYgdG4gIT09ICQuQ0FQVElPTiAmJiB0biAhPT0gJC5DT0wgJiYgdG4gIT09ICQuQ09MR1JPVVAgJiYgdG4gIT09ICQuSFRNTClcbiAgICAgICAgZW5kVGFnSW5Cb2R5KHAsIHRva2VuKTtcbn1cblxuLy8xMi4yLjUuNC4xNiBUaGUgXCJpbiBzZWxlY3RcIiBpbnNlcnRpb24gbW9kZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHN0YXJ0VGFnSW5TZWxlY3QocCwgdG9rZW4pIHtcbiAgICB2YXIgdG4gPSB0b2tlbi50YWdOYW1lO1xuXG4gICAgaWYgKHRuID09PSAkLkhUTUwpXG4gICAgICAgIHN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgIGVsc2UgaWYgKHRuID09PSAkLk9QVElPTikge1xuICAgICAgICBpZiAocC5vcGVuRWxlbWVudHMuY3VycmVudFRhZ05hbWUgPT09ICQuT1BUSU9OKVxuICAgICAgICAgICAgcC5vcGVuRWxlbWVudHMucG9wKCk7XG5cbiAgICAgICAgcC5faW5zZXJ0RWxlbWVudCh0b2tlbiwgTlMuSFRNTCk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAodG4gPT09ICQuT1BUR1JPVVApIHtcbiAgICAgICAgaWYgKHAub3BlbkVsZW1lbnRzLmN1cnJlbnRUYWdOYW1lID09PSAkLk9QVElPTilcbiAgICAgICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcCgpO1xuXG4gICAgICAgIGlmIChwLm9wZW5FbGVtZW50cy5jdXJyZW50VGFnTmFtZSA9PT0gJC5PUFRHUk9VUClcbiAgICAgICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcCgpO1xuXG4gICAgICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIE5TLkhUTUwpO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKHRuID09PSAkLklOUFVUIHx8IHRuID09PSAkLktFWUdFTiB8fCB0biA9PT0gJC5URVhUQVJFQSB8fCB0biA9PT0gJC5TRUxFQ1QpIHtcbiAgICAgICAgaWYgKHAub3BlbkVsZW1lbnRzLmhhc0luU2VsZWN0U2NvcGUoJC5TRUxFQ1QpKSB7XG4gICAgICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3BVbnRpbFRhZ05hbWVQb3BwZWQoJC5TRUxFQ1QpO1xuICAgICAgICAgICAgcC5fcmVzZXRJbnNlcnRpb25Nb2RlKCk7XG5cbiAgICAgICAgICAgIGlmICh0biAhPT0gJC5TRUxFQ1QpXG4gICAgICAgICAgICAgICAgcC5fcHJvY2Vzc1Rva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsc2UgaWYgKHRuID09PSAkLlNDUklQVCB8fCB0biA9PT0gJC5URU1QTEFURSlcbiAgICAgICAgc3RhcnRUYWdJbkhlYWQocCwgdG9rZW4pO1xufVxuXG5mdW5jdGlvbiBlbmRUYWdJblNlbGVjdChwLCB0b2tlbikge1xuICAgIHZhciB0biA9IHRva2VuLnRhZ05hbWU7XG5cbiAgICBpZiAodG4gPT09ICQuT1BUR1JPVVApIHtcbiAgICAgICAgdmFyIHByZXZPcGVuRWxlbWVudCA9IHAub3BlbkVsZW1lbnRzLml0ZW1zW3Aub3BlbkVsZW1lbnRzLnN0YWNrVG9wIC0gMV0sXG4gICAgICAgICAgICBwcmV2T3BlbkVsZW1lbnRUbiA9IHByZXZPcGVuRWxlbWVudCAmJiBwLnRyZWVBZGFwdGVyLmdldFRhZ05hbWUocHJldk9wZW5FbGVtZW50KTtcblxuICAgICAgICBpZiAocC5vcGVuRWxlbWVudHMuY3VycmVudFRhZ05hbWUgPT09ICQuT1BUSU9OICYmIHByZXZPcGVuRWxlbWVudFRuID09PSAkLk9QVEdST1VQKVxuICAgICAgICAgICAgcC5vcGVuRWxlbWVudHMucG9wKCk7XG5cbiAgICAgICAgaWYgKHAub3BlbkVsZW1lbnRzLmN1cnJlbnRUYWdOYW1lID09PSAkLk9QVEdST1VQKVxuICAgICAgICAgICAgcC5vcGVuRWxlbWVudHMucG9wKCk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAodG4gPT09ICQuT1BUSU9OKSB7XG4gICAgICAgIGlmIChwLm9wZW5FbGVtZW50cy5jdXJyZW50VGFnTmFtZSA9PT0gJC5PUFRJT04pXG4gICAgICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3AoKTtcbiAgICB9XG5cbiAgICBlbHNlIGlmICh0biA9PT0gJC5TRUxFQ1QgJiYgcC5vcGVuRWxlbWVudHMuaGFzSW5TZWxlY3RTY29wZSgkLlNFTEVDVCkpIHtcbiAgICAgICAgcC5vcGVuRWxlbWVudHMucG9wVW50aWxUYWdOYW1lUG9wcGVkKCQuU0VMRUNUKTtcbiAgICAgICAgcC5fcmVzZXRJbnNlcnRpb25Nb2RlKCk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAodG4gPT09ICQuVEVNUExBVEUpXG4gICAgICAgIGVuZFRhZ0luSGVhZChwLCB0b2tlbik7XG59XG5cbi8vMTIuMi41LjQuMTcgVGhlIFwiaW4gc2VsZWN0IGluIHRhYmxlXCIgaW5zZXJ0aW9uIG1vZGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzdGFydFRhZ0luU2VsZWN0SW5UYWJsZShwLCB0b2tlbikge1xuICAgIHZhciB0biA9IHRva2VuLnRhZ05hbWU7XG5cbiAgICBpZiAodG4gPT09ICQuQ0FQVElPTiB8fCB0biA9PT0gJC5UQUJMRSB8fCB0biA9PT0gJC5UQk9EWSB8fCB0biA9PT0gJC5URk9PVCB8fFxuICAgICAgICB0biA9PT0gJC5USEVBRCB8fCB0biA9PT0gJC5UUiB8fCB0biA9PT0gJC5URCB8fCB0biA9PT0gJC5USCkge1xuICAgICAgICBwLm9wZW5FbGVtZW50cy5wb3BVbnRpbFRhZ05hbWVQb3BwZWQoJC5TRUxFQ1QpO1xuICAgICAgICBwLl9yZXNldEluc2VydGlvbk1vZGUoKTtcbiAgICAgICAgcC5fcHJvY2Vzc1Rva2VuKHRva2VuKTtcbiAgICB9XG5cbiAgICBlbHNlXG4gICAgICAgIHN0YXJ0VGFnSW5TZWxlY3QocCwgdG9rZW4pO1xufVxuXG5mdW5jdGlvbiBlbmRUYWdJblNlbGVjdEluVGFibGUocCwgdG9rZW4pIHtcbiAgICB2YXIgdG4gPSB0b2tlbi50YWdOYW1lO1xuXG4gICAgaWYgKHRuID09PSAkLkNBUFRJT04gfHwgdG4gPT09ICQuVEFCTEUgfHwgdG4gPT09ICQuVEJPRFkgfHwgdG4gPT09ICQuVEZPT1QgfHxcbiAgICAgICAgdG4gPT09ICQuVEhFQUQgfHwgdG4gPT09ICQuVFIgfHwgdG4gPT09ICQuVEQgfHwgdG4gPT09ICQuVEgpIHtcbiAgICAgICAgaWYgKHAub3BlbkVsZW1lbnRzLmhhc0luVGFibGVTY29wZSh0bikpIHtcbiAgICAgICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcFVudGlsVGFnTmFtZVBvcHBlZCgkLlNFTEVDVCk7XG4gICAgICAgICAgICBwLl9yZXNldEluc2VydGlvbk1vZGUoKTtcbiAgICAgICAgICAgIHAuX3Byb2Nlc3NUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbHNlXG4gICAgICAgIGVuZFRhZ0luU2VsZWN0KHAsIHRva2VuKTtcbn1cblxuLy8xMi4yLjUuNC4xOCBUaGUgXCJpbiB0ZW1wbGF0ZVwiIGluc2VydGlvbiBtb2RlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gc3RhcnRUYWdJblRlbXBsYXRlKHAsIHRva2VuKSB7XG4gICAgdmFyIHRuID0gdG9rZW4udGFnTmFtZTtcblxuICAgIGlmICh0biA9PT0gJC5CQVNFIHx8IHRuID09PSAkLkJBU0VGT05UIHx8IHRuID09PSAkLkJHU09VTkQgfHwgdG4gPT09ICQuTElOSyB8fCB0biA9PT0gJC5NRVRBIHx8XG4gICAgICAgIHRuID09PSAkLk5PRlJBTUVTIHx8IHRuID09PSAkLlNDUklQVCB8fCB0biA9PT0gJC5TVFlMRSB8fCB0biA9PT0gJC5URU1QTEFURSB8fCB0biA9PT0gJC5USVRMRSlcbiAgICAgICAgc3RhcnRUYWdJbkhlYWQocCwgdG9rZW4pO1xuXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBuZXdJbnNlcnRpb25Nb2RlID0gVEVNUExBVEVfSU5TRVJUSU9OX01PREVfU1dJVENIX01BUFt0bl0gfHwgSU5fQk9EWV9NT0RFO1xuXG4gICAgICAgIHAuX3BvcFRtcGxJbnNlcnRpb25Nb2RlKCk7XG4gICAgICAgIHAuX3B1c2hUbXBsSW5zZXJ0aW9uTW9kZShuZXdJbnNlcnRpb25Nb2RlKTtcbiAgICAgICAgcC5pbnNlcnRpb25Nb2RlID0gbmV3SW5zZXJ0aW9uTW9kZTtcbiAgICAgICAgcC5fcHJvY2Vzc1Rva2VuKHRva2VuKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVuZFRhZ0luVGVtcGxhdGUocCwgdG9rZW4pIHtcbiAgICBpZiAodG9rZW4udGFnTmFtZSA9PT0gJC5URU1QTEFURSlcbiAgICAgICAgZW5kVGFnSW5IZWFkKHAsIHRva2VuKTtcbn1cblxuZnVuY3Rpb24gZW9mSW5UZW1wbGF0ZShwLCB0b2tlbikge1xuICAgIGlmIChwLm9wZW5FbGVtZW50cy50bXBsQ291bnQgPiAwKSB7XG4gICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcFVudGlsVGFnTmFtZVBvcHBlZCgkLlRFTVBMQVRFKTtcbiAgICAgICAgcC5hY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMuY2xlYXJUb0xhc3RNYXJrZXIoKTtcbiAgICAgICAgcC5fcG9wVG1wbEluc2VydGlvbk1vZGUoKTtcbiAgICAgICAgcC5fcmVzZXRJbnNlcnRpb25Nb2RlKCk7XG4gICAgICAgIHAuX3Byb2Nlc3NUb2tlbih0b2tlbik7XG4gICAgfVxuXG4gICAgZWxzZVxuICAgICAgICBwLnN0b3BwZWQgPSB0cnVlO1xufVxuXG5cbi8vMTIuMi41LjQuMTkgVGhlIFwiYWZ0ZXIgYm9keVwiIGluc2VydGlvbiBtb2RlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gc3RhcnRUYWdBZnRlckJvZHkocCwgdG9rZW4pIHtcbiAgICBpZiAodG9rZW4udGFnTmFtZSA9PT0gJC5IVE1MKVxuICAgICAgICBzdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICBlbHNlXG4gICAgICAgIHRva2VuQWZ0ZXJCb2R5KHAsIHRva2VuKTtcbn1cblxuZnVuY3Rpb24gZW5kVGFnQWZ0ZXJCb2R5KHAsIHRva2VuKSB7XG4gICAgaWYgKHRva2VuLnRhZ05hbWUgPT09ICQuSFRNTCkge1xuICAgICAgICBpZiAoIXAuZnJhZ21lbnRDb250ZXh0KVxuICAgICAgICAgICAgcC5pbnNlcnRpb25Nb2RlID0gQUZURVJfQUZURVJfQk9EWV9NT0RFO1xuICAgIH1cblxuICAgIGVsc2VcbiAgICAgICAgdG9rZW5BZnRlckJvZHkocCwgdG9rZW4pO1xufVxuXG5mdW5jdGlvbiB0b2tlbkFmdGVyQm9keShwLCB0b2tlbikge1xuICAgIHAuaW5zZXJ0aW9uTW9kZSA9IElOX0JPRFlfTU9ERTtcbiAgICBwLl9wcm9jZXNzVG9rZW4odG9rZW4pO1xufVxuXG4vLzEyLjIuNS40LjIwIFRoZSBcImluIGZyYW1lc2V0XCIgaW5zZXJ0aW9uIG1vZGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzdGFydFRhZ0luRnJhbWVzZXQocCwgdG9rZW4pIHtcbiAgICB2YXIgdG4gPSB0b2tlbi50YWdOYW1lO1xuXG4gICAgaWYgKHRuID09PSAkLkhUTUwpXG4gICAgICAgIHN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgIGVsc2UgaWYgKHRuID09PSAkLkZSQU1FU0VUKVxuICAgICAgICBwLl9pbnNlcnRFbGVtZW50KHRva2VuLCBOUy5IVE1MKTtcblxuICAgIGVsc2UgaWYgKHRuID09PSAkLkZSQU1FKVxuICAgICAgICBwLl9hcHBlbmRFbGVtZW50KHRva2VuLCBOUy5IVE1MKTtcblxuICAgIGVsc2UgaWYgKHRuID09PSAkLk5PRlJBTUVTKVxuICAgICAgICBzdGFydFRhZ0luSGVhZChwLCB0b2tlbik7XG59XG5cbmZ1bmN0aW9uIGVuZFRhZ0luRnJhbWVzZXQocCwgdG9rZW4pIHtcbiAgICBpZiAodG9rZW4udGFnTmFtZSA9PT0gJC5GUkFNRVNFVCAmJiAhcC5vcGVuRWxlbWVudHMuaXNSb290SHRtbEVsZW1lbnRDdXJyZW50KCkpIHtcbiAgICAgICAgcC5vcGVuRWxlbWVudHMucG9wKCk7XG5cbiAgICAgICAgaWYgKCFwLmZyYWdtZW50Q29udGV4dCAmJiBwLm9wZW5FbGVtZW50cy5jdXJyZW50VGFnTmFtZSAhPT0gJC5GUkFNRVNFVClcbiAgICAgICAgICAgIHAuaW5zZXJ0aW9uTW9kZSA9IEFGVEVSX0ZSQU1FU0VUX01PREU7XG4gICAgfVxufVxuXG4vLzEyLjIuNS40LjIxIFRoZSBcImFmdGVyIGZyYW1lc2V0XCIgaW5zZXJ0aW9uIG1vZGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzdGFydFRhZ0FmdGVyRnJhbWVzZXQocCwgdG9rZW4pIHtcbiAgICB2YXIgdG4gPSB0b2tlbi50YWdOYW1lO1xuXG4gICAgaWYgKHRuID09PSAkLkhUTUwpXG4gICAgICAgIHN0YXJ0VGFnSW5Cb2R5KHAsIHRva2VuKTtcblxuICAgIGVsc2UgaWYgKHRuID09PSAkLk5PRlJBTUVTKVxuICAgICAgICBzdGFydFRhZ0luSGVhZChwLCB0b2tlbik7XG59XG5cbmZ1bmN0aW9uIGVuZFRhZ0FmdGVyRnJhbWVzZXQocCwgdG9rZW4pIHtcbiAgICBpZiAodG9rZW4udGFnTmFtZSA9PT0gJC5IVE1MKVxuICAgICAgICBwLmluc2VydGlvbk1vZGUgPSBBRlRFUl9BRlRFUl9GUkFNRVNFVF9NT0RFO1xufVxuXG4vLzEyLjIuNS40LjIyIFRoZSBcImFmdGVyIGFmdGVyIGJvZHlcIiBpbnNlcnRpb24gbW9kZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHN0YXJ0VGFnQWZ0ZXJBZnRlckJvZHkocCwgdG9rZW4pIHtcbiAgICBpZiAodG9rZW4udGFnTmFtZSA9PT0gJC5IVE1MKVxuICAgICAgICBzdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICBlbHNlXG4gICAgICAgIHRva2VuQWZ0ZXJBZnRlckJvZHkocCwgdG9rZW4pO1xufVxuXG5mdW5jdGlvbiB0b2tlbkFmdGVyQWZ0ZXJCb2R5KHAsIHRva2VuKSB7XG4gICAgcC5pbnNlcnRpb25Nb2RlID0gSU5fQk9EWV9NT0RFO1xuICAgIHAuX3Byb2Nlc3NUb2tlbih0b2tlbik7XG59XG5cbi8vMTIuMi41LjQuMjMgVGhlIFwiYWZ0ZXIgYWZ0ZXIgZnJhbWVzZXRcIiBpbnNlcnRpb24gbW9kZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHN0YXJ0VGFnQWZ0ZXJBZnRlckZyYW1lc2V0KHAsIHRva2VuKSB7XG4gICAgdmFyIHRuID0gdG9rZW4udGFnTmFtZTtcblxuICAgIGlmICh0biA9PT0gJC5IVE1MKVxuICAgICAgICBzdGFydFRhZ0luQm9keShwLCB0b2tlbik7XG5cbiAgICBlbHNlIGlmICh0biA9PT0gJC5OT0ZSQU1FUylcbiAgICAgICAgc3RhcnRUYWdJbkhlYWQocCwgdG9rZW4pO1xufVxuXG5cbi8vMTIuMi41LjUgVGhlIHJ1bGVzIGZvciBwYXJzaW5nIHRva2VucyBpbiBmb3JlaWduIGNvbnRlbnRcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBudWxsQ2hhcmFjdGVySW5Gb3JlaWduQ29udGVudChwLCB0b2tlbikge1xuICAgIHRva2VuLmNoYXJzID0gVU5JQ09ERS5SRVBMQUNFTUVOVF9DSEFSQUNURVI7XG4gICAgcC5faW5zZXJ0Q2hhcmFjdGVycyh0b2tlbik7XG59XG5cbmZ1bmN0aW9uIGNoYXJhY3RlckluRm9yZWlnbkNvbnRlbnQocCwgdG9rZW4pIHtcbiAgICBwLl9pbnNlcnRDaGFyYWN0ZXJzKHRva2VuKTtcbiAgICBwLmZyYW1lc2V0T2sgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc3RhcnRUYWdJbkZvcmVpZ25Db250ZW50KHAsIHRva2VuKSB7XG4gICAgaWYgKGZvcmVpZ25Db250ZW50LmNhdXNlc0V4aXQodG9rZW4pICYmICFwLmZyYWdtZW50Q29udGV4dCkge1xuICAgICAgICB3aGlsZSAocC50cmVlQWRhcHRlci5nZXROYW1lc3BhY2VVUkkocC5vcGVuRWxlbWVudHMuY3VycmVudCkgIT09IE5TLkhUTUwgJiYgIXAuX2lzSW50ZWdyYXRpb25Qb2ludChwLm9wZW5FbGVtZW50cy5jdXJyZW50KSlcbiAgICAgICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcCgpO1xuXG4gICAgICAgIHAuX3Byb2Nlc3NUb2tlbih0b2tlbik7XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gcC5fZ2V0QWRqdXN0ZWRDdXJyZW50RWxlbWVudCgpLFxuICAgICAgICAgICAgY3VycmVudE5zID0gcC50cmVlQWRhcHRlci5nZXROYW1lc3BhY2VVUkkoY3VycmVudCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnROcyA9PT0gTlMuTUFUSE1MKVxuICAgICAgICAgICAgZm9yZWlnbkNvbnRlbnQuYWRqdXN0VG9rZW5NYXRoTUxBdHRycyh0b2tlbik7XG5cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudE5zID09PSBOUy5TVkcpIHtcbiAgICAgICAgICAgIGZvcmVpZ25Db250ZW50LmFkanVzdFRva2VuU1ZHVGFnTmFtZSh0b2tlbik7XG4gICAgICAgICAgICBmb3JlaWduQ29udGVudC5hZGp1c3RUb2tlblNWR0F0dHJzKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcmVpZ25Db250ZW50LmFkanVzdFRva2VuWE1MQXR0cnModG9rZW4pO1xuXG4gICAgICAgIGlmICh0b2tlbi5zZWxmQ2xvc2luZylcbiAgICAgICAgICAgIHAuX2FwcGVuZEVsZW1lbnQodG9rZW4sIGN1cnJlbnROcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHAuX2luc2VydEVsZW1lbnQodG9rZW4sIGN1cnJlbnROcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBlbmRUYWdJbkZvcmVpZ25Db250ZW50KHAsIHRva2VuKSB7XG4gICAgZm9yICh2YXIgaSA9IHAub3BlbkVsZW1lbnRzLnN0YWNrVG9wOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gcC5vcGVuRWxlbWVudHMuaXRlbXNbaV07XG5cbiAgICAgICAgaWYgKHAudHJlZUFkYXB0ZXIuZ2V0TmFtZXNwYWNlVVJJKGVsZW1lbnQpID09PSBOUy5IVE1MKSB7XG4gICAgICAgICAgICBwLl9wcm9jZXNzVG9rZW4odG9rZW4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocC50cmVlQWRhcHRlci5nZXRUYWdOYW1lKGVsZW1lbnQpLnRvTG93ZXJDYXNlKCkgPT09IHRva2VuLnRhZ05hbWUpIHtcbiAgICAgICAgICAgIHAub3BlbkVsZW1lbnRzLnBvcFVudGlsRWxlbWVudFBvcHBlZChlbGVtZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlNS9saWIvcGFyc2VyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgSFRNTCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sJyk7XG5cbi8vQWxpYXNlc1xudmFyICQgPSBIVE1MLlRBR19OQU1FUyxcbiAgICBOUyA9IEhUTUwuTkFNRVNQQUNFUztcblxuLy9FbGVtZW50IHV0aWxzXG5cbi8vT1BUSU1JWkFUSU9OOiBJbnRlZ2VyIGNvbXBhcmlzb25zIGFyZSBsb3ctY29zdCwgc28gd2UgY2FuIHVzZSB2ZXJ5IGZhc3QgdGFnIG5hbWUgbGVuZ3RoIGZpbHRlcnMgaGVyZS5cbi8vSXQncyBmYXN0ZXIgdGhhbiB1c2luZyBkaWN0aW9uYXJ5LlxuZnVuY3Rpb24gaXNJbXBsaWVkRW5kVGFnUmVxdWlyZWQodG4pIHtcbiAgICBzd2l0Y2ggKHRuLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gdG4gPT09ICQuUDtcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gdG4gPT09ICQuUkIgfHwgdG4gPT09ICQuUlAgfHwgdG4gPT09ICQuUlQgfHwgdG4gPT09ICQuREQgfHwgdG4gPT09ICQuRFQgfHwgdG4gPT09ICQuTEk7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIHRuID09PSAkLlJUQztcblxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gdG4gPT09ICQuT1BUSU9OO1xuXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiB0biA9PT0gJC5PUFRHUk9VUCB8fCB0biA9PT0gJC5NRU5VSVRFTTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU2NvcGluZ0VsZW1lbnQodG4sIG5zKSB7XG4gICAgc3dpdGNoICh0bi5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKHRuID09PSAkLlREIHx8IHRuID09PSAkLlRIKVxuICAgICAgICAgICAgICAgIHJldHVybiBucyA9PT0gTlMuSFRNTDtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuTUkgfHwgdG4gPT09ICQuTU8gfHwgdG4gPT09ICQuTU4gfHwgdG4gPT09ICQuTVMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5zID09PSBOUy5NQVRITUw7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGlmICh0biA9PT0gJC5IVE1MKVxuICAgICAgICAgICAgICAgIHJldHVybiBucyA9PT0gTlMuSFRNTDtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuREVTQylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnMgPT09IE5TLlNWRztcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgaWYgKHRuID09PSAkLlRBQkxFKVxuICAgICAgICAgICAgICAgIHJldHVybiBucyA9PT0gTlMuSFRNTDtcblxuICAgICAgICAgICAgZWxzZSBpZiAodG4gPT09ICQuTVRFWFQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5zID09PSBOUy5NQVRITUw7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRuID09PSAkLlRJVExFKVxuICAgICAgICAgICAgICAgIHJldHVybiBucyA9PT0gTlMuU1ZHO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gKHRuID09PSAkLkFQUExFVCB8fCB0biA9PT0gJC5PQkpFQ1QpICYmIG5zID09PSBOUy5IVE1MO1xuXG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiAodG4gPT09ICQuQ0FQVElPTiB8fCB0biA9PT0gJC5NQVJRVUVFKSAmJiBucyA9PT0gTlMuSFRNTDtcblxuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gdG4gPT09ICQuVEVNUExBVEUgJiYgbnMgPT09IE5TLkhUTUw7XG5cbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiB0biA9PT0gJC5GT1JFSUdOX09CSkVDVCAmJiBucyA9PT0gTlMuU1ZHO1xuXG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICByZXR1cm4gdG4gPT09ICQuQU5OT1RBVElPTl9YTUwgJiYgbnMgPT09IE5TLk1BVEhNTDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vU3RhY2sgb2Ygb3BlbiBlbGVtZW50c1xudmFyIE9wZW5FbGVtZW50U3RhY2sgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb2N1bWVudCwgdHJlZUFkYXB0ZXIpIHtcbiAgICB0aGlzLnN0YWNrVG9wID0gLTE7XG4gICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuY3VycmVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMuY3VycmVudFRhZ05hbWUgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFRtcGxDb250ZW50ID0gbnVsbDtcbiAgICB0aGlzLnRtcGxDb3VudCA9IDA7XG4gICAgdGhpcy50cmVlQWRhcHRlciA9IHRyZWVBZGFwdGVyO1xufTtcblxuLy9JbmRleCBvZiBlbGVtZW50XG5PcGVuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5faW5kZXhPZiA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIGlkeCA9IC0xO1xuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc3RhY2tUb3A7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zW2ldID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkeDtcbn07XG5cbi8vVXBkYXRlIGN1cnJlbnQgZWxlbWVudFxuT3BlbkVsZW1lbnRTdGFjay5wcm90b3R5cGUuX2lzSW5UZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50VGFnTmFtZSA9PT0gJC5URU1QTEFURSAmJiB0aGlzLnRyZWVBZGFwdGVyLmdldE5hbWVzcGFjZVVSSSh0aGlzLmN1cnJlbnQpID09PSBOUy5IVE1MO1xufTtcblxuT3BlbkVsZW1lbnRTdGFjay5wcm90b3R5cGUuX3VwZGF0ZUN1cnJlbnRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuaXRlbXNbdGhpcy5zdGFja1RvcF07XG4gICAgdGhpcy5jdXJyZW50VGFnTmFtZSA9IHRoaXMuY3VycmVudCAmJiB0aGlzLnRyZWVBZGFwdGVyLmdldFRhZ05hbWUodGhpcy5jdXJyZW50KTtcblxuICAgIHRoaXMuY3VycmVudFRtcGxDb250ZW50ID0gdGhpcy5faXNJblRlbXBsYXRlKCkgPyB0aGlzLnRyZWVBZGFwdGVyLmdldFRlbXBsYXRlQ29udGVudCh0aGlzLmN1cnJlbnQpIDogbnVsbDtcbn07XG5cbi8vTXV0YXRpb25zXG5PcGVuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLml0ZW1zWysrdGhpcy5zdGFja1RvcF0gPSBlbGVtZW50O1xuICAgIHRoaXMuX3VwZGF0ZUN1cnJlbnRFbGVtZW50KCk7XG5cbiAgICBpZiAodGhpcy5faXNJblRlbXBsYXRlKCkpXG4gICAgICAgIHRoaXMudG1wbENvdW50Kys7XG5cbn07XG5cbk9wZW5FbGVtZW50U3RhY2sucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0YWNrVG9wLS07XG5cbiAgICBpZiAodGhpcy50bXBsQ291bnQgPiAwICYmIHRoaXMuX2lzSW5UZW1wbGF0ZSgpKVxuICAgICAgICB0aGlzLnRtcGxDb3VudC0tO1xuXG4gICAgdGhpcy5fdXBkYXRlQ3VycmVudEVsZW1lbnQoKTtcbn07XG5cbk9wZW5FbGVtZW50U3RhY2sucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAob2xkRWxlbWVudCwgbmV3RWxlbWVudCkge1xuICAgIHZhciBpZHggPSB0aGlzLl9pbmRleE9mKG9sZEVsZW1lbnQpO1xuXG4gICAgdGhpcy5pdGVtc1tpZHhdID0gbmV3RWxlbWVudDtcblxuICAgIGlmIChpZHggPT09IHRoaXMuc3RhY2tUb3ApXG4gICAgICAgIHRoaXMuX3VwZGF0ZUN1cnJlbnRFbGVtZW50KCk7XG59O1xuXG5PcGVuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChyZWZlcmVuY2VFbGVtZW50LCBuZXdFbGVtZW50KSB7XG4gICAgdmFyIGluc2VydGlvbklkeCA9IHRoaXMuX2luZGV4T2YocmVmZXJlbmNlRWxlbWVudCkgKyAxO1xuXG4gICAgdGhpcy5pdGVtcy5zcGxpY2UoaW5zZXJ0aW9uSWR4LCAwLCBuZXdFbGVtZW50KTtcblxuICAgIGlmIChpbnNlcnRpb25JZHggPT09ICsrdGhpcy5zdGFja1RvcClcbiAgICAgICAgdGhpcy5fdXBkYXRlQ3VycmVudEVsZW1lbnQoKTtcbn07XG5cbk9wZW5FbGVtZW50U3RhY2sucHJvdG90eXBlLnBvcFVudGlsVGFnTmFtZVBvcHBlZCA9IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgd2hpbGUgKHRoaXMuc3RhY2tUb3AgPiAtMSkge1xuICAgICAgICB2YXIgdG4gPSB0aGlzLmN1cnJlbnRUYWdOYW1lLFxuICAgICAgICAgICAgbnMgPSB0aGlzLnRyZWVBZGFwdGVyLmdldE5hbWVzcGFjZVVSSSh0aGlzLmN1cnJlbnQpO1xuXG4gICAgICAgIHRoaXMucG9wKCk7XG5cbiAgICAgICAgaWYgKHRuID09PSB0YWdOYW1lICYmIG5zID09PSBOUy5IVE1MKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuT3BlbkVsZW1lbnRTdGFjay5wcm90b3R5cGUucG9wVW50aWxFbGVtZW50UG9wcGVkID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB3aGlsZSAodGhpcy5zdGFja1RvcCA+IC0xKSB7XG4gICAgICAgIHZhciBwb3BwZWRFbGVtZW50ID0gdGhpcy5jdXJyZW50O1xuXG4gICAgICAgIHRoaXMucG9wKCk7XG5cbiAgICAgICAgaWYgKHBvcHBlZEVsZW1lbnQgPT09IGVsZW1lbnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG5PcGVuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5wb3BVbnRpbE51bWJlcmVkSGVhZGVyUG9wcGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlICh0aGlzLnN0YWNrVG9wID4gLTEpIHtcbiAgICAgICAgdmFyIHRuID0gdGhpcy5jdXJyZW50VGFnTmFtZSxcbiAgICAgICAgICAgIG5zID0gdGhpcy50cmVlQWRhcHRlci5nZXROYW1lc3BhY2VVUkkodGhpcy5jdXJyZW50KTtcblxuICAgICAgICB0aGlzLnBvcCgpO1xuXG4gICAgICAgIGlmICh0biA9PT0gJC5IMSB8fCB0biA9PT0gJC5IMiB8fCB0biA9PT0gJC5IMyB8fCB0biA9PT0gJC5INCB8fCB0biA9PT0gJC5INSB8fCB0biA9PT0gJC5INiAmJiBucyA9PT0gTlMuSFRNTClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbk9wZW5FbGVtZW50U3RhY2sucHJvdG90eXBlLnBvcFVudGlsVGFibGVDZWxsUG9wcGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlICh0aGlzLnN0YWNrVG9wID4gLTEpIHtcbiAgICAgICAgdmFyIHRuID0gdGhpcy5jdXJyZW50VGFnTmFtZSxcbiAgICAgICAgICAgIG5zID0gdGhpcy50cmVlQWRhcHRlci5nZXROYW1lc3BhY2VVUkkodGhpcy5jdXJyZW50KTtcblxuICAgICAgICB0aGlzLnBvcCgpO1xuXG4gICAgICAgIGlmICh0biA9PT0gJC5URCB8fCB0biA9PT0gJC5USCAmJiBucyA9PT0gTlMuSFRNTClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbk9wZW5FbGVtZW50U3RhY2sucHJvdG90eXBlLnBvcEFsbFVwVG9IdG1sRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL05PVEU6IGhlcmUgd2UgYXNzdW1lIHRoYXQgcm9vdCA8aHRtbD4gZWxlbWVudCBpcyBhbHdheXMgZmlyc3QgaW4gdGhlIG9wZW4gZWxlbWVudCBzdGFjaywgc29cbiAgICAvL3dlIHBlcmZvcm0gdGhpcyBmYXN0IHN0YWNrIGNsZWFuIHVwLlxuICAgIHRoaXMuc3RhY2tUb3AgPSAwO1xuICAgIHRoaXMuX3VwZGF0ZUN1cnJlbnRFbGVtZW50KCk7XG59O1xuXG5PcGVuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5jbGVhckJhY2tUb1RhYmxlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB3aGlsZSAodGhpcy5jdXJyZW50VGFnTmFtZSAhPT0gJC5UQUJMRSAmJlxuICAgICAgICAgICB0aGlzLmN1cnJlbnRUYWdOYW1lICE9PSAkLlRFTVBMQVRFICYmXG4gICAgICAgICAgIHRoaXMuY3VycmVudFRhZ05hbWUgIT09ICQuSFRNTCB8fFxuICAgICAgICAgICB0aGlzLnRyZWVBZGFwdGVyLmdldE5hbWVzcGFjZVVSSSh0aGlzLmN1cnJlbnQpICE9PSBOUy5IVE1MKVxuICAgICAgICB0aGlzLnBvcCgpO1xufTtcblxuT3BlbkVsZW1lbnRTdGFjay5wcm90b3R5cGUuY2xlYXJCYWNrVG9UYWJsZUJvZHlDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlICh0aGlzLmN1cnJlbnRUYWdOYW1lICE9PSAkLlRCT0RZICYmXG4gICAgICAgICAgIHRoaXMuY3VycmVudFRhZ05hbWUgIT09ICQuVEZPT1QgJiZcbiAgICAgICAgICAgdGhpcy5jdXJyZW50VGFnTmFtZSAhPT0gJC5USEVBRCAmJlxuICAgICAgICAgICB0aGlzLmN1cnJlbnRUYWdOYW1lICE9PSAkLlRFTVBMQVRFICYmXG4gICAgICAgICAgIHRoaXMuY3VycmVudFRhZ05hbWUgIT09ICQuSFRNTCB8fFxuICAgICAgICAgICB0aGlzLnRyZWVBZGFwdGVyLmdldE5hbWVzcGFjZVVSSSh0aGlzLmN1cnJlbnQpICE9PSBOUy5IVE1MKVxuICAgICAgICB0aGlzLnBvcCgpO1xufTtcblxuT3BlbkVsZW1lbnRTdGFjay5wcm90b3R5cGUuY2xlYXJCYWNrVG9UYWJsZVJvd0NvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgd2hpbGUgKHRoaXMuY3VycmVudFRhZ05hbWUgIT09ICQuVFIgJiZcbiAgICAgICAgICAgdGhpcy5jdXJyZW50VGFnTmFtZSAhPT0gJC5URU1QTEFURSAmJlxuICAgICAgICAgICB0aGlzLmN1cnJlbnRUYWdOYW1lICE9PSAkLkhUTUwgfHxcbiAgICAgICAgICAgdGhpcy50cmVlQWRhcHRlci5nZXROYW1lc3BhY2VVUkkodGhpcy5jdXJyZW50KSAhPT0gTlMuSFRNTClcbiAgICAgICAgdGhpcy5wb3AoKTtcbn07XG5cbk9wZW5FbGVtZW50U3RhY2sucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc3RhY2tUb3A7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zW2ldID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tUb3AtLTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUN1cnJlbnRFbGVtZW50KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vU2VhcmNoXG5PcGVuRWxlbWVudFN0YWNrLnByb3RvdHlwZS50cnlQZWVrUHJvcGVybHlOZXN0ZWRCb2R5RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL1Byb3Blcmx5IG5lc3RlZCA8Ym9keT4gZWxlbWVudCAoc2hvdWxkIGJlIHNlY29uZCBlbGVtZW50IGluIHN0YWNrKS5cbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuaXRlbXNbMV07XG5cbiAgICByZXR1cm4gZWxlbWVudCAmJiB0aGlzLnRyZWVBZGFwdGVyLmdldFRhZ05hbWUoZWxlbWVudCkgPT09ICQuQk9EWSA/IGVsZW1lbnQgOiBudWxsO1xufTtcblxuT3BlbkVsZW1lbnRTdGFjay5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLl9pbmRleE9mKGVsZW1lbnQpID4gLTE7XG59O1xuXG5PcGVuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5nZXRDb21tb25BbmNlc3RvciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIGVsZW1lbnRJZHggPSB0aGlzLl9pbmRleE9mKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIC0tZWxlbWVudElkeCA+PSAwID8gdGhpcy5pdGVtc1tlbGVtZW50SWR4XSA6IG51bGw7XG59O1xuXG5PcGVuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5pc1Jvb3RIdG1sRWxlbWVudEN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tUb3AgPT09IDAgJiYgdGhpcy5jdXJyZW50VGFnTmFtZSA9PT0gJC5IVE1MO1xufTtcblxuLy9FbGVtZW50IGluIHNjb3BlXG5PcGVuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5oYXNJblNjb3BlID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zdGFja1RvcDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHRuID0gdGhpcy50cmVlQWRhcHRlci5nZXRUYWdOYW1lKHRoaXMuaXRlbXNbaV0pLFxuICAgICAgICAgICAgbnMgPSB0aGlzLnRyZWVBZGFwdGVyLmdldE5hbWVzcGFjZVVSSSh0aGlzLml0ZW1zW2ldKTtcblxuICAgICAgICBpZiAodG4gPT09IHRhZ05hbWUgJiYgbnMgPT09IE5TLkhUTUwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBpZiAoaXNTY29waW5nRWxlbWVudCh0biwgbnMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuT3BlbkVsZW1lbnRTdGFjay5wcm90b3R5cGUuaGFzTnVtYmVyZWRIZWFkZXJJblNjb3BlID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnN0YWNrVG9wOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgdG4gPSB0aGlzLnRyZWVBZGFwdGVyLmdldFRhZ05hbWUodGhpcy5pdGVtc1tpXSksXG4gICAgICAgICAgICBucyA9IHRoaXMudHJlZUFkYXB0ZXIuZ2V0TmFtZXNwYWNlVVJJKHRoaXMuaXRlbXNbaV0pO1xuXG4gICAgICAgIGlmICgodG4gPT09ICQuSDEgfHwgdG4gPT09ICQuSDIgfHwgdG4gPT09ICQuSDMgfHwgdG4gPT09ICQuSDQgfHwgdG4gPT09ICQuSDUgfHwgdG4gPT09ICQuSDYpICYmIG5zID09PSBOUy5IVE1MKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgaWYgKGlzU2NvcGluZ0VsZW1lbnQodG4sIG5zKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbk9wZW5FbGVtZW50U3RhY2sucHJvdG90eXBlLmhhc0luTGlzdEl0ZW1TY29wZSA9IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc3RhY2tUb3A7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciB0biA9IHRoaXMudHJlZUFkYXB0ZXIuZ2V0VGFnTmFtZSh0aGlzLml0ZW1zW2ldKSxcbiAgICAgICAgICAgIG5zID0gdGhpcy50cmVlQWRhcHRlci5nZXROYW1lc3BhY2VVUkkodGhpcy5pdGVtc1tpXSk7XG5cbiAgICAgICAgaWYgKHRuID09PSB0YWdOYW1lICYmIG5zID09PSBOUy5IVE1MKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgaWYgKCh0biA9PT0gJC5VTCB8fCB0biA9PT0gJC5PTCkgJiYgbnMgPT09IE5TLkhUTUwgfHwgaXNTY29waW5nRWxlbWVudCh0biwgbnMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuT3BlbkVsZW1lbnRTdGFjay5wcm90b3R5cGUuaGFzSW5CdXR0b25TY29wZSA9IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc3RhY2tUb3A7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciB0biA9IHRoaXMudHJlZUFkYXB0ZXIuZ2V0VGFnTmFtZSh0aGlzLml0ZW1zW2ldKSxcbiAgICAgICAgICAgIG5zID0gdGhpcy50cmVlQWRhcHRlci5nZXROYW1lc3BhY2VVUkkodGhpcy5pdGVtc1tpXSk7XG5cbiAgICAgICAgaWYgKHRuID09PSB0YWdOYW1lICYmIG5zID09PSBOUy5IVE1MKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgaWYgKHRuID09PSAkLkJVVFRPTiAmJiBucyA9PT0gTlMuSFRNTCB8fCBpc1Njb3BpbmdFbGVtZW50KHRuLCBucykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5PcGVuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5oYXNJblRhYmxlU2NvcGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnN0YWNrVG9wOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgdG4gPSB0aGlzLnRyZWVBZGFwdGVyLmdldFRhZ05hbWUodGhpcy5pdGVtc1tpXSksXG4gICAgICAgICAgICBucyA9IHRoaXMudHJlZUFkYXB0ZXIuZ2V0TmFtZXNwYWNlVVJJKHRoaXMuaXRlbXNbaV0pO1xuXG4gICAgICAgIGlmIChucyAhPT0gTlMuSFRNTClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmICh0biA9PT0gdGFnTmFtZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGlmICh0biA9PT0gJC5UQUJMRSB8fCB0biA9PT0gJC5URU1QTEFURSB8fCB0biA9PT0gJC5IVE1MKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuT3BlbkVsZW1lbnRTdGFjay5wcm90b3R5cGUuaGFzVGFibGVCb2R5Q29udGV4dEluVGFibGVTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zdGFja1RvcDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHRuID0gdGhpcy50cmVlQWRhcHRlci5nZXRUYWdOYW1lKHRoaXMuaXRlbXNbaV0pLFxuICAgICAgICAgICAgbnMgPSB0aGlzLnRyZWVBZGFwdGVyLmdldE5hbWVzcGFjZVVSSSh0aGlzLml0ZW1zW2ldKTtcblxuICAgICAgICBpZiAobnMgIT09IE5TLkhUTUwpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBpZiAodG4gPT09ICQuVEJPRFkgfHwgdG4gPT09ICQuVEhFQUQgfHwgdG4gPT09ICQuVEZPT1QpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBpZiAodG4gPT09ICQuVEFCTEUgfHwgdG4gPT09ICQuSFRNTClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbk9wZW5FbGVtZW50U3RhY2sucHJvdG90eXBlLmhhc0luU2VsZWN0U2NvcGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnN0YWNrVG9wOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgdG4gPSB0aGlzLnRyZWVBZGFwdGVyLmdldFRhZ05hbWUodGhpcy5pdGVtc1tpXSksXG4gICAgICAgICAgICBucyA9IHRoaXMudHJlZUFkYXB0ZXIuZ2V0TmFtZXNwYWNlVVJJKHRoaXMuaXRlbXNbaV0pO1xuXG4gICAgICAgIGlmIChucyAhPT0gTlMuSFRNTClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmICh0biA9PT0gdGFnTmFtZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGlmICh0biAhPT0gJC5PUFRJT04gJiYgdG4gIT09ICQuT1BUR1JPVVApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vL0ltcGxpZWQgZW5kIHRhZ3Ncbk9wZW5FbGVtZW50U3RhY2sucHJvdG90eXBlLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgd2hpbGUgKGlzSW1wbGllZEVuZFRhZ1JlcXVpcmVkKHRoaXMuY3VycmVudFRhZ05hbWUpKVxuICAgICAgICB0aGlzLnBvcCgpO1xufTtcblxuT3BlbkVsZW1lbnRTdGFjay5wcm90b3R5cGUuZ2VuZXJhdGVJbXBsaWVkRW5kVGFnc1dpdGhFeGNsdXNpb24gPSBmdW5jdGlvbiAoZXhjbHVzaW9uVGFnTmFtZSkge1xuICAgIHdoaWxlIChpc0ltcGxpZWRFbmRUYWdSZXF1aXJlZCh0aGlzLmN1cnJlbnRUYWdOYW1lKSAmJiB0aGlzLmN1cnJlbnRUYWdOYW1lICE9PSBleGNsdXNpb25UYWdOYW1lKVxuICAgICAgICB0aGlzLnBvcCgpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZTUvbGliL3BhcnNlci9vcGVuX2VsZW1lbnRfc3RhY2suanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBXcml0YWJsZVN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLldyaXRhYmxlLFxuICAgIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzLFxuICAgIFBhcnNlciA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxudmFyIFBhcnNlclN0cmVhbSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBXcml0YWJsZVN0cmVhbS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5wYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5sYXN0Q2h1bmtXcml0dGVuID0gZmFsc2U7XG4gICAgdGhpcy53cml0ZUNhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLnBhdXNlZEJ5U2NyaXB0ID0gZmFsc2U7XG5cbiAgICB0aGlzLmRvY3VtZW50ID0gdGhpcy5wYXJzZXIudHJlZUFkYXB0ZXIuY3JlYXRlRG9jdW1lbnQoKTtcblxuICAgIHRoaXMucGVuZGluZ0h0bWxJbnNlcnRpb25zID0gW107XG5cbiAgICB0aGlzLl9yZXN1bWUgPSB0aGlzLl9yZXN1bWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9kb2N1bWVudFdyaXRlID0gdGhpcy5fZG9jdW1lbnRXcml0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3NjcmlwdEhhbmRsZXIgPSB0aGlzLl9zY3JpcHRIYW5kbGVyLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnBhcnNlci5fYm9vdHN0cmFwKHRoaXMuZG9jdW1lbnQsIG51bGwpO1xufTtcblxuaW5oZXJpdHMoUGFyc2VyU3RyZWFtLCBXcml0YWJsZVN0cmVhbSk7XG5cbi8vV3JpdGFibGVTdHJlYW0gaW1wbGVtZW50YXRpb25cblBhcnNlclN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICB0aGlzLndyaXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnBhcnNlci50b2tlbml6ZXIud3JpdGUoY2h1bmsudG9TdHJpbmcoJ3V0ZjgnKSwgdGhpcy5sYXN0Q2h1bmtXcml0dGVuKTtcbiAgICB0aGlzLl9ydW5QYXJzaW5nTG9vcCgpO1xufTtcblxuUGFyc2VyU3RyZWFtLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIHRoaXMubGFzdENodW5rV3JpdHRlbiA9IHRydWU7XG4gICAgV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLmVuZC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xufTtcblxuLy9TY3JpcHRhYmxlIHBhcnNlciBpbXBsZW1lbnRhdGlvblxuUGFyc2VyU3RyZWFtLnByb3RvdHlwZS5fcnVuUGFyc2luZ0xvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXJzZXIucnVuUGFyc2luZ0xvb3BGb3JDdXJyZW50Q2h1bmsodGhpcy53cml0ZUNhbGxiYWNrLCB0aGlzLl9zY3JpcHRIYW5kbGVyKTtcbn07XG5cblBhcnNlclN0cmVhbS5wcm90b3R5cGUuX3Jlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMucGF1c2VkQnlTY3JpcHQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyc2VyIHdhcyBhbHJlYWR5IHJlc3VtZWQnKTtcblxuICAgIHdoaWxlICh0aGlzLnBlbmRpbmdIdG1sSW5zZXJ0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGh0bWwgPSB0aGlzLnBlbmRpbmdIdG1sSW5zZXJ0aW9ucy5wb3AoKTtcblxuICAgICAgICB0aGlzLnBhcnNlci50b2tlbml6ZXIuaW5zZXJ0SHRtbEF0Q3VycmVudFBvcyhodG1sKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhdXNlZEJ5U2NyaXB0ID0gZmFsc2U7XG5cbiAgICAvL05PVEU6IGtlZXAgcGFyc2luZyBpZiB3ZSBkb24ndCB3YWl0IGZvciB0aGUgbmV4dCBpbnB1dCBjaHVua1xuICAgIGlmICh0aGlzLnBhcnNlci50b2tlbml6ZXIuYWN0aXZlKVxuICAgICAgICB0aGlzLl9ydW5QYXJzaW5nTG9vcCgpO1xufTtcblxuUGFyc2VyU3RyZWFtLnByb3RvdHlwZS5fZG9jdW1lbnRXcml0ZSA9IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgaWYgKCF0aGlzLnBhcnNlci5zdG9wcGVkKVxuICAgICAgICB0aGlzLnBlbmRpbmdIdG1sSW5zZXJ0aW9ucy5wdXNoKGh0bWwpO1xufTtcblxuUGFyc2VyU3RyZWFtLnByb3RvdHlwZS5fc2NyaXB0SGFuZGxlciA9IGZ1bmN0aW9uIChzY3JpcHRFbGVtZW50KSB7XG4gICAgaWYgKHRoaXMubGlzdGVuZXJzKCdzY3JpcHQnKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wYXVzZWRCeVNjcmlwdCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnc2NyaXB0Jywgc2NyaXB0RWxlbWVudCwgdGhpcy5fZG9jdW1lbnRXcml0ZSwgdGhpcy5fcmVzdW1lKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICB0aGlzLl9ydW5QYXJzaW5nTG9vcCgpO1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlNS9saWIvcGFyc2VyL3BhcnNlcl9zdHJlYW0uanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0VHJlZUFkYXB0ZXIgPSByZXF1aXJlKCcuLi90cmVlX2FkYXB0ZXJzL2RlZmF1bHQnKSxcbiAgICBkb2N0eXBlID0gcmVxdWlyZSgnLi4vY29tbW9uL2RvY3R5cGUnKSxcbiAgICBtZXJnZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9jb21tb24vbWVyZ2Vfb3B0aW9ucycpLFxuICAgIEhUTUwgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbCcpO1xuXG4vL0FsaWFzZXNcbnZhciAkID0gSFRNTC5UQUdfTkFNRVMsXG4gICAgTlMgPSBIVE1MLk5BTUVTUEFDRVM7XG5cbi8vRGVmYXVsdCBzZXJpYWxpemVyIG9wdGlvbnNcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgdHJlZUFkYXB0ZXI6IGRlZmF1bHRUcmVlQWRhcHRlclxufTtcblxuLy9Fc2NhcGluZyByZWdleGVzXG52YXIgQU1QX1JFR0VYID0gLyYvZyxcbiAgICBOQlNQX1JFR0VYID0gL1xcdTAwYTAvZyxcbiAgICBET1VCTEVfUVVPVEVfUkVHRVggPSAvXCIvZyxcbiAgICBMVF9SRUdFWCA9IC88L2csXG4gICAgR1RfUkVHRVggPSAvPi9nO1xuXG4vL1NlcmlhbGl6ZXJcbnZhciBTZXJpYWxpemVyID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHRoaXMudHJlZUFkYXB0ZXIgPSB0aGlzLm9wdGlvbnMudHJlZUFkYXB0ZXI7XG5cbiAgICB0aGlzLmh0bWwgPSAnJztcbiAgICB0aGlzLnN0YXJ0Tm9kZSA9IG5vZGU7XG59O1xuXG4vLyBOT1RFOiBleHBvcnRlZCBhcyBzdGF0aWMgbWV0aG9kIGZvciB0aGUgdGVzdGluZyBwdXJwb3Nlc1xuU2VyaWFsaXplci5lc2NhcGVTdHJpbmcgPSBmdW5jdGlvbiAoc3RyLCBhdHRyTW9kZSkge1xuICAgIHN0ciA9IHN0clxuICAgICAgICAucmVwbGFjZShBTVBfUkVHRVgsICcmYW1wOycpXG4gICAgICAgIC5yZXBsYWNlKE5CU1BfUkVHRVgsICcmbmJzcDsnKTtcblxuICAgIGlmIChhdHRyTW9kZSlcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoRE9VQkxFX1FVT1RFX1JFR0VYLCAnJnF1b3Q7Jyk7XG5cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyID0gc3RyXG4gICAgICAgICAgICAucmVwbGFjZShMVF9SRUdFWCwgJyZsdDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoR1RfUkVHRVgsICcmZ3Q7Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy9BUElcblNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zZXJpYWxpemVDaGlsZE5vZGVzKHRoaXMuc3RhcnROb2RlKTtcblxuICAgIHJldHVybiB0aGlzLmh0bWw7XG59O1xuXG5cbi8vSW50ZXJuYWxzXG5TZXJpYWxpemVyLnByb3RvdHlwZS5fc2VyaWFsaXplQ2hpbGROb2RlcyA9IGZ1bmN0aW9uIChwYXJlbnROb2RlKSB7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzLnRyZWVBZGFwdGVyLmdldENoaWxkTm9kZXMocGFyZW50Tm9kZSk7XG5cbiAgICBpZiAoY2hpbGROb2Rlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgY25MZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGNuTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IGNoaWxkTm9kZXNbaV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRyZWVBZGFwdGVyLmlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpKVxuICAgICAgICAgICAgICAgIHRoaXMuX3NlcmlhbGl6ZUVsZW1lbnQoY3VycmVudE5vZGUpO1xuXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnRyZWVBZGFwdGVyLmlzVGV4dE5vZGUoY3VycmVudE5vZGUpKVxuICAgICAgICAgICAgICAgIHRoaXMuX3NlcmlhbGl6ZVRleHROb2RlKGN1cnJlbnROb2RlKTtcblxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50cmVlQWRhcHRlci5pc0NvbW1lbnROb2RlKGN1cnJlbnROb2RlKSlcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXJpYWxpemVDb21tZW50Tm9kZShjdXJyZW50Tm9kZSk7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudHJlZUFkYXB0ZXIuaXNEb2N1bWVudFR5cGVOb2RlKGN1cnJlbnROb2RlKSlcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXJpYWxpemVEb2N1bWVudFR5cGVOb2RlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblNlcmlhbGl6ZXIucHJvdG90eXBlLl9zZXJpYWxpemVFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgdG4gPSB0aGlzLnRyZWVBZGFwdGVyLmdldFRhZ05hbWUobm9kZSksXG4gICAgICAgIG5zID0gdGhpcy50cmVlQWRhcHRlci5nZXROYW1lc3BhY2VVUkkobm9kZSk7XG5cbiAgICB0aGlzLmh0bWwgKz0gJzwnICsgdG47XG4gICAgdGhpcy5fc2VyaWFsaXplQXR0cmlidXRlcyhub2RlKTtcbiAgICB0aGlzLmh0bWwgKz0gJz4nO1xuXG4gICAgaWYgKHRuICE9PSAkLkFSRUEgJiYgdG4gIT09ICQuQkFTRSAmJiB0biAhPT0gJC5CQVNFRk9OVCAmJiB0biAhPT0gJC5CR1NPVU5EICYmIHRuICE9PSAkLkJSICYmIHRuICE9PSAkLkJSICYmXG4gICAgICAgIHRuICE9PSAkLkNPTCAmJiB0biAhPT0gJC5FTUJFRCAmJiB0biAhPT0gJC5GUkFNRSAmJiB0biAhPT0gJC5IUiAmJiB0biAhPT0gJC5JTUcgJiYgdG4gIT09ICQuSU5QVVQgJiZcbiAgICAgICAgdG4gIT09ICQuS0VZR0VOICYmIHRuICE9PSAkLkxJTksgJiYgdG4gIT09ICQuTUVOVUlURU0gJiYgdG4gIT09ICQuTUVUQSAmJiB0biAhPT0gJC5QQVJBTSAmJiB0biAhPT0gJC5TT1VSQ0UgJiZcbiAgICAgICAgdG4gIT09ICQuVFJBQ0sgJiYgdG4gIT09ICQuV0JSKSB7XG5cbiAgICAgICAgdmFyIGNoaWxkTm9kZXNIb2xkZXIgPSB0biA9PT0gJC5URU1QTEFURSAmJiBucyA9PT0gTlMuSFRNTCA/XG4gICAgICAgICAgICB0aGlzLnRyZWVBZGFwdGVyLmdldFRlbXBsYXRlQ29udGVudChub2RlKSA6XG4gICAgICAgICAgICBub2RlO1xuXG4gICAgICAgIHRoaXMuX3NlcmlhbGl6ZUNoaWxkTm9kZXMoY2hpbGROb2Rlc0hvbGRlcik7XG4gICAgICAgIHRoaXMuaHRtbCArPSAnPC8nICsgdG4gKyAnPic7XG4gICAgfVxufTtcblxuU2VyaWFsaXplci5wcm90b3R5cGUuX3NlcmlhbGl6ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBhdHRycyA9IHRoaXMudHJlZUFkYXB0ZXIuZ2V0QXR0ckxpc3Qobm9kZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYXR0cnNMZW5ndGggPSBhdHRycy5sZW5ndGg7IGkgPCBhdHRyc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhdHRyID0gYXR0cnNbaV0sXG4gICAgICAgICAgICB2YWx1ZSA9IFNlcmlhbGl6ZXIuZXNjYXBlU3RyaW5nKGF0dHIudmFsdWUsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuaHRtbCArPSAnICc7XG5cbiAgICAgICAgaWYgKCFhdHRyLm5hbWVzcGFjZSlcbiAgICAgICAgICAgIHRoaXMuaHRtbCArPSBhdHRyLm5hbWU7XG5cbiAgICAgICAgZWxzZSBpZiAoYXR0ci5uYW1lc3BhY2UgPT09IE5TLlhNTClcbiAgICAgICAgICAgIHRoaXMuaHRtbCArPSAneG1sOicgKyBhdHRyLm5hbWU7XG5cbiAgICAgICAgZWxzZSBpZiAoYXR0ci5uYW1lc3BhY2UgPT09IE5TLlhNTE5TKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lICE9PSAneG1sbnMnKVxuICAgICAgICAgICAgICAgIHRoaXMuaHRtbCArPSAneG1sbnM6JztcblxuICAgICAgICAgICAgdGhpcy5odG1sICs9IGF0dHIubmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGF0dHIubmFtZXNwYWNlID09PSBOUy5YTElOSylcbiAgICAgICAgICAgIHRoaXMuaHRtbCArPSAneGxpbms6JyArIGF0dHIubmFtZTtcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmh0bWwgKz0gYXR0ci5uYW1lc3BhY2UgKyAnOicgKyBhdHRyLm5hbWU7XG5cbiAgICAgICAgdGhpcy5odG1sICs9ICc9XCInICsgdmFsdWUgKyAnXCInO1xuICAgIH1cbn07XG5cblNlcmlhbGl6ZXIucHJvdG90eXBlLl9zZXJpYWxpemVUZXh0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLnRyZWVBZGFwdGVyLmdldFRleHROb2RlQ29udGVudChub2RlKSxcbiAgICAgICAgcGFyZW50ID0gdGhpcy50cmVlQWRhcHRlci5nZXRQYXJlbnROb2RlKG5vZGUpLFxuICAgICAgICBwYXJlbnRUbiA9IHZvaWQgMDtcblxuICAgIGlmIChwYXJlbnQgJiYgdGhpcy50cmVlQWRhcHRlci5pc0VsZW1lbnROb2RlKHBhcmVudCkpXG4gICAgICAgIHBhcmVudFRuID0gdGhpcy50cmVlQWRhcHRlci5nZXRUYWdOYW1lKHBhcmVudCk7XG5cbiAgICBpZiAocGFyZW50VG4gPT09ICQuU1RZTEUgfHwgcGFyZW50VG4gPT09ICQuU0NSSVBUIHx8IHBhcmVudFRuID09PSAkLlhNUCB8fCBwYXJlbnRUbiA9PT0gJC5JRlJBTUUgfHxcbiAgICAgICAgcGFyZW50VG4gPT09ICQuTk9FTUJFRCB8fCBwYXJlbnRUbiA9PT0gJC5OT0ZSQU1FUyB8fCBwYXJlbnRUbiA9PT0gJC5QTEFJTlRFWFQgfHwgcGFyZW50VG4gPT09ICQuTk9TQ1JJUFQpXG5cbiAgICAgICAgdGhpcy5odG1sICs9IGNvbnRlbnQ7XG5cbiAgICBlbHNlXG4gICAgICAgIHRoaXMuaHRtbCArPSBTZXJpYWxpemVyLmVzY2FwZVN0cmluZyhjb250ZW50LCBmYWxzZSk7XG59O1xuXG5TZXJpYWxpemVyLnByb3RvdHlwZS5fc2VyaWFsaXplQ29tbWVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHRoaXMuaHRtbCArPSAnPCEtLScgKyB0aGlzLnRyZWVBZGFwdGVyLmdldENvbW1lbnROb2RlQ29udGVudChub2RlKSArICctLT4nO1xufTtcblxuU2VyaWFsaXplci5wcm90b3R5cGUuX3NlcmlhbGl6ZURvY3VtZW50VHlwZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBuYW1lID0gdGhpcy50cmVlQWRhcHRlci5nZXREb2N1bWVudFR5cGVOb2RlTmFtZShub2RlKTtcblxuICAgIHRoaXMuaHRtbCArPSAnPCcgKyBkb2N0eXBlLnNlcmlhbGl6ZUNvbnRlbnQobmFtZSwgbnVsbCwgbnVsbCkgKyAnPic7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlNS9saWIvc2VyaWFsaXplci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi9TdWJqZWN0Jyk7XG52YXIgcXVldWVfMSA9IHJlcXVpcmUoJy4vc2NoZWR1bGVyL3F1ZXVlJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xudmFyIG9ic2VydmVPbl8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvb2JzZXJ2ZU9uJyk7XG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvcicpO1xudmFyIFN1YmplY3RTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3ViamVjdFN1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBAY2xhc3MgUmVwbGF5U3ViamVjdDxUPlxuICovXG52YXIgUmVwbGF5U3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlcGxheVN1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVwbGF5U3ViamVjdChidWZmZXJTaXplLCB3aW5kb3dUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlclNpemUgPT09IHZvaWQgMCkgeyBidWZmZXJTaXplID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgICAgIGlmICh3aW5kb3dUaW1lID09PSB2b2lkIDApIHsgd2luZG93VGltZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9idWZmZXJTaXplID0gYnVmZmVyU2l6ZSA8IDEgPyAxIDogYnVmZmVyU2l6ZTtcbiAgICAgICAgdGhpcy5fd2luZG93VGltZSA9IHdpbmRvd1RpbWUgPCAxID8gMSA6IHdpbmRvd1RpbWU7XG4gICAgfVxuICAgIFJlcGxheVN1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuX2dldE5vdygpO1xuICAgICAgICB0aGlzLl9ldmVudHMucHVzaChuZXcgUmVwbGF5RXZlbnQobm93LCB2YWx1ZSkpO1xuICAgICAgICB0aGlzLl90cmltQnVmZmVyVGhlbkdldEV2ZW50cygpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBSZXBsYXlTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIF9ldmVudHMgPSB0aGlzLl90cmltQnVmZmVyVGhlbkdldEV2ZW50cygpO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb247XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3ViamVjdFN1YnNjcmlwdGlvbl8xLlN1YmplY3RTdWJzY3JpcHRpb24odGhpcywgc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5hZGQoc3Vic2NyaWJlciA9IG5ldyBvYnNlcnZlT25fMS5PYnNlcnZlT25TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHNjaGVkdWxlcikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW4gPSBfZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4gJiYgIXN1YnNjcmliZXIuY2xvc2VkOyBpKyspIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChfZXZlbnRzW2ldLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcih0aGlzLnRocm93bkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICBSZXBsYXlTdWJqZWN0LnByb3RvdHlwZS5fZ2V0Tm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc2NoZWR1bGVyIHx8IHF1ZXVlXzEucXVldWUpLm5vdygpO1xuICAgIH07XG4gICAgUmVwbGF5U3ViamVjdC5wcm90b3R5cGUuX3RyaW1CdWZmZXJUaGVuR2V0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm93ID0gdGhpcy5fZ2V0Tm93KCk7XG4gICAgICAgIHZhciBfYnVmZmVyU2l6ZSA9IHRoaXMuX2J1ZmZlclNpemU7XG4gICAgICAgIHZhciBfd2luZG93VGltZSA9IHRoaXMuX3dpbmRvd1RpbWU7XG4gICAgICAgIHZhciBfZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICB2YXIgZXZlbnRzQ291bnQgPSBfZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIHNwbGljZUNvdW50ID0gMDtcbiAgICAgICAgLy8gVHJpbSBldmVudHMgdGhhdCBmYWxsIG91dCBvZiB0aGUgdGltZSB3aW5kb3cuXG4gICAgICAgIC8vIFN0YXJ0IGF0IHRoZSBmcm9udCBvZiB0aGUgbGlzdC4gQnJlYWsgZWFybHkgb25jZVxuICAgICAgICAvLyB3ZSBlbmNvdW50ZXIgYW4gZXZlbnQgdGhhdCBmYWxscyB3aXRoaW4gdGhlIHdpbmRvdy5cbiAgICAgICAgd2hpbGUgKHNwbGljZUNvdW50IDwgZXZlbnRzQ291bnQpIHtcbiAgICAgICAgICAgIGlmICgobm93IC0gX2V2ZW50c1tzcGxpY2VDb3VudF0udGltZSkgPCBfd2luZG93VGltZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3BsaWNlQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRzQ291bnQgPiBfYnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgc3BsaWNlQ291bnQgPSBNYXRoLm1heChzcGxpY2VDb3VudCwgZXZlbnRzQ291bnQgLSBfYnVmZmVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGljZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgX2V2ZW50cy5zcGxpY2UoMCwgc3BsaWNlQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZXZlbnRzO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcGxheVN1YmplY3Q7XG59KFN1YmplY3RfMS5TdWJqZWN0KSk7XG5leHBvcnRzLlJlcGxheVN1YmplY3QgPSBSZXBsYXlTdWJqZWN0O1xudmFyIFJlcGxheUV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXBsYXlFdmVudCh0aW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBSZXBsYXlFdmVudDtcbn0oKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXBsYXlTdWJqZWN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL1JlcGxheVN1YmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgY2F0Y2hfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2NhdGNoJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY2F0Y2ggPSBjYXRjaF8xLl9jYXRjaDtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5fY2F0Y2ggPSBjYXRjaF8xLl9jYXRjaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhdGNoLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9jYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBtYXBfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21hcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm1hcCA9IG1hcF8xLm1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9hZGQvb3BlcmF0b3IvbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHNoYXJlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zaGFyZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnNoYXJlID0gc2hhcmVfMS5zaGFyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYXJlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9zaGFyZS5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogSWdub3JlcyBzb3VyY2UgdmFsdWVzIGZvciBhIGR1cmF0aW9uIGRldGVybWluZWQgYnkgYW5vdGhlciBPYnNlcnZhYmxlLCB0aGVuXG4gKiBlbWl0cyB0aGUgbW9zdCByZWNlbnQgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHRoZW4gcmVwZWF0cyB0aGlzXG4gKiBwcm9jZXNzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGF1ZGl0VGltZX0sIGJ1dCB0aGUgc2lsZW5jaW5nXG4gKiBkdXJhdGlvbiBpcyBkZXRlcm1pbmVkIGJ5IGEgc2Vjb25kIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYXVkaXQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGF1ZGl0YCBpcyBzaW1pbGFyIHRvIGB0aHJvdHRsZWAsIGJ1dCBlbWl0cyB0aGUgbGFzdCB2YWx1ZSBmcm9tIHRoZSBzaWxlbmNlZFxuICogdGltZSB3aW5kb3csIGluc3RlYWQgb2YgdGhlIGZpcnN0IHZhbHVlLiBgYXVkaXRgIGVtaXRzIHRoZSBtb3N0IHJlY2VudCB2YWx1ZVxuICogZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGFzIHNvb24gYXMgaXRzIGludGVybmFsXG4gKiB0aW1lciBiZWNvbWVzIGRpc2FibGVkLCBhbmQgaWdub3JlcyBzb3VyY2UgdmFsdWVzIHdoaWxlIHRoZSB0aW1lciBpcyBlbmFibGVkLlxuICogSW5pdGlhbGx5LCB0aGUgdGltZXIgaXMgZGlzYWJsZWQuIEFzIHNvb24gYXMgdGhlIGZpcnN0IHNvdXJjZSB2YWx1ZSBhcnJpdmVzLFxuICogdGhlIHRpbWVyIGlzIGVuYWJsZWQgYnkgY2FsbGluZyB0aGUgYGR1cmF0aW9uU2VsZWN0b3JgIGZ1bmN0aW9uIHdpdGggdGhlXG4gKiBzb3VyY2UgdmFsdWUsIHdoaWNoIHJldHVybnMgdGhlIFwiZHVyYXRpb25cIiBPYnNlcnZhYmxlLiBXaGVuIHRoZSBkdXJhdGlvblxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlIG9yIGNvbXBsZXRlcywgdGhlIHRpbWVyIGlzIGRpc2FibGVkLCB0aGVuIHRoZSBtb3N0XG4gKiByZWNlbnQgc291cmNlIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLCBhbmQgdGhpcyBwcm9jZXNzXG4gKiByZXBlYXRzIGZvciB0aGUgbmV4dCBzb3VyY2UgdmFsdWUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBjbGlja3MgYXQgYSByYXRlIG9mIGF0IG1vc3Qgb25lIGNsaWNrIHBlciBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5hdWRpdChldiA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXRUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBkZWxheVdoZW59XG4gKiBAc2VlIHtAbGluayBzYW1wbGV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBUKTogU3Vic2NyaWJhYmxlT3JQcm9taXNlfSBkdXJhdGlvblNlbGVjdG9yIEEgZnVuY3Rpb25cbiAqIHRoYXQgcmVjZWl2ZXMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgZm9yIGNvbXB1dGluZyB0aGUgc2lsZW5jaW5nXG4gKiBkdXJhdGlvbiwgcmV0dXJuZWQgYXMgYW4gT2JzZXJ2YWJsZSBvciBhIFByb21pc2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgcGVyZm9ybXMgcmF0ZS1saW1pdGluZyBvZlxuICogZW1pc3Npb25zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBhdWRpdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gYXVkaXQoZHVyYXRpb25TZWxlY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiBhdWRpdE9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgQXVkaXRPcGVyYXRvcihkdXJhdGlvblNlbGVjdG9yKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuYXVkaXQgPSBhdWRpdDtcbnZhciBBdWRpdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdWRpdE9wZXJhdG9yKGR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICB9XG4gICAgQXVkaXRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEF1ZGl0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmR1cmF0aW9uU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBBdWRpdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQXVkaXRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXVkaXRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF1ZGl0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZHVyYXRpb25TZWxlY3RvciA9IGR1cmF0aW9uU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgQXVkaXRTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMudGhyb3R0bGVkKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMuZHVyYXRpb25TZWxlY3RvcikodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGR1cmF0aW9uID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGhyb3R0bGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMudGhyb3R0bGVkID0gaW5uZXJTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaXRTdWJzY3JpYmVyLnByb3RvdHlwZS5jbGVhclRocm90dGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCB2YWx1ZSA9IF9hLnZhbHVlLCBoYXNWYWx1ZSA9IF9hLmhhc1ZhbHVlLCB0aHJvdHRsZWQgPSBfYS50aHJvdHRsZWQ7XG4gICAgICAgIGlmICh0aHJvdHRsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHRocm90dGxlZCk7XG4gICAgICAgICAgICB0aGlzLnRocm90dGxlZCA9IG51bGw7XG4gICAgICAgICAgICB0aHJvdHRsZWQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaXRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRocm90dGxlKCk7XG4gICAgfTtcbiAgICBBdWRpdFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyVGhyb3R0bGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBBdWRpdFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXVkaXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL2F1ZGl0LmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlJyk7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIG5vbmUgPSB7fTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvIGNyZWF0ZSBhbiBPYnNlcnZhYmxlIHdob3NlIHZhbHVlcyBhcmVcbiAqIGNhbGN1bGF0ZWQgZnJvbSB0aGUgbGF0ZXN0IHZhbHVlcyBvZiBlYWNoIG9mIGl0cyBpbnB1dCBPYnNlcnZhYmxlcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+V2hlbmV2ZXIgYW55IGlucHV0IE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSwgaXRcbiAqIGNvbXB1dGVzIGEgZm9ybXVsYSB1c2luZyB0aGUgbGF0ZXN0IHZhbHVlcyBmcm9tIGFsbCB0aGUgaW5wdXRzLCB0aGVuIGVtaXRzXG4gKiB0aGUgb3V0cHV0IG9mIHRoYXQgZm9ybXVsYS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9jb21iaW5lTGF0ZXN0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBjb21iaW5lTGF0ZXN0YCBjb21iaW5lcyB0aGUgdmFsdWVzIGZyb20gdGhpcyBPYnNlcnZhYmxlIHdpdGggdmFsdWVzIGZyb21cbiAqIE9ic2VydmFibGVzIHBhc3NlZCBhcyBhcmd1bWVudHMuIFRoaXMgaXMgZG9uZSBieSBzdWJzY3JpYmluZyB0byBlYWNoXG4gKiBPYnNlcnZhYmxlLCBpbiBvcmRlciwgYW5kIGNvbGxlY3RpbmcgYW4gYXJyYXkgb2YgZWFjaCBvZiB0aGUgbW9zdCByZWNlbnRcbiAqIHZhbHVlcyBhbnkgdGltZSBhbnkgb2YgdGhlIGlucHV0IE9ic2VydmFibGVzIGVtaXRzLCB0aGVuIGVpdGhlciB0YWtpbmcgdGhhdFxuICogYXJyYXkgYW5kIHBhc3NpbmcgaXQgYXMgYXJndW1lbnRzIHRvIGFuIG9wdGlvbmFsIGBwcm9qZWN0YCBmdW5jdGlvbiBhbmRcbiAqIGVtaXR0aW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhhdCwgb3IganVzdCBlbWl0dGluZyB0aGUgYXJyYXkgb2YgcmVjZW50XG4gKiB2YWx1ZXMgZGlyZWN0bHkgaWYgdGhlcmUgaXMgbm8gYHByb2plY3RgIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkR5bmFtaWNhbGx5IGNhbGN1bGF0ZSB0aGUgQm9keS1NYXNzIEluZGV4IGZyb20gYW4gT2JzZXJ2YWJsZSBvZiB3ZWlnaHQgYW5kIG9uZSBmb3IgaGVpZ2h0PC9jYXB0aW9uPlxuICogdmFyIHdlaWdodCA9IFJ4Lk9ic2VydmFibGUub2YoNzAsIDcyLCA3NiwgNzksIDc1KTtcbiAqIHZhciBoZWlnaHQgPSBSeC5PYnNlcnZhYmxlLm9mKDEuNzYsIDEuNzcsIDEuNzgpO1xuICogdmFyIGJtaSA9IHdlaWdodC5jb21iaW5lTGF0ZXN0KGhlaWdodCwgKHcsIGgpID0+IHcgLyAoaCAqIGgpKTtcbiAqIGJtaS5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZygnQk1JIGlzICcgKyB4KSk7XG4gKlxuICogLy8gV2l0aCBvdXRwdXQgdG8gY29uc29sZTpcbiAqIC8vIEJNSSBpcyAyNC4yMTIyOTMzODg0Mjk3NTNcbiAqIC8vIEJNSSBpcyAyMy45Mzk0ODA5OTIwNTIwOVxuICogLy8gQk1JIGlzIDIzLjY3MTI1MzYyOTU5MjIyMlxuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVBbGx9XG4gKiBAc2VlIHtAbGluayBtZXJnZX1cbiAqIEBzZWUge0BsaW5rIHdpdGhMYXRlc3RGcm9tfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBvdGhlciBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbWJpbmUgd2l0aCB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBNb3JlIHRoYW4gb25lIGlucHV0IE9ic2VydmFibGVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9qZWN0XSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBwcm9qZWN0IHRoZSB2YWx1ZXMgZnJvbVxuICogdGhlIGNvbWJpbmVkIGxhdGVzdCB2YWx1ZXMgaW50byBhIG5ldyB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIHByb2plY3RlZCB2YWx1ZXMgZnJvbSB0aGUgbW9zdCByZWNlbnRcbiAqIHZhbHVlcyBmcm9tIGVhY2ggaW5wdXQgT2JzZXJ2YWJsZSwgb3IgYW4gYXJyYXkgb2YgdGhlIG1vc3QgcmVjZW50IHZhbHVlcyBmcm9tXG4gKiBlYWNoIGlucHV0IE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIGNvbWJpbmVMYXRlc3RcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVMYXRlc3QoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBwcm9qZWN0ID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb2plY3QgPSBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICB9XG4gICAgLy8gaWYgdGhlIGZpcnN0IGFuZCBvbmx5IG90aGVyIGFyZ3VtZW50IGJlc2lkZXMgdGhlIHJlc3VsdFNlbGVjdG9yIGlzIGFuIGFycmF5XG4gICAgLy8gYXNzdW1lIGl0J3MgYmVlbiBjYWxsZWQgd2l0aCBgY29tYmluZUxhdGVzdChbb2JzMSwgb2JzMiwgb2JzM10sIHByb2plY3QpYFxuICAgIGlmIChvYnNlcnZhYmxlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheV8xLmlzQXJyYXkob2JzZXJ2YWJsZXNbMF0pKSB7XG4gICAgICAgIG9ic2VydmFibGVzID0gb2JzZXJ2YWJsZXNbMF0uc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0LmNhbGwobmV3IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZShbc291cmNlXS5jb25jYXQob2JzZXJ2YWJsZXMpKSwgbmV3IENvbWJpbmVMYXRlc3RPcGVyYXRvcihwcm9qZWN0KSk7IH07XG59XG5leHBvcnRzLmNvbWJpbmVMYXRlc3QgPSBjb21iaW5lTGF0ZXN0O1xudmFyIENvbWJpbmVMYXRlc3RPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tYmluZUxhdGVzdE9wZXJhdG9yKHByb2plY3QpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICB9XG4gICAgQ29tYmluZUxhdGVzdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQ29tYmluZUxhdGVzdFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcm9qZWN0KSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tYmluZUxhdGVzdE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuQ29tYmluZUxhdGVzdE9wZXJhdG9yID0gQ29tYmluZUxhdGVzdE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBDb21iaW5lTGF0ZXN0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gW107XG4gICAgfVxuICAgIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLnB1c2gobm9uZSk7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXMucHVzaChvYnNlcnZhYmxlKTtcbiAgICB9O1xuICAgIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlcyA9IHRoaXMub2JzZXJ2YWJsZXM7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZhYmxlcy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gbGVuO1xuICAgICAgICAgICAgdGhpcy50b1Jlc3BvbmQgPSBsZW47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBvYnNlcnZhYmxlc1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG9ic2VydmFibGUsIG9ic2VydmFibGUsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tYmluZUxhdGVzdFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKHVudXNlZCkge1xuICAgICAgICBpZiAoKHRoaXMuYWN0aXZlIC09IDEpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgdmFyIG9sZFZhbCA9IHZhbHVlc1tvdXRlckluZGV4XTtcbiAgICAgICAgdmFyIHRvUmVzcG9uZCA9ICF0aGlzLnRvUmVzcG9uZFxuICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICA6IG9sZFZhbCA9PT0gbm9uZSA/IC0tdGhpcy50b1Jlc3BvbmQgOiB0aGlzLnRvUmVzcG9uZDtcbiAgICAgICAgdmFsdWVzW291dGVySW5kZXhdID0gaW5uZXJWYWx1ZTtcbiAgICAgICAgaWYgKHRvUmVzcG9uZCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyeVByb2plY3QodmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZXMuc2xpY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UHJvamVjdCA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdC5hcHBseSh0aGlzLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBDb21iaW5lTGF0ZXN0U3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG5leHBvcnRzLkNvbWJpbmVMYXRlc3RTdWJzY3JpYmVyID0gQ29tYmluZUxhdGVzdFN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21iaW5lTGF0ZXN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9jb21iaW5lTGF0ZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYWxsIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgYXJlIGRpc3RpbmN0IGJ5IGNvbXBhcmlzb24gZnJvbSB0aGUgcHJldmlvdXMgaXRlbS5cbiAqXG4gKiBJZiBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHRoZW4gaXQgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggaXRlbSB0byB0ZXN0IGZvciB3aGV0aGVyIG9yIG5vdCB0aGF0IHZhbHVlIHNob3VsZCBiZSBlbWl0dGVkLlxuICpcbiAqIElmIGEgY29tcGFyYXRvciBmdW5jdGlvbiBpcyBub3QgcHJvdmlkZWQsIGFuIGVxdWFsaXR5IGNoZWNrIGlzIHVzZWQgYnkgZGVmYXVsdC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BIHNpbXBsZSBleGFtcGxlIHdpdGggbnVtYmVyczwvY2FwdGlvbj5cbiAqIE9ic2VydmFibGUub2YoMSwgMSwgMiwgMiwgMiwgMSwgMSwgMiwgMywgMywgNClcbiAqICAgLmRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTsgLy8gMSwgMiwgMSwgMiwgMywgNFxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkFuIGV4YW1wbGUgdXNpbmcgYSBjb21wYXJlIGZ1bmN0aW9uPC9jYXB0aW9uPlxuICogaW50ZXJmYWNlIFBlcnNvbiB7XG4gKiAgICBhZ2U6IG51bWJlcixcbiAqICAgIG5hbWU6IHN0cmluZ1xuICogfVxuICpcbiAqIE9ic2VydmFibGUub2Y8UGVyc29uPihcbiAqICAgICB7IGFnZTogNCwgbmFtZTogJ0Zvbyd9LFxuICogICAgIHsgYWdlOiA3LCBuYW1lOiAnQmFyJ30sXG4gKiAgICAgeyBhZ2U6IDUsIG5hbWU6ICdGb28nfSlcbiAqICAgICB7IGFnZTogNiwgbmFtZTogJ0Zvbyd9KVxuICogICAgIC5kaXN0aW5jdFVudGlsQ2hhbmdlZCgocDogUGVyc29uLCBxOiBQZXJzb24pID0+IHAubmFtZSA9PT0gcS5uYW1lKVxuICogICAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gZGlzcGxheXM6XG4gKiAvLyB7IGFnZTogNCwgbmFtZTogJ0ZvbycgfVxuICogLy8geyBhZ2U6IDcsIG5hbWU6ICdCYXInIH1cbiAqIC8vIHsgYWdlOiA1LCBuYW1lOiAnRm9vJyB9XG4gKlxuICogQHNlZSB7QGxpbmsgZGlzdGluY3R9XG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY29tcGFyZV0gT3B0aW9uYWwgY29tcGFyaXNvbiBmdW5jdGlvbiBjYWxsZWQgdG8gdGVzdCBpZiBhbiBpdGVtIGlzIGRpc3RpbmN0IGZyb20gdGhlIHByZXZpb3VzIGl0ZW0gaW4gdGhlIHNvdXJjZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIGRpc3RpbmN0IHZhbHVlcy5cbiAqIEBtZXRob2QgZGlzdGluY3RVbnRpbENoYW5nZWRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRpc3RpbmN0VW50aWxDaGFuZ2VkKGNvbXBhcmUsIGtleVNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZE9wZXJhdG9yKGNvbXBhcmUsIGtleVNlbGVjdG9yKSk7IH07XG59XG5leHBvcnRzLmRpc3RpbmN0VW50aWxDaGFuZ2VkID0gZGlzdGluY3RVbnRpbENoYW5nZWQ7XG52YXIgRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvcihjb21wYXJlLCBrZXlTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgICAgICB0aGlzLmtleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgfVxuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jb21wYXJlLCB0aGlzLmtleVNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbXBhcmUsIGtleVNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgICAgICB0aGlzLmhhc0tleSA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGNvbXBhcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHggPT09IHk7XG4gICAgfTtcbiAgICBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBrZXlTZWxlY3RvciA9IHRoaXMua2V5U2VsZWN0b3I7XG4gICAgICAgIHZhciBrZXkgPSB2YWx1ZTtcbiAgICAgICAgaWYgKGtleVNlbGVjdG9yKSB7XG4gICAgICAgICAgICBrZXkgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMua2V5U2VsZWN0b3IpKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaGFzS2V5KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMuY29tcGFyZSkodGhpcy5rZXksIGtleSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQm9vbGVhbihyZXN1bHQpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGluY3RVbnRpbENoYW5nZWQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL2Rpc3RpbmN0VW50aWxDaGFuZ2VkLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIEVtaXRzIG9ubHkgdGhlIGZpcnN0IHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgbWVldHMgc29tZVxuICogY29uZGl0aW9uLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GaW5kcyB0aGUgZmlyc3QgdmFsdWUgdGhhdCBwYXNzZXMgc29tZSB0ZXN0IGFuZCBlbWl0c1xuICogdGhhdC48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9maW5kLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBmaW5kYCBzZWFyY2hlcyBmb3IgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgbWF0Y2hlcyB0aGVcbiAqIHNwZWNpZmllZCBjb25kaXRpb24gZW1ib2RpZWQgYnkgdGhlIGBwcmVkaWNhdGVgLCBhbmQgcmV0dXJucyB0aGUgZmlyc3RcbiAqIG9jY3VycmVuY2UgaW4gdGhlIHNvdXJjZS4gVW5saWtlIHtAbGluayBmaXJzdH0sIHRoZSBgcHJlZGljYXRlYCBpcyByZXF1aXJlZFxuICogaW4gYGZpbmRgLCBhbmQgZG9lcyBub3QgZW1pdCBhbiBlcnJvciBpZiBhIHZhbGlkIHZhbHVlIGlzIG5vdCBmb3VuZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5GaW5kIGFuZCBlbWl0IHRoZSBmaXJzdCBjbGljayB0aGF0IGhhcHBlbnMgb24gYSBESVYgZWxlbWVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmZpbmQoZXYgPT4gZXYudGFyZ2V0LnRhZ05hbWUgPT09ICdESVYnKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZmlsdGVyfVxuICogQHNlZSB7QGxpbmsgZmlyc3R9XG4gKiBAc2VlIHtAbGluayBmaW5kSW5kZXh9XG4gKiBAc2VlIHtAbGluayB0YWtlfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPik6IGJvb2xlYW59IHByZWRpY2F0ZVxuICogQSBmdW5jdGlvbiBjYWxsZWQgd2l0aCBlYWNoIGl0ZW0gdG8gdGVzdCBmb3IgY29uZGl0aW9uIG1hdGNoaW5nLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIGB0aGlzYFxuICogaW4gdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSBvZiB0aGUgZmlyc3QgaXRlbSB0aGF0IG1hdGNoZXMgdGhlXG4gKiBjb25kaXRpb24uXG4gKiBAbWV0aG9kIGZpbmRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGZpbmQocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgRmluZFZhbHVlT3BlcmF0b3IocHJlZGljYXRlLCBzb3VyY2UsIGZhbHNlLCB0aGlzQXJnKSk7IH07XG59XG5leHBvcnRzLmZpbmQgPSBmaW5kO1xudmFyIEZpbmRWYWx1ZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaW5kVmFsdWVPcGVyYXRvcihwcmVkaWNhdGUsIHNvdXJjZSwgeWllbGRJbmRleCwgdGhpc0FyZykge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMueWllbGRJbmRleCA9IHlpZWxkSW5kZXg7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgfVxuICAgIEZpbmRWYWx1ZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEZpbmRWYWx1ZVN1YnNjcmliZXIob2JzZXJ2ZXIsIHRoaXMucHJlZGljYXRlLCB0aGlzLnNvdXJjZSwgdGhpcy55aWVsZEluZGV4LCB0aGlzLnRoaXNBcmcpKTtcbiAgICB9O1xuICAgIHJldHVybiBGaW5kVmFsdWVPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLkZpbmRWYWx1ZU9wZXJhdG9yID0gRmluZFZhbHVlT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEZpbmRWYWx1ZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaW5kVmFsdWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpbmRWYWx1ZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgc291cmNlLCB5aWVsZEluZGV4LCB0aGlzQXJnKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnlpZWxkSW5kZXggPSB5aWVsZEluZGV4O1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgRmluZFZhbHVlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBGaW5kVmFsdWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcmVkaWNhdGUgPSBfYS5wcmVkaWNhdGUsIHRoaXNBcmcgPSBfYS50aGlzQXJnO1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcHJlZGljYXRlLmNhbGwodGhpc0FyZyB8fCB0aGlzLCB2YWx1ZSwgaW5kZXgsIHRoaXMuc291cmNlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUNvbXBsZXRlKHRoaXMueWllbGRJbmRleCA/IGluZGV4IDogdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmluZFZhbHVlU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeUNvbXBsZXRlKHRoaXMueWllbGRJbmRleCA/IC0xIDogdW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIHJldHVybiBGaW5kVmFsdWVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5GaW5kVmFsdWVTdWJzY3JpYmVyID0gRmluZFZhbHVlU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL2ZpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbmV4cG9ydHMuZGVmYXVsdFRocm90dGxlQ29uZmlnID0ge1xuICAgIGxlYWRpbmc6IHRydWUsXG4gICAgdHJhaWxpbmc6IGZhbHNlXG59O1xuLyoqXG4gKiBFbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGVuIGlnbm9yZXMgc3Vic2VxdWVudCBzb3VyY2VcbiAqIHZhbHVlcyBmb3IgYSBkdXJhdGlvbiBkZXRlcm1pbmVkIGJ5IGFub3RoZXIgT2JzZXJ2YWJsZSwgdGhlbiByZXBlYXRzIHRoaXNcbiAqIHByb2Nlc3MuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgdGhyb3R0bGVUaW1lfSwgYnV0IHRoZSBzaWxlbmNpbmdcbiAqIGR1cmF0aW9uIGlzIGRldGVybWluZWQgYnkgYSBzZWNvbmQgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90aHJvdHRsZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGhyb3R0bGVgIGVtaXRzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlXG4gKiB3aGVuIGl0cyBpbnRlcm5hbCB0aW1lciBpcyBkaXNhYmxlZCwgYW5kIGlnbm9yZXMgc291cmNlIHZhbHVlcyB3aGVuIHRoZSB0aW1lclxuICogaXMgZW5hYmxlZC4gSW5pdGlhbGx5LCB0aGUgdGltZXIgaXMgZGlzYWJsZWQuIEFzIHNvb24gYXMgdGhlIGZpcnN0IHNvdXJjZVxuICogdmFsdWUgYXJyaXZlcywgaXQgaXMgZm9yd2FyZGVkIHRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSwgYW5kIHRoZW4gdGhlIHRpbWVyXG4gKiBpcyBlbmFibGVkIGJ5IGNhbGxpbmcgdGhlIGBkdXJhdGlvblNlbGVjdG9yYCBmdW5jdGlvbiB3aXRoIHRoZSBzb3VyY2UgdmFsdWUsXG4gKiB3aGljaCByZXR1cm5zIHRoZSBcImR1cmF0aW9uXCIgT2JzZXJ2YWJsZS4gV2hlbiB0aGUgZHVyYXRpb24gT2JzZXJ2YWJsZSBlbWl0cyBhXG4gKiB2YWx1ZSBvciBjb21wbGV0ZXMsIHRoZSB0aW1lciBpcyBkaXNhYmxlZCwgYW5kIHRoaXMgcHJvY2VzcyByZXBlYXRzIGZvciB0aGVcbiAqIG5leHQgc291cmNlIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgY2xpY2tzIGF0IGEgcmF0ZSBvZiBhdCBtb3N0IG9uZSBjbGljayBwZXIgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MudGhyb3R0bGUoZXYgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0fVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBkZWxheVdoZW59XG4gKiBAc2VlIHtAbGluayBzYW1wbGV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZVRpbWV9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IFN1YnNjcmliYWJsZU9yUHJvbWlzZX0gZHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uXG4gKiB0aGF0IHJlY2VpdmVzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIGZvciBjb21wdXRpbmcgdGhlIHNpbGVuY2luZ1xuICogZHVyYXRpb24gZm9yIGVhY2ggc291cmNlIHZhbHVlLCByZXR1cm5lZCBhcyBhbiBPYnNlcnZhYmxlIG9yIGEgUHJvbWlzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgYSBjb25maWd1cmF0aW9uIG9iamVjdCB0byBkZWZpbmUgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIGJlaGF2aW9yLiBEZWZhdWx0c1xuICogdG8gYHsgbGVhZGluZzogdHJ1ZSwgdHJhaWxpbmc6IGZhbHNlIH1gLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IHBlcmZvcm1zIHRoZSB0aHJvdHRsZSBvcGVyYXRpb24gdG9cbiAqIGxpbWl0IHRoZSByYXRlIG9mIGVtaXNzaW9ucyBmcm9tIHRoZSBzb3VyY2UuXG4gKiBAbWV0aG9kIHRocm90dGxlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0aHJvdHRsZShkdXJhdGlvblNlbGVjdG9yLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0gZXhwb3J0cy5kZWZhdWx0VGhyb3R0bGVDb25maWc7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFRocm90dGxlT3BlcmF0b3IoZHVyYXRpb25TZWxlY3RvciwgY29uZmlnLmxlYWRpbmcsIGNvbmZpZy50cmFpbGluZykpOyB9O1xufVxuZXhwb3J0cy50aHJvdHRsZSA9IHRocm90dGxlO1xudmFyIFRocm90dGxlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRocm90dGxlT3BlcmF0b3IoZHVyYXRpb25TZWxlY3RvciwgbGVhZGluZywgdHJhaWxpbmcpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICAgICAgdGhpcy5sZWFkaW5nID0gbGVhZGluZztcbiAgICAgICAgdGhpcy50cmFpbGluZyA9IHRyYWlsaW5nO1xuICAgIH1cbiAgICBUaHJvdHRsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGhyb3R0bGVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZHVyYXRpb25TZWxlY3RvciwgdGhpcy5sZWFkaW5nLCB0aGlzLnRyYWlsaW5nKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3R0bGVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2NcbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgVGhyb3R0bGVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGhyb3R0bGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRocm90dGxlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVyYXRpb25TZWxlY3RvciwgX2xlYWRpbmcsIF90cmFpbGluZykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICAgICAgdGhpcy5fbGVhZGluZyA9IF9sZWFkaW5nO1xuICAgICAgICB0aGlzLl90cmFpbGluZyA9IF90cmFpbGluZztcbiAgICAgICAgdGhpcy5faGFzVHJhaWxpbmdWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBUaHJvdHRsZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnRocm90dGxlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RyYWlsaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVHJhaWxpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhaWxpbmdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy50cnlEdXJhdGlvblNlbGVjdG9yKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMudGhyb3R0bGVkID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBkdXJhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xlYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmFpbGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNUcmFpbGluZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhaWxpbmdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVGhyb3R0bGVTdWJzY3JpYmVyLnByb3RvdHlwZS50cnlEdXJhdGlvblNlbGVjdG9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kdXJhdGlvblNlbGVjdG9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGhyb3R0bGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHRocm90dGxlZCA9IF9hLnRocm90dGxlZCwgX3RyYWlsaW5nVmFsdWUgPSBfYS5fdHJhaWxpbmdWYWx1ZSwgX2hhc1RyYWlsaW5nVmFsdWUgPSBfYS5faGFzVHJhaWxpbmdWYWx1ZSwgX3RyYWlsaW5nID0gX2EuX3RyYWlsaW5nO1xuICAgICAgICB0aGlzLl90cmFpbGluZ1ZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5faGFzVHJhaWxpbmdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhyb3R0bGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aHJvdHRsZWQpO1xuICAgICAgICAgICAgdGhpcy50aHJvdHRsZWQgPSBudWxsO1xuICAgICAgICAgICAgdGhyb3R0bGVkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRocm90dGxlU3Vic2NyaWJlci5wcm90b3R5cGUuX3NlbmRUcmFpbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbiwgdGhyb3R0bGVkID0gX2EudGhyb3R0bGVkLCBfdHJhaWxpbmcgPSBfYS5fdHJhaWxpbmcsIF90cmFpbGluZ1ZhbHVlID0gX2EuX3RyYWlsaW5nVmFsdWUsIF9oYXNUcmFpbGluZ1ZhbHVlID0gX2EuX2hhc1RyYWlsaW5nVmFsdWU7XG4gICAgICAgIGlmICh0aHJvdHRsZWQgJiYgX3RyYWlsaW5nICYmIF9oYXNUcmFpbGluZ1ZhbHVlKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KF90cmFpbGluZ1ZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYWlsaW5nVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faGFzVHJhaWxpbmdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaHJvdHRsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5fc2VuZFRyYWlsaW5nKCk7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBUaHJvdHRsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zZW5kVHJhaWxpbmcoKTtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBUaHJvdHRsZVN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3R0bGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL3Rocm90dGxlLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBCcmFuY2ggb3V0IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgYXMgYSBuZXN0ZWQgT2JzZXJ2YWJsZSB3aGVuZXZlclxuICogYHdpbmRvd0JvdW5kYXJpZXNgIGVtaXRzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGJ1ZmZlcn0sIGJ1dCBlbWl0cyBhIG5lc3RlZCBPYnNlcnZhYmxlXG4gKiBpbnN0ZWFkIG9mIGFuIGFycmF5Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3dpbmRvdy5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB3aW5kb3dzIG9mIGl0ZW1zIGl0IGNvbGxlY3RzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzIGNvbm5lY3RlZCwgbm9uLW92ZXJsYXBwaW5nXG4gKiB3aW5kb3dzLiBJdCBlbWl0cyB0aGUgY3VycmVudCB3aW5kb3cgYW5kIG9wZW5zIGEgbmV3IG9uZSB3aGVuZXZlciB0aGVcbiAqIE9ic2VydmFibGUgYHdpbmRvd0JvdW5kYXJpZXNgIGVtaXRzIGFuIGl0ZW0uIEJlY2F1c2UgZWFjaCB3aW5kb3cgaXMgYW5cbiAqIE9ic2VydmFibGUsIHRoZSBvdXRwdXQgaXMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5JbiBldmVyeSB3aW5kb3cgb2YgMSBzZWNvbmQgZWFjaCwgZW1pdCBhdCBtb3N0IDIgY2xpY2sgZXZlbnRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLndpbmRvdyhpbnRlcnZhbClcbiAqICAgLm1hcCh3aW4gPT4gd2luLnRha2UoMikpIC8vIGVhY2ggd2luZG93IGhhcyBhdCBtb3N0IDIgZW1pc3Npb25zXG4gKiAgIC5tZXJnZUFsbCgpOyAvLyBmbGF0dGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHdpbmRvd0NvdW50fVxuICogQHNlZSB7QGxpbmsgd2luZG93VGltZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1doZW59XG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlPGFueT59IHdpbmRvd0JvdW5kYXJpZXMgQW4gT2JzZXJ2YWJsZSB0aGF0IGNvbXBsZXRlcyB0aGVcbiAqIHByZXZpb3VzIHdpbmRvdyBhbmQgc3RhcnRzIGEgbmV3IHdpbmRvdy5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8T2JzZXJ2YWJsZTxUPj59IEFuIE9ic2VydmFibGUgb2Ygd2luZG93cywgd2hpY2ggYXJlXG4gKiBPYnNlcnZhYmxlcyBlbWl0dGluZyB2YWx1ZXMgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCB3aW5kb3dcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHdpbmRvdyh3aW5kb3dCb3VuZGFyaWVzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHdpbmRvd09wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgV2luZG93T3BlcmF0b3Iod2luZG93Qm91bmRhcmllcykpO1xuICAgIH07XG59XG5leHBvcnRzLndpbmRvdyA9IHdpbmRvdztcbnZhciBXaW5kb3dPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2luZG93T3BlcmF0b3Iod2luZG93Qm91bmRhcmllcykge1xuICAgICAgICB0aGlzLndpbmRvd0JvdW5kYXJpZXMgPSB3aW5kb3dCb3VuZGFyaWVzO1xuICAgIH1cbiAgICBXaW5kb3dPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIHdpbmRvd1N1YnNjcmliZXIgPSBuZXcgV2luZG93U3Vic2NyaWJlcihzdWJzY3JpYmVyKTtcbiAgICAgICAgdmFyIHNvdXJjZVN1YnNjcmlwdGlvbiA9IHNvdXJjZS5zdWJzY3JpYmUod2luZG93U3Vic2NyaWJlcik7XG4gICAgICAgIGlmICghc291cmNlU3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgd2luZG93U3Vic2NyaWJlci5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh3aW5kb3dTdWJzY3JpYmVyLCB0aGlzLndpbmRvd0JvdW5kYXJpZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlU3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIFdpbmRvd09wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgV2luZG93U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdpbmRvd1N1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2luZG93U3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMud2luZG93ID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQodGhpcy53aW5kb3cpO1xuICAgIH1cbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMub3BlbldpbmRvdygpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuX2Vycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLndpbmRvdy5uZXh0KHZhbHVlKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy53aW5kb3cuZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLndpbmRvdy5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMud2luZG93ID0gbnVsbDtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLm9wZW5XaW5kb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2V2luZG93ID0gdGhpcy53aW5kb3c7XG4gICAgICAgIGlmIChwcmV2V2luZG93KSB7XG4gICAgICAgICAgICBwcmV2V2luZG93LmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIG5ld1dpbmRvdyA9IHRoaXMud2luZG93ID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQobmV3V2luZG93KTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvdy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvd2luZG93LmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlJyk7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5Jyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBpdGVyYXRvcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL2l0ZXJhdG9yJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBAcGFyYW0gb2JzZXJ2YWJsZXNcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59XG4gKiBAbWV0aG9kIHppcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gemlwKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gemlwT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0LmNhbGwoemlwU3RhdGljLmFwcGx5KHZvaWQgMCwgW3NvdXJjZV0uY29uY2F0KG9ic2VydmFibGVzKSkpO1xuICAgIH07XG59XG5leHBvcnRzLnppcCA9IHppcDtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvIGNyZWF0ZSBhbiBPYnNlcnZhYmxlIHdob3NlIHZhbHVlcyBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSB2YWx1ZXMsIGluIG9yZGVyLCBvZiBlYWNoXG4gKiBvZiBpdHMgaW5wdXQgT2JzZXJ2YWJsZXMuXG4gKlxuICogSWYgdGhlIGxhdGVzdCBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiwgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlIGNyZWF0ZWQgdmFsdWUgZnJvbSB0aGUgaW5wdXQgdmFsdWVzLlxuICogT3RoZXJ3aXNlLCBhbiBhcnJheSBvZiB0aGUgaW5wdXQgdmFsdWVzIGlzIHJldHVybmVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbWJpbmUgYWdlIGFuZCBuYW1lIGZyb20gZGlmZmVyZW50IHNvdXJjZXM8L2NhcHRpb24+XG4gKlxuICogbGV0IGFnZSQgPSBPYnNlcnZhYmxlLm9mPG51bWJlcj4oMjcsIDI1LCAyOSk7XG4gKiBsZXQgbmFtZSQgPSBPYnNlcnZhYmxlLm9mPHN0cmluZz4oJ0ZvbycsICdCYXInLCAnQmVlcicpO1xuICogbGV0IGlzRGV2JCA9IE9ic2VydmFibGUub2Y8Ym9vbGVhbj4odHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICpcbiAqIE9ic2VydmFibGVcbiAqICAgICAuemlwKGFnZSQsXG4gKiAgICAgICAgICBuYW1lJCxcbiAqICAgICAgICAgIGlzRGV2JCxcbiAqICAgICAgICAgIChhZ2U6IG51bWJlciwgbmFtZTogc3RyaW5nLCBpc0RldjogYm9vbGVhbikgPT4gKHsgYWdlLCBuYW1lLCBpc0RldiB9KSlcbiAqICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIG91dHB1dHNcbiAqIC8vIHsgYWdlOiAyNywgbmFtZTogJ0ZvbycsIGlzRGV2OiB0cnVlIH1cbiAqIC8vIHsgYWdlOiAyNSwgbmFtZTogJ0JhcicsIGlzRGV2OiB0cnVlIH1cbiAqIC8vIHsgYWdlOiAyOSwgbmFtZTogJ0JlZXInLCBpc0RldjogZmFsc2UgfVxuICpcbiAqIEBwYXJhbSBvYnNlcnZhYmxlc1xuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn1cbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgemlwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB6aXBTdGF0aWMoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBwcm9qZWN0ID0gb2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHR5cGVvZiBwcm9qZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9ic2VydmFibGVzLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZShvYnNlcnZhYmxlcykubGlmdChuZXcgWmlwT3BlcmF0b3IocHJvamVjdCkpO1xufVxuZXhwb3J0cy56aXBTdGF0aWMgPSB6aXBTdGF0aWM7XG52YXIgWmlwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFppcE9wZXJhdG9yKHByb2plY3QpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICB9XG4gICAgWmlwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBaaXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuWmlwT3BlcmF0b3IgPSBaaXBPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgWmlwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFppcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWmlwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgPT09IHZvaWQgMCkgeyB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5pdGVyYXRvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgICAgICB0aGlzLnByb2plY3QgPSAodHlwZW9mIHByb2plY3QgPT09ICdmdW5jdGlvbicpID8gcHJvamVjdCA6IG51bGw7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgIH1cbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaXRlcmF0b3JzID0gdGhpcy5pdGVyYXRvcnM7XG4gICAgICAgIGlmIChpc0FycmF5XzEuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9ycy5wdXNoKG5ldyBTdGF0aWNBcnJheUl0ZXJhdG9yKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlW2l0ZXJhdG9yXzEuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgU3RhdGljSXRlcmF0b3IodmFsdWVbaXRlcmF0b3JfMS5pdGVyYXRvcl0oKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3JzLnB1c2gobmV3IFppcEJ1ZmZlckl0ZXJhdG9yKHRoaXMuZGVzdGluYXRpb24sIHRoaXMsIHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9ycyA9IHRoaXMuaXRlcmF0b3JzO1xuICAgICAgICB2YXIgbGVuID0gaXRlcmF0b3JzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlID0gbGVuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvcnNbaV07XG4gICAgICAgICAgICBpZiAoaXRlcmF0b3Iuc3RpbGxVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChpdGVyYXRvci5zdWJzY3JpYmUoaXRlcmF0b3IsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlLS07IC8vIG5vdCBhbiBvYnNlcnZhYmxlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUluYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZS0tO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuY2hlY2tJdGVyYXRvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGVyYXRvcnMgPSB0aGlzLml0ZXJhdG9ycztcbiAgICAgICAgdmFyIGxlbiA9IGl0ZXJhdG9ycy5sZW5ndGg7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIC8vIGFib3J0IGlmIG5vdCBhbGwgb2YgdGhlbSBoYXZlIHZhbHVlc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvcnNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yLmhhc1ZhbHVlID09PSAnZnVuY3Rpb24nICYmICFpdGVyYXRvci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzaG91bGRDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvcnNbaV07XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIGl0J3MgY29tcGxldGVkIG5vdyB0aGF0IHlvdSd2ZSBnb3R0ZW5cbiAgICAgICAgICAgIC8vIHRoZSBuZXh0IHZhbHVlLlxuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmhhc0NvbXBsZXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzLnB1c2gocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9qZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl90cnlQcm9qZWN0KGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkQ29tcGxldGUpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlQcm9qZWN0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuWmlwU3Vic2NyaWJlciA9IFppcFN1YnNjcmliZXI7XG52YXIgU3RhdGljSXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRpY0l0ZXJhdG9yKGl0ZXJhdG9yKSB7XG4gICAgICAgIHRoaXMuaXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgICAgICAgdGhpcy5uZXh0UmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIH1cbiAgICBTdGF0aWNJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgU3RhdGljSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLm5leHRSZXN1bHQ7XG4gICAgICAgIHRoaXMubmV4dFJlc3VsdCA9IHRoaXMuaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgU3RhdGljSXRlcmF0b3IucHJvdG90eXBlLmhhc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRSZXN1bHQgPSB0aGlzLm5leHRSZXN1bHQ7XG4gICAgICAgIHJldHVybiBuZXh0UmVzdWx0ICYmIG5leHRSZXN1bHQuZG9uZTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNJdGVyYXRvcjtcbn0oKSk7XG52YXIgU3RhdGljQXJyYXlJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljQXJyYXlJdGVyYXRvcihhcnJheSkge1xuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIH1cbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZVtpdGVyYXRvcl8xLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5pbmRleCsrO1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICByZXR1cm4gaSA8IHRoaXMubGVuZ3RoID8geyB2YWx1ZTogYXJyYXlbaV0sIGRvbmU6IGZhbHNlIH0gOiB7IHZhbHVlOiBudWxsLCBkb25lOiB0cnVlIH07XG4gICAgfTtcbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoID4gdGhpcy5pbmRleDtcbiAgICB9O1xuICAgIFN0YXRpY0FycmF5SXRlcmF0b3IucHJvdG90eXBlLmhhc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoID09PSB0aGlzLmluZGV4O1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY0FycmF5SXRlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBaaXBCdWZmZXJJdGVyYXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFppcEJ1ZmZlckl0ZXJhdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFppcEJ1ZmZlckl0ZXJhdG9yKGRlc3RpbmF0aW9uLCBwYXJlbnQsIG9ic2VydmFibGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbiAgICAgICAgdGhpcy5zdGlsbFVuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JfMS5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gTk9URTogdGhlcmUgaXMgYWN0dWFsbHkgYSBuYW1lIGNvbGxpc2lvbiBoZXJlIHdpdGggU3Vic2NyaWJlci5uZXh0IGFuZCBJdGVyYXRvci5uZXh0XG4gICAgLy8gICAgdGhpcyBpcyBsZWdpdCBiZWNhdXNlIGBuZXh0KClgIHdpbGwgbmV2ZXIgYmUgY2FsbGVkIGJ5IGEgc3Vic2NyaXB0aW9uIGluIHRoaXMgY2FzZS5cbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBudWxsLCBkb25lOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogYnVmZmVyLnNoaWZ0KCksIGRvbmU6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUuaGFzQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoID09PSAwICYmIHRoaXMuaXNDb21wbGV0ZTtcbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5ub3RpZnlJbmFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGlubmVyVmFsdWUpO1xuICAgICAgICB0aGlzLnBhcmVudC5jaGVja0l0ZXJhdG9ycygpO1xuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgdGhpcy5vYnNlcnZhYmxlLCB0aGlzLCBpbmRleCk7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwQnVmZmVySXRlcmF0b3I7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9emlwLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy96aXAuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xudmFyIEFjdGlvbl8xID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQXN5bmNBY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBc3luY0FjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3luY0FjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc2NoZWR1bGVyLCB3b3JrKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMud29yayA9IHdvcms7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsd2F5cyByZXBsYWNlIHRoZSBjdXJyZW50IHN0YXRlIHdpdGggdGhlIG5ldyBzdGF0ZS5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAvLyBTZXQgdGhlIHBlbmRpbmcgZmxhZyBpbmRpY2F0aW5nIHRoYXQgdGhpcyBhY3Rpb24gaGFzIGJlZW4gc2NoZWR1bGVkLCBvclxuICAgICAgICAvLyBoYXMgcmVjdXJzaXZlbHkgcmVzY2hlZHVsZWQgaXRzZWxmLlxuICAgICAgICB0aGlzLnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEltcG9ydGFudCBpbXBsZW1lbnRhdGlvbiBub3RlOlxuICAgICAgICAvL1xuICAgICAgICAvLyBBY3Rpb25zIG9ubHkgZXhlY3V0ZSBvbmNlIGJ5IGRlZmF1bHQsIHVubGVzcyByZXNjaGVkdWxlZCBmcm9tIHdpdGhpbiB0aGVcbiAgICAgICAgLy8gc2NoZWR1bGVkIGNhbGxiYWNrLiBUaGlzIGFsbG93cyB1cyB0byBpbXBsZW1lbnQgc2luZ2xlIGFuZCByZXBlYXRcbiAgICAgICAgLy8gYWN0aW9ucyB2aWEgdGhlIHNhbWUgY29kZSBwYXRoLCB3aXRob3V0IGFkZGluZyBBUEkgc3VyZmFjZSBhcmVhLCBhcyB3ZWxsXG4gICAgICAgIC8vIGFzIG1pbWljIHRyYWRpdGlvbmFsIHJlY3Vyc2lvbiBidXQgYWNyb3NzIGFzeW5jaHJvbm91cyBib3VuZGFyaWVzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIb3dldmVyLCBKUyBydW50aW1lcyBhbmQgdGltZXJzIGRpc3Rpbmd1aXNoIGJldHdlZW4gaW50ZXJ2YWxzIGFjaGlldmVkIGJ5XG4gICAgICAgIC8vIHNlcmlhbCBgc2V0VGltZW91dGAgY2FsbHMgdnMuIGEgc2luZ2xlIGBzZXRJbnRlcnZhbGAgY2FsbC4gQW4gaW50ZXJ2YWwgb2ZcbiAgICAgICAgLy8gc2VyaWFsIGBzZXRUaW1lb3V0YCBjYWxscyBjYW4gYmUgaW5kaXZpZHVhbGx5IGRlbGF5ZWQsIHdoaWNoIGRlbGF5c1xuICAgICAgICAvLyBzY2hlZHVsaW5nIHRoZSBuZXh0IGBzZXRUaW1lb3V0YCwgYW5kIHNvIG9uLiBgc2V0SW50ZXJ2YWxgIGF0dGVtcHRzIHRvXG4gICAgICAgIC8vIGd1YXJhbnRlZSB0aGUgaW50ZXJ2YWwgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIG1vcmUgcHJlY2lzZWx5IHRvIHRoZVxuICAgICAgICAvLyBpbnRlcnZhbCBwZXJpb2QsIHJlZ2FyZGxlc3Mgb2YgbG9hZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlcmVmb3JlLCB3ZSB1c2UgYHNldEludGVydmFsYCB0byBzY2hlZHVsZSBzaW5nbGUgYW5kIHJlcGVhdCBhY3Rpb25zLlxuICAgICAgICAvLyBJZiB0aGUgYWN0aW9uIHJlc2NoZWR1bGVzIGl0c2VsZiB3aXRoIHRoZSBzYW1lIGRlbGF5LCB0aGUgaW50ZXJ2YWwgaXMgbm90XG4gICAgICAgIC8vIGNhbmNlbGVkLiBJZiB0aGUgYWN0aW9uIGRvZXNuJ3QgcmVzY2hlZHVsZSwgb3IgcmVzY2hlZHVsZXMgd2l0aCBhXG4gICAgICAgIC8vIGRpZmZlcmVudCBkZWxheSwgdGhlIGludGVydmFsIHdpbGwgYmUgY2FuY2VsZWQgYWZ0ZXIgc2NoZWR1bGVkIGNhbGxiYWNrXG4gICAgICAgIC8vIGV4ZWN1dGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIC8vIElmIHRoaXMgYWN0aW9uIGhhcyBhbHJlYWR5IGFuIGFzeW5jIElkLCBkb24ndCByZXF1ZXN0IGEgbmV3IG9uZS5cbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuaWQgfHwgdGhpcy5yZXF1ZXN0QXN5bmNJZChzY2hlZHVsZXIsIHRoaXMuaWQsIGRlbGF5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHJldHVybiByb290XzEucm9vdC5zZXRJbnRlcnZhbChzY2hlZHVsZXIuZmx1c2guYmluZChzY2hlZHVsZXIsIHRoaXMpLCBkZWxheSk7XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIC8vIElmIHRoaXMgYWN0aW9uIGlzIHJlc2NoZWR1bGVkIHdpdGggdGhlIHNhbWUgZGVsYXkgdGltZSwgZG9uJ3QgY2xlYXIgdGhlIGludGVydmFsIGlkLlxuICAgICAgICBpZiAoZGVsYXkgIT09IG51bGwgJiYgdGhpcy5kZWxheSA9PT0gZGVsYXkgJiYgdGhpcy5wZW5kaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIGFjdGlvbidzIGRlbGF5IHRpbWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgZGVsYXksXG4gICAgICAgIC8vIG9yIHRoZSBhY3Rpb24gaGFzIGJlZW4gcmVzY2hlZHVsZWQgYmVmb3JlIGl0J3MgZXhlY3V0ZWQsIGNsZWFyIHRoZSBpbnRlcnZhbCBpZFxuICAgICAgICByZXR1cm4gcm9vdF8xLnJvb3QuY2xlYXJJbnRlcnZhbChpZCkgJiYgdW5kZWZpbmVkIHx8IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGV4ZWN1dGVzIHRoaXMgYWN0aW9uIGFuZCB0aGUgYHdvcmtgIGl0IGNvbnRhaW5zLlxuICAgICAqIEByZXR1cm4ge2FueX1cbiAgICAgKi9cbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdleGVjdXRpbmcgYSBjYW5jZWxsZWQgYWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvciA9IHRoaXMuX2V4ZWN1dGUoc3RhdGUsIGRlbGF5KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wZW5kaW5nID09PSBmYWxzZSAmJiB0aGlzLmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERlcXVldWUgaWYgdGhlIGFjdGlvbiBkaWRuJ3QgcmVzY2hlZHVsZSBpdHNlbGYuIERvbid0IGNhbGxcbiAgICAgICAgICAgIC8vIHVuc3Vic2NyaWJlKCksIGJlY2F1c2UgdGhlIGFjdGlvbiBjb3VsZCByZXNjaGVkdWxlIGxhdGVyLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICAgICAgICAvLyBgYGBcbiAgICAgICAgICAgIC8vIHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiBkb1dvcmsoY291bnRlcikge1xuICAgICAgICAgICAgLy8gICAvKiAuLi4gSSdtIGEgYnVzeSB3b3JrZXIgYmVlIC4uLiAqL1xuICAgICAgICAgICAgLy8gICB2YXIgb3JpZ2luYWxBY3Rpb24gPSB0aGlzO1xuICAgICAgICAgICAgLy8gICAvKiB3YWl0IDEwMG1zIGJlZm9yZSByZXNjaGVkdWxpbmcgdGhlIGFjdGlvbiAqL1xuICAgICAgICAgICAgLy8gICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vICAgICBvcmlnaW5hbEFjdGlvbi5zY2hlZHVsZShjb3VudGVyICsgMSk7XG4gICAgICAgICAgICAvLyAgIH0sIDEwMCk7XG4gICAgICAgICAgICAvLyB9LCAxMDAwKTtcbiAgICAgICAgICAgIC8vIGBgYFxuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQodGhpcy5zY2hlZHVsZXIsIHRoaXMuaWQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIHZhciBlcnJvcmVkID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvclZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53b3JrKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvclZhbHVlID0gISFlICYmIGUgfHwgbmV3IEVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JWYWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHNjaGVkdWxlci5hY3Rpb25zO1xuICAgICAgICB2YXIgaW5kZXggPSBhY3Rpb25zLmluZGV4T2YodGhpcyk7XG4gICAgICAgIHRoaXMud29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBudWxsO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsYXkgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jQWN0aW9uO1xufShBY3Rpb25fMS5BY3Rpb24pKTtcbmV4cG9ydHMuQXN5bmNBY3Rpb24gPSBBc3luY0FjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzeW5jQWN0aW9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3NjaGVkdWxlci9Bc3luY0FjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi9TY2hlZHVsZXInKTtcbnZhciBBc3luY1NjaGVkdWxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzeW5jU2NoZWR1bGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFzeW5jU2NoZWR1bGVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGUgU2NoZWR1bGVyIGlzIGN1cnJlbnRseSBleGVjdXRpbmcgYSBiYXRjaCBvZlxuICAgICAgICAgKiBxdWV1ZWQgYWN0aW9ucy5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW50ZXJuYWwgSUQgdXNlZCB0byB0cmFjayB0aGUgbGF0ZXN0IGFzeW5jaHJvbm91cyB0YXNrIHN1Y2ggYXMgdGhvc2VcbiAgICAgICAgICogY29taW5nIGZyb20gYHNldFRpbWVvdXRgLCBgc2V0SW50ZXJ2YWxgLCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCwgYW5kXG4gICAgICAgICAqIG90aGVycy5cbiAgICAgICAgICogQHR5cGUge2FueX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBBc3luY1NjaGVkdWxlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPSBhY3Rpb24uZXhlY3V0ZShhY3Rpb24uc3RhdGUsIGFjdGlvbi5kZWxheSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKTsgLy8gZXhoYXVzdCB0aGUgc2NoZWR1bGVyIHF1ZXVlXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgd2hpbGUgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBc3luY1NjaGVkdWxlcjtcbn0oU2NoZWR1bGVyXzEuU2NoZWR1bGVyKSk7XG5leHBvcnRzLkFzeW5jU2NoZWR1bGVyID0gQXN5bmNTY2hlZHVsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3luY1NjaGVkdWxlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9zY2hlZHVsZXIvQXN5bmNTY2hlZHVsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuLi91dGlsL2lzQXJyYXknKTtcbmZ1bmN0aW9uIGlzTnVtZXJpYyh2YWwpIHtcbiAgICAvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAobnVsbHx0cnVlfGZhbHNlfFwiXCIpXG4gICAgLy8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuICAgIC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuICAgIC8vIGFkZGluZyAxIGNvcnJlY3RzIGxvc3Mgb2YgcHJlY2lzaW9uIGZyb20gcGFyc2VGbG9hdCAoIzE1MTAwKVxuICAgIHJldHVybiAhaXNBcnJheV8xLmlzQXJyYXkodmFsKSAmJiAodmFsIC0gcGFyc2VGbG9hdCh2YWwpICsgMSkgPj0gMDtcbn1cbmV4cG9ydHMuaXNOdW1lcmljID0gaXNOdW1lcmljO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNOdW1lcmljLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvaXNOdW1lcmljLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoMTMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9tZXJnZU1hcC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSgyOSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvbWFwLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2J1bmRsZXMvcGxhdGZvcm0tYnJvd3Nlci51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoNTkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL05vdGlmaWNhdGlvbi5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg2OCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9tZXJnZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg2OSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9vZi5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg3NSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZmlyc3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoODIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9jb25jYXRBbGwuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoODMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9jb25jYXRNYXAuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoODYpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9maWx0ZXIuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoOTEpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9vYnNlcnZlT24uanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXJsXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidXJsXCJcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBTZXJ2ZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1zZXJ2ZXInO1xyXG5pbXBvcnQgeyBBcHBNb2R1bGVTaGFyZWQgfSBmcm9tICcuL2FwcC5zaGFyZWQubW9kdWxlJztcclxuaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAvYXBwLmNvbXBvbmVudCc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gICAgYm9vdHN0cmFwOiBbIEFwcENvbXBvbmVudF0sXHJcbiAgICBpbXBvcnRzOiBbXHJcbiAgICAgICAgU2VydmVyTW9kdWxlLFxyXG4gICAgICAgIEFwcE1vZHVsZVNoYXJlZFxyXG4gICAgXSxcclxuICAgIHByb3ZpZGVyczpbXHJcbiAgICBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvYXBwLnNlcnZlci5tb2R1bGUudHMiLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChDKSBNaWNyb3NvZnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG52YXIgUmVmbGVjdDtcclxuKGZ1bmN0aW9uIChSZWZsZWN0KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG4gICAgLy8gZmVhdHVyZSB0ZXN0IGZvciBTeW1ib2wgc3VwcG9ydFxyXG4gICAgdmFyIHN1cHBvcnRzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiO1xyXG4gICAgdmFyIHRvUHJpbWl0aXZlU3ltYm9sID0gc3VwcG9ydHNTeW1ib2wgJiYgdHlwZW9mIFN5bWJvbC50b1ByaW1pdGl2ZSAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbC50b1ByaW1pdGl2ZSA6IFwiQEB0b1ByaW1pdGl2ZVwiO1xyXG4gICAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gc3VwcG9ydHNTeW1ib2wgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbC5pdGVyYXRvciA6IFwiQEBpdGVyYXRvclwiO1xyXG4gICAgdmFyIEhhc2hNYXA7XHJcbiAgICAoZnVuY3Rpb24gKEhhc2hNYXApIHtcclxuICAgICAgICB2YXIgc3VwcG9ydHNDcmVhdGUgPSB0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiOyAvLyBmZWF0dXJlIHRlc3QgZm9yIE9iamVjdC5jcmVhdGUgc3VwcG9ydFxyXG4gICAgICAgIHZhciBzdXBwb3J0c1Byb3RvID0geyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheTsgLy8gZmVhdHVyZSB0ZXN0IGZvciBfX3Byb3RvX18gc3VwcG9ydFxyXG4gICAgICAgIHZhciBkb3duTGV2ZWwgPSAhc3VwcG9ydHNDcmVhdGUgJiYgIXN1cHBvcnRzUHJvdG87XHJcbiAgICAgICAgLy8gY3JlYXRlIGFuIG9iamVjdCBpbiBkaWN0aW9uYXJ5IG1vZGUgKGEuay5hLiBcInNsb3dcIiBtb2RlIGluIHY4KVxyXG4gICAgICAgIEhhc2hNYXAuY3JlYXRlID0gc3VwcG9ydHNDcmVhdGVcclxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeShPYmplY3QuY3JlYXRlKG51bGwpKTsgfVxyXG4gICAgICAgICAgICA6IHN1cHBvcnRzUHJvdG9cclxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFrZURpY3Rpb25hcnkoeyBfX3Byb3RvX186IG51bGwgfSk7IH1cclxuICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFrZURpY3Rpb25hcnkoe30pOyB9O1xyXG4gICAgICAgIEhhc2hNYXAuaGFzID0gZG93bkxldmVsXHJcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKG1hcCwga2V5KSB7IHJldHVybiBoYXNPd24uY2FsbChtYXAsIGtleSk7IH1cclxuICAgICAgICAgICAgOiBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGtleSBpbiBtYXA7IH07XHJcbiAgICAgICAgSGFzaE1hcC5nZXQgPSBkb3duTGV2ZWxcclxuICAgICAgICAgICAgPyBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGhhc093bi5jYWxsKG1hcCwga2V5KSA/IG1hcFtrZXldIDogdW5kZWZpbmVkOyB9XHJcbiAgICAgICAgICAgIDogZnVuY3Rpb24gKG1hcCwga2V5KSB7IHJldHVybiBtYXBba2V5XTsgfTtcclxuICAgIH0pKEhhc2hNYXAgfHwgKEhhc2hNYXAgPSB7fSkpO1xyXG4gICAgLy8gTG9hZCBnbG9iYWwgb3Igc2hpbSB2ZXJzaW9ucyBvZiBNYXAsIFNldCwgYW5kIFdlYWtNYXBcclxuICAgIHZhciBmdW5jdGlvblByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihGdW5jdGlvbik7XHJcbiAgICB2YXIgdXNlUG9seWZpbGwgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudltcIlJFRkxFQ1RfTUVUQURBVEFfVVNFX01BUF9QT0xZRklMTFwiXSA9PT0gXCJ0cnVlXCI7XHJcbiAgICB2YXIgX01hcCA9ICF1c2VQb2x5ZmlsbCAmJiB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUuZW50cmllcyA9PT0gXCJmdW5jdGlvblwiID8gTWFwIDogQ3JlYXRlTWFwUG9seWZpbGwoKTtcclxuICAgIHZhciBfU2V0ID0gIXVzZVBvbHlmaWxsICYmIHR5cGVvZiBTZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU2V0LnByb3RvdHlwZS5lbnRyaWVzID09PSBcImZ1bmN0aW9uXCIgPyBTZXQgOiBDcmVhdGVTZXRQb2x5ZmlsbCgpO1xyXG4gICAgdmFyIF9XZWFrTWFwID0gIXVzZVBvbHlmaWxsICYmIHR5cGVvZiBXZWFrTWFwID09PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogQ3JlYXRlV2Vha01hcFBvbHlmaWxsKCk7XHJcbiAgICAvLyBbW01ldGFkYXRhXV0gaW50ZXJuYWwgc2xvdFxyXG4gICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnktb2JqZWN0LWludGVybmFsLW1ldGhvZHMtYW5kLWludGVybmFsLXNsb3RzXHJcbiAgICB2YXIgTWV0YWRhdGEgPSBuZXcgX1dlYWtNYXAoKTtcclxuICAgIC8qKlxyXG4gICAgICAqIEFwcGxpZXMgYSBzZXQgb2YgZGVjb3JhdG9ycyB0byBhIHByb3BlcnR5IG9mIGEgdGFyZ2V0IG9iamVjdC5cclxuICAgICAgKiBAcGFyYW0gZGVjb3JhdG9ycyBBbiBhcnJheSBvZiBkZWNvcmF0b3JzLlxyXG4gICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QuXHJcbiAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSB0byBkZWNvcmF0ZS5cclxuICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciB0aGUgdGFyZ2V0IGtleS5cclxuICAgICAgKiBAcmVtYXJrcyBEZWNvcmF0b3JzIGFyZSBhcHBsaWVkIGluIHJldmVyc2Ugb3JkZXIuXHJcbiAgICAgICogQGV4YW1wbGVcclxuICAgICAgKlxyXG4gICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAqXHJcbiAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAqICAgICBFeGFtcGxlID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiLFxyXG4gICAgICAqICAgICAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIsXHJcbiAgICAgICogICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKSkpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIsXHJcbiAgICAgICogICAgICAgICBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIsXHJcbiAgICAgICogICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIikpKTtcclxuICAgICAgKlxyXG4gICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcykge1xyXG4gICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNBcnJheShkZWNvcmF0b3JzKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KGF0dHJpYnV0ZXMpICYmICFJc1VuZGVmaW5lZChhdHRyaWJ1dGVzKSAmJiAhSXNOdWxsKGF0dHJpYnV0ZXMpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICBpZiAoSXNOdWxsKGF0dHJpYnV0ZXMpKVxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRlUHJvcGVydHkoZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIUlzQXJyYXkoZGVjb3JhdG9ycykpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIGlmICghSXNDb25zdHJ1Y3Rvcih0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGVDb25zdHJ1Y3RvcihkZWNvcmF0b3JzLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFJlZmxlY3QuZGVjb3JhdGUgPSBkZWNvcmF0ZTtcclxuICAgIC8vIDQuMS4yIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpXHJcbiAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNyZWZsZWN0Lm1ldGFkYXRhXHJcbiAgICAvKipcclxuICAgICAgKiBBIGRlZmF1bHQgbWV0YWRhdGEgZGVjb3JhdG9yIGZhY3RvcnkgdGhhdCBjYW4gYmUgdXNlZCBvbiBhIGNsYXNzLCBjbGFzcyBtZW1iZXIsIG9yIHBhcmFtZXRlci5cclxuICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgVGhlIGtleSBmb3IgdGhlIG1ldGFkYXRhIGVudHJ5LlxyXG4gICAgICAqIEBwYXJhbSBtZXRhZGF0YVZhbHVlIFRoZSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGVudHJ5LlxyXG4gICAgICAqIEByZXR1cm5zIEEgZGVjb3JhdG9yIGZ1bmN0aW9uLlxyXG4gICAgICAqIEByZW1hcmtzXHJcbiAgICAgICogSWYgYG1ldGFkYXRhS2V5YCBpcyBhbHJlYWR5IGRlZmluZWQgZm9yIHRoZSB0YXJnZXQgYW5kIHRhcmdldCBrZXksIHRoZVxyXG4gICAgICAqIG1ldGFkYXRhVmFsdWUgZm9yIHRoYXQga2V5IHdpbGwgYmUgb3ZlcndyaXR0ZW4uXHJcbiAgICAgICogQGV4YW1wbGVcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAqICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxyXG4gICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvciwgVHlwZVNjcmlwdCBvbmx5KVxyXG4gICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXHJcbiAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlLCBUeXBlU2NyaXB0IG9ubHkpXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcclxuICAgICAgKiAgICAgICAgIHByb3BlcnR5O1xyXG4gICAgICAqICAgICB9XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICogICAgICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxyXG4gICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZCgpIHsgfVxyXG4gICAgICAqICAgICB9XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcclxuICAgICAgKiAgICAgICAgIG1ldGhvZCgpIHsgfVxyXG4gICAgICAqICAgICB9XHJcbiAgICAgICpcclxuICAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSAmJiAhSXNQcm9wZXJ0eUtleShwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVjb3JhdG9yO1xyXG4gICAgfVxyXG4gICAgUmVmbGVjdC5tZXRhZGF0YSA9IG1ldGFkYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgICogRGVmaW5lIGEgdW5pcXVlIG1ldGFkYXRhIGVudHJ5IG9uIHRoZSB0YXJnZXQuXHJcbiAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxyXG4gICAgICAqIEBwYXJhbSBtZXRhZGF0YVZhbHVlIEEgdmFsdWUgdGhhdCBjb250YWlucyBhdHRhY2hlZCBtZXRhZGF0YS5cclxuICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRvIGRlZmluZSBtZXRhZGF0YS5cclxuICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAqIEBleGFtcGxlXHJcbiAgICAgICpcclxuICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAqICAgICB9XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBkZWNvcmF0b3IgZmFjdG9yeSBhcyBtZXRhZGF0YS1wcm9kdWNpbmcgYW5ub3RhdGlvbi5cclxuICAgICAgKiAgICAgZnVuY3Rpb24gTXlBbm5vdGF0aW9uKG9wdGlvbnMpOiBEZWNvcmF0b3Ige1xyXG4gICAgICAqICAgICAgICAgcmV0dXJuICh0YXJnZXQsIGtleT8pID0+IFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCB0YXJnZXQsIGtleSk7XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICByZXR1cm4gT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICB9XHJcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhID0gZGVmaW5lTWV0YWRhdGE7XHJcbiAgICAvKipcclxuICAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB0YXJnZXQgb2JqZWN0IG9yIGl0cyBwcm90b3R5cGUgY2hhaW4gaGFzIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgZGVmaW5lZC5cclxuICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWV0YWRhdGEga2V5IHdhcyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgb2JqZWN0IG9yIGl0cyBwcm90b3R5cGUgY2hhaW47IG90aGVyd2lzZSwgYGZhbHNlYC5cclxuICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc01ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgcmV0dXJuIE9yZGluYXJ5SGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgfVxyXG4gICAgUmVmbGVjdC5oYXNNZXRhZGF0YSA9IGhhc01ldGFkYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgdGFyZ2V0IG9iamVjdCBoYXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBkZWZpbmVkLlxyXG4gICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cclxuICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXRhZGF0YSBrZXkgd2FzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3Q7IG90aGVyd2lzZSwgYGZhbHNlYC5cclxuICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgcmV0dXJuIE9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgfVxyXG4gICAgUmVmbGVjdC5oYXNPd25NZXRhZGF0YSA9IGhhc093bk1ldGFkYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgICogR2V0cyB0aGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbi5cclxuICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAqIEByZXR1cm5zIFRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGtleSBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cclxuICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgfVxyXG4gICAgUmVmbGVjdC5nZXRNZXRhZGF0YSA9IGdldE1ldGFkYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgICogR2V0cyB0aGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgb24gdGhlIHRhcmdldCBvYmplY3QuXHJcbiAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxyXG4gICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXHJcbiAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cclxuICAgICAgKiBAcmV0dXJucyBUaGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBtZXRhZGF0YSBrZXkgaWYgZm91bmQ7IG90aGVyd2lzZSwgYHVuZGVmaW5lZGAuXHJcbiAgICAgICogQGV4YW1wbGVcclxuICAgICAgKlxyXG4gICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAqXHJcbiAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xyXG4gICAgICAqXHJcbiAgICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgIHJldHVybiBPcmRpbmFyeUdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcclxuICAgIH1cclxuICAgIFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEgPSBnZXRPd25NZXRhZGF0YTtcclxuICAgIC8qKlxyXG4gICAgICAqIEdldHMgdGhlIG1ldGFkYXRhIGtleXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluLlxyXG4gICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXHJcbiAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cclxuICAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB1bmlxdWUgbWV0YWRhdGEga2V5cy5cclxuICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xyXG4gICAgICAqXHJcbiAgICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgIHJldHVybiBPcmRpbmFyeU1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KTtcclxuICAgIH1cclxuICAgIFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzID0gZ2V0TWV0YWRhdGFLZXlzO1xyXG4gICAgLyoqXHJcbiAgICAgICogR2V0cyB0aGUgdW5pcXVlIG1ldGFkYXRhIGtleXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdC5cclxuICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdW5pcXVlIG1ldGFkYXRhIGtleXMuXHJcbiAgICAgICogQGV4YW1wbGVcclxuICAgICAgKlxyXG4gICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAqXHJcbiAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgKlxyXG4gICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICByZXR1cm4gT3JkaW5hcnlPd25NZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICB9XHJcbiAgICBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyA9IGdldE93bk1ldGFkYXRhS2V5cztcclxuICAgIC8qKlxyXG4gICAgICAqIERlbGV0ZXMgdGhlIG1ldGFkYXRhIGVudHJ5IGZyb20gdGhlIHRhcmdldCBvYmplY3Qgd2l0aCB0aGUgcHJvdmlkZWQga2V5LlxyXG4gICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cclxuICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXRhZGF0YSBlbnRyeSB3YXMgZm91bmQgYW5kIGRlbGV0ZWQ7IG90aGVyd2lzZSwgZmFsc2UuXHJcbiAgICAgICogQGV4YW1wbGVcclxuICAgICAgKlxyXG4gICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAqXHJcbiAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xyXG4gICAgICAqXHJcbiAgICAgICovXHJcbiAgICBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAodGFyZ2V0LCBwcm9wZXJ0eUtleSwgLypDcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmICghbWV0YWRhdGFNYXAuZGVsZXRlKG1ldGFkYXRhS2V5KSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChtZXRhZGF0YU1hcC5zaXplID4gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgdmFyIHRhcmdldE1ldGFkYXRhID0gTWV0YWRhdGEuZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgdGFyZ2V0TWV0YWRhdGEuZGVsZXRlKHByb3BlcnR5S2V5KTtcclxuICAgICAgICBpZiAodGFyZ2V0TWV0YWRhdGEuc2l6ZSA+IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIE1ldGFkYXRhLmRlbGV0ZSh0YXJnZXQpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgUmVmbGVjdC5kZWxldGVNZXRhZGF0YSA9IGRlbGV0ZU1ldGFkYXRhO1xyXG4gICAgZnVuY3Rpb24gRGVjb3JhdGVDb25zdHJ1Y3RvcihkZWNvcmF0b3JzLCB0YXJnZXQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICB2YXIgZGVjb3JhdG9yID0gZGVjb3JhdG9yc1tpXTtcclxuICAgICAgICAgICAgdmFyIGRlY29yYXRlZCA9IGRlY29yYXRvcih0YXJnZXQpO1xyXG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKGRlY29yYXRlZCkgJiYgIUlzTnVsbChkZWNvcmF0ZWQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzQ29uc3RydWN0b3IoZGVjb3JhdGVkKSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBkZWNvcmF0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIERlY29yYXRlUHJvcGVydHkoZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcikge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBkZWNvcmF0b3JzW2ldO1xyXG4gICAgICAgICAgICB2YXIgZGVjb3JhdGVkID0gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpO1xyXG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKGRlY29yYXRlZCkgJiYgIUlzTnVsbChkZWNvcmF0ZWQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KGRlY29yYXRlZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IGRlY29yYXRlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgQ3JlYXRlKSB7XHJcbiAgICAgICAgdmFyIHRhcmdldE1ldGFkYXRhID0gTWV0YWRhdGEuZ2V0KE8pO1xyXG4gICAgICAgIGlmIChJc1VuZGVmaW5lZCh0YXJnZXRNZXRhZGF0YSkpIHtcclxuICAgICAgICAgICAgaWYgKCFDcmVhdGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0YXJnZXRNZXRhZGF0YSA9IG5ldyBfTWFwKCk7XHJcbiAgICAgICAgICAgIE1ldGFkYXRhLnNldChPLCB0YXJnZXRNZXRhZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IHRhcmdldE1ldGFkYXRhLmdldChQKTtcclxuICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKSB7XHJcbiAgICAgICAgICAgIGlmICghQ3JlYXRlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgbWV0YWRhdGFNYXAgPSBuZXcgX01hcCgpO1xyXG4gICAgICAgICAgICB0YXJnZXRNZXRhZGF0YS5zZXQoUCwgbWV0YWRhdGFNYXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWV0YWRhdGFNYXA7XHJcbiAgICB9XHJcbiAgICAvLyAzLjEuMS4xIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXHJcbiAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWhhc21ldGFkYXRhXHJcbiAgICBmdW5jdGlvbiBPcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSB7XHJcbiAgICAgICAgdmFyIGhhc093biA9IE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xyXG4gICAgICAgIGlmIChoYXNPd24pXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pO1xyXG4gICAgICAgIGlmICghSXNOdWxsKHBhcmVudCkpXHJcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIDMuMS4yLjEgT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcclxuICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5aGFzb3dubWV0YWRhdGFcclxuICAgIGZ1bmN0aW9uIE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcclxuICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gVG9Cb29sZWFuKG1ldGFkYXRhTWFwLmhhcyhNZXRhZGF0YUtleSkpO1xyXG4gICAgfVxyXG4gICAgLy8gMy4xLjMuMSBPcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxyXG4gICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnlnZXRtZXRhZGF0YVxyXG4gICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xyXG4gICAgICAgIHZhciBoYXNPd24gPSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcclxuICAgICAgICBpZiAoaGFzT3duKVxyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTyk7XHJcbiAgICAgICAgaWYgKCFJc051bGwocGFyZW50KSlcclxuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8vIDMuMS40LjEgT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcclxuICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5Z2V0b3dubWV0YWRhdGFcclxuICAgIGZ1bmN0aW9uIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcclxuICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XHJcbiAgICB9XHJcbiAgICAvLyAzLjEuNS4xIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApXHJcbiAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWRlZmluZW93bm1ldGFkYXRhXHJcbiAgICBmdW5jdGlvbiBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKSB7XHJcbiAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKkNyZWF0ZSovIHRydWUpO1xyXG4gICAgICAgIG1ldGFkYXRhTWFwLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvLyAzLjEuNi4xIE9yZGluYXJ5TWV0YWRhdGFLZXlzKE8sIFApXHJcbiAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeW1ldGFkYXRha2V5c1xyXG4gICAgZnVuY3Rpb24gT3JkaW5hcnlNZXRhZGF0YUtleXMoTywgUCkge1xyXG4gICAgICAgIHZhciBvd25LZXlzID0gT3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUCk7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTyk7XHJcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIG93bktleXM7XHJcbiAgICAgICAgdmFyIHBhcmVudEtleXMgPSBPcmRpbmFyeU1ldGFkYXRhS2V5cyhwYXJlbnQsIFApO1xyXG4gICAgICAgIGlmIChwYXJlbnRLZXlzLmxlbmd0aCA8PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gb3duS2V5cztcclxuICAgICAgICBpZiAob3duS2V5cy5sZW5ndGggPD0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudEtleXM7XHJcbiAgICAgICAgdmFyIHNldCA9IG5ldyBfU2V0KCk7XHJcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG93bktleXNfMSA9IG93bktleXM7IF9pIDwgb3duS2V5c18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gb3duS2V5c18xW19pXTtcclxuICAgICAgICAgICAgdmFyIGhhc0tleSA9IHNldC5oYXMoa2V5KTtcclxuICAgICAgICAgICAgaWYgKCFoYXNLZXkpIHtcclxuICAgICAgICAgICAgICAgIHNldC5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgcGFyZW50S2V5c18xID0gcGFyZW50S2V5czsgX2EgPCBwYXJlbnRLZXlzXzEubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBwYXJlbnRLZXlzXzFbX2FdO1xyXG4gICAgICAgICAgICB2YXIgaGFzS2V5ID0gc2V0LmhhcyhrZXkpO1xyXG4gICAgICAgICAgICBpZiAoIWhhc0tleSkge1xyXG4gICAgICAgICAgICAgICAgc2V0LmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICB9XHJcbiAgICAvLyAzLjEuNy4xIE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApXHJcbiAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeW93bm1ldGFkYXRha2V5c1xyXG4gICAgZnVuY3Rpb24gT3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUCkge1xyXG4gICAgICAgIHZhciBrZXlzID0gW107XHJcbiAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKkNyZWF0ZSovIGZhbHNlKTtcclxuICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxyXG4gICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICB2YXIga2V5c09iaiA9IG1ldGFkYXRhTWFwLmtleXMoKTtcclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBHZXRJdGVyYXRvcihrZXlzT2JqKTtcclxuICAgICAgICB2YXIgayA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgdmFyIG5leHQgPSBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpO1xyXG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcclxuICAgICAgICAgICAgICAgIGtleXMubGVuZ3RoID0gaztcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuZXh0VmFsdWUgPSBJdGVyYXRvclZhbHVlKG5leHQpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAga2V5c1trXSA9IG5leHRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaysrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIDYgRUNNQVNjcmlwdCBEYXRhIFR5cDBlcyBhbmQgVmFsdWVzXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWRhdGEtdHlwZXMtYW5kLXZhbHVlc1xyXG4gICAgZnVuY3Rpb24gVHlwZSh4KSB7XHJcbiAgICAgICAgaWYgKHggPT09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiAxIC8qIE51bGwgKi87XHJcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgeCkge1xyXG4gICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6IHJldHVybiAwIC8qIFVuZGVmaW5lZCAqLztcclxuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjogcmV0dXJuIDIgLyogQm9vbGVhbiAqLztcclxuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiByZXR1cm4gMyAvKiBTdHJpbmcgKi87XHJcbiAgICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjogcmV0dXJuIDQgLyogU3ltYm9sICovO1xyXG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6IHJldHVybiA1IC8qIE51bWJlciAqLztcclxuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiByZXR1cm4geCA9PT0gbnVsbCA/IDEgLyogTnVsbCAqLyA6IDYgLyogT2JqZWN0ICovO1xyXG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gNiAvKiBPYmplY3QgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gNi4xLjEgVGhlIFVuZGVmaW5lZCBUeXBlXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzLXVuZGVmaW5lZC10eXBlXHJcbiAgICBmdW5jdGlvbiBJc1VuZGVmaW5lZCh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHggPT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8vIDYuMS4yIFRoZSBOdWxsIFR5cGVcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMtbnVsbC10eXBlXHJcbiAgICBmdW5jdGlvbiBJc051bGwoeCkge1xyXG4gICAgICAgIHJldHVybiB4ID09PSBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gNi4xLjUgVGhlIFN5bWJvbCBUeXBlXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzLXN5bWJvbC10eXBlXHJcbiAgICBmdW5jdGlvbiBJc1N5bWJvbCh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN5bWJvbFwiO1xyXG4gICAgfVxyXG4gICAgLy8gNi4xLjcgVGhlIE9iamVjdCBUeXBlXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QtdHlwZVxyXG4gICAgZnVuY3Rpb24gSXNPYmplY3QoeCkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiA/IHggIT09IG51bGwgOiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiO1xyXG4gICAgfVxyXG4gICAgLy8gNy4xIFR5cGUgQ29udmVyc2lvblxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHlwZS1jb252ZXJzaW9uXHJcbiAgICAvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXHJcbiAgICBmdW5jdGlvbiBUb1ByaW1pdGl2ZShpbnB1dCwgUHJlZmVycmVkVHlwZSkge1xyXG4gICAgICAgIHN3aXRjaCAoVHlwZShpbnB1dCkpIHtcclxuICAgICAgICAgICAgY2FzZSAwIC8qIFVuZGVmaW5lZCAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogTnVsbCAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICBjYXNlIDIgLyogQm9vbGVhbiAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICBjYXNlIDMgLyogU3RyaW5nICovOiByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgICAgIGNhc2UgNCAvKiBTeW1ib2wgKi86IHJldHVybiBpbnB1dDtcclxuICAgICAgICAgICAgY2FzZSA1IC8qIE51bWJlciAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaGludCA9IFByZWZlcnJlZFR5cGUgPT09IDMgLyogU3RyaW5nICovID8gXCJzdHJpbmdcIiA6IFByZWZlcnJlZFR5cGUgPT09IDUgLyogTnVtYmVyICovID8gXCJudW1iZXJcIiA6IFwiZGVmYXVsdFwiO1xyXG4gICAgICAgIHZhciBleG90aWNUb1ByaW0gPSBHZXRNZXRob2QoaW5wdXQsIHRvUHJpbWl0aXZlU3ltYm9sKTtcclxuICAgICAgICBpZiAoZXhvdGljVG9QcmltICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGV4b3RpY1RvUHJpbS5jYWxsKGlucHV0LCBoaW50KTtcclxuICAgICAgICAgICAgaWYgKElzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBoaW50ID09PSBcImRlZmF1bHRcIiA/IFwibnVtYmVyXCIgOiBoaW50KTtcclxuICAgIH1cclxuICAgIC8vIDcuMS4xLjEgT3JkaW5hcnlUb1ByaW1pdGl2ZShPLCBoaW50KVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxyXG4gICAgZnVuY3Rpb24gT3JkaW5hcnlUb1ByaW1pdGl2ZShPLCBoaW50KSB7XHJcbiAgICAgICAgaWYgKGhpbnQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdmFyIHRvU3RyaW5nXzEgPSBPLnRvU3RyaW5nO1xyXG4gICAgICAgICAgICBpZiAoSXNDYWxsYWJsZSh0b1N0cmluZ18xKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRvU3RyaW5nXzEuY2FsbChPKTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QocmVzdWx0KSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZU9mID0gTy52YWx1ZU9mO1xyXG4gICAgICAgICAgICBpZiAoSXNDYWxsYWJsZSh2YWx1ZU9mKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlT2YuY2FsbChPKTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QocmVzdWx0KSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVPZiA9IE8udmFsdWVPZjtcclxuICAgICAgICAgICAgaWYgKElzQ2FsbGFibGUodmFsdWVPZikpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB2YWx1ZU9mLmNhbGwoTyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdG9TdHJpbmdfMiA9IE8udG9TdHJpbmc7XHJcbiAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHRvU3RyaW5nXzIpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdG9TdHJpbmdfMi5jYWxsKE8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgfVxyXG4gICAgLy8gNy4xLjIgVG9Cb29sZWFuKGFyZ3VtZW50KVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLzIwMTYvI3NlYy10b2Jvb2xlYW5cclxuICAgIGZ1bmN0aW9uIFRvQm9vbGVhbihhcmd1bWVudCkge1xyXG4gICAgICAgIHJldHVybiAhIWFyZ3VtZW50O1xyXG4gICAgfVxyXG4gICAgLy8gNy4xLjEyIFRvU3RyaW5nKGFyZ3VtZW50KVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9zdHJpbmdcclxuICAgIGZ1bmN0aW9uIFRvU3RyaW5nKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBhcmd1bWVudDtcclxuICAgIH1cclxuICAgIC8vIDcuMS4xNCBUb1Byb3BlcnR5S2V5KGFyZ3VtZW50KVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxyXG4gICAgZnVuY3Rpb24gVG9Qcm9wZXJ0eUtleShhcmd1bWVudCkge1xyXG4gICAgICAgIHZhciBrZXkgPSBUb1ByaW1pdGl2ZShhcmd1bWVudCwgMyAvKiBTdHJpbmcgKi8pO1xyXG4gICAgICAgIGlmIChJc1N5bWJvbChrZXkpKVxyXG4gICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgIHJldHVybiBUb1N0cmluZyhrZXkpO1xyXG4gICAgfVxyXG4gICAgLy8gNy4yIFRlc3RpbmcgYW5kIENvbXBhcmlzb24gT3BlcmF0aW9uc1xyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGVzdGluZy1hbmQtY29tcGFyaXNvbi1vcGVyYXRpb25zXHJcbiAgICAvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNhcnJheVxyXG4gICAgZnVuY3Rpb24gSXNBcnJheShhcmd1bWVudCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5XHJcbiAgICAgICAgICAgID8gQXJyYXkuaXNBcnJheShhcmd1bWVudClcclxuICAgICAgICAgICAgOiBhcmd1bWVudCBpbnN0YW5jZW9mIE9iamVjdFxyXG4gICAgICAgICAgICAgICAgPyBhcmd1bWVudCBpbnN0YW5jZW9mIEFycmF5XHJcbiAgICAgICAgICAgICAgICA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcclxuICAgIH1cclxuICAgIC8vIDcuMi4zIElzQ2FsbGFibGUoYXJndW1lbnQpXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXHJcbiAgICBmdW5jdGlvbiBJc0NhbGxhYmxlKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBhbiBhcHByb3hpbWF0aW9uIGFzIHdlIGNhbm5vdCBjaGVjayBmb3IgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kLlxyXG4gICAgICAgIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT09IFwiZnVuY3Rpb25cIjtcclxuICAgIH1cclxuICAgIC8vIDcuMi40IElzQ29uc3RydWN0b3IoYXJndW1lbnQpXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXHJcbiAgICBmdW5jdGlvbiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBhbiBhcHByb3hpbWF0aW9uIGFzIHdlIGNhbm5vdCBjaGVjayBmb3IgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2QuXHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PT0gXCJmdW5jdGlvblwiO1xyXG4gICAgfVxyXG4gICAgLy8gNy4yLjcgSXNQcm9wZXJ0eUtleShhcmd1bWVudClcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzcHJvcGVydHlrZXlcclxuICAgIGZ1bmN0aW9uIElzUHJvcGVydHlLZXkoYXJndW1lbnQpIHtcclxuICAgICAgICBzd2l0Y2ggKFR5cGUoYXJndW1lbnQpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTdHJpbmcgKi86IHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBjYXNlIDQgLyogU3ltYm9sICovOiByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIDcuMyBPcGVyYXRpb25zIG9uIE9iamVjdHNcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9wZXJhdGlvbnMtb24tb2JqZWN0c1xyXG4gICAgLy8gNy4zLjkgR2V0TWV0aG9kKFYsIFApXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXRtZXRob2RcclxuICAgIGZ1bmN0aW9uIEdldE1ldGhvZChWLCBQKSB7XHJcbiAgICAgICAgdmFyIGZ1bmMgPSBWW1BdO1xyXG4gICAgICAgIGlmIChmdW5jID09PSB1bmRlZmluZWQgfHwgZnVuYyA9PT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoIUlzQ2FsbGFibGUoZnVuYykpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICByZXR1cm4gZnVuYztcclxuICAgIH1cclxuICAgIC8vIDcuNCBPcGVyYXRpb25zIG9uIEl0ZXJhdG9yIE9iamVjdHNcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9wZXJhdGlvbnMtb24taXRlcmF0b3Itb2JqZWN0c1xyXG4gICAgZnVuY3Rpb24gR2V0SXRlcmF0b3Iob2JqKSB7XHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IEdldE1ldGhvZChvYmosIGl0ZXJhdG9yU3ltYm9sKTtcclxuICAgICAgICBpZiAoIUlzQ2FsbGFibGUobWV0aG9kKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBmcm9tIENhbGxcclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBtZXRob2QuY2FsbChvYmopO1xyXG4gICAgICAgIGlmICghSXNPYmplY3QoaXRlcmF0b3IpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xyXG4gICAgfVxyXG4gICAgLy8gNy40LjQgSXRlcmF0b3JWYWx1ZShpdGVyUmVzdWx0KVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLzIwMTYvI3NlYy1pdGVyYXRvcnZhbHVlXHJcbiAgICBmdW5jdGlvbiBJdGVyYXRvclZhbHVlKGl0ZXJSZXN1bHQpIHtcclxuICAgICAgICByZXR1cm4gaXRlclJlc3VsdC52YWx1ZTtcclxuICAgIH1cclxuICAgIC8vIDcuNC41IEl0ZXJhdG9yU3RlcChpdGVyYXRvcilcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yc3RlcFxyXG4gICAgZnVuY3Rpb24gSXRlcmF0b3JTdGVwKGl0ZXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyBmYWxzZSA6IHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pdGVyYXRvcmNsb3NlXHJcbiAgICBmdW5jdGlvbiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIGYgPSBpdGVyYXRvcltcInJldHVyblwiXTtcclxuICAgICAgICBpZiAoZilcclxuICAgICAgICAgICAgZi5jYWxsKGl0ZXJhdG9yKTtcclxuICAgIH1cclxuICAgIC8vIDkuMSBPcmRpbmFyeSBPYmplY3QgSW50ZXJuYWwgTWV0aG9kcyBhbmQgSW50ZXJuYWwgU2xvdHNcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9yZGluYXJ5LW9iamVjdC1pbnRlcm5hbC1tZXRob2RzLWFuZC1pbnRlcm5hbC1zbG90c1xyXG4gICAgLy8gOS4xLjEuMSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vcmRpbmFyeWdldHByb3RvdHlwZW9mXHJcbiAgICBmdW5jdGlvbiBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pIHtcclxuICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBPICE9PSBcImZ1bmN0aW9uXCIgfHwgTyA9PT0gZnVuY3Rpb25Qcm90b3R5cGUpXHJcbiAgICAgICAgICAgIHJldHVybiBwcm90bztcclxuICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3Qgc2V0IF9fcHJvdG9fXyBpbiBFUzUsIGFzIGl0J3Mgbm9uLXN0YW5kYXJkLlxyXG4gICAgICAgIC8vIFRyeSB0byBkZXRlcm1pbmUgdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IuIENvbXBhdGlibGUgaW1wbGVtZW50YXRpb25zXHJcbiAgICAgICAgLy8gbXVzdCBlaXRoZXIgc2V0IF9fcHJvdG9fXyBvbiBhIHN1YmNsYXNzIGNvbnN0cnVjdG9yIHRvIHRoZSBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yLFxyXG4gICAgICAgIC8vIG9yIGVuc3VyZSBlYWNoIGNsYXNzIGhhcyBhIHZhbGlkIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgb24gaXRzIHByb3RvdHlwZSB0aGF0XHJcbiAgICAgICAgLy8gcG9pbnRzIGJhY2sgdG8gdGhlIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgIC8vIElmIHRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIEZ1bmN0aW9uLltbUHJvdG90eXBlXV0sIHRoZW4gdGhpcyBpcyBkZWZpbmF0ZWx5IGluaGVyaXRlZC5cclxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZW4gaW4gRVM2IG9yIHdoZW4gdXNpbmcgX19wcm90b19fIGluIGEgY29tcGF0aWJsZSBicm93c2VyLlxyXG4gICAgICAgIGlmIChwcm90byAhPT0gZnVuY3Rpb25Qcm90b3R5cGUpXHJcbiAgICAgICAgICAgIHJldHVybiBwcm90bztcclxuICAgICAgICAvLyBJZiB0aGUgc3VwZXIgcHJvdG90eXBlIGlzIE9iamVjdC5wcm90b3R5cGUsIG51bGwsIG9yIHVuZGVmaW5lZCwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cclxuICAgICAgICB2YXIgcHJvdG90eXBlID0gTy5wcm90b3R5cGU7XHJcbiAgICAgICAgdmFyIHByb3RvdHlwZVByb3RvID0gcHJvdG90eXBlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpO1xyXG4gICAgICAgIGlmIChwcm90b3R5cGVQcm90byA9PSBudWxsIHx8IHByb3RvdHlwZVByb3RvID09PSBPYmplY3QucHJvdG90eXBlKVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvdG87XHJcbiAgICAgICAgLy8gSWYgdGhlIGNvbnN0cnVjdG9yIHdhcyBub3QgYSBmdW5jdGlvbiwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cclxuICAgICAgICB2YXIgY29uc3RydWN0b3IgPSBwcm90b3R5cGVQcm90by5jb25zdHJ1Y3RvcjtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbnN0cnVjdG9yICE9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIHJldHVybiBwcm90bztcclxuICAgICAgICAvLyBJZiB3ZSBoYXZlIHNvbWUga2luZCBvZiBzZWxmLXJlZmVyZW5jZSwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cclxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IE8pXHJcbiAgICAgICAgICAgIHJldHVybiBwcm90bztcclxuICAgICAgICAvLyB3ZSBoYXZlIGEgcHJldHR5IGdvb2QgZ3Vlc3MgYXQgdGhlIGhlcml0YWdlLlxyXG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcclxuICAgIH1cclxuICAgIC8vIG5haXZlIE1hcCBzaGltXHJcbiAgICBmdW5jdGlvbiBDcmVhdGVNYXBQb2x5ZmlsbCgpIHtcclxuICAgICAgICB2YXIgY2FjaGVTZW50aW5lbCA9IHt9O1xyXG4gICAgICAgIHZhciBhcnJheVNlbnRpbmVsID0gW107XHJcbiAgICAgICAgdmFyIE1hcEl0ZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gTWFwSXRlcmF0b3Ioa2V5cywgdmFsdWVzLCBzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGtleXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZVtcIkBAaXRlcmF0b3JcIl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xyXG4gICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxuICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9pbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fc2VsZWN0b3IodGhpcy5fa2V5c1tpbmRleF0sIHRoaXMuX3ZhbHVlc1tpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCArIDEgPj0gdGhpcy5fa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGFycmF5U2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IGFycmF5U2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUudGhyb3cgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gYXJyYXlTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5yZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gYXJyYXlTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBNYXBJdGVyYXRvcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBNYXAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5ID0gY2FjaGVTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSAtMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fa2V5cy5sZW5ndGg7IH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHRoaXMuX2ZpbmQoa2V5LCAvKmluc2VydCovIGZhbHNlKSA+PSAwOyB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmQoa2V5LCAvKmluc2VydCovIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA+PSAwID8gdGhpcy5fdmFsdWVzW2luZGV4XSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5fa2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ICsgMTsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzW2kgLSAxXSA9IHRoaXMuX2tleXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpIC0gMV0gPSB0aGlzLl92YWx1ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMubGVuZ3RoLS07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IHRoaXMuX2NhY2hlS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5ID0gY2FjaGVTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IC0yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tleXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IC0yO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRLZXkpOyB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMsIGdldFZhbHVlKTsgfTtcclxuICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcywgZ2V0RW50cnkpOyB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZW50cmllcygpOyB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZW50cmllcygpOyB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLl9maW5kID0gZnVuY3Rpb24gKGtleSwgaW5zZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVLZXkgIT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSB0aGlzLl9rZXlzLmluZGV4T2YodGhpcy5fY2FjaGVLZXkgPSBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlSW5kZXggPCAwICYmIGluc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSB0aGlzLl9rZXlzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlSW5kZXg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBNYXA7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBmdW5jdGlvbiBnZXRLZXkoa2V5LCBfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKF8sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0RW50cnkoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG5haXZlIFNldCBzaGltXHJcbiAgICBmdW5jdGlvbiBDcmVhdGVTZXRQb2x5ZmlsbCgpIHtcclxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU2V0KCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwID0gbmV3IF9NYXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0LnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFwLnNpemU7IH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5fbWFwLmhhcyh2YWx1ZSk7IH07XHJcbiAgICAgICAgICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLl9tYXAuc2V0KHZhbHVlLCB2YWx1ZSksIHRoaXM7IH07XHJcbiAgICAgICAgICAgIFNldC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLl9tYXAuZGVsZXRlKHZhbHVlKTsgfTtcclxuICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fbWFwLmNsZWFyKCk7IH07XHJcbiAgICAgICAgICAgIFNldC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcC5rZXlzKCk7IH07XHJcbiAgICAgICAgICAgIFNldC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFwLnZhbHVlcygpOyB9O1xyXG4gICAgICAgICAgICBTZXQucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAuZW50cmllcygpOyB9O1xyXG4gICAgICAgICAgICBTZXQucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5cygpOyB9O1xyXG4gICAgICAgICAgICBTZXQucHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5cygpOyB9O1xyXG4gICAgICAgICAgICByZXR1cm4gU2V0O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICB9XHJcbiAgICAvLyBuYWl2ZSBXZWFrTWFwIHNoaW1cclxuICAgIGZ1bmN0aW9uIENyZWF0ZVdlYWtNYXBQb2x5ZmlsbCgpIHtcclxuICAgICAgICB2YXIgVVVJRF9TSVpFID0gMTY7XHJcbiAgICAgICAgdmFyIGtleXMgPSBIYXNoTWFwLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciByb290S2V5ID0gQ3JlYXRlVW5pcXVlS2V5KCk7XHJcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXkgPSBDcmVhdGVVbmlxdWVLZXkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIC8qY3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBIYXNoTWFwLmhhcyh0YWJsZSwgdGhpcy5fa2V5KSA6IGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIC8qY3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBIYXNoTWFwLmdldCh0YWJsZSwgdGhpcy5fa2V5KSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRhYmxlW3RoaXMuX2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIC8qY3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBkZWxldGUgdGFibGVbdGhpcy5fa2V5XSA6IGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IG5vdCBhIHJlYWwgY2xlYXIsIGp1c3QgbWFrZXMgdGhlIHByZXZpb3VzIGRhdGEgdW5yZWFjaGFibGVcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tleSA9IENyZWF0ZVVuaXF1ZUtleSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gV2Vha01hcDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGZ1bmN0aW9uIENyZWF0ZVVuaXF1ZUtleSgpIHtcclxuICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgZG9cclxuICAgICAgICAgICAgICAgIGtleSA9IFwiQEBXZWFrTWFwQEBcIiArIENyZWF0ZVVVSUQoKTtcclxuICAgICAgICAgICAgd2hpbGUgKEhhc2hNYXAuaGFzKGtleXMsIGtleSkpO1xyXG4gICAgICAgICAgICBrZXlzW2tleV0gPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIGNyZWF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoIWhhc093bi5jYWxsKHRhcmdldCwgcm9vdEtleSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY3JlYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCByb290S2V5LCB7IHZhbHVlOiBIYXNoTWFwLmNyZWF0ZSgpIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcm9vdEtleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIEZpbGxSYW5kb21CeXRlcyhidWZmZXIsIHNpemUpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpXHJcbiAgICAgICAgICAgICAgICBidWZmZXJbaV0gPSBNYXRoLnJhbmRvbSgpICogMHhmZiB8IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIEdlblJhbmRvbUJ5dGVzKHNpemUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHNpemUpKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbXNDcnlwdG8gIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRmlsbFJhbmRvbUJ5dGVzKG5ldyBVaW50OEFycmF5KHNpemUpLCBzaXplKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gRmlsbFJhbmRvbUJ5dGVzKG5ldyBBcnJheShzaXplKSwgc2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIENyZWF0ZVVVSUQoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gR2VuUmFuZG9tQnl0ZXMoVVVJRF9TSVpFKTtcclxuICAgICAgICAgICAgLy8gbWFyayBhcyByYW5kb20gLSBSRkMgNDEyMiDCpyA0LjRcclxuICAgICAgICAgICAgZGF0YVs2XSA9IGRhdGFbNl0gJiAweDRmIHwgMHg0MDtcclxuICAgICAgICAgICAgZGF0YVs4XSA9IGRhdGFbOF0gJiAweGJmIHwgMHg4MDtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IFVVSURfU0laRTsgKytvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBieXRlID0gZGF0YVtvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gNCB8fCBvZmZzZXQgPT09IDYgfHwgb2Zmc2V0ID09PSA4KVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIi1cIjtcclxuICAgICAgICAgICAgICAgIGlmIChieXRlIDwgMTYpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiMFwiO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGJ5dGUudG9TdHJpbmcoMTYpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB1c2VzIGEgaGV1cmlzdGljIHVzZWQgYnkgdjggYW5kIGNoYWtyYSB0byBmb3JjZSBhbiBvYmplY3QgaW50byBkaWN0aW9uYXJ5IG1vZGUuXHJcbiAgICBmdW5jdGlvbiBNYWtlRGljdGlvbmFyeShvYmopIHtcclxuICAgICAgICBvYmouX18gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZGVsZXRlIG9iai5fXztcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgLy8gcGF0Y2ggZ2xvYmFsIFJlZmxlY3RcclxuICAgIChmdW5jdGlvbiAoX19nbG9iYWwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIF9fZ2xvYmFsLlJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgaWYgKF9fZ2xvYmFsLlJlZmxlY3QgIT09IFJlZmxlY3QpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gUmVmbGVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChSZWZsZWN0LCBwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2dsb2JhbC5SZWZsZWN0W3BdID0gUmVmbGVjdFtwXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9fZ2xvYmFsLlJlZmxlY3QgPSBSZWZsZWN0O1xyXG4gICAgICAgIH1cclxuICAgIH0pKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOlxyXG4gICAgICAgIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6XHJcbiAgICAgICAgICAgIEZ1bmN0aW9uKFwicmV0dXJuIHRoaXM7XCIpKCkpO1xyXG59KShSZWZsZWN0IHx8IChSZWZsZWN0ID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVmbGVjdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVmbGVjdC1tZXRhZGF0YS9SZWZsZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGZpcnN0XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9maXJzdCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmZpcnN0ID0gZmlyc3RfMS5maXJzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpcnN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9maXJzdC5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDQ0KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYXNwbmV0LXByZXJlbmRlcmluZy9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg1MCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3pvbmUuanMvZGlzdC96b25lLW5vZGUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoNDApO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9mb3Jtcy9idW5kbGVzL2Zvcm1zLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBVSU1vZHVsZSB9IGZyb20gJ0B1aS91aS5tb2R1bGUnO1xyXG5pbXBvcnQgeyBEaXJlY3RpdmVNb2R1bGUgfSBmcm9tICdAZGlyZWN0aXZlcy9kaXJlY3RpdmUubW9kdWxlJztcclxuaW1wb3J0IHsgR3VhcmRNb2R1bGUgfSBmcm9tICdAZ3VhcmRzL2d1YXJkLm1vZHVsZSc7XHJcbmltcG9ydCB7IFNlcnZpY2VNb2R1bGUgfSBmcm9tICdAc2VydmljZXMvc2VydmljZS5tb2R1bGUnO1xyXG5pbXBvcnQgeyBQaXBlTW9kdWxlIH0gZnJvbSAnQHNoYXJlZC9waXBlcy9waXBlLm1vZHVsZSc7XHJcblxyXG5cclxuQE5nTW9kdWxlKHtcclxuICAgIGltcG9ydHM6IFtVSU1vZHVsZSwgRGlyZWN0aXZlTW9kdWxlLCBHdWFyZE1vZHVsZSwgUGlwZU1vZHVsZV0sXHJcbiAgICBleHBvcnRzOiBbRGlyZWN0aXZlTW9kdWxlLCBVSU1vZHVsZSwgR3VhcmRNb2R1bGUsIFBpcGVNb2R1bGVdLFxyXG4gICAgZGVjbGFyYXRpb25zOiBbXSxcclxuICAgIHByb3ZpZGVyczogW10sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTaGFyZWRNb2R1bGUgeyB9XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3NoYXJlZC5tb2R1bGUudHMiLCJcclxuXHJcbmltcG9ydCB7IEluamVjdGFibGUsIEV2ZW50RW1pdHRlciB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XHJcbmltcG9ydCB7IEp3dEhlbHBlciB9IGZyb20gXCJhbmd1bGFyMi1qd3QvYW5ndWxhcjItand0XCI7XHJcbmltcG9ydCB7IFVybFZhcmlhYmxlIH0gZnJvbSBcIkBzaGFyZWQvX3ZhcmlhYmxlc1wiO1xyXG5pbXBvcnQgeyBDb21tb25IdHRwU2VydmljZSB9IGZyb20gXCJAc2VydmljZXMvYmFja2VuZC9jb21tb24taHR0cC5zZXJ2aWNlXCI7XHJcbmltcG9ydCB7IEhlYWRlcnMgfSBmcm9tICdAYW5ndWxhci9odHRwJztcclxuaW1wb3J0IHsgd2luZG93IH0gZnJvbSBcInJ4anMvb3BlcmF0b3JzL3dpbmRvd1wiO1xyXG5pbXBvcnQgeyBBbGVydFNlcnZpY2UgfSBmcm9tIFwiQHNlcnZpY2VzL2Zyb250ZW5kL2FsZXJ0LnNlcnZpY2VcIjtcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEF1dGhTZXJ2aWNlIHtcclxuICAgIGxvZ2luJDogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBodHRwQ2xpZW50OiBDb21tb25IdHRwU2VydmljZTxhbnk+LCBwcml2YXRlIHRvYXN0ZXI6IEFsZXJ0U2VydmljZSkgeyB9XHJcbiAgICBjcmVhdGVIZWFkZXIoKTogSGVhZGVycyB7XHJcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XHJcbiAgICAgICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xyXG4gICAgICAgIC8vIC5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xyXG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2lnblVwKHVzZXI6IGFueSwgaXNDb21wYW55OiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgICAgICBsZXQgYm9keSA9IHtcclxuICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXIudXNlcm5hbWUsXHJcbiAgICAgICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxyXG4gICAgICAgICAgICBwYXNzd29yZDogdXNlci5wYXNzd29yZCxcclxuICAgICAgICAgICAgY29tcGFueU5hbWU6IHVzZXIuY29tcGFueU5hbWUsXHJcbiAgICAgICAgICAgIGNvbXBhbnlXZWJzaXRlOiB1c2VyLmNvbXBhbnlXZWJzaXRlLFxyXG4gICAgICAgICAgICByb2xlSWQ6dXNlci5yb2xlSWRcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdDogYW55XHJcbiAgICAgICAgICAgIGlmIChpc0NvbXBhbnkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5wb3N0KFwiL2FwaS9zaWduLXVwL2NvbXBhbnlcIiwgYm9keSwgdGhpcy5jcmVhdGVIZWFkZXIoKSlcclxuICAgICAgICAgICAgICAgICAgICAudG9Qcm9taXNlKClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5wb3N0KFwiL2FwaS9zaWduLXVwL3N0dWRlbnRcIiwgYm9keSwgdGhpcy5jcmVhdGVIZWFkZXIoKSlcclxuICAgICAgICAgICAgICAgICAgICAudG9Qcm9taXNlKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVzdWx0PT10cnVlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy50b2FzdGVyLnNob3coXCLEkMSDbmcga8OtIHRow6BuaCBjw7RuZ1wiLCBcIsSQxINuZyBuaOG6rXAgxJHhu4Mgc+G7rSBk4bulbmcuXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b2FzdGVyLnNob3coXCLEkMSDbmcga8OtIHRo4bqldCBi4bqhaVwiLCBcIlZ1aSBsw7JuZyB0aOG7rSBs4bqhaSBzYXUuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyBsb2dpbih1c2VyOiBhbnkpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgICAgICBsZXQgYm9keSA9IHtcclxuICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXIudXNlcm5hbWUsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiB1c2VyLnBhc3N3b3JkXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5wb3N0KFVybFZhcmlhYmxlLlVSTF9MT0dJTiwgYm9keSwgdGhpcy5jcmVhdGVIZWFkZXIoKSkudG9Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIHZhciB0b2tlbkF1dGggPSAodG9rZW4gYXMgVG9rZW5Qcm92aWRlcik7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0b2tlbl9odXJlJywgdG9rZW5BdXRoLnRva2VuKTtcclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VySWQnLCB0b2tlbkF1dGguZ3VpZC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxvZ2luJC5lbWl0KHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByaXZhdGUgZXh0cmFjdGRhdGEocmVzOiBSZXNwb25zZSkge1xyXG4gICAgICAgIGxldCBib2R5ID0gcmVzLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gYm9keSB8fCB7fTtcclxuICAgIH1cclxuICAgIGlzTG9nZ2VkKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0b2tlbl9odXJlXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGp3dCA9IG5ldyBKd3RIZWxwZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWp3dC5pc1Rva2VuRXhwaXJlZCh0b2tlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbG9nb3V0KCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9naW4kLmVtaXQoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgVG9rZW5Qcm92aWRlciB7XHJcbiAgICB0b2tlbjogc3RyaW5nO1xyXG4gICAgZXhwaXJlc19pbjogRGF0ZTtcclxuICAgIGd1aWQ6IG51bWJlcjtcclxuICAgIGNvbnN0cnVjdG9yKHRva2VuOiBzdHJpbmcsIGd1aWQ6IG51bWJlciwgZXhwaXJlc2luOiBEYXRlKSB7XHJcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xyXG4gICAgICAgIHRoaXMuZ3VpZCA9IGd1aWQ7XHJcbiAgICAgICAgdGhpcy5leHBpcmVzX2luID0gZXhwaXJlc2luO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2VydmljZXMvYmFja2VuZC9hdXRoLnNlcnZpY2UudHMiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBhdWRpdF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvYXVkaXQnKTtcbmV4cG9ydHMuYXVkaXQgPSBhdWRpdF8xLmF1ZGl0O1xudmFyIGF1ZGl0VGltZV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvYXVkaXRUaW1lJyk7XG5leHBvcnRzLmF1ZGl0VGltZSA9IGF1ZGl0VGltZV8xLmF1ZGl0VGltZTtcbnZhciBidWZmZXJfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2J1ZmZlcicpO1xuZXhwb3J0cy5idWZmZXIgPSBidWZmZXJfMS5idWZmZXI7XG52YXIgYnVmZmVyQ291bnRfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2J1ZmZlckNvdW50Jyk7XG5leHBvcnRzLmJ1ZmZlckNvdW50ID0gYnVmZmVyQ291bnRfMS5idWZmZXJDb3VudDtcbnZhciBidWZmZXJUaW1lXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9idWZmZXJUaW1lJyk7XG5leHBvcnRzLmJ1ZmZlclRpbWUgPSBidWZmZXJUaW1lXzEuYnVmZmVyVGltZTtcbnZhciBidWZmZXJUb2dnbGVfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2J1ZmZlclRvZ2dsZScpO1xuZXhwb3J0cy5idWZmZXJUb2dnbGUgPSBidWZmZXJUb2dnbGVfMS5idWZmZXJUb2dnbGU7XG52YXIgYnVmZmVyV2hlbl8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvYnVmZmVyV2hlbicpO1xuZXhwb3J0cy5idWZmZXJXaGVuID0gYnVmZmVyV2hlbl8xLmJ1ZmZlcldoZW47XG52YXIgY2F0Y2hFcnJvcl8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvY2F0Y2hFcnJvcicpO1xuZXhwb3J0cy5jYXRjaEVycm9yID0gY2F0Y2hFcnJvcl8xLmNhdGNoRXJyb3I7XG52YXIgY29tYmluZUFsbF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvY29tYmluZUFsbCcpO1xuZXhwb3J0cy5jb21iaW5lQWxsID0gY29tYmluZUFsbF8xLmNvbWJpbmVBbGw7XG52YXIgY29tYmluZUxhdGVzdF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvY29tYmluZUxhdGVzdCcpO1xuZXhwb3J0cy5jb21iaW5lTGF0ZXN0ID0gY29tYmluZUxhdGVzdF8xLmNvbWJpbmVMYXRlc3Q7XG52YXIgY29uY2F0XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9jb25jYXQnKTtcbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0XzEuY29uY2F0O1xudmFyIGNvbmNhdEFsbF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvY29uY2F0QWxsJyk7XG5leHBvcnRzLmNvbmNhdEFsbCA9IGNvbmNhdEFsbF8xLmNvbmNhdEFsbDtcbnZhciBjb25jYXRNYXBfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2NvbmNhdE1hcCcpO1xuZXhwb3J0cy5jb25jYXRNYXAgPSBjb25jYXRNYXBfMS5jb25jYXRNYXA7XG52YXIgY29uY2F0TWFwVG9fMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2NvbmNhdE1hcFRvJyk7XG5leHBvcnRzLmNvbmNhdE1hcFRvID0gY29uY2F0TWFwVG9fMS5jb25jYXRNYXBUbztcbnZhciBjb3VudF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvY291bnQnKTtcbmV4cG9ydHMuY291bnQgPSBjb3VudF8xLmNvdW50O1xudmFyIGRlYm91bmNlXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9kZWJvdW5jZScpO1xuZXhwb3J0cy5kZWJvdW5jZSA9IGRlYm91bmNlXzEuZGVib3VuY2U7XG52YXIgZGVib3VuY2VUaW1lXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9kZWJvdW5jZVRpbWUnKTtcbmV4cG9ydHMuZGVib3VuY2VUaW1lID0gZGVib3VuY2VUaW1lXzEuZGVib3VuY2VUaW1lO1xudmFyIGRlZmF1bHRJZkVtcHR5XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9kZWZhdWx0SWZFbXB0eScpO1xuZXhwb3J0cy5kZWZhdWx0SWZFbXB0eSA9IGRlZmF1bHRJZkVtcHR5XzEuZGVmYXVsdElmRW1wdHk7XG52YXIgZGVsYXlfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2RlbGF5Jyk7XG5leHBvcnRzLmRlbGF5ID0gZGVsYXlfMS5kZWxheTtcbnZhciBkZWxheVdoZW5fMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2RlbGF5V2hlbicpO1xuZXhwb3J0cy5kZWxheVdoZW4gPSBkZWxheVdoZW5fMS5kZWxheVdoZW47XG52YXIgZGVtYXRlcmlhbGl6ZV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZGVtYXRlcmlhbGl6ZScpO1xuZXhwb3J0cy5kZW1hdGVyaWFsaXplID0gZGVtYXRlcmlhbGl6ZV8xLmRlbWF0ZXJpYWxpemU7XG52YXIgZGlzdGluY3RfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2Rpc3RpbmN0Jyk7XG5leHBvcnRzLmRpc3RpbmN0ID0gZGlzdGluY3RfMS5kaXN0aW5jdDtcbnZhciBkaXN0aW5jdFVudGlsQ2hhbmdlZF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZGlzdGluY3RVbnRpbENoYW5nZWQnKTtcbmV4cG9ydHMuZGlzdGluY3RVbnRpbENoYW5nZWQgPSBkaXN0aW5jdFVudGlsQ2hhbmdlZF8xLmRpc3RpbmN0VW50aWxDaGFuZ2VkO1xudmFyIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCcpO1xuZXhwb3J0cy5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCA9IGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkXzEuZGlzdGluY3RVbnRpbEtleUNoYW5nZWQ7XG52YXIgZWxlbWVudEF0XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9lbGVtZW50QXQnKTtcbmV4cG9ydHMuZWxlbWVudEF0ID0gZWxlbWVudEF0XzEuZWxlbWVudEF0O1xudmFyIGV2ZXJ5XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9ldmVyeScpO1xuZXhwb3J0cy5ldmVyeSA9IGV2ZXJ5XzEuZXZlcnk7XG52YXIgZXhoYXVzdF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZXhoYXVzdCcpO1xuZXhwb3J0cy5leGhhdXN0ID0gZXhoYXVzdF8xLmV4aGF1c3Q7XG52YXIgZXhoYXVzdE1hcF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZXhoYXVzdE1hcCcpO1xuZXhwb3J0cy5leGhhdXN0TWFwID0gZXhoYXVzdE1hcF8xLmV4aGF1c3RNYXA7XG52YXIgZXhwYW5kXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9leHBhbmQnKTtcbmV4cG9ydHMuZXhwYW5kID0gZXhwYW5kXzEuZXhwYW5kO1xudmFyIGZpbHRlcl8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZmlsdGVyJyk7XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcl8xLmZpbHRlcjtcbnZhciBmaW5hbGl6ZV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZmluYWxpemUnKTtcbmV4cG9ydHMuZmluYWxpemUgPSBmaW5hbGl6ZV8xLmZpbmFsaXplO1xudmFyIGZpbmRfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2ZpbmQnKTtcbmV4cG9ydHMuZmluZCA9IGZpbmRfMS5maW5kO1xudmFyIGZpbmRJbmRleF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZmluZEluZGV4Jyk7XG5leHBvcnRzLmZpbmRJbmRleCA9IGZpbmRJbmRleF8xLmZpbmRJbmRleDtcbnZhciBmaXJzdF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZmlyc3QnKTtcbmV4cG9ydHMuZmlyc3QgPSBmaXJzdF8xLmZpcnN0O1xudmFyIGdyb3VwQnlfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2dyb3VwQnknKTtcbmV4cG9ydHMuZ3JvdXBCeSA9IGdyb3VwQnlfMS5ncm91cEJ5O1xudmFyIGlnbm9yZUVsZW1lbnRzXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9pZ25vcmVFbGVtZW50cycpO1xuZXhwb3J0cy5pZ25vcmVFbGVtZW50cyA9IGlnbm9yZUVsZW1lbnRzXzEuaWdub3JlRWxlbWVudHM7XG52YXIgaXNFbXB0eV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvaXNFbXB0eScpO1xuZXhwb3J0cy5pc0VtcHR5ID0gaXNFbXB0eV8xLmlzRW1wdHk7XG52YXIgbGFzdF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvbGFzdCcpO1xuZXhwb3J0cy5sYXN0ID0gbGFzdF8xLmxhc3Q7XG52YXIgbWFwXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9tYXAnKTtcbmV4cG9ydHMubWFwID0gbWFwXzEubWFwO1xudmFyIG1hcFRvXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9tYXBUbycpO1xuZXhwb3J0cy5tYXBUbyA9IG1hcFRvXzEubWFwVG87XG52YXIgbWF0ZXJpYWxpemVfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL21hdGVyaWFsaXplJyk7XG5leHBvcnRzLm1hdGVyaWFsaXplID0gbWF0ZXJpYWxpemVfMS5tYXRlcmlhbGl6ZTtcbnZhciBtYXhfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL21heCcpO1xuZXhwb3J0cy5tYXggPSBtYXhfMS5tYXg7XG52YXIgbWVyZ2VfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL21lcmdlJyk7XG5leHBvcnRzLm1lcmdlID0gbWVyZ2VfMS5tZXJnZTtcbnZhciBtZXJnZUFsbF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvbWVyZ2VBbGwnKTtcbmV4cG9ydHMubWVyZ2VBbGwgPSBtZXJnZUFsbF8xLm1lcmdlQWxsO1xudmFyIG1lcmdlTWFwXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9tZXJnZU1hcCcpO1xuZXhwb3J0cy5tZXJnZU1hcCA9IG1lcmdlTWFwXzEubWVyZ2VNYXA7XG52YXIgbWVyZ2VNYXBfMiA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL21lcmdlTWFwJyk7XG5leHBvcnRzLmZsYXRNYXAgPSBtZXJnZU1hcF8yLm1lcmdlTWFwO1xudmFyIG1lcmdlTWFwVG9fMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL21lcmdlTWFwVG8nKTtcbmV4cG9ydHMubWVyZ2VNYXBUbyA9IG1lcmdlTWFwVG9fMS5tZXJnZU1hcFRvO1xudmFyIG1lcmdlU2Nhbl8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvbWVyZ2VTY2FuJyk7XG5leHBvcnRzLm1lcmdlU2NhbiA9IG1lcmdlU2Nhbl8xLm1lcmdlU2NhbjtcbnZhciBtaW5fMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL21pbicpO1xuZXhwb3J0cy5taW4gPSBtaW5fMS5taW47XG52YXIgbXVsdGljYXN0XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9tdWx0aWNhc3QnKTtcbmV4cG9ydHMubXVsdGljYXN0ID0gbXVsdGljYXN0XzEubXVsdGljYXN0O1xudmFyIG9ic2VydmVPbl8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvb2JzZXJ2ZU9uJyk7XG5leHBvcnRzLm9ic2VydmVPbiA9IG9ic2VydmVPbl8xLm9ic2VydmVPbjtcbnZhciBvbkVycm9yUmVzdW1lTmV4dF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvb25FcnJvclJlc3VtZU5leHQnKTtcbmV4cG9ydHMub25FcnJvclJlc3VtZU5leHQgPSBvbkVycm9yUmVzdW1lTmV4dF8xLm9uRXJyb3JSZXN1bWVOZXh0O1xudmFyIHBhaXJ3aXNlXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9wYWlyd2lzZScpO1xuZXhwb3J0cy5wYWlyd2lzZSA9IHBhaXJ3aXNlXzEucGFpcndpc2U7XG52YXIgcGFydGl0aW9uXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9wYXJ0aXRpb24nKTtcbmV4cG9ydHMucGFydGl0aW9uID0gcGFydGl0aW9uXzEucGFydGl0aW9uO1xudmFyIHBsdWNrXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9wbHVjaycpO1xuZXhwb3J0cy5wbHVjayA9IHBsdWNrXzEucGx1Y2s7XG52YXIgcHVibGlzaF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvcHVibGlzaCcpO1xuZXhwb3J0cy5wdWJsaXNoID0gcHVibGlzaF8xLnB1Ymxpc2g7XG52YXIgcHVibGlzaEJlaGF2aW9yXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9wdWJsaXNoQmVoYXZpb3InKTtcbmV4cG9ydHMucHVibGlzaEJlaGF2aW9yID0gcHVibGlzaEJlaGF2aW9yXzEucHVibGlzaEJlaGF2aW9yO1xudmFyIHB1Ymxpc2hMYXN0XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9wdWJsaXNoTGFzdCcpO1xuZXhwb3J0cy5wdWJsaXNoTGFzdCA9IHB1Ymxpc2hMYXN0XzEucHVibGlzaExhc3Q7XG52YXIgcHVibGlzaFJlcGxheV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvcHVibGlzaFJlcGxheScpO1xuZXhwb3J0cy5wdWJsaXNoUmVwbGF5ID0gcHVibGlzaFJlcGxheV8xLnB1Ymxpc2hSZXBsYXk7XG52YXIgcmFjZV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvcmFjZScpO1xuZXhwb3J0cy5yYWNlID0gcmFjZV8xLnJhY2U7XG52YXIgcmVkdWNlXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9yZWR1Y2UnKTtcbmV4cG9ydHMucmVkdWNlID0gcmVkdWNlXzEucmVkdWNlO1xudmFyIHJlcGVhdF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvcmVwZWF0Jyk7XG5leHBvcnRzLnJlcGVhdCA9IHJlcGVhdF8xLnJlcGVhdDtcbnZhciByZXBlYXRXaGVuXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9yZXBlYXRXaGVuJyk7XG5leHBvcnRzLnJlcGVhdFdoZW4gPSByZXBlYXRXaGVuXzEucmVwZWF0V2hlbjtcbnZhciByZXRyeV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvcmV0cnknKTtcbmV4cG9ydHMucmV0cnkgPSByZXRyeV8xLnJldHJ5O1xudmFyIHJldHJ5V2hlbl8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvcmV0cnlXaGVuJyk7XG5leHBvcnRzLnJldHJ5V2hlbiA9IHJldHJ5V2hlbl8xLnJldHJ5V2hlbjtcbnZhciByZWZDb3VudF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvcmVmQ291bnQnKTtcbmV4cG9ydHMucmVmQ291bnQgPSByZWZDb3VudF8xLnJlZkNvdW50O1xudmFyIHNhbXBsZV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvc2FtcGxlJyk7XG5leHBvcnRzLnNhbXBsZSA9IHNhbXBsZV8xLnNhbXBsZTtcbnZhciBzYW1wbGVUaW1lXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9zYW1wbGVUaW1lJyk7XG5leHBvcnRzLnNhbXBsZVRpbWUgPSBzYW1wbGVUaW1lXzEuc2FtcGxlVGltZTtcbnZhciBzY2FuXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9zY2FuJyk7XG5leHBvcnRzLnNjYW4gPSBzY2FuXzEuc2NhbjtcbnZhciBzZXF1ZW5jZUVxdWFsXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9zZXF1ZW5jZUVxdWFsJyk7XG5leHBvcnRzLnNlcXVlbmNlRXF1YWwgPSBzZXF1ZW5jZUVxdWFsXzEuc2VxdWVuY2VFcXVhbDtcbnZhciBzaGFyZV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvc2hhcmUnKTtcbmV4cG9ydHMuc2hhcmUgPSBzaGFyZV8xLnNoYXJlO1xudmFyIHNoYXJlUmVwbGF5XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9zaGFyZVJlcGxheScpO1xuZXhwb3J0cy5zaGFyZVJlcGxheSA9IHNoYXJlUmVwbGF5XzEuc2hhcmVSZXBsYXk7XG52YXIgc2luZ2xlXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9zaW5nbGUnKTtcbmV4cG9ydHMuc2luZ2xlID0gc2luZ2xlXzEuc2luZ2xlO1xudmFyIHNraXBfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3NraXAnKTtcbmV4cG9ydHMuc2tpcCA9IHNraXBfMS5za2lwO1xudmFyIHNraXBMYXN0XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9za2lwTGFzdCcpO1xuZXhwb3J0cy5za2lwTGFzdCA9IHNraXBMYXN0XzEuc2tpcExhc3Q7XG52YXIgc2tpcFVudGlsXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9za2lwVW50aWwnKTtcbmV4cG9ydHMuc2tpcFVudGlsID0gc2tpcFVudGlsXzEuc2tpcFVudGlsO1xudmFyIHNraXBXaGlsZV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvc2tpcFdoaWxlJyk7XG5leHBvcnRzLnNraXBXaGlsZSA9IHNraXBXaGlsZV8xLnNraXBXaGlsZTtcbnZhciBzdGFydFdpdGhfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3N0YXJ0V2l0aCcpO1xuZXhwb3J0cy5zdGFydFdpdGggPSBzdGFydFdpdGhfMS5zdGFydFdpdGg7XG4vKipcbiAqIFRPRE8oaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9yeGpzL2lzc3Vlcy8yOTAwKTogQWRkIGJhY2sgc3Vic2NyaWJlT24gb25jZSBpdCBjYW4gYmVcbiAqIHRyZWVzaGFrZW4uIEN1cnJlbnRseSBpZiB0aGlzIGV4cG9ydCBpcyBhZGRlZCBiYWNrLCBpdFxuICogZm9yY2VzIGFwcHMgdG8gYnJpbmcgaW4gYXNhcCBzY2hlZHVsZXIgYWxvbmcgd2l0aFxuICogSW1tZWRpYXRlLCByb290LCBhbmQgb3RoZXIgc3VwcG9ydGluZyBjb2RlLlxuICovXG4vLyBleHBvcnQgeyBzdWJzY3JpYmVPbiB9IGZyb20gJy4vb3BlcmF0b3JzL3N1YnNjcmliZU9uJztcbnZhciBzd2l0Y2hBbGxfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3N3aXRjaEFsbCcpO1xuZXhwb3J0cy5zd2l0Y2hBbGwgPSBzd2l0Y2hBbGxfMS5zd2l0Y2hBbGw7XG52YXIgc3dpdGNoTWFwXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9zd2l0Y2hNYXAnKTtcbmV4cG9ydHMuc3dpdGNoTWFwID0gc3dpdGNoTWFwXzEuc3dpdGNoTWFwO1xudmFyIHN3aXRjaE1hcFRvXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9zd2l0Y2hNYXBUbycpO1xuZXhwb3J0cy5zd2l0Y2hNYXBUbyA9IHN3aXRjaE1hcFRvXzEuc3dpdGNoTWFwVG87XG52YXIgdGFrZV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvdGFrZScpO1xuZXhwb3J0cy50YWtlID0gdGFrZV8xLnRha2U7XG52YXIgdGFrZUxhc3RfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3Rha2VMYXN0Jyk7XG5leHBvcnRzLnRha2VMYXN0ID0gdGFrZUxhc3RfMS50YWtlTGFzdDtcbnZhciB0YWtlVW50aWxfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3Rha2VVbnRpbCcpO1xuZXhwb3J0cy50YWtlVW50aWwgPSB0YWtlVW50aWxfMS50YWtlVW50aWw7XG52YXIgdGFrZVdoaWxlXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy90YWtlV2hpbGUnKTtcbmV4cG9ydHMudGFrZVdoaWxlID0gdGFrZVdoaWxlXzEudGFrZVdoaWxlO1xudmFyIHRhcF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvdGFwJyk7XG5leHBvcnRzLnRhcCA9IHRhcF8xLnRhcDtcbnZhciB0aHJvdHRsZV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvdGhyb3R0bGUnKTtcbmV4cG9ydHMudGhyb3R0bGUgPSB0aHJvdHRsZV8xLnRocm90dGxlO1xudmFyIHRocm90dGxlVGltZV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvdGhyb3R0bGVUaW1lJyk7XG5leHBvcnRzLnRocm90dGxlVGltZSA9IHRocm90dGxlVGltZV8xLnRocm90dGxlVGltZTtcbnZhciB0aW1lSW50ZXJ2YWxfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3RpbWVJbnRlcnZhbCcpO1xuZXhwb3J0cy50aW1lSW50ZXJ2YWwgPSB0aW1lSW50ZXJ2YWxfMS50aW1lSW50ZXJ2YWw7XG52YXIgdGltZW91dF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvdGltZW91dCcpO1xuZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dF8xLnRpbWVvdXQ7XG52YXIgdGltZW91dFdpdGhfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3RpbWVvdXRXaXRoJyk7XG5leHBvcnRzLnRpbWVvdXRXaXRoID0gdGltZW91dFdpdGhfMS50aW1lb3V0V2l0aDtcbnZhciB0aW1lc3RhbXBfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3RpbWVzdGFtcCcpO1xuZXhwb3J0cy50aW1lc3RhbXAgPSB0aW1lc3RhbXBfMS50aW1lc3RhbXA7XG52YXIgdG9BcnJheV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvdG9BcnJheScpO1xuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheV8xLnRvQXJyYXk7XG52YXIgd2luZG93XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy93aW5kb3cnKTtcbmV4cG9ydHMud2luZG93ID0gd2luZG93XzEud2luZG93O1xudmFyIHdpbmRvd0NvdW50XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy93aW5kb3dDb3VudCcpO1xuZXhwb3J0cy53aW5kb3dDb3VudCA9IHdpbmRvd0NvdW50XzEud2luZG93Q291bnQ7XG52YXIgd2luZG93VGltZV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvd2luZG93VGltZScpO1xuZXhwb3J0cy53aW5kb3dUaW1lID0gd2luZG93VGltZV8xLndpbmRvd1RpbWU7XG52YXIgd2luZG93VG9nZ2xlXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy93aW5kb3dUb2dnbGUnKTtcbmV4cG9ydHMud2luZG93VG9nZ2xlID0gd2luZG93VG9nZ2xlXzEud2luZG93VG9nZ2xlO1xudmFyIHdpbmRvd1doZW5fMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3dpbmRvd1doZW4nKTtcbmV4cG9ydHMud2luZG93V2hlbiA9IHdpbmRvd1doZW5fMS53aW5kb3dXaGVuO1xudmFyIHdpdGhMYXRlc3RGcm9tXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy93aXRoTGF0ZXN0RnJvbScpO1xuZXhwb3J0cy53aXRoTGF0ZXN0RnJvbSA9IHdpdGhMYXRlc3RGcm9tXzEud2l0aExhdGVzdEZyb207XG52YXIgemlwXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy96aXAnKTtcbmV4cG9ydHMuemlwID0gemlwXzEuemlwO1xudmFyIHppcEFsbF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvemlwQWxsJyk7XG5leHBvcnRzLnppcEFsbCA9IHppcEFsbF8xLnppcEFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZXJhdG9ycy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIENvbmZpcm1TZXJ2aWNlIHtcclxuICAgIGNvbmZpcm1DaGFuZ2VkOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIHB1YmxpYyBzaG93Q29uZmlybSA9ICh0aXRsZTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcsIGFjdGlvbnM6YW55W10pID0+XHJcbiAgICAgICAgdGhpcy5jb25maXJtQ2hhbmdlZC5lbWl0KHsgbWVzc2FnZTogbWVzc2FnZSwgdGl0bGU6IHRpdGxlLCBhY3Rpb25zOmFjdGlvbnMgfSk7XHJcblxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3NlcnZpY2VzL2Zyb250ZW5kL2NvbmZpcm0uc2VydmljZS50cyIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcclxuaW1wb3J0IHsgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgQ29tbW9uSHR0cFNlcnZpY2UgfSBmcm9tICdAc2VydmljZXMvYmFja2VuZC9jb21tb24taHR0cC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTG9hZGluZ1NlcnZpY2UgfSBmcm9tICdAc2VydmljZXMvZnJvbnRlbmQvbG9hZGluZy5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQWxlcnRTZXJ2aWNlIH0gZnJvbSAnQHNlcnZpY2VzL2Zyb250ZW5kL2FsZXJ0LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBVUkwgfSBmcm9tICdAc2VydmljZXMvc2VydmljZS52YXJpYWJsZXMnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcclxuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9zaGFyZSc7XHJcbmltcG9ydCB7IEh0dHBIZWFkZXJzIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgSm9iU2VydmljZSB7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IFVSTCA9IFVSTC5KT0JfVVJMO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBPSk9CX1VSTCA9IFVSTC5KT0JfVVJMICsgJy9vbmx5LWpvYnMnXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IE9JTlRFUk5fVVJMID0gVVJMLkpPQl9VUkwgKyAnL29ubHktaW50ZXJucydcclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgaHR0cDogQ29tbW9uSHR0cFNlcnZpY2U8Sm9iPikgeyB9XHJcbiAgICBwcml2YXRlIGdldEpvYnMkOiBPYnNlcnZhYmxlPEpvYltdPlxyXG4gICAgZ2V0Sm9iRGV0YWlsKGlkOiBudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5odHRwLmdldDxKb2I+KHRoaXMuVVJMLCBpZCwgdGhpcy5odHRwLmNyZWF0ZUhlYWRlcigpKS5zaGFyZSgpXHJcbiAgICB9XHJcbiAgICBnZXRKb2JzKCk6IE9ic2VydmFibGU8Sm9iW10+IHtcclxuICAgICAgICBpZiAoIXRoaXMuZ2V0Sm9icyQpIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRKb2JzJCA9IHRoaXMuaHR0cC5nZXRzPEpvYj4odGhpcy5VUkwsIHRoaXMuaHR0cC5jcmVhdGVIZWFkZXIoKSkuc2hhcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Sm9icyQ7XHJcbiAgICB9XHJcbiAgICBnZXRTZWFyY2hKb2JzKGtleXdvcmQ6IHN0cmluZywgam9iR3JvdXBJZDogbnVtYmVyID0gMCwgd29ya1R5cGVJZDogbnVtYmVyID0gMCkge1xyXG4gICAgICAgIGlmICghdGhpcy5nZXRKb2JzJCkge1xyXG4gICAgICAgICAgICB0aGlzLmdldEpvYnMoKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRKb2JzJC5tYXAoam9icyA9PiB7XHJcbiAgICAgICAgICAgIGxldCBqb2JGaWx0ZXJLZXl3b3JkID0gam9icy5maWx0ZXIoam9iID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqb2IuY29udGFjdEFkZHJlc3MudG9VcHBlckNhc2UoKS5pbmNsdWRlcyhrZXl3b3JkLnRvVXBwZXJDYXNlKCkpIHx8IGpvYi5tYWpvclRhZy50b1VwcGVyQ2FzZSgpLmluY2x1ZGVzKGtleXdvcmQudG9VcHBlckNhc2UoKSlcclxuICAgICAgICAgICAgICAgICAgICB8fCBqb2IudGl0bGUudG9VcHBlckNhc2UoKS5pbmNsdWRlcyhrZXl3b3JkLnRvVXBwZXJDYXNlKCkpIHx8IGpvYi5zaG9ydERlc2NyaXB0aW9uLnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoa2V5d29yZC50b1VwcGVyQ2FzZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHx8IGpvYi5iZW5lZml0LnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoa2V5d29yZC50b1VwcGVyQ2FzZSgpKSB8fCBqb2IucGxhY2UudG9VcHBlckNhc2UoKS5pbmNsdWRlcyhrZXl3b3JkLnRvVXBwZXJDYXNlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgam9iLnJlcXVpcmVtZW50LnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoa2V5d29yZC50b1VwcGVyQ2FzZSgpKSB8fCBqb2IucG9zaXRpb24udG9VcHBlckNhc2UoKS5pbmNsdWRlcyhrZXl3b3JkLnRvVXBwZXJDYXNlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgam9iLmNvbXBhbnkuYWRkcmVzcy50b1VwcGVyQ2FzZSgpLmluY2x1ZGVzKGtleXdvcmQudG9VcHBlckNhc2UoKSkgfHwgam9iLmNvbXBhbnkuZGVzY3JpcHRpb24udG9VcHBlckNhc2UoKS5pbmNsdWRlcyhrZXl3b3JkLnRvVXBwZXJDYXNlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgam9iLmNvbXBhbnkubmFtZS50b1VwcGVyQ2FzZSgpLmluY2x1ZGVzKGtleXdvcmQudG9VcHBlckNhc2UoKSkgfHwgam9iLmNvbXBhbnkuc2hvcnROYW1lLnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoa2V5d29yZC50b1VwcGVyQ2FzZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHx8IGpvYi53b3JrVHlwZS5uYW1lLnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoa2V5d29yZC50b1VwcGVyQ2FzZSgpKSB8fCBqb2Iud29ya1R5cGUuc2hvcnROYW1lLnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoa2V5d29yZC50b1VwcGVyQ2FzZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHx8IGpvYi5qb2JHcm91cC5uYW1lLnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoa2V5d29yZC50b1VwcGVyQ2FzZSgpKSB8fCBqb2Iuam9iR3JvdXAuc2hvcnROYW1lLnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoa2V5d29yZC50b1VwcGVyQ2FzZSgpKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGpvYkdyb3VwSWQgIT0gMCAmJiB3b3JrVHlwZUlkICE9IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqb2JGaWx0ZXJLZXl3b3JkLmZpbHRlcihqID0+IGoud29ya1R5cGVJZCA9PSB3b3JrVHlwZUlkICYmIGouam9iR3JvdXBJZCA9PSBqb2JHcm91cElkKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGpvYkdyb3VwSWQgPT0gMCAmJiB3b3JrVHlwZUlkICE9IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqb2JGaWx0ZXJLZXl3b3JkLmZpbHRlcihqID0+IGoud29ya1R5cGVJZCA9PSB3b3JrVHlwZUlkKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGpvYkdyb3VwSWQgIT0gMCAmJiB3b3JrVHlwZUlkID09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqb2JGaWx0ZXJLZXl3b3JkLmZpbHRlcihqID0+IGouam9iR3JvdXBJZCA9PSBqb2JHcm91cElkKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpvYkZpbHRlcktleXdvcmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgZ2V0T25seUpvYnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5nZXRzPEpvYj4odGhpcy5PSk9CX1VSTCwgdGhpcy5odHRwLmNyZWF0ZUhlYWRlcigpKS5zaGFyZSgpXHJcbiAgICB9XHJcbiAgICBnZXRPbmx5SW50ZXJucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5odHRwLmdldHM8Sm9iPih0aGlzLk9JTlRFUk5fVVJMLCB0aGlzLmh0dHAuY3JlYXRlSGVhZGVyKCkpLnNoYXJlKClcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3NlcnZpY2VzL2JhY2tlbmQvam9iLnNlcnZpY2UudHMiLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XHJcbmltcG9ydCB7IGNhdGNoRXJyb3IgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IENvbW1vbkh0dHBTZXJ2aWNlIH0gZnJvbSAnQHNlcnZpY2VzL2JhY2tlbmQvY29tbW9uLWh0dHAuc2VydmljZSc7XHJcbmltcG9ydCB7IExvYWRpbmdTZXJ2aWNlIH0gZnJvbSAnQHNlcnZpY2VzL2Zyb250ZW5kL2xvYWRpbmcuc2VydmljZSc7XHJcbmltcG9ydCB7IEFsZXJ0U2VydmljZSB9IGZyb20gJ0BzZXJ2aWNlcy9mcm9udGVuZC9hbGVydC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgVVJMIH0gZnJvbSAnQHNlcnZpY2VzL3NlcnZpY2UudmFyaWFibGVzJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XHJcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3Ivc2hhcmUnO1xyXG5pbXBvcnQgeyBIdHRwSGVhZGVycyB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEV2ZW50U2VydmljZSB7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IFVSTCA9IFVSTC5FVkVOVF9VUkw7XHJcbiAgICBoZWFkZXJzID0gbmV3IEh0dHBIZWFkZXJzKClcclxuICAgICAgICAuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgaHR0cDogQ29tbW9uSHR0cFNlcnZpY2U8RXZlbnRJdGVtPikgeyB9XHJcbiAgICBwcml2YXRlIGdldEV2ZW50cyQ6IE9ic2VydmFibGU8RXZlbnRJdGVtW10+XHJcbiAgICBnZXRFdmVudHMoKTogT2JzZXJ2YWJsZTxFdmVudEl0ZW1bXT4ge1xyXG4gICAgICAgIGlmICghdGhpcy5nZXRFdmVudHMkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRzJCA9IHRoaXMuaHR0cC5nZXRzPEV2ZW50SXRlbT4odGhpcy5VUkwsIHRoaXMuaHR0cC5jcmVhdGVIZWFkZXIoKSkuc2hhcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXZlbnRzJDtcclxuICAgIH1cclxuXHJcbiAgICBnZXRFdmVudHNQYWdlKGN1cnJlbnRQYWdlOiBudW1iZXIsIG51bWJlckl0ZW1QYWdlOiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgICAgIGxldCBib2R5ID0ge1xyXG4gICAgICAgICAgICBDdXJyZW50UGFnZTogY3VycmVudFBhZ2UsXHJcbiAgICAgICAgICAgIE51bWJlckl0ZW1QYWdlOiBudW1iZXJJdGVtUGFnZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5odHRwLnBvc3QoVVJMLkVWRU5UX1VSTCwgYm9keSwgdGhpcy5odHRwLmNyZWF0ZUhlYWRlcigpKS50b1Byb21pc2UoKTtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3NlcnZpY2VzL2JhY2tlbmQvZXZlbnQuc2VydmljZS50cyIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uSHR0cFNlcnZpY2UgfSBmcm9tICdAc2VydmljZXMvYmFja2VuZC9jb21tb24taHR0cC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgVVJMIH0gZnJvbSAnQHNlcnZpY2VzL3NlcnZpY2UudmFyaWFibGVzJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBKb2JHcm91cFNlcnZpY2Uge1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBVUkwgPSBVUkwuSk9CX0dST1VQX1VSTDtcclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgaHR0cDogQ29tbW9uSHR0cFNlcnZpY2U8Sm9iR3JvdXA+KSB7IH1cclxuICAgIHByaXZhdGUgZ2V0Sm9iRyQ6IE9ic2VydmFibGU8Sm9iR3JvdXBbXT5cclxuICAgIGdldEpvYnMoKTogT2JzZXJ2YWJsZTxKb2JHcm91cFtdPiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmdldEpvYkckKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0Sm9iRyQgPSB0aGlzLmh0dHAuZ2V0czxKb2JHcm91cD4odGhpcy5VUkwsIHRoaXMuaHR0cC5jcmVhdGVIZWFkZXIoKSkuc2hhcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Sm9iRyQ7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9zZXJ2aWNlcy9iYWNrZW5kL2pvYi1ncm91cC5zZXJ2aWNlLnRzIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoMjQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJleHBvcnQgY29uc3QgTkFWX01FTlUgPSBbXHJcbiAgICB7XHJcbiAgICAgICAgbGluazogXCIvXCIsIHRleHQ6IFwidHJhbmcgY2jhu6dcIlxyXG4gICAgfSwge1xyXG4gICAgICAgIGxpbms6IFwiL2Fib3V0XCIsIHRleHQ6IFwiZ2nhu5tpIHRoaeG7h3VcIlxyXG4gICAgfSwge1xyXG4gICAgICAgIGxpbms6IFwiL2pvYnMvbGlzdC9pbnRlcm5zaGlwXCIsIHRleHQ6IFwidGjhu7FjIHThuq1wXCJcclxuICAgIH0sIHtcclxuICAgICAgICBsaW5rOiBcIi9qb2JzL2xpc3RcIiwgdGV4dDogXCJ2aeG7h2MgbMOgbVwiXHJcbiAgICB9LCB7XHJcbiAgICAgICAgbGluazogXCIvY29tcGFueVwiLCB0ZXh0OiBcImRvYW5oIG5naGnhu4dwXCJcclxuICAgIH0sIHtcclxuICAgICAgICBsaW5rOiBcIi9ldmVudHNcIiwgdGV4dDogXCJz4buxIGtp4buHblwiXHJcbiAgICB9LCB7XHJcbiAgICAgICAgbGluazogXCIvc2tpbGxzXCIsIHRleHQ6IFwia8SpIG7Eg25nXCJcclxuICAgIH0sIHtcclxuICAgICAgICBsaW5rOiBcIi9jb250YWN0XCIsIHRleHQ6IFwibGnDqm4gaOG7h1wiXHJcbiAgICB9XHJcbl1cclxuZXhwb3J0IGNsYXNzIFVybFZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgVVJMX0xPR0lOID0gJ2FwaS9sb2dpbidcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL192YXJpYWJsZXMudHMiLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENhbkFjdGl2YXRlLCBSb3V0ZXIsIEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIFJvdXRlclN0YXRlU25hcHNob3QgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5pbXBvcnQgeyBKd3RIZWxwZXIgfSBmcm9tICdhbmd1bGFyMi1qd3QnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQWRtaW5HdWFyZCBpbXBsZW1lbnRzIENhbkFjdGl2YXRlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9yb3V0ZXI6IFJvdXRlcikgeyB9XHJcblxyXG4gICAgcHVibGljIGNhbkFjdGl2YXRlKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBzdGF0ZTogUm91dGVyU3RhdGVTbmFwc2hvdCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7IC8vIGNoZWNrIGlmIG5vdCBsb2NhbFN0b3JhZ2UgaXMgbm90IGRlZmluZWRcclxuICAgICAgICAgICAgdmFyIGp3dCA9IG5ldyBKd3RIZWxwZXIoKTtcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rva2VuX2h1cmUnKTtcclxuICAgICAgICAgICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoand0LmlzVG9rZW5FeHBpcmVkKHRva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JvdXRlci5uYXZpZ2F0ZShbXCJhZG1pbi9sb2dpblwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm9sZUpzb24gPSBqd3QuZGVjb2RlVG9rZW4odG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByb2xlID0gcm9sZUpzb24uUm9sZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocm9sZSA9PSBcIkFkbWluXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JvdXRlci5uYXZpZ2F0ZShbXCJhZG1pbi9sb2dpblwiXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9ndWFyZHMvYWRtaW4uZ3VhcmQudHMiLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEh0dHAsIFJlc3BvbnNlIH0gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xyXG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL21hcCc7XHJcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvY2F0Y2gnO1xyXG5pbXBvcnQgeyBDb21tb25IdHRwU2VydmljZSB9IGZyb20gJ0BzZXJ2aWNlcy9iYWNrZW5kL2NvbW1vbi1odHRwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBQcm9maWxlIH0gZnJvbSAnQG1vZGVscy9wcm9maWxlLm1vZGVsJztcclxuaW1wb3J0IHsgVVJMIH0gZnJvbSAnQHNlcnZpY2VzL3NlcnZpY2UudmFyaWFibGVzJztcclxuaW1wb3J0IHsgTG9jYWxTZXJ2aWNlIH0gZnJvbSAnQHNlcnZpY2VzL2JhY2tlbmQvbG9jYWwuc2VydmljZSc7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBQcm9maWxlU2VydmljZSB7XHJcbiAgICBwcml2YXRlIFVSTCA9IFVSTC5QUk9GSUxFX1VSTDtcclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgaHR0cDogQ29tbW9uSHR0cFNlcnZpY2U8UHJvZmlsZT4sIHByaXZhdGUgbG9jYWxTdmM6TG9jYWxTZXJ2aWNlKSB7IH1cclxuICAgIGdldFByb2ZpbGUoKTogT2JzZXJ2YWJsZTxQcm9maWxlPiB7XHJcbiAgICAgICAgbGV0IGd1aWQgPSB0aGlzLmxvY2FsU3ZjLmdldEd1aWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5odHRwLnBvc3QodGhpcy5VUkwsIHsgZ3VpZDogZ3VpZCB9KTtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3NlcnZpY2VzL2JhY2tlbmQvcHJvZmlsZS5zZXJ2aWNlLnRzIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21tb25IdHRwU2VydmljZSB9IGZyb20gJ0BzZXJ2aWNlcy9iYWNrZW5kL2NvbW1vbi1odHRwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcclxuaW1wb3J0IHsgVVJMIH0gZnJvbSAnQHNlcnZpY2VzL3NlcnZpY2UudmFyaWFibGVzJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFJvbGVTZXJ2aWNlIHtcclxuICAgIHByaXZhdGUgVVJMID0gVVJMLlJPTEVfVVJMXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGh0dHA6IENvbW1vbkh0dHBTZXJ2aWNlPFJvbGU+KSB7IH1cclxuICAgIHByaXZhdGUgZ2V0Um9sZXMkOiBPYnNlcnZhYmxlPFJvbGVbXT5cclxuICAgIGdldHMoKTogT2JzZXJ2YWJsZTxSb2xlW10+IHtcclxuICAgICAgICBpZiAoIXRoaXMuZ2V0Um9sZXMkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0Um9sZXMkID0gdGhpcy5odHRwLmdldHM8Um9sZT4odGhpcy5VUkwsIHRoaXMuaHR0cC5jcmVhdGVIZWFkZXIoKSkuc2hhcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Um9sZXMkO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2VydmljZXMvYmFja2VuZC9yb2xlLnNlcnZpY2UudHMiLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFVSTCB9IGZyb20gJ0BzZXJ2aWNlcy9zZXJ2aWNlLnZhcmlhYmxlcyc7XHJcbmltcG9ydCB7IENvbW1vbkh0dHBTZXJ2aWNlIH0gZnJvbSAnQHNlcnZpY2VzL2JhY2tlbmQvY29tbW9uLWh0dHAuc2VydmljZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgV29ya1R5cGVTZXJ2aWNlIHtcclxuICAgIHByaXZhdGUgVVJMID0gVVJMLldPUktUWVBFX1VSTFxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBodHRwOkNvbW1vbkh0dHBTZXJ2aWNlPFdvcmtUeXBlPil7fVxyXG4gICAgcHJpdmF0ZSB3b3JrVHlwZXMkOk9ic2VydmFibGU8V29ya1R5cGVbXT5cclxuICAgIGdldFdvcmtUeXBlcygpe1xyXG4gICAgICAgIGlmKCF0aGlzLndvcmtUeXBlcyQpe1xyXG4gICAgICAgICAgICB0aGlzLndvcmtUeXBlcyQgPSB0aGlzLmh0dHAuZ2V0czxXb3JrVHlwZT4odGhpcy5VUkwsIHRoaXMuaHR0cC5jcmVhdGVIZWFkZXIoKSkuc2hhcmUoKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy53b3JrVHlwZXMkO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2VydmljZXMvYmFja2VuZC93b3JrLXR5cGUuc2VydmljZS50cyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUGVyZm9ybSBhIHNpZGUgZWZmZWN0IGZvciBldmVyeSBlbWlzc2lvbiBvbiB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCByZXR1cm5cbiAqIGFuIE9ic2VydmFibGUgdGhhdCBpcyBpZGVudGljYWwgdG8gdGhlIHNvdXJjZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SW50ZXJjZXB0cyBlYWNoIGVtaXNzaW9uIG9uIHRoZSBzb3VyY2UgYW5kIHJ1bnMgYVxuICogZnVuY3Rpb24sIGJ1dCByZXR1cm5zIGFuIG91dHB1dCB3aGljaCBpcyBpZGVudGljYWwgdG8gdGhlIHNvdXJjZSBhcyBsb25nIGFzIGVycm9ycyBkb24ndCBvY2N1ci48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kby5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGEgbWlycm9yZWQgT2JzZXJ2YWJsZSBvZiB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCBtb2RpZmllZCBzbyB0aGF0XG4gKiB0aGUgcHJvdmlkZWQgT2JzZXJ2ZXIgaXMgY2FsbGVkIHRvIHBlcmZvcm0gYSBzaWRlIGVmZmVjdCBmb3IgZXZlcnkgdmFsdWUsXG4gKiBlcnJvciwgYW5kIGNvbXBsZXRpb24gZW1pdHRlZCBieSB0aGUgc291cmNlLiBBbnkgZXJyb3JzIHRoYXQgYXJlIHRocm93biBpblxuICogdGhlIGFmb3JlbWVudGlvbmVkIE9ic2VydmVyIG9yIGhhbmRsZXJzIGFyZSBzYWZlbHkgc2VudCBkb3duIHRoZSBlcnJvciBwYXRoXG4gKiBvZiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogVGhpcyBvcGVyYXRvciBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZyB5b3VyIE9ic2VydmFibGVzIGZvciB0aGUgY29ycmVjdCB2YWx1ZXNcbiAqIG9yIHBlcmZvcm1pbmcgb3RoZXIgc2lkZSBlZmZlY3RzLlxuICpcbiAqIE5vdGU6IHRoaXMgaXMgZGlmZmVyZW50IHRvIGEgYHN1YnNjcmliZWAgb24gdGhlIE9ic2VydmFibGUuIElmIHRoZSBPYnNlcnZhYmxlXG4gKiByZXR1cm5lZCBieSBgZG9gIGlzIG5vdCBzdWJzY3JpYmVkLCB0aGUgc2lkZSBlZmZlY3RzIHNwZWNpZmllZCBieSB0aGVcbiAqIE9ic2VydmVyIHdpbGwgbmV2ZXIgaGFwcGVuLiBgZG9gIHRoZXJlZm9yZSBzaW1wbHkgc3BpZXMgb24gZXhpc3RpbmdcbiAqIGV4ZWN1dGlvbiwgaXQgZG9lcyBub3QgdHJpZ2dlciBhbiBleGVjdXRpb24gdG8gaGFwcGVuIGxpa2UgYHN1YnNjcmliZWAgZG9lcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgZXZlcnkgY2xpY2sgdG8gdGhlIGNsaWVudFggcG9zaXRpb24gb2YgdGhhdCBjbGljaywgd2hpbGUgYWxzbyBsb2dnaW5nIHRoZSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcG9zaXRpb25zID0gY2xpY2tzXG4gKiAgIC5kbyhldiA9PiBjb25zb2xlLmxvZyhldikpXG4gKiAgIC5tYXAoZXYgPT4gZXYuY2xpZW50WCk7XG4gKiBwb3NpdGlvbnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIG1hcH1cbiAqIEBzZWUge0BsaW5rIHN1YnNjcmliZX1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmVyfGZ1bmN0aW9ufSBbbmV4dE9yT2JzZXJ2ZXJdIEEgbm9ybWFsIE9ic2VydmVyIG9iamVjdCBvciBhXG4gKiBjYWxsYmFjayBmb3IgYG5leHRgLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayBmb3IgZXJyb3JzIGluIHRoZSBzb3VyY2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY29tcGxldGVdIENhbGxiYWNrIGZvciB0aGUgY29tcGxldGlvbiBvZiB0aGUgc291cmNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBpZGVudGljYWwgdG8gdGhlIHNvdXJjZSwgYnV0IHJ1bnMgdGhlXG4gKiBzcGVjaWZpZWQgT2JzZXJ2ZXIgb3IgY2FsbGJhY2socykgZm9yIGVhY2ggaXRlbS5cbiAqIEBuYW1lIHRhcFxuICovXG5mdW5jdGlvbiB0YXAobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiB0YXBPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IERvT3BlcmF0b3IobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkpO1xuICAgIH07XG59XG5leHBvcnRzLnRhcCA9IHRhcDtcbnZhciBEb09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb09wZXJhdG9yKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5uZXh0T3JPYnNlcnZlciA9IG5leHRPck9ic2VydmVyO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuY29tcGxldGUgPSBjb21wbGV0ZTtcbiAgICB9XG4gICAgRG9PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERvU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5leHRPck9ic2VydmVyLCB0aGlzLmVycm9yLCB0aGlzLmNvbXBsZXRlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRG9PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERvU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEb1N1YnNjcmliZXIoZGVzdGluYXRpb24sIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKHNhZmVTdWJzY3JpYmVyKTtcbiAgICAgICAgdGhpcy5zYWZlU3Vic2NyaWJlciA9IHNhZmVTdWJzY3JpYmVyO1xuICAgIH1cbiAgICBEb1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBzYWZlU3Vic2NyaWJlciA9IHRoaXMuc2FmZVN1YnNjcmliZXI7XG4gICAgICAgIHNhZmVTdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBpZiAoc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSB0aGlzLnNhZmVTdWJzY3JpYmVyO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICBpZiAoc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzYWZlU3Vic2NyaWJlciA9IHRoaXMuc2FmZVN1YnNjcmliZXI7XG4gICAgICAgIHNhZmVTdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIGlmIChzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3Ioc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRG9TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFwLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy90YXAuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoNTcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL0JlaGF2aW9yU3ViamVjdC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBVUkwgfSBmcm9tICdAc2VydmljZXMvc2VydmljZS52YXJpYWJsZXMnO1xyXG5pbXBvcnQgeyBDb21tb25IdHRwU2VydmljZSB9IGZyb20gJ0BzZXJ2aWNlcy9iYWNrZW5kL2NvbW1vbi1odHRwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQ29tcGFueVNlcnZpY2Uge1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBVUkwgPSBVUkwuQ09NUEFOWV9VUkw7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGh0dHA6IENvbW1vbkh0dHBTZXJ2aWNlPENvbXBhbnk+KSB7IH1cclxuICAgIGdldEpvYk9mQ29tcGFueShpZDpudW1iZXIpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAuZ2V0czxKb2I+KHRoaXMuVVJMICsgYC8ke2lkfS9qb2JzYCwgdGhpcy5odHRwLmNyZWF0ZUhlYWRlcigpKS5zaGFyZSgpO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2VydmljZXMvYmFja2VuZC9jb21wYW55LnNlcnZpY2UudHMiLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBHcm91cENvbXBvbmVudCB9IGZyb20gJy4vZ3JvdXAvZ3JvdXAuY29tcG9uZW50JztcclxuaW1wb3J0IHsgVGFiYmVkQ29tcG9uZW50IH0gZnJvbSAnLi90YWJiZWQvdGFiYmVkLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IERyb3Bkb3duQ29tcG9uZW50IH0gZnJvbSAnLi9kcm9wZG93bi9kcm9wZG93bi5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBEcm9wZG93bkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL2Ryb3Bkb3duL2Ryb3Bkb3duSXRlbS9kcm9wZG93bkl0ZW0uY29tcG9uZW50JztcclxuaW1wb3J0IHsgVGFiQ29tcG9uZW50IH0gZnJvbSAnLi90YWJiZWQvdGFiL3RhYi5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBKb2JDb21wb25lbnQgfSBmcm9tICcuL2pvYi9qb2IuY29tcG9uZW50JztcclxuaW1wb3J0IHsgQmxvZ0NvbXBvbmVudCB9IGZyb20gJy4vYmxvZy9ibG9nLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFJhdGluZ0JhckNvbXBvbmVudCB9IGZyb20gJy4vcmF0aW5nL3JhdGluZy5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBFeHBhbnNpYmxlQ2FyZENvbXBvbmVudCB9IGZyb20gJy4vZXhwYW5zaWJsZS1jYXJkL2V4cGFuc2libGUtY2FyZC5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBQb3BvdmVyQ29tcG9uZW50IH0gZnJvbSAnLi9wb3BvdmVyL3BvcG92ZXIuY29tcG9uZW50JztcclxuaW1wb3J0IHsgRGlyZWN0aXZlTW9kdWxlIH0gZnJvbSAnQGRpcmVjdGl2ZXMvZGlyZWN0aXZlLm1vZHVsZSc7XHJcbmltcG9ydCB7IENhcmRDb21wb25lbnQgfSBmcm9tICdAdWkvY2FyZC9jYXJkLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFdhaXRlckNvbXBvbmVudCB9IGZyb20gJ0B1aS93YWl0ZXIvd2FpdGVyLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IENhcm91c2VsTGlzdENvbXBvbmVudCB9IGZyb20gJ0B1aS9jYXJvdXNlbC1saXN0L2Nhcm91c2VsLWxpc3QuY29tcG9uZW50JztcclxuaW1wb3J0IHsgQWN0aW9uTWVudUNvbXBvbmVudCB9IGZyb20gJ0B1aS9hY3Rpb24tbWVudS9hY3Rpb24tbWVudS5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBBY3Rpb25JdGVtQ29tcG9uZW50IH0gZnJvbSAnQHVpL2FjdGlvbi1tZW51L2FjdGlvbi1pdGVtL2FjdGlvbi1pdGVtLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFBpcGVNb2R1bGUgfSBmcm9tICdAc2hhcmVkL3BpcGVzL3BpcGUubW9kdWxlJztcclxuaW1wb3J0IHsgT3ZlcmxheUNvbXBvbmVudCB9IGZyb20gJy4vb3ZlcmxheS9vdmVybGF5LmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IEpvYnNDb250YWluZXJDb21wb25lbnQgfSBmcm9tICdAYXBwL2VuZC11c2VyL2hvbWUvY29tcG9uZW50cy9qb2JzLWNvbnRhaW5lci9qb2JzLWNvbnRhaW5lci5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBTZXJ2aWNlTW9kdWxlIH0gZnJvbSAnQHNlcnZpY2VzL3NlcnZpY2UubW9kdWxlJztcclxuQE5nTW9kdWxlKHtcclxuICAgIGRlY2xhcmF0aW9uczogW0dyb3VwQ29tcG9uZW50LCBUYWJiZWRDb21wb25lbnQsIERyb3Bkb3duQ29tcG9uZW50LFxyXG4gICAgICAgIERyb3Bkb3duSXRlbUNvbXBvbmVudCwgVGFiQ29tcG9uZW50LCBKb2JDb21wb25lbnQsIEJsb2dDb21wb25lbnQsIFdhaXRlckNvbXBvbmVudCxcclxuICAgICAgICBSYXRpbmdCYXJDb21wb25lbnQsIEV4cGFuc2libGVDYXJkQ29tcG9uZW50LCBQb3BvdmVyQ29tcG9uZW50LCBDYXJkQ29tcG9uZW50LCBDYXJvdXNlbExpc3RDb21wb25lbnQsXHJcbiAgICAgICAgQWN0aW9uTWVudUNvbXBvbmVudCwgQWN0aW9uSXRlbUNvbXBvbmVudCxcclxuICAgICAgICBPdmVybGF5Q29tcG9uZW50LCBKb2JzQ29udGFpbmVyQ29tcG9uZW50XHJcbiAgICBdLFxyXG4gICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgRGlyZWN0aXZlTW9kdWxlLCBQaXBlTW9kdWxlXSxcclxuICAgIGV4cG9ydHM6IFtHcm91cENvbXBvbmVudCwgVGFiYmVkQ29tcG9uZW50LCBEcm9wZG93bkNvbXBvbmVudCxcclxuICAgICAgICBEcm9wZG93bkl0ZW1Db21wb25lbnQsIFRhYkNvbXBvbmVudCwgSm9iQ29tcG9uZW50LCBDYXJkQ29tcG9uZW50LCBXYWl0ZXJDb21wb25lbnQsXHJcbiAgICAgICAgT3ZlcmxheUNvbXBvbmVudCxKb2JzQ29udGFpbmVyQ29tcG9uZW50LFxyXG4gICAgICAgIEJsb2dDb21wb25lbnQsIFJhdGluZ0JhckNvbXBvbmVudCwgRXhwYW5zaWJsZUNhcmRDb21wb25lbnQsIFBvcG92ZXJDb21wb25lbnQsIENhcm91c2VsTGlzdENvbXBvbmVudCxcclxuICAgICAgICBBY3Rpb25NZW51Q29tcG9uZW50LCBBY3Rpb25JdGVtQ29tcG9uZW50XSxcclxuICAgIHByb3ZpZGVyczogW10sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBVSU1vZHVsZSB7IH1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS91aS5tb2R1bGUudHMiLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjQuMy42XG4gKiAoYykgMjAxMC0yMDE3IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInKSwgcmVxdWlyZSgnQGFuZ3VsYXIvYW5pbWF0aW9ucycpLCByZXF1aXJlKCdAYW5ndWxhci9hbmltYXRpb25zL2Jyb3dzZXInKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnLCAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcicsICdAYW5ndWxhci9hbmltYXRpb25zJywgJ0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnJvd3NlciddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXIgPSBnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyIHx8IHt9LCBnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyLmFuaW1hdGlvbnMgPSBnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyLmFuaW1hdGlvbnMgfHwge30pLGdsb2JhbC5uZy5jb3JlLGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXIsZ2xvYmFsLm5nLmFuaW1hdGlvbnMsZ2xvYmFsLm5nLmFuaW1hdGlvbnMuYnJvd3NlcikpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsX2FuZ3VsYXJfY29yZSxfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIsX2FuZ3VsYXJfYW5pbWF0aW9ucyxfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxuXG4vKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjQuMy42XG4gKiAoYykgMjAxMC0yMDE3IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEJyb3dzZXJBbmltYXRpb25CdWlsZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByb290UmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IGRvY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJBbmltYXRpb25CdWlsZGVyKHJvb3RSZW5kZXJlciwgZG9jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9uZXh0QW5pbWF0aW9uSWQgPSAwO1xuICAgICAgICB2YXIgdHlwZURhdGEgPSB7XG4gICAgICAgICAgICBpZDogJzAnLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgc3R5bGVzOiBbXSxcbiAgICAgICAgICAgIGRhdGE6IHsgYW5pbWF0aW9uOiBbXSB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9yZW5kZXJlciA9IHJvb3RSZW5kZXJlci5jcmVhdGVSZW5kZXJlcihkb2MuYm9keSwgdHlwZURhdGEpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYW5pbWF0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCcm93c2VyQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkID0gdGhpcy5fbmV4dEFuaW1hdGlvbklkLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuX25leHRBbmltYXRpb25JZCsrO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeSA9IEFycmF5LmlzQXJyYXkoYW5pbWF0aW9uKSA/IF9hbmd1bGFyX2FuaW1hdGlvbnMuc2VxdWVuY2UoYW5pbWF0aW9uKSA6IGFuaW1hdGlvbjtcbiAgICAgICAgaXNzdWVBbmltYXRpb25Db21tYW5kKHRoaXMuX3JlbmRlcmVyLCBudWxsLCBpZCwgJ3JlZ2lzdGVyJywgW2VudHJ5XSk7XG4gICAgICAgIHJldHVybiBuZXcgQnJvd3NlckFuaW1hdGlvbkZhY3RvcnkoaWQsIHRoaXMuX3JlbmRlcmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBCcm93c2VyQW5pbWF0aW9uQnVpbGRlcjtcbn0oX2FuZ3VsYXJfYW5pbWF0aW9ucy5BbmltYXRpb25CdWlsZGVyKSk7XG5Ccm93c2VyQW5pbWF0aW9uQnVpbGRlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5Ccm93c2VyQW5pbWF0aW9uQnVpbGRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJGYWN0b3J5MiwgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRE9DVU1FTlQsXSB9LF0gfSxcbl07IH07XG52YXIgQnJvd3NlckFuaW1hdGlvbkZhY3RvcnkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCcm93c2VyQW5pbWF0aW9uRmFjdG9yeSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9pZFxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQnJvd3NlckFuaW1hdGlvbkZhY3RvcnkoX2lkLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2lkID0gX2lkO1xuICAgICAgICBfdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQnJvd3NlckFuaW1hdGlvbkZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIodGhpcy5faWQsIGVsZW1lbnQsIG9wdGlvbnMgfHwge30sIHRoaXMuX3JlbmRlcmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBCcm93c2VyQW5pbWF0aW9uRmFjdG9yeTtcbn0oX2FuZ3VsYXJfYW5pbWF0aW9ucy5BbmltYXRpb25GYWN0b3J5KSk7XG52YXIgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyKGlkLCBlbGVtZW50LCBvcHRpb25zLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5wYXJlbnRQbGF5ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudG90YWxUaW1lID0gMDtcbiAgICAgICAgdGhpcy5fY29tbWFuZCgnY3JlYXRlJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLl9saXN0ZW4gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIubGlzdGVuKHRoaXMuZWxlbWVudCwgXCJAQFwiICsgdGhpcy5pZCArIFwiOlwiICsgZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1hbmRcbiAgICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5fY29tbWFuZCA9IGZ1bmN0aW9uIChjb21tYW5kKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc3N1ZUFuaW1hdGlvbkNvbW1hbmQodGhpcy5fcmVuZGVyZXIsIHRoaXMuZWxlbWVudCwgdGhpcy5pZCwgY29tbWFuZCwgYXJncyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUub25Eb25lID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX2xpc3RlbignZG9uZScsIGZuKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9saXN0ZW4oJ3N0YXJ0JywgZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fbGlzdGVuKCdkZXN0cm95JywgZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2NvbW1hbmQoJ2luaXQnKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5oYXNTdGFydGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhcnRlZDsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb21tYW5kKCdwbGF5Jyk7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2NvbW1hbmQoJ3BhdXNlJyk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fY29tbWFuZCgncmVzdGFydCcpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fY29tbWFuZCgnZmluaXNoJyk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fY29tbWFuZCgnZGVzdHJveScpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9jb21tYW5kKCdyZXNldCcpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHApIHsgdGhpcy5fY29tbWFuZCgnc2V0UG9zaXRpb24nLCBwKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH07XG4gICAgcmV0dXJuIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSByZW5kZXJlclxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez99IGlkXG4gKiBAcGFyYW0gez99IGNvbW1hbmRcbiAqIEBwYXJhbSB7P30gYXJnc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNzdWVBbmltYXRpb25Db21tYW5kKHJlbmRlcmVyLCBlbGVtZW50LCBpZCwgY29tbWFuZCwgYXJncykge1xuICAgIHJldHVybiByZW5kZXJlci5zZXRQcm9wZXJ0eShlbGVtZW50LCBcIkBAXCIgKyBpZCArIFwiOlwiICsgY29tbWFuZCwgYXJncyk7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQU5JTUFUSU9OX1BSRUZJWCA9ICdAJztcbnZhciBESVNBQkxFX0FOSU1BVElPTlNfRkxBRyA9ICdALmRpc2FibGVkJztcbnZhciBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVsZWdhdGVcbiAgICAgKiBAcGFyYW0gez99IGVuZ2luZVxuICAgICAqIEBwYXJhbSB7P30gX3pvbmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkoZGVsZWdhdGUsIGVuZ2luZSwgX3pvbmUpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLl9jdXJyZW50SWQgPSAwO1xuICAgICAgICB0aGlzLl9taWNyb3Rhc2tJZCA9IDE7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbkNhbGxiYWNrc0J1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLl9yZW5kZXJlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jZFJlY3VyRGVwdGggPSAwO1xuICAgICAgICBlbmdpbmUub25SZW1vdmFsQ29tcGxldGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IGlmIGFuIGNvbXBvbmVudCBlbGVtZW50IGhhcyBhIGxlYXZlIGFuaW1hdGlvbiwgYW5kIHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgIC8vIGEgaG9zdCBsZWF2ZSBhbmltYXRpb24sIHRoZSB2aWV3IGVuZ2luZSB3aWxsIGNhbGwgYHJlbW92ZUNoaWxkYCBmb3IgdGhlIHBhcmVudFxuICAgICAgICAgICAgLy8gY29tcG9uZW50IHJlbmRlcmVyIGFzIHdlbGwgYXMgZm9yIHRoZSBjaGlsZCBjb21wb25lbnQgcmVuZGVyZXIuXG4gICAgICAgICAgICAvLyBUaGVyZWZvcmUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgYWxyZWFkeSByZW1vdmVkIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKGRlbGVnYXRlICYmIGRlbGVnYXRlLnBhcmVudE5vZGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5yZW1vdmVDaGlsZChlbGVtZW50LnBhcmVudE5vZGUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZVJlbmRlcmVyID0gZnVuY3Rpb24gKGhvc3RFbGVtZW50LCB0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIEVNUFRZX05BTUVTUEFDRV9JRCA9ICcnO1xuICAgICAgICAvLyBjYWNoZSB0aGUgZGVsZWdhdGVzIHRvIGZpbmQgb3V0IHdoaWNoIGNhY2hlZCBkZWxlZ2F0ZSBjYW5cbiAgICAgICAgLy8gYmUgdXNlZCBieSB3aGljaCBjYWNoZWQgcmVuZGVyZXJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVsZWdhdGUgPSB0aGlzLmRlbGVnYXRlLmNyZWF0ZVJlbmRlcmVyKGhvc3RFbGVtZW50LCB0eXBlKTtcbiAgICAgICAgaWYgKCFob3N0RWxlbWVudCB8fCAhdHlwZSB8fCAhdHlwZS5kYXRhIHx8ICF0eXBlLmRhdGFbJ2FuaW1hdGlvbiddKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyQ2FjaGUuZ2V0KGRlbGVnYXRlKTtcbiAgICAgICAgICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlciA9IG5ldyBCYXNlQW5pbWF0aW9uUmVuZGVyZXIoRU1QVFlfTkFNRVNQQUNFX0lELCBkZWxlZ2F0ZSwgdGhpcy5lbmdpbmUpO1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgY2FjaGUgdGhpcyByZXN1bHQgd2hlbiB0aGUgYmFzZSByZW5kZXJlciBpcyB1c2VkXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXJDYWNoZS5zZXQoZGVsZWdhdGUsIHJlbmRlcmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRJZCA9IHR5cGUuaWQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVzcGFjZUlkID0gdHlwZS5pZCArICctJyArIHRoaXMuX2N1cnJlbnRJZDtcbiAgICAgICAgdGhpcy5fY3VycmVudElkKys7XG4gICAgICAgIHRoaXMuZW5naW5lLnJlZ2lzdGVyKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuaW1hdGlvblRyaWdnZXJzID0gKHR5cGUuZGF0YVsnYW5pbWF0aW9uJ10pO1xuICAgICAgICBhbmltYXRpb25UcmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0cmlnZ2VyKSB7IHJldHVybiBfdGhpcy5lbmdpbmUucmVnaXN0ZXJUcmlnZ2VyKGNvbXBvbmVudElkLCBuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQsIHRyaWdnZXIubmFtZSwgdHJpZ2dlcik7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvblJlbmRlcmVyKHRoaXMsIG5hbWVzcGFjZUlkLCBkZWxlZ2F0ZSwgdGhpcy5lbmdpbmUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jZFJlY3VyRGVwdGgrKztcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuYmVnaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYmVnaW4oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkucHJvdG90eXBlLl9zY2hlZHVsZUNvdW50VGFzayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgWm9uZS5jdXJyZW50LnNjaGVkdWxlTWljcm9UYXNrKCdpbmNyZW1lbmV0IHRoZSBhbmltYXRpb24gbWljcm90YXNrJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX21pY3JvdGFza0lkKys7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb3VudFxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcGFyYW0gez99IGRhdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeS5wcm90b3R5cGUuc2NoZWR1bGVMaXN0ZW5lckNhbGxiYWNrID0gZnVuY3Rpb24gKGNvdW50LCBmbiwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY291bnQgPj0gMCAmJiBjb3VudCA8IHRoaXMuX21pY3JvdGFza0lkKSB7XG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IHJldHVybiBmbihkYXRhKTsgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbkNhbGxiYWNrc0J1ZmZlci5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKG51bGwpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRpb25DYWxsYmFja3NCdWZmZXIuZm9yRWFjaChmdW5jdGlvbiAodHVwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHR1cGxlWzBdLCBkYXRhID0gdHVwbGVbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBmbihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRpb25DYWxsYmFja3NCdWZmZXIgPSBbXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbkNhbGxiYWNrc0J1ZmZlci5wdXNoKFtmbiwgZGF0YV0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY2RSZWN1ckRlcHRoLS07XG4gICAgICAgIC8vIHRoaXMgaXMgdG8gcHJldmVudCBhbmltYXRpb25zIGZyb20gcnVubmluZyB0d2ljZSB3aGVuIGFuIGlubmVyXG4gICAgICAgIC8vIGNvbXBvbmVudCBkb2VzIENEIHdoZW4gYSBwYXJlbnQgY29tcG9uZW50IGluc3RlZCBoYXMgaW5zZXJ0ZWQgaXRcbiAgICAgICAgaWYgKHRoaXMuX2NkUmVjdXJEZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2NoZWR1bGVDb3VudFRhc2soKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbmdpbmUuZmx1c2goX3RoaXMuX21pY3JvdGFza0lkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmVuZCkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbmQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkucHJvdG90eXBlLndoZW5SZW5kZXJpbmdEb25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5lbmdpbmUud2hlblJlbmRlcmluZ0RvbmUoKTsgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5O1xufSgpKTtcbkFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5BbmltYXRpb25SZW5kZXJlckZhY3RvcnkuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyRmFjdG9yeTIsIH0sXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIuybVBbmltYXRpb25FbmdpbmUsIH0sXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nWm9uZSwgfSxcbl07IH07XG52YXIgQmFzZUFuaW1hdGlvblJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBkZWxlZ2F0ZVxuICAgICAqIEBwYXJhbSB7P30gZW5naW5lXG4gICAgICovXG4gICAgZnVuY3Rpb24gQmFzZUFuaW1hdGlvblJlbmRlcmVyKG5hbWVzcGFjZUlkLCBkZWxlZ2F0ZSwgZW5naW5lKSB7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlSWQgPSBuYW1lc3BhY2VJZDtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgdGhpcy5kZXN0cm95Tm9kZSA9IHRoaXMuZGVsZWdhdGUuZGVzdHJveU5vZGUgPyBmdW5jdGlvbiAobikgeyByZXR1cm4gZGVsZWdhdGUuZGVzdHJveU5vZGUobik7IH0gOiBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZSwgXCJkYXRhXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUuZGF0YTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLmRlc3Ryb3kodGhpcy5uYW1lc3BhY2VJZCwgdGhpcy5kZWxlZ2F0ZSk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuZGVzdHJveSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAobmFtZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmNyZWF0ZUVsZW1lbnQobmFtZSwgbmFtZXNwYWNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ29tbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5jcmVhdGVDb21tZW50KHZhbHVlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUuY3JlYXRlVGV4dCh2YWx1ZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IG5ld0NoaWxkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKHBhcmVudCwgbmV3Q2hpbGQpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5hcHBlbmRDaGlsZChwYXJlbnQsIG5ld0NoaWxkKTtcbiAgICAgICAgdGhpcy5lbmdpbmUub25JbnNlcnQodGhpcy5uYW1lc3BhY2VJZCwgbmV3Q2hpbGQsIHBhcmVudCwgZmFsc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IG5ld0NoaWxkXG4gICAgICogQHBhcmFtIHs/fSByZWZDaGlsZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAocGFyZW50LCBuZXdDaGlsZCwgcmVmQ2hpbGQpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5pbnNlcnRCZWZvcmUocGFyZW50LCBuZXdDaGlsZCwgcmVmQ2hpbGQpO1xuICAgICAgICB0aGlzLmVuZ2luZS5vbkluc2VydCh0aGlzLm5hbWVzcGFjZUlkLCBuZXdDaGlsZCwgcGFyZW50LCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBvbGRDaGlsZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChwYXJlbnQsIG9sZENoaWxkKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLm9uUmVtb3ZlKHRoaXMubmFtZXNwYWNlSWQsIG9sZENoaWxkLCB0aGlzLmRlbGVnYXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JPck5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuc2VsZWN0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3JPck5vZGUpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUuc2VsZWN0Um9vdEVsZW1lbnQoc2VsZWN0b3JPck5vZGUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5wYXJlbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUucGFyZW50Tm9kZShub2RlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUubmV4dFNpYmxpbmcgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5uZXh0U2libGluZyhub2RlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRBdHRyaWJ1dGUoZWwsIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIG5hbWVzcGFjZSkge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnJlbW92ZUF0dHJpYnV0ZShlbCwgbmFtZSwgbmFtZXNwYWNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIG5hbWUpIHsgdGhpcy5kZWxlZ2F0ZS5hZGRDbGFzcyhlbCwgbmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlbCwgbmFtZSkgeyB0aGlzLmRlbGVnYXRlLnJlbW92ZUNsYXNzKGVsLCBuYW1lKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBmbGFnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uIChlbCwgc3R5bGUsIHZhbHVlLCBmbGFncykge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFN0eWxlKGVsLCBzdHlsZSwgdmFsdWUsIGZsYWdzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHBhcmFtIHs/PX0gZmxhZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlU3R5bGUgPSBmdW5jdGlvbiAoZWwsIHN0eWxlLCBmbGFncykge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnJlbW92ZVN0eWxlKGVsLCBzdHlsZSwgZmxhZ3MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PSBBTklNQVRJT05fUFJFRklYICYmIG5hbWUgPT0gRElTQUJMRV9BTklNQVRJT05TX0ZMQUcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUFuaW1hdGlvbnMoZWwsICEhdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRQcm9wZXJ0eShlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7IHRoaXMuZGVsZWdhdGUuc2V0VmFsdWUobm9kZSwgdmFsdWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubGlzdGVuKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmRpc2FibGVBbmltYXRpb25zID0gZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLmRpc2FibGVBbmltYXRpb25zKGVsZW1lbnQsIHZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlQW5pbWF0aW9uUmVuZGVyZXI7XG59KCkpO1xudmFyIEFuaW1hdGlvblJlbmRlcmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5pbWF0aW9uUmVuZGVyZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmYWN0b3J5XG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZGVsZWdhdGVcbiAgICAgKiBAcGFyYW0gez99IGVuZ2luZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblJlbmRlcmVyKGZhY3RvcnksIG5hbWVzcGFjZUlkLCBkZWxlZ2F0ZSwgZW5naW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWVzcGFjZUlkLCBkZWxlZ2F0ZSwgZW5naW5lKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgX3RoaXMubmFtZXNwYWNlSWQgPSBuYW1lc3BhY2VJZDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT0gQU5JTUFUSU9OX1BSRUZJWCkge1xuICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDEpID09ICcuJyAmJiBuYW1lID09IERJU0FCTEVfQU5JTUFUSU9OU19GTEFHKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlQW5pbWF0aW9ucyhlbCwgLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lLnByb2Nlc3ModGhpcy5uYW1lc3BhY2VJZCwgZWwsIG5hbWUuc3Vic3RyKDEpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFByb3BlcnR5KGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZXZlbnROYW1lLmNoYXJBdCgwKSA9PSBBTklNQVRJT05fUFJFRklYKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gcmVzb2x2ZUVsZW1lbnRGcm9tVGFyZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gZXZlbnROYW1lLnN1YnN0cigxKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBoYXNlID0gJyc7XG4gICAgICAgICAgICAvLyBAbGlzdGVuZXIucGhhc2UgaXMgZm9yIHRyaWdnZXIgYW5pbWF0aW9uIGNhbGxiYWNrc1xuICAgICAgICAgICAgLy8gQEBsaXN0ZW5lciBpcyBmb3IgYW5pbWF0aW9uIGJ1aWxkZXIgY2FsbGJhY2tzXG4gICAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gQU5JTUFUSU9OX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIF9hID0gcGFyc2VUcmlnZ2VyQ2FsbGJhY2tOYW1lKG5hbWUpLCBuYW1lID0gX2FbMF0sIHBoYXNlID0gX2FbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUubGlzdGVuKHRoaXMubmFtZXNwYWNlSWQsIGVsZW1lbnQsIG5hbWUsIHBoYXNlLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb3VudElkID0gKChldmVudCkpWydfZGF0YSddIHx8IC0xO1xuICAgICAgICAgICAgICAgIF90aGlzLmZhY3Rvcnkuc2NoZWR1bGVMaXN0ZW5lckNhbGxiYWNrKGNvdW50SWQsIGNhbGxiYWNrLCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5saXN0ZW4odGFyZ2V0LCBldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgcmV0dXJuIEFuaW1hdGlvblJlbmRlcmVyO1xufShCYXNlQW5pbWF0aW9uUmVuZGVyZXIpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB0YXJnZXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVFbGVtZW50RnJvbVRhcmdldCh0YXJnZXQpIHtcbiAgICBzd2l0Y2ggKHRhcmdldCkge1xuICAgICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIGNhc2UgJ3dpbmRvdyc6XG4gICAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdHJpZ2dlck5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVHJpZ2dlckNhbGxiYWNrTmFtZSh0cmlnZ2VyTmFtZSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRvdEluZGV4ID0gdHJpZ2dlck5hbWUuaW5kZXhPZignLicpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXIgPSB0cmlnZ2VyTmFtZS5zdWJzdHJpbmcoMCwgZG90SW5kZXgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBoYXNlID0gdHJpZ2dlck5hbWUuc3Vic3RyKGRvdEluZGV4ICsgMSk7XG4gICAgcmV0dXJuIFt0cmlnZ2VyLCBwaGFzZV07XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluamVjdGFibGVBbmltYXRpb25FbmdpbmUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkcml2ZXJcbiAgICAgKiBAcGFyYW0gez99IG5vcm1hbGl6ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbmplY3RhYmxlQW5pbWF0aW9uRW5naW5lKGRyaXZlciwgbm9ybWFsaXplcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZHJpdmVyLCBub3JtYWxpemVyKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZTtcbn0oX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1QW5pbWF0aW9uRW5naW5lKSk7XG5JbmplY3RhYmxlQW5pbWF0aW9uRW5naW5lLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkluamVjdGFibGVBbmltYXRpb25FbmdpbmUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIuQW5pbWF0aW9uRHJpdmVyLCB9LFxuICAgIHsgdHlwZTogX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1QW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyLCB9LFxuXTsgfTtcbi8qKlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVTdXBwb3J0ZWRBbmltYXRpb25Ecml2ZXIoKSB7XG4gICAgaWYgKF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtXN1cHBvcnRzV2ViQW5pbWF0aW9ucygpKSB7XG4gICAgICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1V2ViQW5pbWF0aW9uc0RyaXZlcigpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtU5vb3BBbmltYXRpb25Ecml2ZXIoKTtcbn1cbi8qKlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVEZWZhdWx0U3R5bGVOb3JtYWxpemVyKCkge1xuICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1V2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplcigpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gKiBAcGFyYW0gez99IGVuZ2luZVxuICogQHBhcmFtIHs/fSB6b25lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVJlbmRlcmVyRmFjdG9yeShyZW5kZXJlciwgZW5naW5lLCB6b25lKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkocmVuZGVyZXIsIGVuZ2luZSwgem9uZSk7XG59XG52YXIgU0hBUkVEX0FOSU1BVElPTl9QUk9WSURFUlMgPSBbXG4gICAgeyBwcm92aWRlOiBfYW5ndWxhcl9hbmltYXRpb25zLkFuaW1hdGlvbkJ1aWxkZXIsIHVzZUNsYXNzOiBCcm93c2VyQW5pbWF0aW9uQnVpbGRlciB9LFxuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1QW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyLCB1c2VGYWN0b3J5OiBpbnN0YW50aWF0ZURlZmF1bHRTdHlsZU5vcm1hbGl6ZXIgfSxcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtUFuaW1hdGlvbkVuZ2luZSwgdXNlQ2xhc3M6IEluamVjdGFibGVBbmltYXRpb25FbmdpbmUgfSwge1xuICAgICAgICBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyRmFjdG9yeTIsXG4gICAgICAgIHVzZUZhY3Rvcnk6IGluc3RhbnRpYXRlUmVuZGVyZXJGYWN0b3J5LFxuICAgICAgICBkZXBzOiBbX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1RG9tUmVuZGVyZXJGYWN0b3J5MiwgX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1QW5pbWF0aW9uRW5naW5lLCBfYW5ndWxhcl9jb3JlLk5nWm9uZV1cbiAgICB9XG5dO1xuLyoqXG4gKiBTZXBhcmF0ZSBwcm92aWRlcnMgZnJvbSB0aGUgYWN0dWFsIG1vZHVsZSBzbyB0aGF0IHdlIGNhbiBkbyBhIGxvY2FsIG1vZGlmaWNhdGlvbiBpbiBHb29nbGUzIHRvXG4gKiBpbmNsdWRlIHRoZW0gaW4gdGhlIEJyb3dzZXJNb2R1bGUuXG4gKi9cbnZhciBCUk9XU0VSX0FOSU1BVElPTlNfUFJPVklERVJTID0gW1xuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLkFuaW1hdGlvbkRyaXZlciwgdXNlRmFjdG9yeTogaW5zdGFudGlhdGVTdXBwb3J0ZWRBbmltYXRpb25Ecml2ZXIgfVxuXS5jb25jYXQoU0hBUkVEX0FOSU1BVElPTl9QUk9WSURFUlMpO1xuLyoqXG4gKiBTZXBhcmF0ZSBwcm92aWRlcnMgZnJvbSB0aGUgYWN0dWFsIG1vZHVsZSBzbyB0aGF0IHdlIGNhbiBkbyBhIGxvY2FsIG1vZGlmaWNhdGlvbiBpbiBHb29nbGUzIHRvXG4gKiBpbmNsdWRlIHRoZW0gaW4gdGhlIEJyb3dzZXJUZXN0aW5nTW9kdWxlLlxuICovXG52YXIgQlJPV1NFUl9OT09QX0FOSU1BVElPTlNfUFJPVklERVJTID0gW3sgcHJvdmlkZTogX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLkFuaW1hdGlvbkRyaXZlciwgdXNlQ2xhc3M6IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtU5vb3BBbmltYXRpb25Ecml2ZXIgfV0uY29uY2F0KFNIQVJFRF9BTklNQVRJT05fUFJPVklERVJTKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqL1xudmFyIEJyb3dzZXJBbmltYXRpb25zTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIEJyb3dzZXJBbmltYXRpb25zTW9kdWxlO1xufSgpKTtcbkJyb3dzZXJBbmltYXRpb25zTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuQnJvd3Nlck1vZHVsZV0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBCUk9XU0VSX0FOSU1BVElPTlNfUFJPVklERVJTLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5Ccm93c2VyQW5pbWF0aW9uc01vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICovXG52YXIgTm9vcEFuaW1hdGlvbnNNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vb3BBbmltYXRpb25zTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTm9vcEFuaW1hdGlvbnNNb2R1bGU7XG59KCkpO1xuTm9vcEFuaW1hdGlvbnNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0czogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5Ccm93c2VyTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IEJST1dTRVJfTk9PUF9BTklNQVRJT05TX1BST1ZJREVSUyxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTm9vcEFuaW1hdGlvbnNNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcblxuZXhwb3J0cy5Ccm93c2VyQW5pbWF0aW9uc01vZHVsZSA9IEJyb3dzZXJBbmltYXRpb25zTW9kdWxlO1xuZXhwb3J0cy5Ob29wQW5pbWF0aW9uc01vZHVsZSA9IE5vb3BBbmltYXRpb25zTW9kdWxlO1xuZXhwb3J0cy7JtUJyb3dzZXJBbmltYXRpb25CdWlsZGVyID0gQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXI7XG5leHBvcnRzLsm1QnJvd3NlckFuaW1hdGlvbkZhY3RvcnkgPSBCcm93c2VyQW5pbWF0aW9uRmFjdG9yeTtcbmV4cG9ydHMuybVBbmltYXRpb25SZW5kZXJlciA9IEFuaW1hdGlvblJlbmRlcmVyO1xuZXhwb3J0cy7JtUFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeSA9IEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeTtcbmV4cG9ydHMuybVhID0gQmFzZUFuaW1hdGlvblJlbmRlcmVyO1xuZXhwb3J0cy7JtWYgPSBCUk9XU0VSX0FOSU1BVElPTlNfUFJPVklERVJTO1xuZXhwb3J0cy7JtWcgPSBCUk9XU0VSX05PT1BfQU5JTUFUSU9OU19QUk9WSURFUlM7XG5leHBvcnRzLsm1YiA9IEluamVjdGFibGVBbmltYXRpb25FbmdpbmU7XG5leHBvcnRzLsm1ZCA9IGluc3RhbnRpYXRlRGVmYXVsdFN0eWxlTm9ybWFsaXplcjtcbmV4cG9ydHMuybVlID0gaW5zdGFudGlhdGVSZW5kZXJlckZhY3Rvcnk7XG5leHBvcnRzLsm1YyA9IGluc3RhbnRpYXRlU3VwcG9ydGVkQW5pbWF0aW9uRHJpdmVyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGxhdGZvcm0tYnJvd3Nlci1hbmltYXRpb25zLnVtZC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2J1bmRsZXMvcGxhdGZvcm0tYnJvd3Nlci1hbmltYXRpb25zLnVtZC5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJpbXBvcnQgeyBSb3V0ZXIsIFJvdXRlcywgUm91dGVyTW9kdWxlIH0gZnJvbSBcIkBhbmd1bGFyL3JvdXRlclwiO1xyXG5pbXBvcnQgeyBNb2R1bGVXaXRoUHJvdmlkZXJzIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcclxuaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSBcIi4vYXBwL2FwcC5jb21wb25lbnRcIjtcclxuaW1wb3J0IHsgRXJyb3JDb21wb25lbnQgfSBmcm9tIFwiQGFwcC9lbmQtdXNlci9lcnJvci9lcnJvci5jb21wb25lbnRcIjtcclxuZXhwb3J0IGNvbnN0IHJvdXRlczogUm91dGVzID0gW1xyXG4gICAge1xyXG4gICAgICAgIHBhdGg6ICcnLCBsb2FkQ2hpbGRyZW46ICgpID0+IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7ICAocmVxdWlyZSBhcyBhbnkpLmVuc3VyZShbXSwgZnVuY3Rpb24gKHJlcXVpcmU6IGFueSkgeyAgICByZXNvbHZlKHJlcXVpcmUoJy5cXFxcYXBwXFxcXGVuZC11c2VyXFxcXGVuZC11c2VyLm1vZHVsZScpWydFbmRVc2VyTW9kdWxlJ10pOyAgfSk7fSlcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgcGF0aDogJ2FkbWluJywgbG9hZENoaWxkcmVuOiAoKSA9PiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyAgKHJlcXVpcmUgYXMgYW55KS5lbnN1cmUoW10sIGZ1bmN0aW9uIChyZXF1aXJlOiBhbnkpIHsgICAgcmVzb2x2ZShyZXF1aXJlKCcuXFxcXGFwcFxcXFxhZG1pblxcXFxhZG1pbi5tb2R1bGUnKVsnQWRtaW5Nb2R1bGUnXSk7ICB9KTt9KVxyXG4gICAgfSxcclxuICAgIHsgcGF0aDogJyoqJywgY29tcG9uZW50OiBFcnJvckNvbXBvbmVudCB9XHJcbl1cclxuZXhwb3J0IGNvbnN0IHJvdXRpbmc6IE1vZHVsZVdpdGhQcm92aWRlcnMgPSBSb3V0ZXJNb2R1bGUuZm9yUm9vdChyb3V0ZXMpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvYXBwLnJvdXRlci50cyIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBIdHRwTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XHJcbmltcG9ydCB7IFJvdXRlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XHJcbmltcG9ydCB7IHJvdXRpbmcgfSBmcm9tIFwiLi9hcHAucm91dGVyXCI7XHJcbmltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwL2FwcC5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBTZXJ2aWNlTW9kdWxlIH0gZnJvbSAnQHNlcnZpY2VzL3NlcnZpY2UubW9kdWxlJztcclxuaW1wb3J0IHsgVUlNb2R1bGUgfSBmcm9tICdAdWkvdWkubW9kdWxlJztcclxuaW1wb3J0IHsgRGlyZWN0aXZlTW9kdWxlfSBmcm9tICdAZGlyZWN0aXZlcy9kaXJlY3RpdmUubW9kdWxlJztcclxuaW1wb3J0IHsgU2hhcmVkTW9kdWxlIH0gZnJvbSAnQHNoYXJlZC9zaGFyZWQubW9kdWxlJztcclxuaW1wb3J0IHsgRXJyb3JDb21wb25lbnQgfSBmcm9tICdAYXBwL2VuZC11c2VyL2Vycm9yL2Vycm9yLmNvbXBvbmVudCc7XHJcbkBOZ01vZHVsZSh7XHJcbiAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnQsIEVycm9yQ29tcG9uZW50XHJcbiAgICBdLFxyXG4gICAgaW1wb3J0czogW1xyXG4gICAgICAgIENvbW1vbk1vZHVsZSxcclxuICAgICAgICBIdHRwTW9kdWxlLFxyXG4gICAgICAgIFNlcnZpY2VNb2R1bGUsXHJcbiAgICAgICAgU2hhcmVkTW9kdWxlLFxyXG4gICAgICAgIEZvcm1zTW9kdWxlLFxyXG4gICAgICAgIHJvdXRpbmcsXHJcbiAgICBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBBcHBNb2R1bGVTaGFyZWQge1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvYXBwLnNoYXJlZC5tb2R1bGUudHMiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgSW5wdXQsIE9uRGVzdHJveSwgQWZ0ZXJWaWV3SW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBKb2JTZXJ2aWNlIH0gZnJvbSAnQHNlcnZpY2VzL2JhY2tlbmQvam9iLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcclxuaW1wb3J0IHsgc2hhcmUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnaHVyZS1qb2JzLWNvbnRhaW5lcicsXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9qb2JzLWNvbnRhaW5lci5jb21wb25lbnQuaHRtbCcpLFxyXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9qb2JzLWNvbnRhaW5lci5jb21wb25lbnQuc2NzcycpXVxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIEpvYnNDb250YWluZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgQWZ0ZXJWaWV3SW5pdCB7XHJcbiAgICBcclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgfVxyXG4gICAgam9icyQ6IE9ic2VydmFibGU8Sm9iW10+IFxyXG4gICAgQElucHV0KCkgam9ic09ic2VydmVyOiBPYnNlcnZhYmxlPEpvYltdPi8vID0gbmV3IE9ic2VydmFibGU8Sm9iW10+KHN1Yj0+IHN1Yi5uZXh0KFtdKSlcclxuICAgIEBJbnB1dCgpIHRpdGxlOiBzdHJpbmcgPSBcIkPDtG5nIHZp4buHY1wiO1xyXG4gICAgQElucHV0KCkgbGltaXQ6IG51bWJlciA9IDU7XHJcbiAgICBASW5wdXQoKSBzaXplOnN0cmluZyA9ICdtZWRpdW0nO1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcblxyXG4gICAgfVxyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcbiAgICBuZ0FmdGVyVmlld0luaXQoKTp2b2lke1xyXG4gICAgICAgIHRoaXMuZ2V0RGF0YUFzeW5jKClcclxuICAgIH1cclxuICAgIGdldERhdGFBc3luYygpIHtcclxuICAgICAgIHRyeXtcclxuICAgICAgICBpZiAoIXRoaXMuam9icyQpIHtcclxuICAgICAgICAgICAgdGhpcy5qb2JzJCA9IHRoaXMuam9ic09ic2VydmVyLnBpcGUoc2hhcmUoKSlcclxuICAgICAgICB9XHJcbiAgICAgICB9Y2F0Y2goZXJyKXtcclxuICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpXHJcbiAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9hcHAvZW5kLXVzZXIvaG9tZS9jb21wb25lbnRzL2pvYnMtY29udGFpbmVyL2pvYnMtY29udGFpbmVyLmNvbXBvbmVudC50cyIsImltcG9ydCB7RGlyZWN0aXZlLCBFbGVtZW50UmVmLCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gICBzZWxlY3RvcjogJ1tjbGlja091dHNpZGVdJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgQ2xpY2tPdXRzaWRlRGlyZWN0aXZlIHtcclxuICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZiA6IEVsZW1lbnRSZWYpIHtcclxuICAgfVxyXG5cclxuICAgQE91dHB1dCgpXHJcbiAgIHB1YmxpYyBjbGlja091dHNpZGUgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcclxuXHJcbiAgIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmNsaWNrJywgWyckZXZlbnQudGFyZ2V0J10pXHJcbiAgIHB1YmxpYyBvbkNsaWNrKHRhcmdldEVsZW1lbnQ6YW55KSB7XHJcbiAgICAgICBjb25zdCBjbGlja2VkSW5zaWRlID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRhcmdldEVsZW1lbnQpO1xyXG4gICAgICAgaWYgKCFjbGlja2VkSW5zaWRlKSB7XHJcbiAgICAgICAgICAgdGhpcy5jbGlja091dHNpZGUuZW1pdChudWxsKTtcclxuICAgICAgIH1cclxuICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZGlyZWN0aXZlcy9jbGlja091dHNpZGUuZGlyZWN0aXZlLnRzIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgUmVuZGVyZXIyLEhvc3RMaXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1tob3ZlckVmZmVjdF0nLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgSG92ZXJFZmZlY3Qge1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjpSZW5kZXJlcjIgLHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xyXG4gICAgfVxyXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpIG9ubW91c2VlbnRlcigpe1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdhY3RpdmUnKTtcclxuICAgIH1cclxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSBvbm1vdXNlbGVhdmUoKXtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnYWN0aXZlJyk7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9kaXJlY3RpdmVzL2hvdmVyRWZmZWN0LmRpcmVjdGl2ZS50cyIsImltcG9ydCB7IERpcmVjdGl2ZSwgSG9zdExpc3RlbmVyLCBFbGVtZW50UmVmLCBSZW5kZXJlciwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IHN0eWxlLCBhbmltYXRlLCBncm91cCwgQW5pbWF0aW9uQnVpbGRlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xyXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbcmlwcGxlRWZmZWN0XScgfSlcclxuZXhwb3J0IGNsYXNzIFJpcHBsZURpcmVjdGl2ZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlciwgcHJpdmF0ZSByZW5kZXJlcjI6IFJlbmRlcmVyMikge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ292ZXJmbG93JywgJ2hpZGRlbicpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyk7XHJcbiAgICB9XHJcbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZWRvd24nLCBbJyRldmVudCddKSBvbm1vdXNlZG93bihldmVudDogYW55KSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVTaGFwZVJpcHBsZShldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKVxyXG4gICAgfVxyXG4gICAgY3JlYXRlU2hhcGVSaXBwbGUoeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcclxuICAgICAgICB2YXIgcmlwcGxlID0gdGhpcy5yZW5kZXJlci5jcmVhdGVFbGVtZW50KHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2RpdicpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHJpcHBsZSwgJ2JvcmRlci1yYWRpdXMnLCAnMjBweCcpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHJpcHBsZSwgJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUocmlwcGxlLCAnaGVpZ2h0JywgJzQwcHgnKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRTdHlsZShyaXBwbGUsICd3aWR0aCcsICc0MHB4Jyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUocmlwcGxlLCAncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xyXG4gICAgICAgIGxldCBjb2xvckJhY2tncm91bmQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpLmJhY2tncm91bmRDb2xvciB8fCBcInJnYmEoMCwwLDAsMClcIjtcclxuICAgICAgICBsZXQgY29sb3JBcnIgPSBjb2xvckJhY2tncm91bmQucmVwbGFjZSgncmdiYScsICcnKS5yZXBsYWNlKCdyZ2InLCAnJykucmVwbGFjZSgnKScsICcnKS5yZXBsYWNlKCcoJywgJycpLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgaWYgKGNvbG9yQXJyLmZpbHRlcih0ID0+IHQudHJpbSgpID09PSBcIjBcIikubGVuZ3RoID49IDMgfHwgY29sb3JCYWNrZ3JvdW5kID09IFwidHJhbnNwYXJlbnRcIikge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRTdHlsZShyaXBwbGUsICdiYWNrZ3JvdW5kJywgJ2JsYWNrJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUocmlwcGxlLCAnYmFja2dyb3VuZCcsICd3aGl0ZScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUocmlwcGxlLCAnbGVmdCcsICh4IC0gMTApLnRvU3RyaW5nKCkgKyAncHgnKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRTdHlsZShyaXBwbGUsICd0b3AnLCAoeSAtIDEwKS50b1N0cmluZygpICsgJ3B4Jyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUocmlwcGxlLCAnb3BhY2l0eScsICcwLjUnKTtcclxuICAgICAgICBsZXQgc2NhbGVOdW1iZXIgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggLyA0MDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRTdHlsZShyaXBwbGUsICd0cmFuc2l0aW9uJywgJ2FsbCAuOHMgZWFzZS1vdXQnKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRTdHlsZShyaXBwbGUsICdvcGFjaXR5JywgJzAnKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRTdHlsZShyaXBwbGUsICd0cmFuc2Zvcm0nLCAnc2NhbGUoJyArIHNjYWxlTnVtYmVyICogMiArICcpJyk7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlbmRlcmVyMi5yZW1vdmVDaGlsZCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsIHJpcHBsZSksIDgwMCk7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9kaXJlY3RpdmVzL3JpcHBsZS5kaXJlY3RpdmUudHMiLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENhbkFjdGl2YXRlLCBSb3V0ZXIsIEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIFJvdXRlclN0YXRlU25hcHNob3QgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5pbXBvcnQgeyBKd3RIZWxwZXIgfSBmcm9tICdhbmd1bGFyMi1qd3QnO1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBBdXRoR3VhcmQgaW1wbGVtZW50cyBDYW5BY3RpdmF0ZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByb3V0ZXI6IFJvdXRlcikgeyB9XHJcblxyXG4gICAgcHVibGljIGNhbkFjdGl2YXRlKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBzdGF0ZTogUm91dGVyU3RhdGVTbmFwc2hvdCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBqd3QgPSBuZXcgSnd0SGVscGVyKCk7XHJcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbl9odXJlJyk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGp3dC5pc1Rva2VuRXhwaXJlZCh0b2tlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZShbXCJcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFtcIlwiXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZ3VhcmRzL2F1dGguZ3VhcmQudHMiLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENhbkFjdGl2YXRlLCBSb3V0ZXIsIEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIFJvdXRlclN0YXRlU25hcHNob3QgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5pbXBvcnQgeyBKd3RIZWxwZXIgfSBmcm9tICdhbmd1bGFyMi1qd3QnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQ29tcGFueUd1YXJkIGltcGxlbWVudHMgQ2FuQWN0aXZhdGUge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3JvdXRlcjogUm91dGVyKSB7IH1cclxuXHJcbiAgICBwdWJsaWMgY2FuQWN0aXZhdGUocm91dGU6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIHN0YXRlOiBSb3V0ZXJTdGF0ZVNuYXBzaG90KTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHsgLy8gY2hlY2sgaWYgbm90IGxvY2FsU3RvcmFnZSBpcyBub3QgZGVmaW5lZFxyXG4gICAgICAgICAgICB2YXIgand0ID0gbmV3IEp3dEhlbHBlcigpO1xyXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW5faHVyZScpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChqd3QuaXNUb2tlbkV4cGlyZWQodG9rZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcm91dGVyLm5hdmlnYXRlKFtcImRvYW5obmdoaWVwL2xvZ2luXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByb2xlSnNvbiA9IGp3dC5kZWNvZGVUb2tlbih0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvbGUgPSByb2xlSnNvbi5Sb2xlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb2xlID09IFwiQ29tcGFueVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yb3V0ZXIubmF2aWdhdGUoW1wiZG9hbmhuZ2hpZXAvbG9naW5cIl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZ3VhcmRzL2NvbXBhbnkuZ3VhcmQudHMiLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBBZG1pbkd1YXJkIH0gZnJvbSAnQGd1YXJkcy9hZG1pbi5ndWFyZCc7XHJcbmltcG9ydCB7IEF1dGhHdWFyZCB9IGZyb20gJ0BndWFyZHMvYXV0aC5ndWFyZCc7XHJcbmltcG9ydCB7IFN0dWRlbnRHdWFyZH0gZnJvbSAnQGd1YXJkcy9zdHVkZW50Lmd1YXJkJztcclxuaW1wb3J0IHsgQ29tcGFueUd1YXJkfSBmcm9tICdAZ3VhcmRzL2NvbXBhbnkuZ3VhcmQnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICAgIGltcG9ydHM6IFtdLFxyXG4gICAgZXhwb3J0czogW10sXHJcbiAgICBkZWNsYXJhdGlvbnM6IFtdLFxyXG4gICAgcHJvdmlkZXJzOiBbQWRtaW5HdWFyZCxBdXRoR3VhcmQsU3R1ZGVudEd1YXJkLENvbXBhbnlHdWFyZF0sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBHdWFyZE1vZHVsZSB7IH1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZ3VhcmRzL2d1YXJkLm1vZHVsZS50cyIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ2FuQWN0aXZhdGUsIFJvdXRlciwgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgUm91dGVyU3RhdGVTbmFwc2hvdCB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XHJcbmltcG9ydCB7IEp3dEhlbHBlciB9IGZyb20gJ2FuZ3VsYXIyLWp3dCc7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTdHVkZW50R3VhcmQgaW1wbGVtZW50cyBDYW5BY3RpdmF0ZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcm91dGVyOiBSb3V0ZXIpIHsgfVxyXG5cclxuICAgIHB1YmxpYyBjYW5BY3RpdmF0ZShyb3V0ZTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgc3RhdGU6IFJvdXRlclN0YXRlU25hcHNob3QpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikgeyAvLyBjaGVjayBpZiBub3QgbG9jYWxTdG9yYWdlIGlzIG5vdCBkZWZpbmVkXHJcbiAgICAgICAgICAgIHZhciBqd3QgPSBuZXcgSnd0SGVscGVyKCk7XHJcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbl9odXJlJyk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGp3dC5pc1Rva2VuRXhwaXJlZCh0b2tlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yb3V0ZXIubmF2aWdhdGUoW1wic2luaHZpZW4vbG9naW5cIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvbGVKc29uID0gand0LmRlY29kZVRva2VuKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm9sZSA9IHJvbGVKc29uLlJvbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvbGUgPT0gXCJTdHVkZW50XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JvdXRlci5uYXZpZ2F0ZShbXCJzaW5odmllbi9sb2dpblwiXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9ndWFyZHMvc3R1ZGVudC5ndWFyZC50cyIsImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBQaXBlKHtcclxuICBuYW1lOiAnbGltaXRUZXh0J1xyXG59KVxyXG5leHBvcnQgY2xhc3MgTGltaXRUZXh0UGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xyXG5cclxuICB0cmFuc2Zvcm0odmFsdWU6IGFueSwgbGltaXQ6IG51bWJlciA9IDEwMCk6IHN0cmluZyB7XHJcbiAgICBcclxuICAgIGxldCB2YWwgPSB2YWx1ZSBhcyBzdHJpbmc7XHJcbiAgICBpZiAodmFsLmxlbmd0aCA+IGxpbWl0KSB7XHJcbiAgICAgIHJldHVybiB2YWwuc2xpY2UoMCwgbGltaXQtMykgKyBcIi4uLlwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxuICB9XHJcblxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvcGlwZXMvbGltaXQtdGV4dC5waXBlLnRzIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBQcm9ncmVzc1NlcnZpY2Uge1xyXG4gICAgcHJvZ3Jlc3NDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIHB1YmxpYyBzZXRQZXJjZW50ID0gKHBlcmNlbnQ6IG51bWJlcikgPT5cclxuICAgICAgICB0aGlzLnByb2dyZXNzQ2hhbmdlZC5lbWl0KHBlcmNlbnQpO1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2VydmljZXMvZnJvbnRlbmQvcHJvZ3Jlc3Muc2VydmljZS50cyIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcblxyXG5pbXBvcnQgeyBDb25maXJtU2VydmljZSB9IGZyb20gJy4vZnJvbnRlbmQvY29uZmlybS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQWxlcnRTZXJ2aWNlIH0gZnJvbSAnLi9mcm9udGVuZC9hbGVydC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUHJvZ3Jlc3NTZXJ2aWNlIH0gZnJvbSAnLi9mcm9udGVuZC9wcm9ncmVzcy5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTG9hZGluZ1NlcnZpY2UgfSBmcm9tICcuL2Zyb250ZW5kL2xvYWRpbmcuc2VydmljZSc7XHJcbmltcG9ydCB7IENvbW1vbkh0dHBTZXJ2aWNlIH0gZnJvbSAnLi9iYWNrZW5kL2NvbW1vbi1odHRwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBBdXRoU2VydmljZSB9IGZyb20gXCJAc2VydmljZXMvYmFja2VuZC9hdXRoLnNlcnZpY2VcIjtcclxuaW1wb3J0IHsgQ29yZU1vZHVsZSB9IGZyb20gJ0Bjb3JlL2NvcmUubW9kdWxlJztcclxuaW1wb3J0IHsgSm9iU2VydmljZSB9IGZyb20gJ0BzZXJ2aWNlcy9iYWNrZW5kL2pvYi5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSHR0cE1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xyXG5pbXBvcnQgeyBQcm9maWxlU2VydmljZSB9IGZyb20gJ0BzZXJ2aWNlcy9iYWNrZW5kL3Byb2ZpbGUuc2VydmljZSc7XHJcbmltcG9ydCB7IExvY2FsU2VydmljZSB9IGZyb20gJ0BzZXJ2aWNlcy9iYWNrZW5kL2xvY2FsLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBFdmVudFNlcnZpY2UgfSBmcm9tIFwiQHNlcnZpY2VzL2JhY2tlbmQvZXZlbnQuc2VydmljZVwiO1xyXG5pbXBvcnQgeyBKb2JHcm91cFNlcnZpY2UgfSBmcm9tICdAc2VydmljZXMvYmFja2VuZC9qb2ItZ3JvdXAuc2VydmljZSc7XHJcbmltcG9ydCB7IFJvbGVTZXJ2aWNlIH0gZnJvbSAnQHNlcnZpY2VzL2JhY2tlbmQvcm9sZS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgV29ya1R5cGVTZXJ2aWNlIH0gZnJvbSAnQHNlcnZpY2VzL2JhY2tlbmQvd29yay10eXBlLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBDb21wYW55U2VydmljZSB9IGZyb20gJ0BzZXJ2aWNlcy9iYWNrZW5kL2NvbXBhbnkuc2VydmljZSc7XHJcbmltcG9ydCB7IERhdGFTZXJ2aWNlIH0gZnJvbSAnQHNlcnZpY2VzL2Zyb250ZW5kL2RhdGEuc2VydmljZSc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gICAgZGVjbGFyYXRpb25zOiBbXSxcclxuICAgIGltcG9ydHM6IFsgQ29tbW9uTW9kdWxlLCBIdHRwTW9kdWxlIF0sXHJcbiAgICBleHBvcnRzOiBbXSxcclxuICAgIHByb3ZpZGVyczogW0NvbmZpcm1TZXJ2aWNlLCBBbGVydFNlcnZpY2UsIFByb2dyZXNzU2VydmljZSwgTG9hZGluZ1NlcnZpY2UsIENvbW1vbkh0dHBTZXJ2aWNlLEF1dGhTZXJ2aWNlLERhdGFTZXJ2aWNlLFxyXG4gICAgSm9iU2VydmljZSwgUHJvZmlsZVNlcnZpY2UsIExvY2FsU2VydmljZSxFdmVudFNlcnZpY2UsIEpvYkdyb3VwU2VydmljZSwgUm9sZVNlcnZpY2UsIFdvcmtUeXBlU2VydmljZSwgQ29tcGFueVNlcnZpY2VdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgU2VydmljZU1vZHVsZSB7fVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3NlcnZpY2VzL3NlcnZpY2UubW9kdWxlLnRzIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE1lbnVJdGVtIH0gZnJvbSAnQHVpL2FjdGlvbi1tZW51L2FjdGlvbi1tZW51LmNvbXBvbmVudCc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnaHVyZS1hY3Rpb24taXRlbScsXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9hY3Rpb24taXRlbS5jb21wb25lbnQuaHRtbCcpLFxyXG4gICAgc3R5bGVzOltyZXF1aXJlKCcuL2FjdGlvbi1pdGVtLmNvbXBvbmVudC5zY3NzJyldXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgQWN0aW9uSXRlbUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XHJcbiAgICBASW5wdXQoKSBpdGVtOiBNZW51SXRlbTtcclxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XHJcblxyXG4gICAgbmdPbkluaXQoKSB7IH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2FjdGlvbi1tZW51L2FjdGlvbi1pdGVtL2FjdGlvbi1pdGVtLmNvbXBvbmVudC50cyIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ2h1cmUtYWN0aW9uLW1lbnUnLFxyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vYWN0aW9uLW1lbnUuY29tcG9uZW50Lmh0bWwnKSxcclxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vYWN0aW9uLW1lbnUuY29tcG9uZW50LnNjc3MnKV1cclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBBY3Rpb25NZW51Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcclxuICAgIEBJbnB1dCgpIGl0ZW1zOiBNZW51SXRlbVtdXHJcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCkgeyB9XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBNZW51SXRlbSB7XHJcbiAgICBpY29uQ2xhc3M6IHN0cmluZyxcclxuICAgIHRleHQ6IHN0cmluZyxcclxuICAgIGFjdGlvbj86ICgpID0+IHZvaWQsXHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9hY3Rpb24tbWVudS9hY3Rpb24tbWVudS5jb21wb25lbnQudHMiLCJpbXBvcnR7Q29tcG9uZW50LElucHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjonaHVyZS1ibG9nJyxcclxuICAgIHRlbXBsYXRlOnJlcXVpcmUoJy4vYmxvZy5jb21wb25lbnQuaHRtbCcpLFxyXG4gICAgc3R5bGVzOltyZXF1aXJlKCcuL2Jsb2cuY29tcG9uZW50LnNjc3MnKV1cclxufSlcclxuZXhwb3J0IGNsYXNzIEJsb2dDb21wb25lbnR7XHJcbiAgICBASW5wdXQoKSBpbWFnZTogc3RyaW5nO1xyXG4gICAgQElucHV0KCkgbGluazogc3RyaW5nO1xyXG4gICAgQElucHV0KCkgbGlua3RvdGltZTogc3RyaW5nO1xyXG4gICAgQElucHV0KCkgbGlua2NvbW1lbnQ6IHN0cmluZztcclxuICAgIEBJbnB1dCgpIHRpdGxlOiBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBjb250ZW50OiBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSB0aW1lOiBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBjb21tZW50OiBzdHJpbmc7XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9ibG9nL2Jsb2cuY29tcG9uZW50LnRzIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7IFxyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ2h1cmUtY2FyZCcsXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9jYXJkLmNvbXBvbmVudC5odG1sJyksXHJcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2NhcmQuY29tcG9uZW50LnNjc3MnKV0sXHJcblxyXG59KVxyXG5leHBvcnQgY2xhc3MgQ2FyZENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XHJcbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcm91dGVyOiBSb3V0ZXIpIHsgfVxyXG4gICAgQElucHV0KCkgZXZlbnQ6IEV2ZW50SXRlbTsgXHJcbiAgICBhcHBseSgpIHtcclxuICAgICAgICBpZiAodGhpcy5ldmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZShbJ2V2ZW50cycsIHRoaXMuZXZlbnQgPyB0aGlzLmV2ZW50LmlkLnRvU3RyaW5nKCkgOiAxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvY2FyZC9jYXJkLmNvbXBvbmVudC50cyIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCwgQWZ0ZXJWaWV3SW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyB0cmlnZ2VyLCB0cmFuc2l0aW9uLCBzdHlsZSwgYW5pbWF0ZSwgc3RhdGUgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcclxuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIsIGlzUGxhdGZvcm1TZXJ2ZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ2h1cmUtY2Fyb3VzZWwtbGlzdCcsXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9jYXJvdXNlbC1saXN0LmNvbXBvbmVudC5odG1sJyksXHJcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2Nhcm91c2VsLWxpc3QuY29tcG9uZW50LnNjc3MnKV0sXHJcbiAgICBhbmltYXRpb25zOiBbXHJcbiAgICAgICAgdHJpZ2dlcignaXRlbURpcycsIFtcclxuICAgICAgICAgICAgc3RhdGUoJ3ZvaWQnLCBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknfSkpLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBbXHJcbiAgICAgICAgICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMTAwJSknfSksXHJcbiAgICAgICAgICAgICAgICBhbmltYXRlKCc1MDBtcyBlYXNlLW91dCcpXHJcbiAgICAgICAgICAgIF0pLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCcqID0+IHZvaWQnLCBbXHJcbiAgICAgICAgICAgICAgICBhbmltYXRlKCc1MDBtcyBlYXNlLWluJywgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC0xMDAlKScgfSkpXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgXSlcclxuICAgIF1cclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBDYXJvdXNlbExpc3RDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQge1xyXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc2xpZGUoKVxyXG4gICAgfVxyXG5cclxuICAgIEBJbnB1dCgpIGxpc3RJdGVtOiBDYXJvdXNlbEl0ZW1bXVxyXG4gICAgQElucHV0KCkgc2hvdzogbnVtYmVyID0gNDtcclxuICAgIEBJbnB1dCgpIHNpemU6IG51bWJlciA9IDEzNjtcclxuICAgIHB1YmxpYyBzdGF0aWMgc2VydmVyOiBzdHJpbmc7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuXHJcbiAgICB9XHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgIH1cclxuICAgIHNsaWRlKCkge1xyXG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5saXN0SXRlbS5zaGlmdCgpO1xyXG4gICAgICAgIHRoaXMubGlzdEl0ZW0ucHVzaChpdGVtISk7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNsaWRlKCksIDMwMDApXHJcbiAgICB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBDYXJvdXNlbEl0ZW0ge1xyXG4gICAgaW1nOiBzdHJpbmc7XHJcbiAgICB0ZXh0OiBzdHJpbmdcclxuICAgIHVybDogc3RyaW5nO1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvY2Fyb3VzZWwtbGlzdC9jYXJvdXNlbC1saXN0LmNvbXBvbmVudC50cyIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCwgQWZ0ZXJWaWV3SW5pdCwgT25DaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IERyb3Bkb3duQ29tcG9uZW50IH0gZnJvbSAnLi4vZHJvcGRvd24uY29tcG9uZW50JztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdodXJlLWRyb3Bkb3duLWl0ZW0nLFxyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vZHJvcGRvd25JdGVtLmNvbXBvbmVudC5odG1sJylcclxufSlcclxuZXhwb3J0IGNsYXNzIERyb3Bkb3duSXRlbUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XHJcblxyXG4gICAgLy8gdmFsdWUgaXMgb2JqZWN0O1xyXG4gICAgQElucHV0KCkgdmFsdWU6IGFueTtcclxuICAgIC8vIGNvbnRlbnQgaXMgb3B0aW9uIHRleHQgaW4gZHJvcGRvd25cclxuICAgIEBJbnB1dCgpIHRleHQ6IHN0cmluZztcclxuICAgIEBJbnB1dCgpIGlzU2VsZWN0ZWQ6IGJvb2xlYW47XHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRyb3Bkb3duOiBEcm9wZG93bkNvbXBvbmVudCkge1xyXG4gICAgICAgIHRoaXMuZHJvcGRvd24uYWRkSXRlbSh0aGlzKTtcclxuICAgIH1cclxuICAgIHNlbGVjdEl0ZW0oKSB7XHJcbiAgICAgICAgdGhpcy5kcm9wZG93bi5zZWxlY3RJdGVtRW1pdCh0aGlzKTtcclxuICAgIH1cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5zZWxlY3RJdGVtKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2Ryb3Bkb3duL2Ryb3Bkb3duSXRlbS9kcm9wZG93bkl0ZW0uY29tcG9uZW50LnRzIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIEVsZW1lbnRSZWYsIFZpZXdDaGlsZCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IHRyaWdnZXIsIHN0YXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgYW5pbWF0ZSwgZ3JvdXAgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ2h1cmUtZXhwYW5zaWJsZS1jYXJkJyxcclxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2V4cGFuc2libGUtY2FyZC5jb21wb25lbnQuaHRtbCcpLFxyXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9leHBhbnNpYmxlLWNhcmQuY29tcG9uZW50LnNjc3MnKV0sXHJcbiAgICBhbmltYXRpb25zOiBbXHJcbiAgICAgICAgdHJpZ2dlcignZXhwYW5kQ2hhbmdlZCcsIFtcclxuICAgICAgICAgICAgc3RhdGUoJzAnLCBzdHlsZSh7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcyMDBweCdcclxuICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICBzdGF0ZSgnMScsIHN0eWxlKHtcclxuICAgICAgICAgICAgICAgIGhlaWdodDogJ2F1dG8nLCBcclxuICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCcxID0+IDAnLCBbXHJcbiAgICAgICAgICAgICAgICBzdHlsZSh7IGhlaWdodDogJyonIH0pLFxyXG4gICAgICAgICAgICAgICAgYW5pbWF0ZSgxMDAsIHN0eWxlKHsgaGVpZ2h0OiAyMDAgfSkpXHJcbiAgICAgICAgICAgIF0pLCB0cmFuc2l0aW9uKCcwID0+IDEnLCBbXHJcbiAgICAgICAgICAgICAgICBzdHlsZSh7IGhlaWdodDogMjAwIH0pLFxyXG4gICAgICAgICAgICAgICAgYW5pbWF0ZSgxMDAsIHN0eWxlKHsgaGVpZ2h0OiAnKicgfSkpXHJcbiAgICAgICAgICAgIF0pLFxyXG4gICAgICAgIF0pXHJcbiAgICBdXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgRXhwYW5zaWJsZUNhcmRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xyXG4gICAgaXNFeHBhbmRlZCA9IGZhbHNlO1xyXG4gICAgY29uc3RydWN0b3IoKSB7IH1cclxuICAgIG5nT25Jbml0KCkgeyB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9leHBhbnNpYmxlLWNhcmQvZXhwYW5zaWJsZS1jYXJkLmNvbXBvbmVudC50cyIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnaHVyZS1ncm91cCcsXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9ncm91cC5jb21wb25lbnQuaHRtbCcpLFxyXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9ncm91cC5jb21wb25lbnQuc2NzcycpXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgR3JvdXBDb21wb25lbnQge1xyXG4gICAgQElucHV0KCkgaW1hZ2U6IHN0cmluZztcclxuICAgIEBJbnB1dCgpIGxpbms6IHN0cmluZztcclxuICAgIEBJbnB1dCgpIHRleHQ6IHN0cmluZztcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2dyb3VwL2dyb3VwLmNvbXBvbmVudC50cyIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHsgRGF0YVNlcnZpY2UgfSBmcm9tICdAc2VydmljZXMvZnJvbnRlbmQvZGF0YS5zZXJ2aWNlJztcclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ2h1cmUtam9iJyxcclxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2pvYi5jb21wb25lbnQuaHRtbCcpLFxyXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9qb2IuY29tcG9uZW50LnNjc3MnKV1cclxufSlcclxuZXhwb3J0IGNsYXNzIEpvYkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJvdXRlcjogUm91dGVyLCBwcml2YXRlIGRhdGE6RGF0YVNlcnZpY2UpIHsgfVxyXG4gICAgQElucHV0KCkgam9iOiBKb2I7XHJcbiAgICBASW5wdXQoKSBzaXplOnN0cmluZz0gJ21lZGl1bSc7XHJcbiAgICBhcHBseSgpIHtcclxuICAgICAgICBpZih0aGlzLmpvYil7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5kYXRhID0gdGhpcy5qb2I7XHJcbiAgICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFsnam9icycsJ2RldGFpbHMnLCB0aGlzLmpvYj90aGlzLmpvYi5pZC50b1N0cmluZygpOjFdKTtcclxuICAgICAgICAgLy8gIHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwoYC9qb2JzL2RldGFpbHMvJHt0aGlzLmpvYj90aGlzLmpvYi5pZC50b1N0cmluZygpOjF9YClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9qb2Ivam9iLmNvbXBvbmVudC50cyIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdodXJlLW92ZXJsYXknLFxyXG4gIHRlbXBsYXRlOiByZXF1aXJlKCcuL292ZXJsYXkuY29tcG9uZW50Lmh0bWwnKSxcclxuICBzdHlsZXM6IFtyZXF1aXJlKCcuL292ZXJsYXkuY29tcG9uZW50LnNjc3MnKV1cclxufSlcclxuZXhwb3J0IGNsYXNzIE92ZXJsYXlDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xyXG4gIEBJbnB1dCgpIGlzQWN0aXZhdGVkOmJvb2xlYW49ZmFsc2VcclxuICBjb25zdHJ1Y3RvcigpIHsgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICB9XHJcblxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL292ZXJsYXkvb3ZlcmxheS5jb21wb25lbnQudHMiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgSW5wdXQsIEVsZW1lbnRSZWYsIFZpZXdDaGlsZCwgUmVuZGVyZXIsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyB0cmlnZ2VyLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIGFuaW1hdGUsIGdyb3VwIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdodXJlLXBvcG92ZXInLFxyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vcG9wb3Zlci5jb21wb25lbnQuaHRtbCcpLFxyXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9wb3BvdmVyLmNvbXBvbmVudC5zY3NzJyldLCBhbmltYXRpb25zOiBbXHJcbiAgICAgICAgdHJpZ2dlcignbWVudUNoYW5nZWQnLCBbXHJcbiAgICAgICAgICAgIHN0YXRlKCcwJywgc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMCcsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgIHN0YXRlKCcxJywgc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnYXV0bycsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICBdKVxyXG4gICAgXVxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIFBvcG92ZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xyXG4gICAgc3RhdGUgPSBmYWxzZTtcclxuICAgIGVuYWJsZWQgPSBmYWxzZTtcclxuICAgIEBWaWV3Q2hpbGQoJ2J0bicpIGJ0bjogRWxlbWVudFJlZjtcclxuICAgIEBWaWV3Q2hpbGQoJ3BvcG92ZXInKSBwb3BvdmVyOiBFbGVtZW50UmVmO1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIsIHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZiwgcHJpdmF0ZSByZW5kZXJlcjI6IFJlbmRlcmVyMikgeyB9XHJcbiAgICBjaGFuZ2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgbGV0IHBhcmVuVG9wID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICBsZXQgcGFyZW50TGVmdCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldExlZnQgfHwgd2luZG93LmlubmVyV2lkdGggLSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRSaWdodCAtIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICBsZXQgcGFyZW50SGVpZ2h0ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICBsZXQgcGFyZW50V2lkdGggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgbGV0IHBhcmVudFJpZ2h0ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0UmlnaHQgfHwgd2luZG93LmlubmVyV2lkdGggLSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0IC0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgIGxldCBwb3BvdmVyV2lkdGggPSB0aGlzLnBvcG92ZXIubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5wb3BvdmVyLm5hdGl2ZUVsZW1lbnQsICd0b3AnLCBwYXJlbnRIZWlnaHQrIDIyICsgJ3B4Jyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMucG9wb3Zlci5uYXRpdmVFbGVtZW50LCAnbGVmdCcsICcwJyk7XHJcbiAgICAgICAgICAgIGxldCBzaXplT3V0UmlnaHQgPSBwYXJlbnRMZWZ0ICsgcGFyZW50V2lkdGggLyAyICsgcG9wb3ZlcldpZHRoIC8gMiAtIHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgICAgICAgICBsZXQgc2l6ZU91dExlZnQgPSBwYXJlbnRSaWdodCArIHBhcmVudFdpZHRoIC8gMiArIHBvcG92ZXJXaWR0aCAvIDIgLSB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgICAgICAgaWYgKHNpemVPdXRMZWZ0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbFRvVHJhbnNmb3JtID0gc2l6ZU91dExlZnQgKyA4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5wb3BvdmVyLm5hdGl2ZUVsZW1lbnQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlWCgnICsgIDEgKyAncHgpJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2l6ZU91dFJpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbFRvVHJhbnNmb3JtID0gc2l6ZU91dFJpZ2h0ICsgODtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5wb3BvdmVyLm5hdGl2ZUVsZW1lbnQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlWCgnICsgKC1wb3BvdmVyV2lkdGggLyAyIC0gdmFsVG9UcmFuc2Zvcm0pICsgJ3B4KScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAhdGhpcy5zdGF0ZTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWVcclxuICAgICAgICAgICAgfSwgMTAwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlSXQoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsb3NlSXQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLnBvcG92ZXIubmF0aXZlRWxlbWVudCwgJ3RvcCcsIC0xMDAwMCArICdweCcpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG5nT25Jbml0KCkgeyB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9wb3BvdmVyL3BvcG92ZXIuY29tcG9uZW50LnRzIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPdXRwdXQsIElucHV0IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdodXJlLXJhdGluZy1iYXInLFxyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vcmF0aW5nLmNvbXBvbmVudC5odG1sJyksXHJcbiAgICBzdHlsZXM6IFtgXHJcbiAgICAgICAgLmZpbGx7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IGJsYWNrO1xyXG4gICAgICAgIH1cclxuICAgIGBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBSYXRpbmdCYXJDb21wb25lbnQge1xyXG4gICAgdGV4dFJhdGluZyA9IFtcIlZlcnkgQmFkXCIsIFwiQmFkXCIsIFwiU28gc29cIiwgXCJHb29kXCIsIFwiUGVyZmVjdFwiXVxyXG4gICAgQElucHV0KCkgcmF0aW5nOiBudW1iZXIgPSAwO1xyXG4gICAgQElucHV0KCkgbWF4OiBudW1iZXIgPSA1O1xyXG4gICAgcmFuZ2Uoc3RhcjogbnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPD0gdGhpcy5tYXg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgYXJyLnB1c2goaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG4gICAgc2VsZWN0U3RhcihpOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLnJhdGluZyA9IGk7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9yYXRpbmcvcmF0aW5nLmNvbXBvbmVudC50cyIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBUYWJiZWRDb21wb25lbnQgfSBmcm9tICcuLi90YWJiZWQuY29tcG9uZW50JztcclxuaW1wb3J0IHsgdHJpZ2dlciwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCBhbmltYXRlLCBncm91cCB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnaHVyZS10YWInLFxyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vdGFiLmNvbXBvbmVudC5odG1sJyksXHJcbiAgICBhbmltYXRpb25zOiBbXHJcbiAgICAgICAgdHJpZ2dlcigndGFiQ2hhbmdlZCcsIFtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbigndm9pZCA9PiAqJywgW1xyXG4gICAgICAgICAgICAgICAgc3R5bGUoeyBvcGFjaXR5OjEsIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTEwMCUpJyB9KSxcclxuICAgICAgICAgICAgICAgIGFuaW1hdGUoMjUwKVxyXG4gICAgICAgICAgICBdKSxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgW1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0ZSgyNTAsIHN0eWxlKHsgb3BhY2l0eTowLCB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDEwMCUpJyB9KSlcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICBdKVxyXG4gICAgXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgVGFiQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcclxuICAgIEBJbnB1dCgpIHRpdGxlOiBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBpc0FjdGl2YXRlZDogYm9vbGVhbjtcclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgdGFiYmVkOiBUYWJiZWRDb21wb25lbnQpIHtcclxuICAgICAgICB0aGlzLnRhYmJlZC5hZGRUYWIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkluaXQoKSB7IFxyXG4gICAgICAgIGlmKHRoaXMuaXNBY3RpdmF0ZWQpe1xyXG4gICAgICAgICAgICB0aGlzLnRhYmJlZC5zZWxlY3RUYWIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvdGFiYmVkL3RhYi90YWIuY29tcG9uZW50LnRzIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgdHJpZ2dlciwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCBhbmltYXRlLCBncm91cCB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnaHVyZS13YWl0ZXInLFxyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vd2FpdGVyLmNvbXBvbmVudC5odG1sJyksXHJcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL3dhaXRlci5jb21wb25lbnQuc2NzcycpXSxcclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBXYWl0ZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7IH1cclxuXHJcbiAgICBuZ09uSW5pdCgpIHsgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvd2FpdGVyL3dhaXRlci5jb21wb25lbnQudHMiLCJpbXBvcnQgJ3JlZmxlY3QtbWV0YWRhdGEnO1xyXG5pbXBvcnQgJ3pvbmUuanMnO1xyXG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL2ZpcnN0JztcclxuaW1wb3J0IHsgQVBQX0JBU0VfSFJFRiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IGVuYWJsZVByb2RNb2RlLCBBcHBsaWNhdGlvblJlZiwgTmdab25lLCBWYWx1ZVByb3ZpZGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IHBsYXRmb3JtRHluYW1pY1NlcnZlciwgUGxhdGZvcm1TdGF0ZSwgSU5JVElBTF9DT05GSUcgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1zZXJ2ZXInO1xyXG5pbXBvcnQgeyBjcmVhdGVTZXJ2ZXJSZW5kZXJlciwgUmVuZGVyUmVzdWx0IH0gZnJvbSAnYXNwbmV0LXByZXJlbmRlcmluZyc7XHJcbmltcG9ydCB7IEFwcE1vZHVsZSB9IGZyb20gJy4vYXBwL2FwcC5zZXJ2ZXIubW9kdWxlJztcclxuXHJcbmVuYWJsZVByb2RNb2RlKCk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTZXJ2ZXJSZW5kZXJlcihwYXJhbXMgPT4ge1xyXG4gICAgY29uc3QgcHJvdmlkZXJzID0gW1xyXG4gICAgICAgIHsgcHJvdmlkZTogSU5JVElBTF9DT05GSUcsIHVzZVZhbHVlOiB7IGRvY3VtZW50OiAnPGFwcD48L2FwcD4nLCB1cmw6IHBhcmFtcy51cmwgfSB9LFxyXG4gICAgICAgIHsgcHJvdmlkZTogQVBQX0JBU0VfSFJFRiwgdXNlVmFsdWU6IHBhcmFtcy5iYXNlVXJsIH0sXHJcbiAgICAgICAgeyBwcm92aWRlOiAnQkFTRV9VUkwnLCB1c2VWYWx1ZTogcGFyYW1zLm9yaWdpbiArIHBhcmFtcy5iYXNlVXJsIH0sXHJcbiAgICBdO1xyXG5cclxuICAgIHJldHVybiBwbGF0Zm9ybUR5bmFtaWNTZXJ2ZXIocHJvdmlkZXJzKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKS50aGVuKG1vZHVsZVJlZiA9PiB7XHJcbiAgICAgICAgY29uc3QgYXBwUmVmOiBBcHBsaWNhdGlvblJlZiA9IG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoQXBwbGljYXRpb25SZWYpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChQbGF0Zm9ybVN0YXRlKTtcclxuICAgICAgICBjb25zdCB6b25lID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChOZ1pvbmUpO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8UmVuZGVyUmVzdWx0PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHpvbmUub25FcnJvci5zdWJzY3JpYmUoKGVycm9ySW5mbzogYW55KSA9PiByZWplY3QoZXJyb3JJbmZvKSk7XHJcbiAgICAgICAgICAgIGFwcFJlZi5pc1N0YWJsZS5maXJzdChpc1N0YWJsZSA9PiBpc1N0YWJsZSkuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgJ29uU3RhYmxlJyBmaXJlcyBiZWZvcmUgJ29uRXJyb3InLCB3ZSBoYXZlIHRvIGRlbGF5IHNsaWdodGx5IGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgLy8gY29tcGxldGluZyB0aGUgcmVxdWVzdCBpbiBjYXNlIHRoZXJlJ3MgYW4gZXJyb3IgdG8gcmVwb3J0XHJcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiBzdGF0ZS5yZW5kZXJUb1N0cmluZygpXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlUmVmLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2Jvb3Quc2VydmVyLnRzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9DbGllbnRBcHAvYXBwL2FwcC9hcHAuY29tcG9uZW50LmNzc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcImlkXCI6MSxcIm9taXRcIjoxLFwicmVtb3ZlXCI6dHJ1ZX0hLi9+L3N0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9zb3VyY2VNYXAhLi9DbGllbnRBcHAvYXBwL2FwcC9lbmQtdXNlci9ob21lL2NvbXBvbmVudHMvam9icy1jb250YWluZXIvam9icy1jb250YWluZXIuY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJpZFwiOjEsXCJvbWl0XCI6MSxcInJlbW92ZVwiOnRydWV9IS4vfi9zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXIhLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/c291cmNlTWFwIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvYWN0aW9uLW1lbnUvYWN0aW9uLWl0ZW0vYWN0aW9uLWl0ZW0uY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJpZFwiOjEsXCJvbWl0XCI6MSxcInJlbW92ZVwiOnRydWV9IS4vfi9zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXIhLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/c291cmNlTWFwIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvYWN0aW9uLW1lbnUvYWN0aW9uLW1lbnUuY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJpZFwiOjEsXCJvbWl0XCI6MSxcInJlbW92ZVwiOnRydWV9IS4vfi9zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXIhLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/c291cmNlTWFwIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvYmxvZy9ibG9nLmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wiaWRcIjoxLFwib21pdFwiOjEsXCJyZW1vdmVcIjp0cnVlfSEuL34vc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyIS4vfi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3NvdXJjZU1hcCEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2NhcmQvY2FyZC5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcImlkXCI6MSxcIm9taXRcIjoxLFwicmVtb3ZlXCI6dHJ1ZX0hLi9+L3N0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9zb3VyY2VNYXAhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9jYXJvdXNlbC1saXN0L2Nhcm91c2VsLWxpc3QuY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJpZFwiOjEsXCJvbWl0XCI6MSxcInJlbW92ZVwiOnRydWV9IS4vfi9zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXIhLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/c291cmNlTWFwIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvZHJvcGRvd24vZHJvcGRvd24uY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJpZFwiOjEsXCJvbWl0XCI6MSxcInJlbW92ZVwiOnRydWV9IS4vfi9zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXIhLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/c291cmNlTWFwIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvZXhwYW5zaWJsZS1jYXJkL2V4cGFuc2libGUtY2FyZC5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcImlkXCI6MSxcIm9taXRcIjoxLFwicmVtb3ZlXCI6dHJ1ZX0hLi9+L3N0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9zb3VyY2VNYXAhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9ncm91cC9ncm91cC5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcImlkXCI6MSxcIm9taXRcIjoxLFwicmVtb3ZlXCI6dHJ1ZX0hLi9+L3N0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9zb3VyY2VNYXAhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9qb2Ivam9iLmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wiaWRcIjoxLFwib21pdFwiOjEsXCJyZW1vdmVcIjp0cnVlfSEuL34vc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyIS4vfi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3NvdXJjZU1hcCEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL292ZXJsYXkvb3ZlcmxheS5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcImlkXCI6MSxcIm9taXRcIjoxLFwicmVtb3ZlXCI6dHJ1ZX0hLi9+L3N0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9zb3VyY2VNYXAhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9wb3BvdmVyL3BvcG92ZXIuY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJpZFwiOjEsXCJvbWl0XCI6MSxcInJlbW92ZVwiOnRydWV9IS4vfi9zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXIhLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/c291cmNlTWFwIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvd2FpdGVyL3dhaXRlci5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHJvdXRlci1vdXRsZXQ+PC9yb3V0ZXItb3V0bGV0PlxcclxcblwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9hcHAvYXBwLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IHN0eWxlPVxcXCJoZWlnaHQ6IDYwMHB4O1xcXCI+XFxyXFxuICAgIDxoMSBjbGFzcz1cXFwiYWxpZ24tbWlkZGxlIHRleHQtY2VudGVyXFxcIj5cXHJcXG4gICAgICAgIFRoaXMgZmVhdHVyZSBpcyBpbiBkZXZlbG9wIHByb2Nlc3MuIEJhY2sgb2ZmLlxcclxcbiAgICA8L2gxPlxcclxcbjwvZGl2PlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9hcHAvZW5kLXVzZXIvZXJyb3IvZXJyb3IuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImh1cmVzLWNvbnRhaW5lclxcXCI+XFxyXFxuICAgIDxoNSBjbGFzcz1cXFwidGV4dC1jZW50ZXIgbS0yXFxcIj57e3RpdGxlfX08L2g1PlxcclxcbiAgICA8ZGl2ICpuZ0lmPVxcXCJqb2JzJCB8IGFzeW5jOyBsZXQgam9iczsgZWxzZSB3YWl0aW5nXFxcIiBjbGFzcz1cXFwiZC1mbGV4IGZsZXgtY29sdW1uXFxcIj5cXHJcXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVxcXCJsZXQgam9iIG9mIGpvYnM7bGV0IGk9aW5kZXhcXFwiPlxcclxcbiAgICAgICAgICAgIDxodXJlLWpvYiAqbmdJZj1cXFwiaTxsaW1pdFxcXCIgW2pvYl09XFxcImpvYlxcXCIgY2xhc3M9XFxcIm0tMVxcXCIgW3NpemVdPVxcXCJzaXplXFxcIj48L2h1cmUtam9iPlxcclxcbiAgICAgICAgICAgIDxociAqbmdJZj1cXFwiaTxqb2JzLmxlbmd0aC0xICYmIGk8bGltaXQtMVxcXCIgc3R5bGU9XFxcIndpZHRoOjEwMCU7XFxcIj5cXHJcXG4gICAgICAgIDwvbmctY29udGFpbmVyPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPG5nLXRlbXBsYXRlICN3YWl0aW5nPlxcclxcbiAgICAgICAgPGh1cmUtd2FpdGVyPjwvaHVyZS13YWl0ZXI+XFxyXFxuICAgIDwvbmctdGVtcGxhdGU+XFxyXFxuPC9kaXY+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2FwcC9lbmQtdXNlci9ob21lL2NvbXBvbmVudHMvam9icy1jb250YWluZXIvam9icy1jb250YWluZXIuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtY2VudGVyIGh1cmVzLW1lbnUtaXRlbVxcXCI+XFxyXFxuICAgIDxidXR0b24gKGNsaWNrKT1cXFwiaXRlbS5hY3Rpb24oKVxcXCIgY2xhc3M9XFxcImh1cmVzLW1lbnUtYnV0dG9uXFxcIiByaXBwbGVFZmZlY3Q+XFxyXFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwidGV4dC1zaXplXFxcIj5cXHJcXG5cXHJcXG4gICAgICAgICAgICA8aSBjbGFzcz1cXFwie3sgaXRlbS5pY29uQ2xhc3MgfX1cXFwiPjwvaT4ge3sgaXRlbS50ZXh0IH19PC9zcGFuPlxcclxcbiAgICA8L2J1dHRvbj5cXHJcXG48L2Rpdj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2FjdGlvbi1tZW51L2FjdGlvbi1pdGVtL2FjdGlvbi1pdGVtLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJkLWZsZXgganVzdGlmeS1jb250ZW50LWNlbnRlciBodXJlcy1tZW51XFxcIj5cXHJcXG4gICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XFxcImxldCBpdGVtIG9mIGl0ZW1zOyBsZXQgaT1pbmRleFxcXCI+XFxyXFxuICAgICAgICA8aHVyZS1hY3Rpb24taXRlbSBbaXRlbV09XFxcIml0ZW1cXFwiPjwvaHVyZS1hY3Rpb24taXRlbT5cXHJcXG4gICAgPC9uZy1jb250YWluZXI+XFxyXFxuPC9kaXY+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9hY3Rpb24tbWVudS9hY3Rpb24tbWVudS5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiYmxvZy1jb21wb25lbnRcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjcy1ibG9nXFxcIj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNzLW1lZGlhXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZmlndXJlPlxcclxcbiAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCJ7e2xpbmt9fVxcXCIgdGl0bGU9XFxcIlxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aW1nIGFsdD1cXFwiXFxcIiBzcmM9XFxcInt7aW1hZ2V9fVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDwvYT5cXHJcXG4gICAgICAgICAgICA8L2ZpZ3VyZT5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYmxvZy10ZXh0XFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjcy1pbm5lci1ib2xnXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicG9zdC1vcHRpb25cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInBvc3QtZGF0ZVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwie3tsaW5rdG90aW1lfX1cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e3RpbWV9fVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcInt7bGlua3RvdGltZX19XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJwb3N0LWNvbW1lbnRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcInt7bGlua2NvbW1lbnR9fVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAge3tjb21tZW50fX1cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXHJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNzLXBvc3QtdGl0bGVcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGg1PlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcInt7bGlua319XFxcIiB0aXRsZT1cXFwiQ2FuZGlkYXRlcyBmb3IgVGhpcyBQb3NpdGlvbiBTaG91bGQgTG92ZSBQcm9kdWNpbmdcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e3RpdGxlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2g1PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPHA+IFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt7Y29udGVudH19XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L3A+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCJ7e2xpbmt9fWcvXFxcIiBjbGFzcz1cXFwicmVhZC1tb3JlXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkIE1vcmVcXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXHJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9kaXY+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9ibG9nL2Jsb2cuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImh1cmVzLWV2ZW50LWNhcmRcXFwiPlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiY2hlY2t0aW1lXFxcIj5DSMavQSBCSeG6vlQgQEA8L2Rpdj5cXHJcXG4gIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJodXJlcy1ldmVudC1pbWdcXFwiPlxcclxcbiAgICA8aW1nIGFsdD1cXFwibG9nb1xcXCIgc3JjPVxcXCJodHRwczovL3N0YXRpYy50b3Bjdi52bi9ldmVudC9pbWFnZXMvN2NjMmIzM2JlY2IzZmQ0YzgyYjg1ZTI2YTM2OGU5YjYtNWEzN2VlODllMTc2Yy5qcGdcXFwiIGNsYXNzPVxcXCJpbWduZVxcXCJcXHJcXG4gICAgLz5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiaW1nLWhvdmVyXFxcIj48L2Rpdj5cXHJcXG4gIDwvYT5cXHJcXG4gIDxkaXYgY2xhc3M9XFxcImh1cmVzLWV2ZW50LXJlbGF0aXZlXFxcIj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiaHVyZXMtZXZlbnQtYnV0dG9uXFxcIj5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJsYWJlbFxcXCI+VEjhu4IgTE/huqBJPC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJodXJlcy1ldmVudC1uYW1lXFxcIj48YSBocmVmPVxcXCIjXFxcIj57eyBldmVudD8ubmFtZSB9fTwvYT48L2Rpdj5cXHJcXG4gICAgPGhyPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJodXJlcy1ldmVudC1yZWdpb25cXFwiPlxcclxcblxcclxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImh1cmVzLWV2ZW50LXJlZ2lvbi1wbGFjZVxcXCI+XFxyXFxuICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtbWFwLW1hcmtlclxcXCI+PC9pPiB7eyBldmVudD8ucGxhY2UgfX08L2Rpdj5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJodXJlcy1ldmVudC1yZWdpb24tZGF0ZVxcXCI+XFxyXFxuICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtY2FsZW5kYXJcXFwiPjwvaT4gSOG6oW4gY2jDs3Q6IHt7IGV2ZW50Py5lbmRUaW1lIHwgZGF0ZSA6IGZvcm1hdCB9fTwvZGl2PlxcclxcblxcclxcblxcclxcbiAgICA8L2Rpdj5cXHJcXG5cXHJcXG5cXHJcXG4gIDwvZGl2PlxcclxcbjwvZGl2PlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvY2FyZC9jYXJkLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJhcHAtY2Fyb3VzZWxcXFwiPlxcclxcbiAgICAgICAgPHVsIGNsYXNzPVxcXCJzbGlkZXMgcm93XFxcIiA+XFxyXFxuICAgICAgICAgICAgPGxpIFtAaXRlbURpc109XFxcIml0ZW0uc3RhdGVcXFwiICpuZ0Zvcj1cXFwibGV0IGl0ZW0gb2YgbGlzdEl0ZW1cXFwiICAgY2xhc3M9XFxcImFwcC1jYXJvdXNlbC1pbWctY29udGFpbmVyIGNvbC0xMiBjb2wtc20tNCBjb2wtbWQtMyBjb2wteGwtMlxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxhIFtocmVmXT1cXFwiaXRlbT8udXJsXFxcIiA+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aW1nIFtzcmNdPVxcXCJpdGVtPy5pbWdcXFwiIGFsdD1cXFwie3sgaXRlbT8udGV4dCB9fVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDwvYT5cXHJcXG4gICAgICAgICAgICA8L2xpPlxcclxcbiAgICAgICAgPC91bD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9kaXY+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9jYXJvdXNlbC1saXN0L2Nhcm91c2VsLWxpc3QuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInctMTAwIGh1cmVzLWRyb3Bkb3duLWNvbnRhaW5lclxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImh1cmVzLWRyb3Bkb3duIHctMTAwXFxcIiAoY2xpY2spPVxcXCJpc0FjdGl2YXRlZD0haXNBY3RpdmF0ZWRcXFwiPlxcclxcbiAgICAgICAgPHA+e3sgc2VsZWN0SXRlbS50ZXh0IHx8IHBsYWNlaG9sZGVyIHwgbGltaXRUZXh0OjI1IH19PC9wPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGh1cmUtb3ZlcmxheSBbaXNBY3RpdmF0ZWRdPVxcXCJpc0FjdGl2YXRlZFxcXCI+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJodXJlcy1waWNrZXJcXFwiPlxcclxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImgtMTAwXFxcIiBzdHlsZT1cXFwicGFkZGluZzo4cHhcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJodXJlcy1waWNrZXItaXRlbXNcXFwiIHN0eWxlPVxcXCJvdmVyZmxvdy15OmF1dG87IG92ZXJmbG93LXg6aGlkZGVuO1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxyXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJodXJlcy1kcm9wZG93bi1jbG9zZS1idG5cXFwiIChjbGljayk9XFxcImlzQWN0aXZhdGVkPSFpc0FjdGl2YXRlZFxcXCIgcmlwcGxlRWZmZWN0PkNsb3NlPC9idXR0b24+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgPC9odXJlLW92ZXJsYXk+XFxyXFxuPC9kaXY+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9kcm9wZG93bi9kcm9wZG93bi5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGEgY2xhc3M9XFxcImRyb3Bkb3duLWl0ZW1cXFwiIChjbGljayk9XFxcInNlbGVjdEl0ZW0oKVxcXCIgc3R5bGU9XFxcImN1cnNvcjpwb2ludGVyO1xcXCIgPlxcclxcbiAgICB7e3RleHQgfCBsaW1pdFRleHQ6IDMwfX1cXHJcXG48L2E+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9kcm9wZG93bi9kcm9wZG93bkl0ZW0vZHJvcGRvd25JdGVtLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJjYXJkIGFwcC1jYXJkLWNvbnRhaW5lclxcXCIgPlxcclxcbiAgICA8ZGl2IFtAZXhwYW5kQ2hhbmdlZF09XFxcImlzRXhwYW5kZWRcXFwiIGNsYXNzPVxcXCJjYXJkLWJvZHkgYXBwLWNhcmRcXFwiPlxcclxcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGJ1dHRvbiBjbGFzcz1cXFwidGV4dC1jYXBpdGFsaXplXFxcIiAoY2xpY2spPVxcXCJpc0V4cGFuZGVkPSFpc0V4cGFuZGVkXFxcIiByaXBwbGVFZmZlY3Q+IHt7IGlzRXhwYW5kZWQ/J0NvbGxhcHNlJzonU2VlIG1vcmUnIH19PC9idXR0b24+XFxyXFxuPC9kaXY+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9leHBhbnNpYmxlLWNhcmQvZXhwYW5zaWJsZS1jYXJkLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8IS0tPGRpdiBjbGFzcz1cXFwiY29sLW1kLTNcXFwiPi0tPlxcclxcbjxkaXYgY2xhc3M9XFxcImdyb3VwLWNvbXBvbmVudFxcXCI+XFxyXFxuICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiIHN0eWxlPVxcXCJwYWRkaW5nOiA1cHg7IHRleHQtYWxpZ246IGNlbnRlcjthbGlnbi1pdGVtczogY2VudGVyO1xcXCI+XFxyXFxuICAgIFxcclxcbiAgICA8IS0tPGRpdiBjbGFzcz1cXFwiY29sLW1kLTZcXFwiPi0tPlxcclxcbiAgICAgIDxhIGhyZWY9XFxcImxpbmtcXFwiIGNsYXNzPVxcXCJpbWctcG9zaXRpb25cXFwiPlxcclxcbiAgICAgICAgPGltZyBbc3JjXT1cXFwiaW1hZ2VcXFwiIGFsdD1cXFwiXFxcIiBzdHlsZT1cXFwid2lkdGg6IDY0cHg7IGhlaWdodDogNjRweDtcXFwiPlxcclxcbiAgICAgIDwvYT5cXHJcXG4gICAgPCEtLTwvZGl2Pi0tPlxcclxcbiAgICA8IS0tPGRpdiBjbGFzcz1cXFwiY29sLW1kLTZcXFwiPi0tPlxcclxcbiAgICAgIDxzdHJvbmcgY2xhc3M9XFxcInRleHQtcG9zaXRpb25cXFwiPnt7dGV4dH19PC9zdHJvbmc+XFxyXFxuICAgIDwhLS08L2Rpdj4tLT5cXHJcXG4gIDwvZGl2PlxcclxcbjwvZGl2PlxcclxcbjwhLS08L2Rpdj4tLT5cXHJcXG48IS0tPGRpdiBjbGFzcz1cXFwiZ3JvdXAtY29tcG9uZW50XFxcIj5cXHJcXG4gIDxkaXYgY2xhc3M9XFxcImNzLW1lZGlhXFxcIj5cXHJcXG4gICAgPGZpZ3VyZT5cXHJcXG4gICAgICA8YSBocmVmPVxcXCJsaW5rXFxcIj5cXHJcXG4gICAgICAgIDxpbWcgW3NyY109XFxcImltYWdlXFxcIiBhbHQ9XFxcIlxcXCI+XFxyXFxuICAgICAgPC9hPlxcclxcbiAgICA8L2ZpZ3VyZT5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiY3MtdGV4dFxcXCIgc3R5bGU9XFxcInRleHQtYWxpZ246IGNlbnRlclxcXCI+XFxyXFxuICAgIDxhIGhyZWY9XFxcImxpbmtcXFwiPlxcclxcblxcclxcbiAgICA8L2E+XFxyXFxuICA8L2Rpdj5cXHJcXG48L2Rpdj4tLT5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2dyb3VwL2dyb3VwLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2ICpuZ0lmPVxcXCJzaXplPT0nbWVkaXVtJ1xcXCIgY2xhc3M9XFxcImh1cmVzLWpvYi1jYXJkIGQtZmxleCBmbGV4LXJvdyBhbGlnbi1jb250ZW50LXN0cmV0Y2hcXFwiIGlkPVxcXCJodXJlcy1qb2ItY2FyZFxcXCI+XFxyXFxuICA8aW1nIGFsdD1cXFwibG9nb1xcXCIgW3NyY109XFxcImpvYi5jb21wYW55LnVybExvZ29cXFwiIC8+XFxyXFxuICA8ZGl2IGNsYXNzPVxcXCJodXJlcy1qb2ItY29udGVudFxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImQtZmxleC1jb2x1bW5cXFwiPlxcclxcbiAgICAgIDxoNCBjbGFzcz1cXFwiY2FyZC10ZXh0IHRleHQtdXBwZXJjYXNlXFxcIj57eyBqb2I/LnRpdGxlIH19PC9oND5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJkLWZsZXggZmxleC1yb3cgdW5mbGV4eHhcXFwiPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZC1mbGV4IGZsZXgtY29sdW1uIGh1cmVzLWpvYi1pbmZvXFxcIj5cXHJcXG4gICAgICAgICAgPHA+e3sgam9iPy5zaG9ydERlc2NyaXB0aW9uIHwgbGltaXRUZXh0OjM5fX08L3A+XFxyXFxuICAgICAgICAgIDxzcGFuPlxcclxcbiAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1tYXAtbWFya2VyXFxcIj48L2k+IHt7IGpvYj8ucGxhY2UgfX08L3NwYW4+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZsb2F0LXJpZ2h0XFxcIj5cXHJcXG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiaHVyZXMtam9iLWFwcGx5LWJ1dHRvblxcXCIgcmlwcGxlRWZmZWN0IChjbGljayk9XFxcImFwcGx5KClcXFwiPk7hu5lwIMSRxqFuPC9idXR0b24+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICA8L2Rpdj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICA8L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG48ZGl2ICpuZ0lmPVxcXCJzaXplPT0nc21hbGwnXFxcIj5cXHJcXG4gIDxkaXYgY2xhc3M9XFxcImh1cmVzLWpvYi1jb250ZW50LXNtYWxsXFxcIj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICA8cCBjbGFzcz1cXFwiY2FyZC10ZXh0IHRleHQtdXBwZXJjYXNlXFxcIj57eyBqb2I/LnRpdGxlIH19PC9wPlxcclxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcImh1cmVzLWpvYi1hcHBseS1idXR0b25cXFwiIHJpcHBsZUVmZmVjdCAoY2xpY2spPVxcXCJhcHBseSgpXFxcIj5DaGkgdGnhur90PC9idXR0b24+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgPC9kaXY+XFxyXFxuPC9kaXY+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9qb2Ivam9iLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2ICpuZ0lmPVxcXCJpc0FjdGl2YXRlZFxcXCI+XFxyXFxuICA8ZGl2IGNsYXNzPVxcXCJodXJlcy1vdmVybGF5XFxcIj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiaHVyZXMtb3ZlcmxheS1jb250YWluZXJcXFwiPlxcclxcbiAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICA8L2Rpdj5cXHJcXG48L2Rpdj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL292ZXJsYXkvb3ZlcmxheS5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiaHVyZXMtcG9wb3Zlci1jb250YWluZXIgYWxpZ24tbWlkZGxlXFxcIj5cXHJcXG4gICAgPGRpdiAoY2xpY2spPVxcXCJjaGFuZ2UoKVxcXCIgY2xhc3M9XFxcImh1cmVzLXBvcG92ZXItYnV0dG9uXFxcIj5cXHJcXG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cXFwiW2J1dHRvbl1cXFwiID5cXHJcXG4gICAgXFxyXFxuICAgICAgICA8L25nLWNvbnRlbnQ+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IFtAbWVudUNoYW5nZWRdPVxcXCJzdGF0ZVxcXCIgY2xhc3M9XFxcInBvcG92ZXIgYnMtcG9wb3Zlci1ib3R0b20gYnMtcG9wb3Zlci1ib3R0b20tZG9jcyBhcHAtcG9wb3ZlclxcXCIgI3BvcG92ZXIgXFxyXFxuICAgIChjbGlja091dHNpZGUpPVxcXCJjbG9zZUl0KClcXFwiPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1ib2R5XFxcIj5cXHJcXG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XFxcIltwb3BvdmVyXVxcXCI+PC9uZy1jb250ZW50PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZGl2PlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvcG9wb3Zlci9wb3BvdmVyLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJkLWZsZXgganVzdGlmeS1jb250ZW50LWNlbnRlclxcXCI+XFxyXFxuICAgIDxhICpuZ0Zvcj1cXFwibGV0IGkgb2YgcmFuZ2UobWF4KVxcXCIgKGNsaWNrKT1cXFwic2VsZWN0U3RhcihpKVxcXCIgPiBcXHJcXG4gICAgICAgIDxzcGFuPjxpIGNsYXNzPVxcXCJmYVxcXCIgW2NsYXNzLmZhLXN0YXJdPVxcXCJpPD1yYXRpbmdcXFwiIFtjbGFzcy5mYS1zdGFyLW9dPVxcXCJpPnJhdGluZ1xcXCIgc3R5bGU9XFxcImZvbnQtc2l6ZToyZW07XFxcIlxcclxcbiAgICAgICAgICAgIFtzdHlsZS5jb2xvci55ZWxsb3ddPVxcXCJpPD1yYXRpbmdcXFwiIFtzdHlsZS5jb2xvci5ibGFja109XFxcImk+cmF0aW5nXFxcIj48L2k+PC9zcGFuPiAgICBcXHJcXG4gICAgPC9hPlxcclxcbjwvZGl2PlxcclxcbjxoMSBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPnt7IHRleHRSYXRpbmdbcmF0aW5nLTFdIH19PC9oMT4gXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9yYXRpbmcvcmF0aW5nLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IFtAdGFiQ2hhbmdlZF0gKm5nSWY9XFxcImlzQWN0aXZhdGVkXFxcIiBjbGFzcz1cXFwiY2Fyb3VzZWwtaXRlbSBhY3RpdmVcXFwiID5cXHJcXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcclxcbjwvZGl2PlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvdGFiYmVkL3RhYi90YWIuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSBcIjx1bCBjbGFzcz1cXFwibmF2IGp1c3RpZnktY29udGVudC1jZW50ZXJcXFwiPlxcclxcbiAgICA8bGkgKm5nRm9yPVxcXCJsZXQgdGFiIG9mIHRhYnNcXFwiIGNsYXNzPVxcXCJuYXYtaXRlbVxcXCIgKGNsaWNrKT1cXFwic2VsZWN0VGFiKHRhYilcXFwiPlxcclxcbiAgICAgICAgPGEgY2xhc3M9XFxcIm5hdi1saW5rXFxcIiBbY2xhc3MuYWN0aXZlXT1cXFwidGFiLmlzQWN0aXZhdGVkXFxcIj57e3RhYi50aXRsZX19PC9hPlxcclxcbiAgICA8L2xpPlxcclxcbjwvdWw+XFxyXFxuPGRpdiBjbGFzcz1cXFwiY2Fyb3VzZWwgc2xpZGUgdGFiYmVkXFxcIiBbc3R5bGUuaGVpZ2h0LnB4XT1cXFwiaGVpZ2h0XFxcIj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiY2Fyb3VzZWwtaW5uZXJcXFwiPlxcclxcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcclxcbiAgICA8L2Rpdj5cXHJcXG48L2Rpdj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL3RhYmJlZC90YWJiZWQuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImh1cmVzLXdhaXRlclxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiByb2xlPVxcXCJkaWFsb2dcXFwiPlxcclxcbiAgICA8ZGl2IGlkPVxcXCJsb2FkZXJcXFwiPlxcclxcbiAgICAgICAgPGRpdiBpZD1cXFwic2hhZG93XFxcIj48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgaWQ9XFxcImJveFxcXCI+PC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZGl2PlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvd2FpdGVyL3dhaXRlci5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBPcGVuRWxlbWVudFN0YWNrID0gcmVxdWlyZSgnLi4vcGFyc2VyL29wZW5fZWxlbWVudF9zdGFjaycpLFxuICAgIFRva2VuaXplciA9IHJlcXVpcmUoJy4uL3Rva2VuaXplcicpLFxuICAgIEhUTUwgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbCcpO1xuXG5cbi8vQWxpYXNlc1xudmFyICQgPSBIVE1MLlRBR19OQU1FUztcblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgLy9OT1RFOiBvYnRhaW4gUGFyc2VyIHByb3RvIHRoaXMgd2F5IHRvIGF2b2lkIG1vZHVsZSBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgdmFyIHBhcnNlclByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHBhcnNlciksXG4gICAgICAgIHRyZWVBZGFwdGVyID0gcGFyc2VyLnRyZWVBZGFwdGVyLFxuICAgICAgICBhdHRhY2hhYmxlRWxlbWVudExvY2F0aW9uID0gbnVsbCxcbiAgICAgICAgbGFzdEZvc3RlclBhcmVudGluZ0xvY2F0aW9uID0gbnVsbCxcbiAgICAgICAgY3VycmVudFRva2VuID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIHNldEVuZExvY2F0aW9uKGVsZW1lbnQsIGNsb3NpbmdUb2tlbikge1xuICAgICAgICB2YXIgbG9jID0gZWxlbWVudC5fX2xvY2F0aW9uO1xuXG4gICAgICAgIGlmICghbG9jKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGlmICghbG9jLnN0YXJ0VGFnKSB7XG4gICAgICAgICAgICBsb2Muc3RhcnRUYWcgPSB7XG4gICAgICAgICAgICAgICAgbGluZTogbG9jLmxpbmUsXG4gICAgICAgICAgICAgICAgY29sOiBsb2MuY29sLFxuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBsb2Muc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0OiBsb2MuZW5kT2Zmc2V0XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAobG9jLmF0dHJzKVxuICAgICAgICAgICAgICAgIGxvYy5zdGFydFRhZy5hdHRycyA9IGxvYy5hdHRycztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9zaW5nVG9rZW4ubG9jYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBjdExvY2F0aW9uID0gY2xvc2luZ1Rva2VuLmxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIHRuID0gdHJlZUFkYXB0ZXIuZ2V0VGFnTmFtZShlbGVtZW50KSxcbiAgICAgICAgICAgIC8vIE5PVEU6IEZvciBjYXNlcyBsaWtlIDxwPiA8cD4gPC9wPiAtIEZpcnN0ICdwJyBjbG9zZXMgd2l0aG91dCBhIGNsb3NpbmcgdGFnIGFuZFxuICAgICAgICAgICAgLy8gZm9yIGNhc2VzIGxpa2UgPHRkPiA8cD4gPC90ZD4gLSAncCcgY2xvc2VzIHdpdGhvdXQgYSBjbG9zaW5nIHRhZ1xuICAgICAgICAgICAgICAgIGlzQ2xvc2luZ0VuZFRhZyA9IGNsb3NpbmdUb2tlbi50eXBlID09PSBUb2tlbml6ZXIuRU5EX1RBR19UT0tFTiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRuID09PSBjbG9zaW5nVG9rZW4udGFnTmFtZTtcblxuICAgICAgICAgICAgaWYgKGlzQ2xvc2luZ0VuZFRhZykge1xuICAgICAgICAgICAgICAgIGxvYy5lbmRUYWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGN0TG9jYXRpb24ubGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sOiBjdExvY2F0aW9uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IGN0TG9jYXRpb24uc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGVuZE9mZnNldDogY3RMb2NhdGlvbi5lbmRPZmZzZXRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNDbG9zaW5nRW5kVGFnKVxuICAgICAgICAgICAgICAgIGxvYy5lbmRPZmZzZXQgPSBjdExvY2F0aW9uLmVuZE9mZnNldDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsb2MuZW5kT2Zmc2V0ID0gY3RMb2NhdGlvbi5zdGFydE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGNsb3NpbmdUb2tlbi50eXBlID09PSBUb2tlbml6ZXIuRU9GX1RPS0VOKVxuICAgICAgICAgICAgbG9jLmVuZE9mZnNldCA9IHBhcnNlci50b2tlbml6ZXIucHJlcHJvY2Vzc29yLnNvdXJjZVBvcztcbiAgICB9XG5cbiAgICAvL05PVEU6IHBhdGNoIF9ib290c3RyYXAgbWV0aG9kXG4gICAgcGFyc2VyLl9ib290c3RyYXAgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIGZyYWdtZW50Q29udGV4dCkge1xuICAgICAgICBwYXJzZXJQcm90by5fYm9vdHN0cmFwLmNhbGwodGhpcywgZG9jdW1lbnQsIGZyYWdtZW50Q29udGV4dCk7XG5cbiAgICAgICAgYXR0YWNoYWJsZUVsZW1lbnRMb2NhdGlvbiA9IG51bGw7XG4gICAgICAgIGxhc3RGb3N0ZXJQYXJlbnRpbmdMb2NhdGlvbiA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRUb2tlbiA9IG51bGw7XG5cbiAgICAgICAgLy9PcGVuRWxlbWVudFN0YWNrXG4gICAgICAgIHBhcnNlci5vcGVuRWxlbWVudHMucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0RW5kTG9jYXRpb24odGhpcy5jdXJyZW50LCBjdXJyZW50VG9rZW4pO1xuICAgICAgICAgICAgT3BlbkVsZW1lbnRTdGFjay5wcm90b3R5cGUucG9wLmNhbGwodGhpcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcGFyc2VyLm9wZW5FbGVtZW50cy5wb3BBbGxVcFRvSHRtbEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5zdGFja1RvcDsgaSA+IDA7IGktLSlcbiAgICAgICAgICAgICAgICBzZXRFbmRMb2NhdGlvbih0aGlzLml0ZW1zW2ldLCBjdXJyZW50VG9rZW4pO1xuXG4gICAgICAgICAgICBPcGVuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5wb3BBbGxVcFRvSHRtbEVsZW1lbnQuY2FsbCh0aGlzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBwYXJzZXIub3BlbkVsZW1lbnRzLnJlbW92ZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICBzZXRFbmRMb2NhdGlvbihlbGVtZW50LCBjdXJyZW50VG9rZW4pO1xuICAgICAgICAgICAgT3BlbkVsZW1lbnRTdGFjay5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcywgZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHBhcnNlci5fcnVuUGFyc2luZ0xvb3AgPSBmdW5jdGlvbiAoc2NyaXB0SGFuZGxlcikge1xuICAgICAgICBwYXJzZXJQcm90by5fcnVuUGFyc2luZ0xvb3AuY2FsbCh0aGlzLCBzY3JpcHRIYW5kbGVyKTtcblxuICAgICAgICAvLyBOT1RFOiBnZW5lcmF0ZSBsb2NhdGlvbiBpbmZvIGZvciBlbGVtZW50c1xuICAgICAgICAvLyB0aGF0IHJlbWFpbnMgb24gb3BlbiBlbGVtZW50IHN0YWNrXG4gICAgICAgIGZvciAodmFyIGkgPSBwYXJzZXIub3BlbkVsZW1lbnRzLnN0YWNrVG9wOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIHNldEVuZExvY2F0aW9uKHBhcnNlci5vcGVuRWxlbWVudHMuaXRlbXNbaV0sIGN1cnJlbnRUb2tlbik7XG4gICAgfTtcblxuXG4gICAgLy9Ub2tlbiBwcm9jZXNzaW5nXG4gICAgcGFyc2VyLl9wcm9jZXNzVG9rZW5JbkZvcmVpZ25Db250ZW50ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGN1cnJlbnRUb2tlbiA9IHRva2VuO1xuICAgICAgICBwYXJzZXJQcm90by5fcHJvY2Vzc1Rva2VuSW5Gb3JlaWduQ29udGVudC5jYWxsKHRoaXMsIHRva2VuKTtcbiAgICB9O1xuXG4gICAgcGFyc2VyLl9wcm9jZXNzVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgY3VycmVudFRva2VuID0gdG9rZW47XG4gICAgICAgIHBhcnNlclByb3RvLl9wcm9jZXNzVG9rZW4uY2FsbCh0aGlzLCB0b2tlbik7XG5cbiAgICAgICAgLy9OT1RFOiA8Ym9keT4gYW5kIDxodG1sPiBhcmUgbmV2ZXIgcG9wcGVkIGZyb20gdGhlIHN0YWNrLCBzbyB3ZSBuZWVkIHRvIHVwZGF0ZWRcbiAgICAgICAgLy90aGVpciBlbmQgbG9jYXRpb24gZXhwbGljaXRseS5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuaXplci5FTkRfVEFHX1RPS0VOICYmXG4gICAgICAgICAgICAodG9rZW4udGFnTmFtZSA9PT0gJC5IVE1MIHx8XG4gICAgICAgICAgICAgdG9rZW4udGFnTmFtZSA9PT0gJC5CT0RZICYmIHRoaXMub3BlbkVsZW1lbnRzLmhhc0luU2NvcGUoJC5CT0RZKSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLm9wZW5FbGVtZW50cy5zdGFja1RvcDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMub3BlbkVsZW1lbnRzLml0ZW1zW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJlZUFkYXB0ZXIuZ2V0VGFnTmFtZShlbGVtZW50KSA9PT0gdG9rZW4udGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRFbmRMb2NhdGlvbihlbGVtZW50LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8vRG9jdHlwZVxuICAgIHBhcnNlci5fc2V0RG9jdW1lbnRUeXBlID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHBhcnNlclByb3RvLl9zZXREb2N1bWVudFR5cGUuY2FsbCh0aGlzLCB0b2tlbik7XG5cbiAgICAgICAgdmFyIGRvY3VtZW50Q2hpbGRyZW4gPSB0aGlzLnRyZWVBZGFwdGVyLmdldENoaWxkTm9kZXModGhpcy5kb2N1bWVudCksXG4gICAgICAgICAgICBjbkxlbmd0aCA9IGRvY3VtZW50Q2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY25MZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudENoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICBpZiAodGhpcy50cmVlQWRhcHRlci5pc0RvY3VtZW50VHlwZU5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBub2RlLl9fbG9jYXRpb24gPSB0b2tlbi5sb2NhdGlvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8vRWxlbWVudHNcbiAgICBwYXJzZXIuX2F0dGFjaEVsZW1lbnRUb1RyZWUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAvL05PVEU6IF9hdHRhY2hFbGVtZW50VG9UcmVlIGlzIGNhbGxlZCBmcm9tIF9hcHBlbmRFbGVtZW50LCBfaW5zZXJ0RWxlbWVudCBhbmQgX2luc2VydFRlbXBsYXRlIG1ldGhvZHMuXG4gICAgICAgIC8vU28gd2Ugd2lsbCB1c2UgdG9rZW4gbG9jYXRpb24gc3RvcmVkIGluIHRoaXMgbWV0aG9kcyBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICAgIGVsZW1lbnQuX19sb2NhdGlvbiA9IGF0dGFjaGFibGVFbGVtZW50TG9jYXRpb24gfHwgbnVsbDtcbiAgICAgICAgYXR0YWNoYWJsZUVsZW1lbnRMb2NhdGlvbiA9IG51bGw7XG4gICAgICAgIHBhcnNlclByb3RvLl9hdHRhY2hFbGVtZW50VG9UcmVlLmNhbGwodGhpcywgZWxlbWVudCk7XG4gICAgfTtcblxuICAgIHBhcnNlci5fYXBwZW5kRWxlbWVudCA9IGZ1bmN0aW9uICh0b2tlbiwgbmFtZXNwYWNlVVJJKSB7XG4gICAgICAgIGF0dGFjaGFibGVFbGVtZW50TG9jYXRpb24gPSB0b2tlbi5sb2NhdGlvbjtcbiAgICAgICAgcGFyc2VyUHJvdG8uX2FwcGVuZEVsZW1lbnQuY2FsbCh0aGlzLCB0b2tlbiwgbmFtZXNwYWNlVVJJKTtcbiAgICB9O1xuXG4gICAgcGFyc2VyLl9pbnNlcnRFbGVtZW50ID0gZnVuY3Rpb24gKHRva2VuLCBuYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgYXR0YWNoYWJsZUVsZW1lbnRMb2NhdGlvbiA9IHRva2VuLmxvY2F0aW9uO1xuICAgICAgICBwYXJzZXJQcm90by5faW5zZXJ0RWxlbWVudC5jYWxsKHRoaXMsIHRva2VuLCBuYW1lc3BhY2VVUkkpO1xuICAgIH07XG5cbiAgICBwYXJzZXIuX2luc2VydFRlbXBsYXRlID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGF0dGFjaGFibGVFbGVtZW50TG9jYXRpb24gPSB0b2tlbi5sb2NhdGlvbjtcbiAgICAgICAgcGFyc2VyUHJvdG8uX2luc2VydFRlbXBsYXRlLmNhbGwodGhpcywgdG9rZW4pO1xuXG4gICAgICAgIHZhciB0bXBsQ29udGVudCA9IHRoaXMudHJlZUFkYXB0ZXIuZ2V0VGVtcGxhdGVDb250ZW50KHRoaXMub3BlbkVsZW1lbnRzLmN1cnJlbnQpO1xuXG4gICAgICAgIHRtcGxDb250ZW50Ll9fbG9jYXRpb24gPSBudWxsO1xuICAgIH07XG5cbiAgICBwYXJzZXIuX2luc2VydEZha2VSb290RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGFyc2VyUHJvdG8uX2luc2VydEZha2VSb290RWxlbWVudC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9wZW5FbGVtZW50cy5jdXJyZW50Ll9fbG9jYXRpb24gPSBudWxsO1xuICAgIH07XG5cblxuICAgIC8vQ29tbWVudHNcbiAgICBwYXJzZXIuX2FwcGVuZENvbW1lbnROb2RlID0gZnVuY3Rpb24gKHRva2VuLCBwYXJlbnQpIHtcbiAgICAgICAgcGFyc2VyUHJvdG8uX2FwcGVuZENvbW1lbnROb2RlLmNhbGwodGhpcywgdG9rZW4sIHBhcmVudCk7XG5cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy50cmVlQWRhcHRlci5nZXRDaGlsZE5vZGVzKHBhcmVudCksXG4gICAgICAgICAgICBjb21tZW50Tm9kZSA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGNvbW1lbnROb2RlLl9fbG9jYXRpb24gPSB0b2tlbi5sb2NhdGlvbjtcbiAgICB9O1xuXG5cbiAgICAvL1RleHRcbiAgICBwYXJzZXIuX2ZpbmRGb3N0ZXJQYXJlbnRpbmdMb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9OT1RFOiBzdG9yZSBsYXN0IGZvc3RlciBwYXJlbnRpbmcgbG9jYXRpb24sIHNvIHdlIHdpbGwgYmUgYWJsZSB0byBmaW5kIGluc2VydGVkIHRleHRcbiAgICAgICAgLy9pbiBjYXNlIG9mIGZvc3RlciBwYXJlbnRpbmdcbiAgICAgICAgbGFzdEZvc3RlclBhcmVudGluZ0xvY2F0aW9uID0gcGFyc2VyUHJvdG8uX2ZpbmRGb3N0ZXJQYXJlbnRpbmdMb2NhdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gbGFzdEZvc3RlclBhcmVudGluZ0xvY2F0aW9uO1xuICAgIH07XG5cbiAgICBwYXJzZXIuX2luc2VydENoYXJhY3RlcnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgcGFyc2VyUHJvdG8uX2luc2VydENoYXJhY3RlcnMuY2FsbCh0aGlzLCB0b2tlbik7XG5cbiAgICAgICAgdmFyIGhhc0Zvc3RlclBhcmVudCA9IHRoaXMuX3Nob3VsZEZvc3RlclBhcmVudE9uSW5zZXJ0aW9uKCksXG4gICAgICAgICAgICBwYXJlbnQgPSBoYXNGb3N0ZXJQYXJlbnQgJiYgbGFzdEZvc3RlclBhcmVudGluZ0xvY2F0aW9uLnBhcmVudCB8fFxuICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuRWxlbWVudHMuY3VycmVudFRtcGxDb250ZW50IHx8XG4gICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW5FbGVtZW50cy5jdXJyZW50LFxuICAgICAgICAgICAgc2libGluZ3MgPSB0aGlzLnRyZWVBZGFwdGVyLmdldENoaWxkTm9kZXMocGFyZW50KSxcbiAgICAgICAgICAgIHRleHROb2RlSWR4ID0gaGFzRm9zdGVyUGFyZW50ICYmIGxhc3RGb3N0ZXJQYXJlbnRpbmdMb2NhdGlvbi5iZWZvcmVFbGVtZW50ID9cbiAgICAgICAgICAgIHNpYmxpbmdzLmluZGV4T2YobGFzdEZvc3RlclBhcmVudGluZ0xvY2F0aW9uLmJlZm9yZUVsZW1lbnQpIC0gMSA6XG4gICAgICAgICAgICBzaWJsaW5ncy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgdGV4dE5vZGUgPSBzaWJsaW5nc1t0ZXh0Tm9kZUlkeF07XG5cbiAgICAgICAgLy9OT1RFOiBpZiB3ZSBoYXZlIGxvY2F0aW9uIGFzc2lnbmVkIGJ5IGFub3RoZXIgdG9rZW4sIHRoZW4ganVzdCB1cGRhdGUgZW5kIHBvc2l0aW9uXG4gICAgICAgIGlmICh0ZXh0Tm9kZS5fX2xvY2F0aW9uKVxuICAgICAgICAgICAgdGV4dE5vZGUuX19sb2NhdGlvbi5lbmRPZmZzZXQgPSB0b2tlbi5sb2NhdGlvbi5lbmRPZmZzZXQ7XG5cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGV4dE5vZGUuX19sb2NhdGlvbiA9IHRva2VuLmxvY2F0aW9uO1xuICAgIH07XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFyc2U1L2xpYi9sb2NhdGlvbl9pbmZvL3BhcnNlcl9taXhpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBVTklDT0RFID0gcmVxdWlyZSgnLi4vY29tbW9uL3VuaWNvZGUnKTtcblxuLy9BbGlhc2VzXG52YXIgJCA9IFVOSUNPREUuQ09ERV9QT0lOVFM7XG5cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAodG9rZW5pemVyKSB7XG4gICAgLy9OT1RFOiBvYnRhaW4gVG9rZW5pemVyIHByb3RvIHRoaXMgd2F5IHRvIGF2b2lkIG1vZHVsZSBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgdmFyIHRva2VuaXplclByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRva2VuaXplciksXG4gICAgICAgIHRva2VuU3RhcnRPZmZzZXQgPSAtMSxcbiAgICAgICAgdG9rZW5Db2wgPSAtMSxcbiAgICAgICAgdG9rZW5MaW5lID0gMSxcbiAgICAgICAgaXNFb2wgPSBmYWxzZSxcbiAgICAgICAgbGluZVN0YXJ0UG9zID0gMCxcbiAgICAgICAgY29sID0gLTEsXG4gICAgICAgIGxpbmUgPSAxO1xuXG4gICAgZnVuY3Rpb24gYXR0YWNoTG9jYXRpb25JbmZvKHRva2VuKSB7XG4gICAgICAgIHRva2VuLmxvY2F0aW9uID0ge1xuICAgICAgICAgICAgbGluZTogdG9rZW5MaW5lLFxuICAgICAgICAgICAgY29sOiB0b2tlbkNvbCxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiB0b2tlblN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiAtMVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vTk9URTogcGF0Y2ggY29uc3VtcHRpb24gbWV0aG9kIHRvIHRyYWNrIGxpbmUvY29sIGluZm9ybWF0aW9uXG4gICAgdG9rZW5pemVyLl9jb25zdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3AgPSB0b2tlbml6ZXJQcm90by5fY29uc3VtZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIC8vTk9URTogTEYgc2hvdWxkIGJlIGluIHRoZSBsYXN0IGNvbHVtbiBvZiB0aGUgbGluZVxuICAgICAgICBpZiAoaXNFb2wpIHtcbiAgICAgICAgICAgIGlzRW9sID0gZmFsc2U7XG4gICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICBsaW5lU3RhcnRQb3MgPSB0aGlzLnByZXByb2Nlc3Nvci5zb3VyY2VQb3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3AgPT09ICQuTElORV9GRUVEKVxuICAgICAgICAgICAgaXNFb2wgPSB0cnVlO1xuXG4gICAgICAgIGNvbCA9IHRoaXMucHJlcHJvY2Vzc29yLnNvdXJjZVBvcyAtIGxpbmVTdGFydFBvcyArIDE7XG5cbiAgICAgICAgcmV0dXJuIGNwO1xuICAgIH07XG5cbiAgICB0b2tlbml6ZXIuX3VuY29uc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdG9rZW5pemVyUHJvdG8uX3VuY29uc3VtZS5jYWxsKHRoaXMpO1xuICAgICAgICBpc0VvbCA9IGZhbHNlO1xuXG4gICAgICAgIGNvbCA9IHRoaXMucHJlcHJvY2Vzc29yLnNvdXJjZVBvcyAtIGxpbmVTdGFydFBvcyArIDE7XG4gICAgfTtcblxuICAgIC8vTk9URTogcGF0Y2ggdG9rZW4gY3JlYXRpb24gbWV0aG9kcyBhbmQgYXR0YWNoIGxvY2F0aW9uIG9iamVjdHNcbiAgICB0b2tlbml6ZXIuX2NyZWF0ZVN0YXJ0VGFnVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRva2VuaXplclByb3RvLl9jcmVhdGVTdGFydFRhZ1Rva2VuLmNhbGwodGhpcyk7XG4gICAgICAgIGF0dGFjaExvY2F0aW9uSW5mbyh0aGlzLmN1cnJlbnRUb2tlbik7XG4gICAgfTtcblxuICAgIHRva2VuaXplci5fY3JlYXRlRW5kVGFnVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRva2VuaXplclByb3RvLl9jcmVhdGVFbmRUYWdUb2tlbi5jYWxsKHRoaXMpO1xuICAgICAgICBhdHRhY2hMb2NhdGlvbkluZm8odGhpcy5jdXJyZW50VG9rZW4pO1xuICAgIH07XG5cbiAgICB0b2tlbml6ZXIuX2NyZWF0ZUNvbW1lbnRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdG9rZW5pemVyUHJvdG8uX2NyZWF0ZUNvbW1lbnRUb2tlbi5jYWxsKHRoaXMpO1xuICAgICAgICBhdHRhY2hMb2NhdGlvbkluZm8odGhpcy5jdXJyZW50VG9rZW4pO1xuICAgIH07XG5cbiAgICB0b2tlbml6ZXIuX2NyZWF0ZURvY3R5cGVUb2tlbiA9IGZ1bmN0aW9uIChpbml0aWFsTmFtZSkge1xuICAgICAgICB0b2tlbml6ZXJQcm90by5fY3JlYXRlRG9jdHlwZVRva2VuLmNhbGwodGhpcywgaW5pdGlhbE5hbWUpO1xuICAgICAgICBhdHRhY2hMb2NhdGlvbkluZm8odGhpcy5jdXJyZW50VG9rZW4pO1xuICAgIH07XG5cbiAgICB0b2tlbml6ZXIuX2NyZWF0ZUNoYXJhY3RlclRva2VuID0gZnVuY3Rpb24gKHR5cGUsIGNoKSB7XG4gICAgICAgIHRva2VuaXplclByb3RvLl9jcmVhdGVDaGFyYWN0ZXJUb2tlbi5jYWxsKHRoaXMsIHR5cGUsIGNoKTtcbiAgICAgICAgYXR0YWNoTG9jYXRpb25JbmZvKHRoaXMuY3VycmVudENoYXJhY3RlclRva2VuKTtcbiAgICB9O1xuXG4gICAgdG9rZW5pemVyLl9jcmVhdGVBdHRyID0gZnVuY3Rpb24gKGF0dHJOYW1lRmlyc3RDaCkge1xuICAgICAgICB0b2tlbml6ZXJQcm90by5fY3JlYXRlQXR0ci5jYWxsKHRoaXMsIGF0dHJOYW1lRmlyc3RDaCk7XG4gICAgICAgIHRoaXMuY3VycmVudEF0dHJMb2NhdGlvbiA9IHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiB0aGlzLnByZXByb2Nlc3Nvci5zb3VyY2VQb3MsXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IC0xXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHRva2VuaXplci5fbGVhdmVBdHRyTmFtZSA9IGZ1bmN0aW9uICh0b1N0YXRlKSB7XG4gICAgICAgIHRva2VuaXplclByb3RvLl9sZWF2ZUF0dHJOYW1lLmNhbGwodGhpcywgdG9TdGF0ZSk7XG4gICAgICAgIHRoaXMuX2F0dGFjaEN1cnJlbnRBdHRyTG9jYXRpb25JbmZvKCk7XG4gICAgfTtcblxuICAgIHRva2VuaXplci5fbGVhdmVBdHRyVmFsdWUgPSBmdW5jdGlvbiAodG9TdGF0ZSkge1xuICAgICAgICB0b2tlbml6ZXJQcm90by5fbGVhdmVBdHRyVmFsdWUuY2FsbCh0aGlzLCB0b1N0YXRlKTtcbiAgICAgICAgdGhpcy5fYXR0YWNoQ3VycmVudEF0dHJMb2NhdGlvbkluZm8oKTtcbiAgICB9O1xuXG4gICAgdG9rZW5pemVyLl9hdHRhY2hDdXJyZW50QXR0ckxvY2F0aW9uSW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QXR0ckxvY2F0aW9uLmVuZE9mZnNldCA9IHRoaXMucHJlcHJvY2Vzc29yLnNvdXJjZVBvcztcblxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudFRva2VuLmxvY2F0aW9uLmF0dHJzKVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4ubG9jYXRpb24uYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLmxvY2F0aW9uLmF0dHJzW3RoaXMuY3VycmVudEF0dHIubmFtZV0gPSB0aGlzLmN1cnJlbnRBdHRyTG9jYXRpb247XG4gICAgfTtcblxuICAgIC8vTk9URTogcGF0Y2ggdG9rZW4gZW1pc3Npb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgZW5kIGxvY2F0aW9uXG4gICAgdG9rZW5pemVyLl9lbWl0Q3VycmVudFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvL05PVEU6IGlmIHdlIGhhdmUgcGVuZGluZyBjaGFyYWN0ZXIgdG9rZW4gbWFrZSBpdCdzIGVuZCBsb2NhdGlvbiBlcXVhbCB0byB0aGVcbiAgICAgICAgLy9jdXJyZW50IHRva2VuJ3Mgc3RhcnQgbG9jYXRpb24uXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGFyYWN0ZXJUb2tlbilcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENoYXJhY3RlclRva2VuLmxvY2F0aW9uLmVuZE9mZnNldCA9IHRoaXMuY3VycmVudFRva2VuLmxvY2F0aW9uLnN0YXJ0T2Zmc2V0O1xuXG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuLmxvY2F0aW9uLmVuZE9mZnNldCA9IHRoaXMucHJlcHJvY2Vzc29yLnNvdXJjZVBvcyArIDE7XG4gICAgICAgIHRva2VuaXplclByb3RvLl9lbWl0Q3VycmVudFRva2VuLmNhbGwodGhpcyk7XG4gICAgfTtcblxuICAgIHRva2VuaXplci5fZW1pdEN1cnJlbnRDaGFyYWN0ZXJUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9OT1RFOiBpZiB3ZSBoYXZlIGNoYXJhY3RlciB0b2tlbiBhbmQgaXQncyBsb2NhdGlvbiB3YXNuJ3Qgc2V0IGluIHRoZSBfZW1pdEN1cnJlbnRUb2tlbigpLFxuICAgICAgICAvL3RoZW4gc2V0IGl0J3MgbG9jYXRpb24gYXQgdGhlIGN1cnJlbnQgcHJlcHJvY2Vzc29yIHBvc2l0aW9uLlxuICAgICAgICAvL1dlIGRvbid0IG5lZWQgdG8gaW5jcmVtZW50IHByZXByb2Nlc3NvciBwb3NpdGlvbiwgc2luY2UgY2hhcmFjdGVyIHRva2VuXG4gICAgICAgIC8vZW1pc3Npb24gaXMgYWx3YXlzIGZvcmNlZCBieSB0aGUgc3RhcnQgb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRva2VuIGhlcmUuXG4gICAgICAgIC8vU28sIHdlIGFscmVhZHkgaGF2ZSBhZHZhbmNlZCBwb3NpdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoYXJhY3RlclRva2VuICYmIHRoaXMuY3VycmVudENoYXJhY3RlclRva2VuLmxvY2F0aW9uLmVuZE9mZnNldCA9PT0gLTEpXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGFyYWN0ZXJUb2tlbi5sb2NhdGlvbi5lbmRPZmZzZXQgPSB0aGlzLnByZXByb2Nlc3Nvci5zb3VyY2VQb3M7XG5cbiAgICAgICAgdG9rZW5pemVyUHJvdG8uX2VtaXRDdXJyZW50Q2hhcmFjdGVyVG9rZW4uY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgLy9OT1RFOiBwYXRjaCBpbml0aWFsIHN0YXRlcyBmb3IgZWFjaCBtb2RlIHRvIG9idGFpbiB0b2tlbiBzdGFydCBwb3NpdGlvblxuICAgIE9iamVjdC5rZXlzKHRva2VuaXplclByb3RvLk1PREUpXG5cbiAgICAgICAgLm1hcChmdW5jdGlvbiAobW9kZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbml6ZXJQcm90by5NT0RFW21vZGVOYW1lXTtcbiAgICAgICAgfSlcblxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHRva2VuaXplcltzdGF0ZV0gPSBmdW5jdGlvbiAoY3ApIHtcbiAgICAgICAgICAgICAgICB0b2tlblN0YXJ0T2Zmc2V0ID0gdGhpcy5wcmVwcm9jZXNzb3Iuc291cmNlUG9zO1xuICAgICAgICAgICAgICAgIHRva2VuTGluZSA9IGxpbmU7XG4gICAgICAgICAgICAgICAgdG9rZW5Db2wgPSBjb2w7XG4gICAgICAgICAgICAgICAgdG9rZW5pemVyUHJvdG9bc3RhdGVdLmNhbGwodGhpcywgY3ApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlNS9saWIvbG9jYXRpb25faW5mby90b2tlbml6ZXJfbWl4aW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vL0NvbnN0XG52YXIgTk9BSF9BUktfQ0FQQUNJVFkgPSAzO1xuXG4vL0xpc3Qgb2YgZm9ybWF0dGluZyBlbGVtZW50c1xudmFyIEZvcm1hdHRpbmdFbGVtZW50TGlzdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRyZWVBZGFwdGVyKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZW50cmllcyA9IFtdO1xuICAgIHRoaXMudHJlZUFkYXB0ZXIgPSB0cmVlQWRhcHRlcjtcbiAgICB0aGlzLmJvb2ttYXJrID0gbnVsbDtcbn07XG5cbi8vRW50cnkgdHlwZXNcbkZvcm1hdHRpbmdFbGVtZW50TGlzdC5NQVJLRVJfRU5UUlkgPSAnTUFSS0VSX0VOVFJZJztcbkZvcm1hdHRpbmdFbGVtZW50TGlzdC5FTEVNRU5UX0VOVFJZID0gJ0VMRU1FTlRfRU5UUlknO1xuXG4vL05vYWggQXJrJ3MgY29uZGl0aW9uXG4vL09QVElNSVpBVElPTjogYXQgZmlyc3Qgd2UgdHJ5IHRvIGZpbmQgcG9zc2libGUgY2FuZGlkYXRlcyBmb3IgZXhjbHVzaW9uIHVzaW5nXG4vL2xpZ2h0d2VpZ2h0IGhldXJpc3RpY3Mgd2l0aG91dCB0aG9yb3VnaCBhdHRyaWJ1dGVzIGNoZWNrLlxuRm9ybWF0dGluZ0VsZW1lbnRMaXN0LnByb3RvdHlwZS5fZ2V0Tm9haEFya0NvbmRpdGlvbkNhbmRpZGF0ZXMgPSBmdW5jdGlvbiAobmV3RWxlbWVudCkge1xuICAgIHZhciBjYW5kaWRhdGVzID0gW107XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPj0gTk9BSF9BUktfQ0FQQUNJVFkpIHtcbiAgICAgICAgdmFyIG5lQXR0cnNMZW5ndGggPSB0aGlzLnRyZWVBZGFwdGVyLmdldEF0dHJMaXN0KG5ld0VsZW1lbnQpLmxlbmd0aCxcbiAgICAgICAgICAgIG5lVGFnTmFtZSA9IHRoaXMudHJlZUFkYXB0ZXIuZ2V0VGFnTmFtZShuZXdFbGVtZW50KSxcbiAgICAgICAgICAgIG5lTmFtZXNwYWNlVVJJID0gdGhpcy50cmVlQWRhcHRlci5nZXROYW1lc3BhY2VVUkkobmV3RWxlbWVudCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZW50cmllc1tpXTtcblxuICAgICAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09IEZvcm1hdHRpbmdFbGVtZW50TGlzdC5NQVJLRVJfRU5UUlkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZW50cnkuZWxlbWVudCxcbiAgICAgICAgICAgICAgICBlbGVtZW50QXR0cnMgPSB0aGlzLnRyZWVBZGFwdGVyLmdldEF0dHJMaXN0KGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIGlzQ2FuZGlkYXRlID0gdGhpcy50cmVlQWRhcHRlci5nZXRUYWdOYW1lKGVsZW1lbnQpID09PSBuZVRhZ05hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUFkYXB0ZXIuZ2V0TmFtZXNwYWNlVVJJKGVsZW1lbnQpID09PSBuZU5hbWVzcGFjZVVSSSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudEF0dHJzLmxlbmd0aCA9PT0gbmVBdHRyc0xlbmd0aDtcblxuICAgICAgICAgICAgaWYgKGlzQ2FuZGlkYXRlKVxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7aWR4OiBpLCBhdHRyczogZWxlbWVudEF0dHJzfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2FuZGlkYXRlcy5sZW5ndGggPCBOT0FIX0FSS19DQVBBQ0lUWSA/IFtdIDogY2FuZGlkYXRlcztcbn07XG5cbkZvcm1hdHRpbmdFbGVtZW50TGlzdC5wcm90b3R5cGUuX2Vuc3VyZU5vYWhBcmtDb25kaXRpb24gPSBmdW5jdGlvbiAobmV3RWxlbWVudCkge1xuICAgIHZhciBjYW5kaWRhdGVzID0gdGhpcy5fZ2V0Tm9haEFya0NvbmRpdGlvbkNhbmRpZGF0ZXMobmV3RWxlbWVudCksXG4gICAgICAgIGNMZW5ndGggPSBjYW5kaWRhdGVzLmxlbmd0aDtcblxuICAgIGlmIChjTGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZUF0dHJzID0gdGhpcy50cmVlQWRhcHRlci5nZXRBdHRyTGlzdChuZXdFbGVtZW50KSxcbiAgICAgICAgICAgIG5lQXR0cnNMZW5ndGggPSBuZUF0dHJzLmxlbmd0aCxcbiAgICAgICAgICAgIG5lQXR0cnNNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIC8vTk9URTogYnVpbGQgYXR0cnMgbWFwIGZvciB0aGUgbmV3IGVsZW1lbnQgc28gd2UgY2FuIHBlcmZvcm0gZmFzdCBsb29rdXBzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVBdHRyc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmVBdHRyID0gbmVBdHRyc1tpXTtcblxuICAgICAgICAgICAgbmVBdHRyc01hcFtuZUF0dHIubmFtZV0gPSBuZUF0dHIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmVBdHRyc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBjQXR0ciA9IGNhbmRpZGF0ZXNbal0uYXR0cnNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAobmVBdHRyc01hcFtjQXR0ci5uYW1lXSAhPT0gY0F0dHIudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNMZW5ndGgtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPCBOT0FIX0FSS19DQVBBQ0lUWSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9OT1RFOiByZW1vdmUgYm90dG9tbW9zdCBjYW5kaWRhdGVzIHVudGlsIE5vYWgncyBBcmsgY29uZGl0aW9uIHdpbGwgbm90IGJlIG1ldFxuICAgICAgICBmb3IgKGkgPSBjTGVuZ3RoIC0gMTsgaSA+PSBOT0FIX0FSS19DQVBBQ0lUWSAtIDE7IGktLSkge1xuICAgICAgICAgICAgdGhpcy5lbnRyaWVzLnNwbGljZShjYW5kaWRhdGVzW2ldLmlkeCwgMSk7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy9NdXRhdGlvbnNcbkZvcm1hdHRpbmdFbGVtZW50TGlzdC5wcm90b3R5cGUuaW5zZXJ0TWFya2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW50cmllcy5wdXNoKHt0eXBlOiBGb3JtYXR0aW5nRWxlbWVudExpc3QuTUFSS0VSX0VOVFJZfSk7XG4gICAgdGhpcy5sZW5ndGgrKztcbn07XG5cbkZvcm1hdHRpbmdFbGVtZW50TGlzdC5wcm90b3R5cGUucHVzaEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgdG9rZW4pIHtcbiAgICB0aGlzLl9lbnN1cmVOb2FoQXJrQ29uZGl0aW9uKGVsZW1lbnQpO1xuXG4gICAgdGhpcy5lbnRyaWVzLnB1c2goe1xuICAgICAgICB0eXBlOiBGb3JtYXR0aW5nRWxlbWVudExpc3QuRUxFTUVOVF9FTlRSWSxcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgdG9rZW46IHRva2VuXG4gICAgfSk7XG5cbiAgICB0aGlzLmxlbmd0aCsrO1xufTtcblxuRm9ybWF0dGluZ0VsZW1lbnRMaXN0LnByb3RvdHlwZS5pbnNlcnRFbGVtZW50QWZ0ZXJCb29rbWFyayA9IGZ1bmN0aW9uIChlbGVtZW50LCB0b2tlbikge1xuICAgIHZhciBib29rbWFya0lkeCA9IHRoaXMubGVuZ3RoIC0gMTtcblxuICAgIGZvciAoOyBib29rbWFya0lkeCA+PSAwOyBib29rbWFya0lkeC0tKSB7XG4gICAgICAgIGlmICh0aGlzLmVudHJpZXNbYm9va21hcmtJZHhdID09PSB0aGlzLmJvb2ttYXJrKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5lbnRyaWVzLnNwbGljZShib29rbWFya0lkeCArIDEsIDAsIHtcbiAgICAgICAgdHlwZTogRm9ybWF0dGluZ0VsZW1lbnRMaXN0LkVMRU1FTlRfRU5UUlksXG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIHRva2VuOiB0b2tlblxuICAgIH0pO1xuXG4gICAgdGhpcy5sZW5ndGgrKztcbn07XG5cbkZvcm1hdHRpbmdFbGVtZW50TGlzdC5wcm90b3R5cGUucmVtb3ZlRW50cnkgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAodGhpcy5lbnRyaWVzW2ldID09PSBlbnRyeSkge1xuICAgICAgICAgICAgdGhpcy5lbnRyaWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkZvcm1hdHRpbmdFbGVtZW50TGlzdC5wcm90b3R5cGUuY2xlYXJUb0xhc3RNYXJrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZW50cmllcy5wb3AoKTtcblxuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuXG4gICAgICAgIGlmIChlbnRyeS50eXBlID09PSBGb3JtYXR0aW5nRWxlbWVudExpc3QuTUFSS0VSX0VOVFJZKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuLy9TZWFyY2hcbkZvcm1hdHRpbmdFbGVtZW50TGlzdC5wcm90b3R5cGUuZ2V0RWxlbWVudEVudHJ5SW5TY29wZVdpdGhUYWdOYW1lID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmVudHJpZXNbaV07XG5cbiAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09IEZvcm1hdHRpbmdFbGVtZW50TGlzdC5NQVJLRVJfRU5UUlkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy50cmVlQWRhcHRlci5nZXRUYWdOYW1lKGVudHJ5LmVsZW1lbnQpID09PSB0YWdOYW1lKVxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuRm9ybWF0dGluZ0VsZW1lbnRMaXN0LnByb3RvdHlwZS5nZXRFbGVtZW50RW50cnkgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZW50cmllc1tpXTtcblxuICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gRm9ybWF0dGluZ0VsZW1lbnRMaXN0LkVMRU1FTlRfRU5UUlkgJiYgZW50cnkuZWxlbWVudCA9PT0gZWxlbWVudClcbiAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFyc2U1L2xpYi9wYXJzZXIvZm9ybWF0dGluZ19lbGVtZW50X2xpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDE3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUGFyc2VyU3RyZWFtID0gcmVxdWlyZSgnLi9wYXJzZXJfc3RyZWFtJyksXG4gICAgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMsXG4gICAgJCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sJykuVEFHX05BTUVTO1xuXG52YXIgUGxhaW5UZXh0Q29udmVyc2lvblN0cmVhbSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBQYXJzZXJTdHJlYW0uY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIC8vIE5PVEU6IHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNyZWFkLXRleHRcbiAgICB0aGlzLnBhcnNlci5faW5zZXJ0RmFrZUVsZW1lbnQoJC5IVE1MKTtcbiAgICB0aGlzLnBhcnNlci5faW5zZXJ0RmFrZUVsZW1lbnQoJC5IRUFEKTtcbiAgICB0aGlzLnBhcnNlci5vcGVuRWxlbWVudHMucG9wKCk7XG4gICAgdGhpcy5wYXJzZXIuX2luc2VydEZha2VFbGVtZW50KCQuQk9EWSk7XG4gICAgdGhpcy5wYXJzZXIuX2luc2VydEZha2VFbGVtZW50KCQuUFJFKTtcbiAgICB0aGlzLnBhcnNlci50cmVlQWRhcHRlci5pbnNlcnRUZXh0KHRoaXMucGFyc2VyLm9wZW5FbGVtZW50cy5jdXJyZW50LCAnXFxuJyk7XG4gICAgdGhpcy5wYXJzZXIuc3dpdGNoVG9QbGFpbnRleHRQYXJzaW5nKCk7XG59O1xuXG5pbmhlcml0cyhQbGFpblRleHRDb252ZXJzaW9uU3RyZWFtLCBQYXJzZXJTdHJlYW0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlNS9saWIvcGFyc2VyL3BsYWluX3RleHRfY29udmVyc2lvbl9zdHJlYW0uanNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgV3JpdGFibGVTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5Xcml0YWJsZSxcbiAgICB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgRGV2TnVsbFN0cmVhbSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIFdyaXRhYmxlU3RyZWFtLmNhbGwodGhpcyk7XG59O1xuXG51dGlsLmluaGVyaXRzKERldk51bGxTdHJlYW0sIFdyaXRhYmxlU3RyZWFtKTtcblxuRGV2TnVsbFN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBjYigpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZTUvbGliL3NheC9kZXZfbnVsbF9zdHJlYW0uanNcbi8vIG1vZHVsZSBpZCA9IDE3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHJhbnNmb3JtU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtLFxuICAgIERldk51bGxTdHJlYW0gPSByZXF1aXJlKCcuL2Rldl9udWxsX3N0cmVhbScpLFxuICAgIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzLFxuICAgIFRva2VuaXplciA9IHJlcXVpcmUoJy4uL3Rva2VuaXplcicpLFxuICAgIFBhcnNlckZlZWRiYWNrU2ltdWxhdG9yID0gcmVxdWlyZSgnLi9wYXJzZXJfZmVlZGJhY2tfc2ltdWxhdG9yJyksXG4gICAgbWVyZ2VPcHRpb25zID0gcmVxdWlyZSgnLi4vY29tbW9uL21lcmdlX29wdGlvbnMnKTtcblxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBsb2NhdGlvbkluZm86IGZhbHNlXG59O1xuXG52YXIgU0FYUGFyc2VyID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIFRyYW5zZm9ybVN0cmVhbS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIob3B0aW9ucyk7XG4gICAgdGhpcy5wYXJzZXJGZWVkYmFja1NpbXVsYXRvciA9IG5ldyBQYXJzZXJGZWVkYmFja1NpbXVsYXRvcih0aGlzLnRva2VuaXplcik7XG5cbiAgICB0aGlzLnBlbmRpbmdUZXh0ID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUb2tlbkxvY2F0aW9uID0gdm9pZCAwO1xuXG4gICAgdGhpcy5sYXN0Q2h1bmtXcml0dGVuID0gZmFsc2U7XG4gICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG5cbiAgICAvLyBOT1RFOiBhbHdheXMgcGlwZSBzdHJlYW0gdG8gdGhlIC9kZXYvbnVsbCBzdHJlYW0gdG8gYXZvaWRcbiAgICAvLyBgaGlnaFdhdGVyTWFya2AgaGl0IGV2ZW4gaWYgd2UgZG9uJ3QgaGF2ZSBjb25zdW1lcnMuXG4gICAgLy8gKHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2luaWt1bGluL3BhcnNlNS9pc3N1ZXMvOTcjaXNzdWVjb21tZW50LTE3MTk0MDc3NClcbiAgICB0aGlzLnBpcGUobmV3IERldk51bGxTdHJlYW0oKSk7XG59O1xuXG5pbmhlcml0cyhTQVhQYXJzZXIsIFRyYW5zZm9ybVN0cmVhbSk7XG5cbi8vVHJhbnNmb3JtU3RyZWFtIGltcGxlbWVudGF0aW9uXG5TQVhQYXJzZXIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5zdG9wcGVkKSB7XG4gICAgICAgIHRoaXMudG9rZW5pemVyLndyaXRlKGNodW5rLnRvU3RyaW5nKCd1dGY4JyksIHRoaXMubGFzdENodW5rV3JpdHRlbik7XG4gICAgICAgIHRoaXMuX3J1blBhcnNpbmdMb29wKCk7XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoKGNodW5rKTtcblxuICAgIGNhbGxiYWNrKCk7XG59O1xuXG5TQVhQYXJzZXIucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG59O1xuXG5TQVhQYXJzZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5sYXN0Q2h1bmtXcml0dGVuID0gdHJ1ZTtcbiAgICBUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLmVuZC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xufTtcblxuU0FYUGFyc2VyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG59O1xuXG4vL0ludGVybmFsc1xuU0FYUGFyc2VyLnByb3RvdHlwZS5fcnVuUGFyc2luZ0xvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgZG8ge1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnBhcnNlckZlZWRiYWNrU2ltdWxhdG9yLmdldE5leHRUb2tlbigpO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbml6ZXIuSElCRVJOQVRJT05fVE9LRU4pXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5pemVyLkNIQVJBQ1RFUl9UT0tFTiB8fFxuICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW5pemVyLldISVRFU1BBQ0VfQ0hBUkFDVEVSX1RPS0VOIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbml6ZXIuTlVMTF9DSEFSQUNURVJfVE9LRU4pIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbkluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nVGV4dCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VG9rZW5Mb2NhdGlvbiA9IHRva2VuLmxvY2F0aW9uO1xuXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbkxvY2F0aW9uLmVuZE9mZnNldCA9IHRva2VuLmxvY2F0aW9uLmVuZE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGV4dCA9ICh0aGlzLnBlbmRpbmdUZXh0IHx8ICcnKSArIHRva2VuLmNoYXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0UGVuZGluZ1RleHQoKTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKCF0aGlzLnN0b3BwZWQgJiYgdG9rZW4udHlwZSAhPT0gVG9rZW5pemVyLkVPRl9UT0tFTik7XG59O1xuXG5TQVhQYXJzZXIucHJvdG90eXBlLl9oYW5kbGVUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25JbmZvKVxuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbkxvY2F0aW9uID0gdG9rZW4ubG9jYXRpb247XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5pemVyLlNUQVJUX1RBR19UT0tFTilcbiAgICAgICAgdGhpcy5lbWl0KCdzdGFydFRhZycsIHRva2VuLnRhZ05hbWUsIHRva2VuLmF0dHJzLCB0b2tlbi5zZWxmQ2xvc2luZywgdGhpcy5jdXJyZW50VG9rZW5Mb2NhdGlvbik7XG5cbiAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSBUb2tlbml6ZXIuRU5EX1RBR19UT0tFTilcbiAgICAgICAgdGhpcy5lbWl0KCdlbmRUYWcnLCB0b2tlbi50YWdOYW1lLCB0aGlzLmN1cnJlbnRUb2tlbkxvY2F0aW9uKTtcblxuICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuaXplci5DT01NRU5UX1RPS0VOKVxuICAgICAgICB0aGlzLmVtaXQoJ2NvbW1lbnQnLCB0b2tlbi5kYXRhLCB0aGlzLmN1cnJlbnRUb2tlbkxvY2F0aW9uKTtcblxuICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuaXplci5ET0NUWVBFX1RPS0VOKVxuICAgICAgICB0aGlzLmVtaXQoJ2RvY3R5cGUnLCB0b2tlbi5uYW1lLCB0b2tlbi5wdWJsaWNJZCwgdG9rZW4uc3lzdGVtSWQsIHRoaXMuY3VycmVudFRva2VuTG9jYXRpb24pO1xufTtcblxuU0FYUGFyc2VyLnByb3RvdHlwZS5fZW1pdFBlbmRpbmdUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmdUZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZW1pdCgndGV4dCcsIHRoaXMucGVuZGluZ1RleHQsIHRoaXMuY3VycmVudFRva2VuTG9jYXRpb24pO1xuICAgICAgICB0aGlzLnBlbmRpbmdUZXh0ID0gbnVsbDtcbiAgICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlNS9saWIvc2F4L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRva2VuaXplciA9IHJlcXVpcmUoJy4uL3Rva2VuaXplcicpLFxuICAgIGZvcmVpZ25Db250ZW50ID0gcmVxdWlyZSgnLi4vY29tbW9uL2ZvcmVpZ25fY29udGVudCcpLFxuICAgIFVOSUNPREUgPSByZXF1aXJlKCcuLi9jb21tb24vdW5pY29kZScpLFxuICAgIEhUTUwgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbCcpO1xuXG5cbi8vQWxpYXNlc1xudmFyICQgPSBIVE1MLlRBR19OQU1FUyxcbiAgICBOUyA9IEhUTUwuTkFNRVNQQUNFUztcblxuXG4vL1BhcnNlckZlZWRiYWNrU2ltdWxhdG9yXG4vL1NpbXVsYXRlcyBhZGp1c3RtZW50IG9mIHRoZSBUb2tlbml6ZXIgd2hpY2ggcGVyZm9ybWVkIGJ5IHN0YW5kYXJkIHBhcnNlciBkdXJpbmcgdHJlZSBjb25zdHJ1Y3Rpb24uXG52YXIgUGFyc2VyRmVlZGJhY2tTaW11bGF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0b2tlbml6ZXIpIHtcbiAgICB0aGlzLnRva2VuaXplciA9IHRva2VuaXplcjtcblxuICAgIHRoaXMubmFtZXNwYWNlU3RhY2sgPSBbXTtcbiAgICB0aGlzLm5hbWVzcGFjZVN0YWNrVG9wID0gLTE7XG4gICAgdGhpcy5fZW50ZXJOYW1lc3BhY2UoTlMuSFRNTCk7XG59O1xuXG5QYXJzZXJGZWVkYmFja1NpbXVsYXRvci5wcm90b3R5cGUuZ2V0TmV4dFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0b2tlbiA9IHRoaXMudG9rZW5pemVyLmdldE5leHRUb2tlbigpO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuaXplci5TVEFSVF9UQUdfVE9LRU4pXG4gICAgICAgIHRoaXMuX2hhbmRsZVN0YXJ0VGFnVG9rZW4odG9rZW4pO1xuXG4gICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5pemVyLkVORF9UQUdfVE9LRU4pXG4gICAgICAgIHRoaXMuX2hhbmRsZUVuZFRhZ1Rva2VuKHRva2VuKTtcblxuICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuaXplci5OVUxMX0NIQVJBQ1RFUl9UT0tFTiAmJiB0aGlzLmluRm9yZWlnbkNvbnRlbnQpIHtcbiAgICAgICAgdG9rZW4udHlwZSA9IFRva2VuaXplci5DSEFSQUNURVJfVE9LRU47XG4gICAgICAgIHRva2VuLmNoYXJzID0gVU5JQ09ERS5SRVBMQUNFTUVOVF9DSEFSQUNURVI7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAodGhpcy5za2lwTmV4dE5ld0xpbmUpIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuaXplci5ISUJFUk5BVElPTl9UT0tFTilcbiAgICAgICAgICAgIHRoaXMuc2tpcE5leHROZXdMaW5lID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuaXplci5XSElURVNQQUNFX0NIQVJBQ1RFUl9UT0tFTiAmJiB0b2tlbi5jaGFyc1swXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi5jaGFycy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmV4dFRva2VuKCk7XG5cbiAgICAgICAgICAgIHRva2VuLmNoYXJzID0gdG9rZW4uY2hhcnMuc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2VuO1xufTtcblxuLy9OYW1lc3BhY2Ugc3RhY2sgbXV0YXRpb25zXG5QYXJzZXJGZWVkYmFja1NpbXVsYXRvci5wcm90b3R5cGUuX2VudGVyTmFtZXNwYWNlID0gZnVuY3Rpb24gKG5hbWVzcGFjZSkge1xuICAgIHRoaXMubmFtZXNwYWNlU3RhY2tUb3ArKztcbiAgICB0aGlzLm5hbWVzcGFjZVN0YWNrLnB1c2gobmFtZXNwYWNlKTtcblxuICAgIHRoaXMuaW5Gb3JlaWduQ29udGVudCA9IG5hbWVzcGFjZSAhPT0gTlMuSFRNTDtcbiAgICB0aGlzLmN1cnJlbnROYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgdGhpcy50b2tlbml6ZXIuYWxsb3dDREFUQSA9IHRoaXMuaW5Gb3JlaWduQ29udGVudDtcbn07XG5cblBhcnNlckZlZWRiYWNrU2ltdWxhdG9yLnByb3RvdHlwZS5fbGVhdmVDdXJyZW50TmFtZXNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubmFtZXNwYWNlU3RhY2tUb3AtLTtcbiAgICB0aGlzLm5hbWVzcGFjZVN0YWNrLnBvcCgpO1xuXG4gICAgdGhpcy5jdXJyZW50TmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2VTdGFja1t0aGlzLm5hbWVzcGFjZVN0YWNrVG9wXTtcbiAgICB0aGlzLmluRm9yZWlnbkNvbnRlbnQgPSB0aGlzLmN1cnJlbnROYW1lc3BhY2UgIT09IE5TLkhUTUw7XG4gICAgdGhpcy50b2tlbml6ZXIuYWxsb3dDREFUQSA9IHRoaXMuaW5Gb3JlaWduQ29udGVudDtcbn07XG5cbi8vVG9rZW4gaGFuZGxlcnNcblBhcnNlckZlZWRiYWNrU2ltdWxhdG9yLnByb3RvdHlwZS5fZW5zdXJlVG9rZW5pemVyTW9kZSA9IGZ1bmN0aW9uICh0bikge1xuICAgIGlmICh0biA9PT0gJC5URVhUQVJFQSB8fCB0biA9PT0gJC5USVRMRSlcbiAgICAgICAgdGhpcy50b2tlbml6ZXIuc3RhdGUgPSBUb2tlbml6ZXIuTU9ERS5SQ0RBVEE7XG5cbiAgICBlbHNlIGlmICh0biA9PT0gJC5QTEFJTlRFWFQpXG4gICAgICAgIHRoaXMudG9rZW5pemVyLnN0YXRlID0gVG9rZW5pemVyLk1PREUuUExBSU5URVhUO1xuXG4gICAgZWxzZSBpZiAodG4gPT09ICQuU0NSSVBUKVxuICAgICAgICB0aGlzLnRva2VuaXplci5zdGF0ZSA9IFRva2VuaXplci5NT0RFLlNDUklQVF9EQVRBO1xuXG4gICAgZWxzZSBpZiAodG4gPT09ICQuU1RZTEUgfHwgdG4gPT09ICQuSUZSQU1FIHx8IHRuID09PSAkLlhNUCB8fFxuICAgICAgICAgICAgIHRuID09PSAkLk5PRU1CRUQgfHwgdG4gPT09ICQuTk9GUkFNRVMgfHwgdG4gPT09ICQuTk9TQ1JJUFQpXG4gICAgICAgIHRoaXMudG9rZW5pemVyLnN0YXRlID0gVG9rZW5pemVyLk1PREUuUkFXVEVYVDtcbn07XG5cblBhcnNlckZlZWRiYWNrU2ltdWxhdG9yLnByb3RvdHlwZS5faGFuZGxlU3RhcnRUYWdUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIHZhciB0biA9IHRva2VuLnRhZ05hbWU7XG5cbiAgICBpZiAodG4gPT09ICQuU1ZHKVxuICAgICAgICB0aGlzLl9lbnRlck5hbWVzcGFjZShOUy5TVkcpO1xuXG4gICAgZWxzZSBpZiAodG4gPT09ICQuTUFUSClcbiAgICAgICAgdGhpcy5fZW50ZXJOYW1lc3BhY2UoTlMuTUFUSE1MKTtcblxuICAgIGlmICh0aGlzLmluRm9yZWlnbkNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGZvcmVpZ25Db250ZW50LmNhdXNlc0V4aXQodG9rZW4pKSB7XG4gICAgICAgICAgICB0aGlzLl9sZWF2ZUN1cnJlbnROYW1lc3BhY2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJyZW50TnMgPSB0aGlzLmN1cnJlbnROYW1lc3BhY2U7XG5cbiAgICAgICAgaWYgKGN1cnJlbnROcyA9PT0gTlMuTUFUSE1MKVxuICAgICAgICAgICAgZm9yZWlnbkNvbnRlbnQuYWRqdXN0VG9rZW5NYXRoTUxBdHRycyh0b2tlbik7XG5cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudE5zID09PSBOUy5TVkcpIHtcbiAgICAgICAgICAgIGZvcmVpZ25Db250ZW50LmFkanVzdFRva2VuU1ZHVGFnTmFtZSh0b2tlbik7XG4gICAgICAgICAgICBmb3JlaWduQ29udGVudC5hZGp1c3RUb2tlblNWR0F0dHJzKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcmVpZ25Db250ZW50LmFkanVzdFRva2VuWE1MQXR0cnModG9rZW4pO1xuXG4gICAgICAgIHRuID0gdG9rZW4udGFnTmFtZTtcblxuICAgICAgICBpZiAoIXRva2VuLnNlbGZDbG9zaW5nICYmIGZvcmVpZ25Db250ZW50LmlzSW50ZWdyYXRpb25Qb2ludCh0biwgY3VycmVudE5zLCB0b2tlbi5hdHRycykpXG4gICAgICAgICAgICB0aGlzLl9lbnRlck5hbWVzcGFjZShOUy5IVE1MKTtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRuID09PSAkLlBSRSB8fCB0biA9PT0gJC5URVhUQVJFQSB8fCB0biA9PT0gJC5MSVNUSU5HKVxuICAgICAgICAgICAgdGhpcy5za2lwTmV4dE5ld0xpbmUgPSB0cnVlO1xuXG4gICAgICAgIGVsc2UgaWYgKHRuID09PSAkLklNQUdFKVxuICAgICAgICAgICAgdG9rZW4udGFnTmFtZSA9ICQuSU1HO1xuXG4gICAgICAgIHRoaXMuX2Vuc3VyZVRva2VuaXplck1vZGUodG4pO1xuICAgIH1cbn07XG5cblBhcnNlckZlZWRiYWNrU2ltdWxhdG9yLnByb3RvdHlwZS5faGFuZGxlRW5kVGFnVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICB2YXIgdG4gPSB0b2tlbi50YWdOYW1lO1xuXG4gICAgaWYgKCF0aGlzLmluRm9yZWlnbkNvbnRlbnQpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzTnMgPSB0aGlzLm5hbWVzcGFjZVN0YWNrW3RoaXMubmFtZXNwYWNlU3RhY2tUb3AgLSAxXTtcblxuICAgICAgICBpZiAocHJldmlvdXNOcyA9PT0gTlMuU1ZHICYmIGZvcmVpZ25Db250ZW50LlNWR19UQUdfTkFNRVNfQURKVVNUTUVOVF9NQVBbdG5dKVxuICAgICAgICAgICAgdG4gPSBmb3JlaWduQ29udGVudC5TVkdfVEFHX05BTUVTX0FESlVTVE1FTlRfTUFQW3RuXTtcblxuICAgICAgICAvL05PVEU6IGNoZWNrIGZvciBleGl0IGZyb20gaW50ZWdyYXRpb24gcG9pbnRcbiAgICAgICAgaWYgKGZvcmVpZ25Db250ZW50LmlzSW50ZWdyYXRpb25Qb2ludCh0biwgcHJldmlvdXNOcywgdG9rZW4uYXR0cnMpKVxuICAgICAgICAgICAgdGhpcy5fbGVhdmVDdXJyZW50TmFtZXNwYWNlKCk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAodG4gPT09ICQuU1ZHICYmIHRoaXMuY3VycmVudE5hbWVzcGFjZSA9PT0gTlMuU1ZHIHx8XG4gICAgICAgICAgICAgdG4gPT09ICQuTUFUSCAmJiB0aGlzLmN1cnJlbnROYW1lc3BhY2UgPT09IE5TLk1BVEhNTClcbiAgICAgICAgdGhpcy5fbGVhdmVDdXJyZW50TmFtZXNwYWNlKCk7XG5cbiAgICAvLyBOT1RFOiBhZGp1c3QgZW5kIHRhZyBuYW1lIGFzIHdlbGwgZm9yIGNvbnNpc3RlbmN5XG4gICAgaWYgKHRoaXMuY3VycmVudE5hbWVzcGFjZSA9PT0gTlMuU1ZHKVxuICAgICAgICBmb3JlaWduQ29udGVudC5hZGp1c3RUb2tlblNWR1RhZ05hbWUodG9rZW4pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZTUvbGliL3NheC9wYXJzZXJfZmVlZGJhY2tfc2ltdWxhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWRhYmxlU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuUmVhZGFibGUsXG4gICAgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMsXG4gICAgU2VyaWFsaXplciA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxudmFyIFNlcmlhbGl6ZXJTdHJlYW0gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gICAgUmVhZGFibGVTdHJlYW0uY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuc2VyaWFsaXplciA9IG5ldyBTZXJpYWxpemVyKG5vZGUsIG9wdGlvbnMpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuc2VyaWFsaXplciwgJ2h0bWwnLCB7XG4gICAgICAgIC8vTk9URTogVG8gbWFrZSBgKz1gIGNvbmNhdCBvcGVyYXRvciB3b3JrIHByb3Blcmx5IHdlIGRlZmluZVxuICAgICAgICAvL2dldHRlciB3aGljaCBhbHdheXMgcmV0dXJucyBlbXB0eSBzdHJpbmdcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogdGhpcy5wdXNoLmJpbmQodGhpcylcbiAgICB9KTtcbn07XG5cbmluaGVyaXRzKFNlcmlhbGl6ZXJTdHJlYW0sIFJlYWRhYmxlU3RyZWFtKTtcblxuLy9SZWFkYWJsZSBzdHJlYW0gaW1wbGVtZW50YXRpb25cblNlcmlhbGl6ZXJTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VyaWFsaXplci5zZXJpYWxpemUoKTtcbiAgICB0aGlzLnB1c2gobnVsbCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlNS9saWIvc2VyaWFsaXplci9zZXJpYWxpemVyX3N0cmVhbS5qc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIndXNlIHN0cmljdCc7XG5cbi8vTk9URTogdGhpcyBmaWxlIGNvbnRhaW5zIGF1dG8tZ2VuZXJhdGVkIGFycmF5IG1hcHBlZCByYWRpeCB0cmVlIHRoYXQgaXMgdXNlZCBmb3IgdGhlIG5hbWVkIGVudGl0eSByZWZlcmVuY2VzIGNvbnN1bXB0aW9uXG4vLyhkZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vaW5pa3VsaW4vcGFyc2U1L3RyZWUvbWFzdGVyL3NjcmlwdHMvZ2VuZXJhdGVfbmFtZWRfZW50aXR5X2RhdGEvUkVBRE1FLm1kKVxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVWludDE2QXJyYXkoWzQsNTIsNjUsNjYsNjcsNjgsNjksNzAsNzEsNzIsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODEsODIsODMsODQsODUsODYsODcsODgsODksOTAsOTcsOTgsOTksMTAwLDEwMSwxMDIsMTAzLDEwNCwxMDUsMTA2LDEwNywxMDgsMTA5LDExMCwxMTEsMTEyLDExMywxMTQsMTE1LDExNiwxMTcsMTE4LDExOSwxMjAsMTIxLDEyMiwxMDYsMzAzLDQxMiw4MTAsMTQzMiwxNzAxLDE3OTYsMTk4NywyMTE0LDIzNjAsMjQyMCwyNDg0LDMxNzAsMzI1MSw0MTQwLDQzOTMsNDU3NSw0NjEwLDUxMDYsNTUxMiw1NzI4LDYxMTcsNjI3NCw2MzE1LDYzNDUsNjQyNyw2NTE2LDcwMDIsNzkxMCw4NzMzLDkzMjMsOTg3MCwxMDE3MCwxMDYzMSwxMDg5MywxMTMxOCwxMTM4NiwxMTQ2NywxMjc3MywxMzA5MiwxNDQ3NCwxNDkyMiwxNTQ0OCwxNTU0MiwxNjQxOSwxNzY2NiwxODE2NiwxODYxMSwxOTAwNCwxOTA5NSwxOTI5OCwxOTM5Nyw0LDE2LDY5LDc3LDk3LDk4LDk5LDEwMiwxMDMsMTA4LDEwOSwxMTAsMTExLDExMiwxMTQsMTE1LDExNiwxMTcsMTQwLDE1MCwxNTgsMTY5LDE3NiwxOTQsMTk5LDIxMCwyMTYsMjIyLDIyNiwyNDIsMjU2LDI2NiwyODMsMjk0LDEwOCwxMDUsMTAzLDUsMTk4LDEsNTksMTQ4LDEsMTk4LDgwLDUsMzgsMSw1OSwxNTYsMSwzOCw5OSwxMTcsMTE2LDEwMSw1LDE5MywxLDU5LDE2NywxLDE5MywxMTQsMTAxLDExOCwxMDEsNTksMSwyNTgsNCwyLDEwNSwxMjEsMTgyLDE5MSwxMTQsOTksNSwxOTQsMSw1OSwxODksMSwxOTQsNTksMSwxMDQwLDExNCw1OSwzLDU1MzQ5LDU2NTgwLDExNCw5NywxMTgsMTAxLDUsMTkyLDEsNTksMjA4LDEsMTkyLDExMiwxMDQsOTcsNTksMSw5MTMsOTcsOTksMTE0LDU5LDEsMjU2LDEwMCw1OSwxLDEwODM1LDQsMiwxMDMsMTEyLDIzMiwyMzcsMTExLDExMCw1OSwxLDI2MCwxMDIsNTksMyw1NTM0OSw1NjYzMiwxMTIsMTA4LDEyMSw3MCwxMTcsMTEwLDk5LDExNiwxMDUsMTExLDExMCw1OSwxLDgyODksMTA1LDExMCwxMDMsNSwxOTcsMSw1OSwyNjQsMSwxOTcsNCwyLDk5LDExNSwyNzIsMjc3LDExNCw1OSwzLDU1MzQ5LDU2NDc2LDEwNSwxMDMsMTEwLDU5LDEsODc4OCwxMDUsMTA4LDEwMCwxMDEsNSwxOTUsMSw1OSwyOTIsMSwxOTUsMTA5LDEwOCw1LDE5NiwxLDU5LDMwMSwxLDE5Niw0LDgsOTcsOTksMTAxLDEwMiwxMTEsMTE0LDExNSwxMTcsMzIxLDM1MCwzNTQsMzgzLDM4OCwzOTQsNDAwLDQwNSw0LDIsOTksMTE0LDMyNywzMzYsMTA3LDExNSwxMDgsOTcsMTE1LDEwNCw1OSwxLDg3MjYsNCwyLDExOCwxMTksMzQyLDM0NSw1OSwxLDEwOTgzLDEwMSwxMDAsNTksMSw4OTY2LDEyMSw1OSwxLDEwNDEsNCwzLDk5LDExNCwxMTYsMzYyLDM2OSwzNzksOTcsMTE3LDExNSwxMDEsNTksMSw4NzU3LDExMCwxMTEsMTE3LDEwOCwxMDgsMTA1LDExNSw1OSwxLDg0OTIsOTcsNTksMSw5MTQsMTE0LDU5LDMsNTUzNDksNTY1ODEsMTEyLDEwMiw1OSwzLDU1MzQ5LDU2NjMzLDEwMSwxMTgsMTAxLDU5LDEsNzI4LDk5LDExNCw1OSwxLDg0OTIsMTA5LDExMiwxMDEsMTEzLDU5LDEsODc4Miw0LDE0LDcyLDc5LDk3LDk5LDEwMCwxMDEsMTAyLDEwNCwxMDUsMTA4LDExMSwxMTQsMTE1LDExNyw0NDIsNDQ3LDQ1Niw1MDQsNTQyLDU0Nyw1NjksNTczLDU3Nyw2MTYsNjc4LDc4NCw3OTAsNzk2LDk5LDEyMSw1OSwxLDEwNjMsODAsODksNSwxNjksMSw1OSw0NTQsMSwxNjksNCwzLDk5LDExMiwxMjEsNDY0LDQ3MCw0OTcsMTE3LDExNiwxMDEsNTksMSwyNjIsNCwyLDU5LDEwNSw0NzYsNDc4LDEsODkxNCwxMTYsOTcsMTA4LDY4LDEwNSwxMDIsMTAyLDEwMSwxMTQsMTAxLDExMCwxMTYsMTA1LDk3LDEwOCw2OCw1OSwxLDg1MTcsMTA4LDEwMSwxMjEsMTE1LDU5LDEsODQ5Myw0LDQsOTcsMTAxLDEwNSwxMTEsNTE0LDUyMCw1MzAsNTM1LDExNCwxMTEsMTEwLDU5LDEsMjY4LDEwMCwxMDUsMTA4LDUsMTk5LDEsNTksNTI4LDEsMTk5LDExNCw5OSw1OSwxLDI2NCwxMTAsMTA1LDExMCwxMTYsNTksMSw4NzUyLDExMSwxMTYsNTksMSwyNjYsNCwyLDEwMCwxMTAsNTUzLDU2MCwxMDUsMTA4LDEwOCw5Nyw1OSwxLDE4NCwxMTYsMTAxLDExNCw2OCwxMTEsMTE2LDU5LDEsMTgzLDExNCw1OSwxLDg0OTMsMTA1LDU5LDEsOTM1LDExNCw5OSwxMDgsMTAxLDQsNCw2OCw3Nyw4MCw4NCw1OTEsNTk2LDYwMyw2MDksMTExLDExNiw1OSwxLDg4NTcsMTA1LDExMCwxMTcsMTE1LDU5LDEsODg1NCwxMDgsMTE3LDExNSw1OSwxLDg4NTMsMTA1LDEwOSwxMDEsMTE1LDU5LDEsODg1NSwxMTEsNCwyLDk5LDExNSw2MjMsNjQ2LDEwNywxMTksMTA1LDExNSwxMDEsNjcsMTExLDExMCwxMTYsMTExLDExNywxMTQsNzMsMTEwLDExNiwxMDEsMTAzLDExNCw5NywxMDgsNTksMSw4NzU0LDEwMSw2NywxMTcsMTE0LDEwOCwxMjEsNCwyLDY4LDgxLDY1OCw2NzEsMTExLDExNyw5OCwxMDgsMTAxLDgxLDExNywxMTEsMTE2LDEwMSw1OSwxLDgyMjEsMTE3LDExMSwxMTYsMTAxLDU5LDEsODIxNyw0LDQsMTA4LDExMCwxMTIsMTE3LDY4OCw3MDEsNzM2LDc1MywxMTEsMTEwLDQsMiw1OSwxMDEsNjk2LDY5OCwxLDg3NTksNTksMSwxMDg2OCw0LDMsMTAzLDEwNSwxMTYsNzA5LDcxNyw3MjIsMTE0LDExNywxMDEsMTEwLDExNiw1OSwxLDg4MDEsMTEwLDExNiw1OSwxLDg3NTEsMTExLDExNywxMTQsNzMsMTEwLDExNiwxMDEsMTAzLDExNCw5NywxMDgsNTksMSw4NzUwLDQsMiwxMDIsMTE0LDc0Miw3NDUsNTksMSw4NDUwLDExMSwxMDAsMTE3LDk5LDExNiw1OSwxLDg3MjAsMTEwLDExNiwxMDEsMTE0LDY3LDEwOCwxMTEsOTksMTA3LDExOSwxMDUsMTE1LDEwMSw2NywxMTEsMTEwLDExNiwxMTEsMTE3LDExNCw3MywxMTAsMTE2LDEwMSwxMDMsMTE0LDk3LDEwOCw1OSwxLDg3NTUsMTExLDExNSwxMTUsNTksMSwxMDc5OSw5OSwxMTQsNTksMyw1NTM0OSw1NjQ3OCwxMTIsNCwyLDU5LDY3LDgwMyw4MDUsMSw4OTE1LDk3LDExMiw1OSwxLDg3ODEsNCwxMSw2OCw3NCw4Myw5MCw5Nyw5OSwxMDEsMTAyLDEwNSwxMTEsMTE1LDgzNCw4NTAsODU1LDg2MCw4NjUsODg4LDkwMyw5MTYsOTIxLDEwMTEsMTQxNSw0LDIsNTksMTExLDg0MCw4NDIsMSw4NTE3LDExNiwxMTQsOTcsMTA0LDEwMCw1OSwxLDEwNTEzLDk5LDEyMSw1OSwxLDEwMjYsOTksMTIxLDU5LDEsMTAyOSw5OSwxMjEsNTksMSwxMDM5LDQsMywxMDMsMTE0LDExNSw4NzMsODc5LDg4MywxMDMsMTAxLDExNCw1OSwxLDgyMjUsMTE0LDU5LDEsODYwOSwxMDQsMTE4LDU5LDEsMTA5ODAsNCwyLDk3LDEyMSw4OTQsOTAwLDExNCwxMTEsMTEwLDU5LDEsMjcwLDU5LDEsMTA0NCwxMDgsNCwyLDU5LDExNiw5MTAsOTEyLDEsODcxMSw5Nyw1OSwxLDkxNiwxMTQsNTksMyw1NTM0OSw1NjU4Myw0LDIsOTcsMTAyLDkyNyw5OTgsNCwyLDk5LDEwOSw5MzMsOTkyLDExNCwxMDUsMTE2LDEwNSw5OSw5NywxMDgsNCw0LDY1LDY4LDcxLDg0LDk1MCw5NTcsOTc4LDk4NSw5OSwxMTcsMTE2LDEwMSw1OSwxLDE4MCwxMTEsNCwyLDExNiwxMTcsOTY0LDk2Nyw1OSwxLDcyOSw5OCwxMDgsMTAxLDY1LDk5LDExNywxMTYsMTAxLDU5LDEsNzMzLDExNCw5NywxMTgsMTAxLDU5LDEsOTYsMTA1LDEwOCwxMDAsMTAxLDU5LDEsNzMyLDExMSwxMTAsMTAwLDU5LDEsODkwMCwxMDIsMTAxLDExNCwxMDEsMTEwLDExNiwxMDUsOTcsMTA4LDY4LDU5LDEsODUxOCw0LDQsMTEyLDExNiwxMTcsMTE5LDEwMjEsMTAyNiwxMDQ4LDEyNDksMTAyLDU5LDMsNTUzNDksNTY2MzUsNCwzLDU5LDY4LDY5LDEwMzQsMTAzNiwxMDQxLDEsMTY4LDExMSwxMTYsNTksMSw4NDEyLDExMywxMTcsOTcsMTA4LDU5LDEsODc4NCw5OCwxMDgsMTAxLDQsNiw2Nyw2OCw3Niw4Miw4NSw4NiwxMDY1LDEwODIsMTEwMSwxMTg5LDEyMTEsMTIzNiwxMTEsMTEwLDExNiwxMTEsMTE3LDExNCw3MywxMTAsMTE2LDEwMSwxMDMsMTE0LDk3LDEwOCw1OSwxLDg3NTEsMTExLDQsMiwxMTYsMTE5LDEwODksMTA5Miw1OSwxLDE2OCwxMTAsNjUsMTE0LDExNCwxMTEsMTE5LDU5LDEsODY1OSw0LDIsMTAxLDExMSwxMTA3LDExNDEsMTAyLDExNiw0LDMsNjUsODIsODQsMTExNywxMTI0LDExMzYsMTE0LDExNCwxMTEsMTE5LDU5LDEsODY1NiwxMDUsMTAzLDEwNCwxMTYsNjUsMTE0LDExNCwxMTEsMTE5LDU5LDEsODY2MCwxMDEsMTAxLDU5LDEsMTA5ODAsMTEwLDEwMyw0LDIsNzYsODIsMTE0OSwxMTc3LDEwMSwxMDIsMTE2LDQsMiw2NSw4MiwxMTU4LDExNjUsMTE0LDExNCwxMTEsMTE5LDU5LDEsMTAyMzIsMTA1LDEwMywxMDQsMTE2LDY1LDExNCwxMTQsMTExLDExOSw1OSwxLDEwMjM0LDEwNSwxMDMsMTA0LDExNiw2NSwxMTQsMTE0LDExMSwxMTksNTksMSwxMDIzMywxMDUsMTAzLDEwNCwxMTYsNCwyLDY1LDg0LDExOTksMTIwNiwxMTQsMTE0LDExMSwxMTksNTksMSw4NjU4LDEwMSwxMDEsNTksMSw4ODcyLDExMiw0LDIsNjUsNjgsMTIxOCwxMjI1LDExNCwxMTQsMTExLDExOSw1OSwxLDg2NTcsMTExLDExOSwxMTAsNjUsMTE0LDExNCwxMTEsMTE5LDU5LDEsODY2MSwxMDEsMTE0LDExNiwxMDUsOTksOTcsMTA4LDY2LDk3LDExNCw1OSwxLDg3NDEsMTEwLDQsNiw2NSw2Niw3Niw4Miw4NCw5NywxMjY0LDEyOTIsMTI5OSwxMzUyLDEzOTEsMTQwOCwxMTQsMTE0LDExMSwxMTksNCwzLDU5LDY2LDg1LDEyNzYsMTI3OCwxMjgzLDEsODU5NSw5NywxMTQsNTksMSwxMDUxNSwxMTIsNjUsMTE0LDExNCwxMTEsMTE5LDU5LDEsODY5MywxMTQsMTAxLDExOCwxMDEsNTksMSw3ODUsMTAxLDEwMiwxMTYsNCwzLDgyLDg0LDg2LDEzMTAsMTMyMywxMzM0LDEwNSwxMDMsMTA0LDExNiw4NiwxMDEsOTksMTE2LDExMSwxMTQsNTksMSwxMDU3NiwxMDEsMTAxLDg2LDEwMSw5OSwxMTYsMTExLDExNCw1OSwxLDEwNTkwLDEwMSw5OSwxMTYsMTExLDExNCw0LDIsNTksNjYsMTM0NSwxMzQ3LDEsODYzNyw5NywxMTQsNTksMSwxMDU4MiwxMDUsMTAzLDEwNCwxMTYsNCwyLDg0LDg2LDEzNjIsMTM3MywxMDEsMTAxLDg2LDEwMSw5OSwxMTYsMTExLDExNCw1OSwxLDEwNTkxLDEwMSw5OSwxMTYsMTExLDExNCw0LDIsNTksNjYsMTM4NCwxMzg2LDEsODY0MSw5NywxMTQsNTksMSwxMDU4MywxMDEsMTAxLDQsMiw1OSw2NSwxMzk5LDE0MDEsMSw4ODY4LDExNCwxMTQsMTExLDExOSw1OSwxLDg2MTUsMTE0LDExNCwxMTEsMTE5LDU5LDEsODY1OSw0LDIsOTksMTE2LDE0MjEsMTQyNiwxMTQsNTksMyw1NTM0OSw1NjQ3OSwxMTQsMTExLDEwNyw1OSwxLDI3Miw0LDE2LDc4LDg0LDk3LDk5LDEwMCwxMDIsMTAzLDEwOCwxMDksMTExLDExMiwxMTMsMTE1LDExNiwxMTcsMTIwLDE0NjYsMTQ3MCwxNDc4LDE0ODksMTUxNSwxNTIwLDE1MjUsMTUzNiwxNTQ0LDE1OTMsMTYwOSwxNjE3LDE2NTAsMTY2NCwxNjY4LDE2NzcsNzEsNTksMSwzMzAsNzIsNSwyMDgsMSw1OSwxNDc2LDEsMjA4LDk5LDExNywxMTYsMTAxLDUsMjAxLDEsNTksMTQ4NywxLDIwMSw0LDMsOTcsMTA1LDEyMSwxNDk3LDE1MDMsMTUxMiwxMTQsMTExLDExMCw1OSwxLDI4MiwxMTQsOTksNSwyMDIsMSw1OSwxNTEwLDEsMjAyLDU5LDEsMTA2OSwxMTEsMTE2LDU5LDEsMjc4LDExNCw1OSwzLDU1MzQ5LDU2NTg0LDExNCw5NywxMTgsMTAxLDUsMjAwLDEsNTksMTUzNCwxLDIwMCwxMDEsMTA5LDEwMSwxMTAsMTE2LDU5LDEsODcxMiw0LDIsOTcsMTEyLDE1NTAsMTU1NSw5OSwxMTQsNTksMSwyNzQsMTE2LDEyMSw0LDIsODMsODYsMTU2MywxNTc2LDEwOSw5NywxMDgsMTA4LDgzLDExMywxMTcsOTcsMTE0LDEwMSw1OSwxLDk3MjMsMTAxLDExNCwxMjEsODMsMTA5LDk3LDEwOCwxMDgsODMsMTEzLDExNyw5NywxMTQsMTAxLDU5LDEsOTY0Myw0LDIsMTAzLDExMiwxNTk5LDE2MDQsMTExLDExMCw1OSwxLDI4MCwxMDIsNTksMyw1NTM0OSw1NjYzNiwxMTUsMTA1LDEwOCwxMTEsMTEwLDU5LDEsOTE3LDExNyw0LDIsOTcsMTA1LDE2MjQsMTY0MCwxMDgsNCwyLDU5LDg0LDE2MzEsMTYzMywxLDEwODY5LDEwNSwxMDgsMTAwLDEwMSw1OSwxLDg3NzAsMTA4LDEwNSw5OCwxMTQsMTA1LDExNywxMDksNTksMSw4NjUyLDQsMiw5OSwxMDUsMTY1NiwxNjYwLDExNCw1OSwxLDg0OTYsMTA5LDU5LDEsMTA4NjcsOTcsNTksMSw5MTksMTA5LDEwOCw1LDIwMywxLDU5LDE2NzUsMSwyMDMsNCwyLDEwNSwxMTIsMTY4MywxNjg5LDExNSwxMTYsMTE1LDU5LDEsODcwNywxMTEsMTEwLDEwMSwxMTAsMTE2LDEwNSw5NywxMDgsNjksNTksMSw4NTE5LDQsNSw5OSwxMDIsMTA1LDExMSwxMTUsMTcxMywxNzE3LDE3MjIsMTc2MiwxNzkxLDEyMSw1OSwxLDEwNjAsMTE0LDU5LDMsNTUzNDksNTY1ODUsMTA4LDEwOCwxMDEsMTAwLDQsMiw4Myw4NiwxNzMyLDE3NDUsMTA5LDk3LDEwOCwxMDgsODMsMTEzLDExNyw5NywxMTQsMTAxLDU5LDEsOTcyNCwxMDEsMTE0LDEyMSw4MywxMDksOTcsMTA4LDEwOCw4MywxMTMsMTE3LDk3LDExNCwxMDEsNTksMSw5NjQyLDQsMywxMTIsMTE0LDExNywxNzcwLDE3NzUsMTc4MSwxMDIsNTksMyw1NTM0OSw1NjYzNyw2NSwxMDgsMTA4LDU5LDEsODcwNCwxMTQsMTA1LDEwMSwxMTQsMTE2LDExNCwxMDIsNTksMSw4NDk3LDk5LDExNCw1OSwxLDg0OTcsNCwxMiw3NCw4NCw5Nyw5OCw5OSwxMDAsMTAyLDEwMywxMTEsMTE0LDExNSwxMTYsMTgyMiwxODI3LDE4MzQsMTg0OCwxODU1LDE4NzcsMTg4MiwxODg3LDE4OTAsMTg5NiwxOTc4LDE5ODQsOTksMTIxLDU5LDEsMTAyNyw1LDYyLDEsNTksMTgzMiwxLDYyLDEwOSwxMDksOTcsNCwyLDU5LDEwMCwxODQzLDE4NDUsMSw5MTUsNTksMSw5ODgsMTE0LDEwMSwxMTgsMTAxLDU5LDEsMjg2LDQsMywxMDEsMTA1LDEyMSwxODYzLDE4NjksMTg3NCwxMDAsMTA1LDEwOCw1OSwxLDI5MCwxMTQsOTksNTksMSwyODQsNTksMSwxMDQzLDExMSwxMTYsNTksMSwyODgsMTE0LDU5LDMsNTUzNDksNTY1ODYsNTksMSw4OTIxLDExMiwxMDIsNTksMyw1NTM0OSw1NjYzOCwxMDEsOTcsMTE2LDEwMSwxMTQsNCw2LDY5LDcwLDcxLDc2LDgzLDg0LDE5MTUsMTkzMywxOTQ0LDE5NTMsMTk1OSwxOTcxLDExMywxMTcsOTcsMTA4LDQsMiw1OSw3NiwxOTI1LDE5MjcsMSw4ODA1LDEwMSwxMTUsMTE1LDU5LDEsODkyMywxMTcsMTA4LDEwOCw2OSwxMTMsMTE3LDk3LDEwOCw1OSwxLDg4MDcsMTE0LDEwMSw5NywxMTYsMTAxLDExNCw1OSwxLDEwOTE0LDEwMSwxMTUsMTE1LDU5LDEsODgyMywxMDgsOTcsMTEwLDExNiw2OSwxMTMsMTE3LDk3LDEwOCw1OSwxLDEwODc4LDEwNSwxMDgsMTAwLDEwMSw1OSwxLDg4MTksOTksMTE0LDU5LDMsNTUzNDksNTY0ODIsNTksMSw4ODExLDQsOCw2NSw5Nyw5OSwxMDIsMTA1LDExMSwxMTUsMTE3LDIwMDUsMjAxMiwyMDI2LDIwMzIsMjAzNiwyMDQ5LDIwNzMsMjA4OSw4Miw2OCw5OSwxMjEsNTksMSwxMDY2LDQsMiw5OSwxMTYsMjAxOCwyMDIzLDEwMSwxMDcsNTksMSw3MTEsNTksMSw5NCwxMDUsMTE0LDk5LDU5LDEsMjkyLDExNCw1OSwxLDg0NjAsMTA4LDk4LDEwMSwxMTQsMTE2LDgzLDExMiw5Nyw5OSwxMDEsNTksMSw4NDU5LDQsMiwxMTIsMTE0LDIwNTUsMjA1OSwxMDIsNTksMSw4NDYxLDEwNSwxMjIsMTExLDExMCwxMTYsOTcsMTA4LDc2LDEwNSwxMTAsMTAxLDU5LDEsOTQ3Miw0LDIsOTksMTE2LDIwNzksMjA4MywxMTQsNTksMSw4NDU5LDExNCwxMTEsMTA3LDU5LDEsMjk0LDEwOSwxMTIsNCwyLDY4LDY5LDIwOTcsMjEwNywxMTEsMTE5LDExMCw3MiwxMTcsMTA5LDExMiw1OSwxLDg3ODIsMTEzLDExNyw5NywxMDgsNTksMSw4NzgzLDQsMTQsNjksNzQsNzksOTcsOTksMTAwLDEwMiwxMDMsMTA5LDExMCwxMTEsMTE1LDExNiwxMTcsMjE0NCwyMTQ5LDIxNTUsMjE2MCwyMTcxLDIxODksMjE5NCwyMTk4LDIyMDksMjI0NSwyMzA3LDIzMjksMjMzNCwyMzQxLDk5LDEyMSw1OSwxLDEwNDUsMTA4LDEwNSwxMDMsNTksMSwzMDYsOTksMTIxLDU5LDEsMTAyNSw5OSwxMTcsMTE2LDEwMSw1LDIwNSwxLDU5LDIxNjksMSwyMDUsNCwyLDEwNSwxMjEsMjE3NywyMTg2LDExNCw5OSw1LDIwNiwxLDU5LDIxODQsMSwyMDYsNTksMSwxMDQ4LDExMSwxMTYsNTksMSwzMDQsMTE0LDU5LDEsODQ2NSwxMTQsOTcsMTE4LDEwMSw1LDIwNCwxLDU5LDIyMDcsMSwyMDQsNCwzLDU5LDk3LDExMiwyMjE3LDIyMTksMjIzOCwxLDg0NjUsNCwyLDk5LDEwMywyMjI1LDIyMjksMTE0LDU5LDEsMjk4LDEwNSwxMTAsOTcsMTE0LDEyMSw3Myw1OSwxLDg1MjAsMTA4LDEwNSwxMDEsMTE1LDU5LDEsODY1OCw0LDIsMTE2LDExOCwyMjUxLDIyODEsNCwyLDU5LDEwMSwyMjU3LDIyNTksMSw4NzQ4LDQsMiwxMDMsMTE0LDIyNjUsMjI3MSwxMTQsOTcsMTA4LDU5LDEsODc0NywxMTUsMTAxLDk5LDExNiwxMDUsMTExLDExMCw1OSwxLDg4OTgsMTA1LDExNSwxMDUsOTgsMTA4LDEwMSw0LDIsNjcsODQsMjI5MywyMzAwLDExMSwxMDksMTA5LDk3LDU5LDEsODI5MSwxMDUsMTA5LDEwMSwxMTUsNTksMSw4MjkwLDQsMywxMDMsMTEyLDExNiwyMzE1LDIzMjAsMjMyNSwxMTEsMTEwLDU5LDEsMzAyLDEwMiw1OSwzLDU1MzQ5LDU2NjQwLDk3LDU5LDEsOTIxLDk5LDExNCw1OSwxLDg0NjQsMTA1LDEwOCwxMDAsMTAxLDU5LDEsMjk2LDQsMiwxMDcsMTA5LDIzNDcsMjM1Miw5OSwxMjEsNTksMSwxMDMwLDEwOCw1LDIwNywxLDU5LDIzNTgsMSwyMDcsNCw1LDk5LDEwMiwxMTEsMTE1LDExNywyMzcyLDIzODYsMjM5MSwyMzk3LDI0MTQsNCwyLDEwNSwxMjEsMjM3OCwyMzgzLDExNCw5OSw1OSwxLDMwOCw1OSwxLDEwNDksMTE0LDU5LDMsNTUzNDksNTY1ODksMTEyLDEwMiw1OSwzLDU1MzQ5LDU2NjQxLDQsMiw5OSwxMDEsMjQwMywyNDA4LDExNCw1OSwzLDU1MzQ5LDU2NDg1LDExNCw5OSwxMjEsNTksMSwxMDMyLDEwNyw5OSwxMjEsNTksMSwxMDI4LDQsNyw3Miw3NCw5Nyw5OSwxMDIsMTExLDExNSwyNDM2LDI0NDEsMjQ0NiwyNDUyLDI0NjcsMjQ3MiwyNDc4LDk5LDEyMSw1OSwxLDEwNjEsOTksMTIxLDU5LDEsMTAzNiwxMTIsMTEyLDk3LDU5LDEsOTIyLDQsMiwxMDEsMTIxLDI0NTgsMjQ2NCwxMDAsMTA1LDEwOCw1OSwxLDMxMCw1OSwxLDEwNTAsMTE0LDU5LDMsNTUzNDksNTY1OTAsMTEyLDEwMiw1OSwzLDU1MzQ5LDU2NjQyLDk5LDExNCw1OSwzLDU1MzQ5LDU2NDg2LDQsMTEsNzQsODQsOTcsOTksMTAxLDEwMiwxMDgsMTA5LDExMSwxMTUsMTE2LDI1MDgsMjUxMywyNTIwLDI1NjIsMjU4NSwyOTgxLDI5ODYsMzAwNCwzMDExLDMxNDYsMzE2Nyw5OSwxMjEsNTksMSwxMDMzLDUsNjAsMSw1OSwyNTE4LDEsNjAsNCw1LDk5LDEwOSwxMTAsMTEyLDExNCwyNTMyLDI1MzgsMjU0NCwyNTQ4LDI1NTgsMTE3LDExNiwxMDEsNTksMSwzMTMsOTgsMTAwLDk3LDU5LDEsOTIzLDEwMyw1OSwxLDEwMjE4LDEwOCw5Nyw5OSwxMDEsMTE2LDExNCwxMDIsNTksMSw4NDY2LDExNCw1OSwxLDg2MDYsNCwzLDk3LDEwMSwxMjEsMjU3MCwyNTc2LDI1ODIsMTE0LDExMSwxMTAsNTksMSwzMTcsMTAwLDEwNSwxMDgsNTksMSwzMTUsNTksMSwxMDUxLDQsMiwxMDIsMTE1LDI1OTEsMjkwNywxMTYsNCwxMCw2NSw2Nyw2OCw3MCw4Miw4NCw4NSw4Niw5NywxMTQsMjYxNCwyNjYzLDI2NzIsMjcyOCwyNzM1LDI3NjAsMjgyMCwyODcwLDI4ODgsMjg5NSw0LDIsMTEwLDExNCwyNjIwLDI2MzMsMTAzLDEwOCwxMDEsNjYsMTE0LDk3LDk5LDEwNywxMDEsMTE2LDU5LDEsMTAyMTYsMTE0LDExMSwxMTksNCwzLDU5LDY2LDgyLDI2NDQsMjY0NiwyNjUxLDEsODU5Miw5NywxMTQsNTksMSw4Njc2LDEwNSwxMDMsMTA0LDExNiw2NSwxMTQsMTE0LDExMSwxMTksNTksMSw4NjQ2LDEwMSwxMDUsMTA4LDEwNSwxMTAsMTAzLDU5LDEsODk2OCwxMTEsNCwyLDExNywxMTksMjY3OSwyNjkyLDk4LDEwOCwxMDEsNjYsMTE0LDk3LDk5LDEwNywxMDEsMTE2LDU5LDEsMTAyMTQsMTEwLDQsMiw4NCw4NiwyNjk5LDI3MTAsMTAxLDEwMSw4NiwxMDEsOTksMTE2LDExMSwxMTQsNTksMSwxMDU5MywxMDEsOTksMTE2LDExMSwxMTQsNCwyLDU5LDY2LDI3MjEsMjcyMywxLDg2NDMsOTcsMTE0LDU5LDEsMTA1ODUsMTA4LDExMSwxMTEsMTE0LDU5LDEsODk3MCwxMDUsMTAzLDEwNCwxMTYsNCwyLDY1LDg2LDI3NDUsMjc1MiwxMTQsMTE0LDExMSwxMTksNTksMSw4NTk2LDEwMSw5OSwxMTYsMTExLDExNCw1OSwxLDEwNTc0LDQsMiwxMDEsMTE0LDI3NjYsMjc5MiwxMDEsNCwzLDU5LDY1LDg2LDI3NzUsMjc3NywyNzg0LDEsODg2NywxMTQsMTE0LDExMSwxMTksNTksMSw4NjEyLDEwMSw5OSwxMTYsMTExLDExNCw1OSwxLDEwNTg2LDEwNSw5NywxMTAsMTAzLDEwOCwxMDEsNCwzLDU5LDY2LDY5LDI4MDYsMjgwOCwyODEzLDEsODg4Miw5NywxMTQsNTksMSwxMDcwMywxMTMsMTE3LDk3LDEwOCw1OSwxLDg4ODQsMTEyLDQsMyw2OCw4NCw4NiwyODI5LDI4NDEsMjg1MiwxMTEsMTE5LDExMCw4NiwxMDEsOTksMTE2LDExMSwxMTQsNTksMSwxMDU3NywxMDEsMTAxLDg2LDEwMSw5OSwxMTYsMTExLDExNCw1OSwxLDEwNTkyLDEwMSw5OSwxMTYsMTExLDExNCw0LDIsNTksNjYsMjg2MywyODY1LDEsODYzOSw5NywxMTQsNTksMSwxMDU4NCwxMDEsOTksMTE2LDExMSwxMTQsNCwyLDU5LDY2LDI4ODEsMjg4MywxLDg2MzYsOTcsMTE0LDU5LDEsMTA1NzgsMTE0LDExNCwxMTEsMTE5LDU5LDEsODY1NiwxMDUsMTAzLDEwNCwxMTYsOTcsMTE0LDExNCwxMTEsMTE5LDU5LDEsODY2MCwxMTUsNCw2LDY5LDcwLDcxLDc2LDgzLDg0LDI5MjIsMjkzNiwyOTQ3LDI5NTYsMjk2MiwyOTc0LDExMywxMTcsOTcsMTA4LDcxLDExNCwxMDEsOTcsMTE2LDEwMSwxMTQsNTksMSw4OTIyLDExNywxMDgsMTA4LDY5LDExMywxMTcsOTcsMTA4LDU5LDEsODgwNiwxMTQsMTAxLDk3LDExNiwxMDEsMTE0LDU5LDEsODgyMiwxMDEsMTE1LDExNSw1OSwxLDEwOTEzLDEwOCw5NywxMTAsMTE2LDY5LDExMywxMTcsOTcsMTA4LDU5LDEsMTA4NzcsMTA1LDEwOCwxMDAsMTAxLDU5LDEsODgxOCwxMTQsNTksMyw1NTM0OSw1NjU5MSw0LDIsNTksMTAxLDI5OTIsMjk5NCwxLDg5MjAsMTAyLDExNiw5NywxMTQsMTE0LDExMSwxMTksNTksMSw4NjY2LDEwNSwxMDAsMTExLDExNiw1OSwxLDMxOSw0LDMsMTEwLDExMiwxMTksMzAxOSwzMTEwLDMxMTUsMTAzLDQsNCw3Niw4MiwxMDgsMTE0LDMwMzAsMzA1OCwzMDcwLDMwOTgsMTAxLDEwMiwxMTYsNCwyLDY1LDgyLDMwMzksMzA0NiwxMTQsMTE0LDExMSwxMTksNTksMSwxMDIyOSwxMDUsMTAzLDEwNCwxMTYsNjUsMTE0LDExNCwxMTEsMTE5LDU5LDEsMTAyMzEsMTA1LDEwMywxMDQsMTE2LDY1LDExNCwxMTQsMTExLDExOSw1OSwxLDEwMjMwLDEwMSwxMDIsMTE2LDQsMiw5NywxMTQsMzA3OSwzMDg2LDExNCwxMTQsMTExLDExOSw1OSwxLDEwMjMyLDEwNSwxMDMsMTA0LDExNiw5NywxMTQsMTE0LDExMSwxMTksNTksMSwxMDIzNCwxMDUsMTAzLDEwNCwxMTYsOTcsMTE0LDExNCwxMTEsMTE5LDU5LDEsMTAyMzMsMTAyLDU5LDMsNTUzNDksNTY2NDMsMTAxLDExNCw0LDIsNzYsODIsMzEyMywzMTM0LDEwMSwxMDIsMTE2LDY1LDExNCwxMTQsMTExLDExOSw1OSwxLDg2MDEsMTA1LDEwMywxMDQsMTE2LDY1LDExNCwxMTQsMTExLDExOSw1OSwxLDg2MDAsNCwzLDk5LDEwNCwxMTYsMzE1NCwzMTU4LDMxNjEsMTE0LDU5LDEsODQ2Niw1OSwxLDg2MjQsMTE0LDExMSwxMDcsNTksMSwzMjEsNTksMSw4ODEwLDQsOCw5Nyw5OSwxMDEsMTAyLDEwNSwxMTEsMTE1LDExNywzMTg4LDMxOTIsMzE5NiwzMjIyLDMyMjcsMzIzNywzMjQzLDMyNDgsMTEyLDU5LDEsMTA1MDEsMTIxLDU5LDEsMTA1Miw0LDIsMTAwLDEwOCwzMjAyLDMyMTMsMTA1LDExNywxMDksODMsMTEyLDk3LDk5LDEwMSw1OSwxLDgyODcsMTA4LDEwNSwxMTAsMTE2LDExNCwxMDIsNTksMSw4NDk5LDExNCw1OSwzLDU1MzQ5LDU2NTkyLDExMCwxMTcsMTE1LDgwLDEwOCwxMTcsMTE1LDU5LDEsODcyMywxMTIsMTAyLDU5LDMsNTUzNDksNTY2NDQsOTksMTE0LDU5LDEsODQ5OSw1OSwxLDkyNCw0LDksNzQsOTcsOTksMTAxLDEwMiwxMTEsMTE1LDExNiwxMTcsMzI3MSwzMjc2LDMyODMsMzMwNiwzNDIyLDM0MjcsNDEyMCw0MTI2LDQxMzcsOTksMTIxLDU5LDEsMTAzNCw5OSwxMTcsMTE2LDEwMSw1OSwxLDMyMyw0LDMsOTcsMTAxLDEyMSwzMjkxLDMyOTcsMzMwMywxMTQsMTExLDExMCw1OSwxLDMyNywxMDAsMTA1LDEwOCw1OSwxLDMyNSw1OSwxLDEwNTMsNCwzLDEwMywxMTUsMTE5LDMzMTQsMzM4MCwzNDE1LDk3LDExNiwxMDUsMTE4LDEwMSw0LDMsNzcsODQsODYsMzMyNywzMzQwLDMzNjUsMTAxLDEwMCwxMDUsMTE3LDEwOSw4MywxMTIsOTcsOTksMTAxLDU5LDEsODIwMywxMDQsMTA1LDQsMiw5OSwxMTAsMzM0OCwzMzU3LDEwNyw4MywxMTIsOTcsOTksMTAxLDU5LDEsODIwMyw4MywxMTIsOTcsOTksMTAxLDU5LDEsODIwMywxMDEsMTE0LDEyMSw4NCwxMDQsMTA1LDExMCw4MywxMTIsOTcsOTksMTAxLDU5LDEsODIwMywxMTYsMTAxLDEwMCw0LDIsNzEsNzYsMzM4OSwzNDA1LDExNCwxMDEsOTcsMTE2LDEwMSwxMTQsNzEsMTE0LDEwMSw5NywxMTYsMTAxLDExNCw1OSwxLDg4MTEsMTAxLDExNSwxMTUsNzYsMTAxLDExNSwxMTUsNTksMSw4ODEwLDc2LDEwNSwxMTAsMTAxLDU5LDEsMTAsMTE0LDU5LDMsNTUzNDksNTY1OTMsNCw0LDY2LDExMCwxMTIsMTE2LDM0MzcsMzQ0NCwzNDYwLDM0NjQsMTE0LDEwMSw5NywxMDcsNTksMSw4Mjg4LDY2LDExNCwxMDEsOTcsMTA3LDEwNSwxMTAsMTAzLDgzLDExMiw5Nyw5OSwxMDEsNTksMSwxNjAsMTAyLDU5LDEsODQ2OSw0LDEzLDU5LDY3LDY4LDY5LDcxLDcyLDc2LDc4LDgwLDgyLDgzLDg0LDg2LDM0OTIsMzQ5NCwzNTE3LDM1MzYsMzU3OCwzNjU3LDM2ODUsMzc4NCwzODIzLDM4NjAsMzkxNSw0MDY2LDQxMDcsMSwxMDk4OCw0LDIsMTExLDExNywzNTAwLDM1MTAsMTEwLDEwMywxMTQsMTE3LDEwMSwxMTAsMTE2LDU5LDEsODgwMiwxMTIsNjcsOTcsMTEyLDU5LDEsODgxMywxMTEsMTE3LDk4LDEwOCwxMDEsODYsMTAxLDExNCwxMTYsMTA1LDk5LDk3LDEwOCw2Niw5NywxMTQsNTksMSw4NzQyLDQsMywxMDgsMTEzLDEyMCwzNTQ0LDM1NTIsMzU3MSwxMDEsMTA5LDEwMSwxMTAsMTE2LDU5LDEsODcxMywxMTcsOTcsMTA4LDQsMiw1OSw4NCwzNTYxLDM1NjMsMSw4ODAwLDEwNSwxMDgsMTAwLDEwMSw1OSwzLDg3NzAsODI0LDEwNSwxMTUsMTE2LDExNSw1OSwxLDg3MDgsMTE0LDEwMSw5NywxMTYsMTAxLDExNCw0LDcsNTksNjksNzAsNzEsNzYsODMsODQsMzYwMCwzNjAyLDM2MDksMzYyMSwzNjMxLDM2MzcsMzY1MCwxLDg4MTUsMTEzLDExNyw5NywxMDgsNTksMSw4ODE3LDExNywxMDgsMTA4LDY5LDExMywxMTcsOTcsMTA4LDU5LDMsODgwNyw4MjQsMTE0LDEwMSw5NywxMTYsMTAxLDExNCw1OSwzLDg4MTEsODI0LDEwMSwxMTUsMTE1LDU5LDEsODgyNSwxMDgsOTcsMTEwLDExNiw2OSwxMTMsMTE3LDk3LDEwOCw1OSwzLDEwODc4LDgyNCwxMDUsMTA4LDEwMCwxMDEsNTksMSw4ODIxLDExNywxMDksMTEyLDQsMiw2OCw2OSwzNjY2LDM2NzcsMTExLDExOSwxMTAsNzIsMTE3LDEwOSwxMTIsNTksMyw4NzgyLDgyNCwxMTMsMTE3LDk3LDEwOCw1OSwzLDg3ODMsODI0LDEwMSw0LDIsMTAyLDExNSwzNjkyLDM3MjQsMTE2LDg0LDExNCwxMDUsOTcsMTEwLDEwMywxMDgsMTAxLDQsMyw1OSw2Niw2OSwzNzA5LDM3MTEsMzcxNywxLDg5MzgsOTcsMTE0LDU5LDMsMTA3MDMsODI0LDExMywxMTcsOTcsMTA4LDU5LDEsODk0MCwxMTUsNCw2LDU5LDY5LDcxLDc2LDgzLDg0LDM3MzksMzc0MSwzNzQ4LDM3NTcsMzc2NCwzNzc3LDEsODgxNCwxMTMsMTE3LDk3LDEwOCw1OSwxLDg4MTYsMTE0LDEwMSw5NywxMTYsMTAxLDExNCw1OSwxLDg4MjQsMTAxLDExNSwxMTUsNTksMyw4ODEwLDgyNCwxMDgsOTcsMTEwLDExNiw2OSwxMTMsMTE3LDk3LDEwOCw1OSwzLDEwODc3LDgyNCwxMDUsMTA4LDEwMCwxMDEsNTksMSw4ODIwLDEwMSwxMTUsMTE2LDEwMSwxMDAsNCwyLDcxLDc2LDM3OTUsMzgxMiwxMTQsMTAxLDk3LDExNiwxMDEsMTE0LDcxLDExNCwxMDEsOTcsMTE2LDEwMSwxMTQsNTksMywxMDkxNCw4MjQsMTAxLDExNSwxMTUsNzYsMTAxLDExNSwxMTUsNTksMywxMDkxMyw4MjQsMTE0LDEwMSw5OSwxMDEsMTAwLDEwMSwxMTUsNCwzLDU5LDY5LDgzLDM4MzgsMzg0MCwzODQ4LDEsODgzMiwxMTMsMTE3LDk3LDEwOCw1OSwzLDEwOTI3LDgyNCwxMDgsOTcsMTEwLDExNiw2OSwxMTMsMTE3LDk3LDEwOCw1OSwxLDg5MjgsNCwyLDEwMSwxMDUsMzg2NiwzODgxLDExOCwxMDEsMTE0LDExNSwxMDEsNjksMTA4LDEwMSwxMDksMTAxLDExMCwxMTYsNTksMSw4NzE2LDEwMywxMDQsMTE2LDg0LDExNCwxMDUsOTcsMTEwLDEwMywxMDgsMTAxLDQsMyw1OSw2Niw2OSwzOTAwLDM5MDIsMzkwOCwxLDg5MzksOTcsMTE0LDU5LDMsMTA3MDQsODI0LDExMywxMTcsOTcsMTA4LDU5LDEsODk0MSw0LDIsMTEzLDExNywzOTIxLDM5NzMsMTE3LDk3LDExNCwxMDEsODMsMTE3LDQsMiw5OCwxMTIsMzkzMywzOTUyLDExNSwxMDEsMTE2LDQsMiw1OSw2OSwzOTQyLDM5NDUsMyw4ODQ3LDgyNCwxMTMsMTE3LDk3LDEwOCw1OSwxLDg5MzAsMTAxLDExNCwxMTUsMTAxLDExNiw0LDIsNTksNjksMzk2MywzOTY2LDMsODg0OCw4MjQsMTEzLDExNyw5NywxMDgsNTksMSw4OTMxLDQsMyw5OCw5OSwxMTIsMzk4MSw0MDAwLDQwNDUsMTE1LDEwMSwxMTYsNCwyLDU5LDY5LDM5OTAsMzk5MywzLDg4MzQsODQwMiwxMTMsMTE3LDk3LDEwOCw1OSwxLDg4NDAsOTksMTAxLDEwMSwxMDAsMTE1LDQsNCw1OSw2OSw4Myw4NCw0MDE1LDQwMTcsNDAyNSw0MDM3LDEsODgzMywxMTMsMTE3LDk3LDEwOCw1OSwzLDEwOTI4LDgyNCwxMDgsOTcsMTEwLDExNiw2OSwxMTMsMTE3LDk3LDEwOCw1OSwxLDg5MjksMTA1LDEwOCwxMDAsMTAxLDU5LDMsODgzMSw4MjQsMTAxLDExNCwxMTUsMTAxLDExNiw0LDIsNTksNjksNDA1Niw0MDU5LDMsODgzNSw4NDAyLDExMywxMTcsOTcsMTA4LDU5LDEsODg0MSwxMDUsMTA4LDEwMCwxMDEsNCw0LDU5LDY5LDcwLDg0LDQwODAsNDA4Miw0MDg5LDQxMDAsMSw4NzY5LDExMywxMTcsOTcsMTA4LDU5LDEsODc3MiwxMTcsMTA4LDEwOCw2OSwxMTMsMTE3LDk3LDEwOCw1OSwxLDg3NzUsMTA1LDEwOCwxMDAsMTAxLDU5LDEsODc3NywxMDEsMTE0LDExNiwxMDUsOTksOTcsMTA4LDY2LDk3LDExNCw1OSwxLDg3NDAsOTksMTE0LDU5LDMsNTUzNDksNTY0ODksMTA1LDEwOCwxMDAsMTAxLDUsMjA5LDEsNTksNDEzNSwxLDIwOSw1OSwxLDkyNSw0LDE0LDY5LDk3LDk5LDEwMCwxMDIsMTAzLDEwOSwxMTEsMTEyLDExNCwxMTUsMTE2LDExNywxMTgsNDE3MCw0MTc2LDQxODcsNDIwNSw0MjEyLDQyMTcsNDIyOCw0MjUzLDQyNTksNDI5Miw0Mjk1LDQzMTYsNDMzNyw0MzQ2LDEwOCwxMDUsMTAzLDU5LDEsMzM4LDk5LDExNywxMTYsMTAxLDUsMjExLDEsNTksNDE4NSwxLDIxMSw0LDIsMTA1LDEyMSw0MTkzLDQyMDIsMTE0LDk5LDUsMjEyLDEsNTksNDIwMCwxLDIxMiw1OSwxLDEwNTQsOTgsMTA4LDk3LDk5LDU5LDEsMzM2LDExNCw1OSwzLDU1MzQ5LDU2NTk0LDExNCw5NywxMTgsMTAxLDUsMjEwLDEsNTksNDIyNiwxLDIxMCw0LDMsOTcsMTAxLDEwNSw0MjM2LDQyNDEsNDI0Niw5OSwxMTQsNTksMSwzMzIsMTAzLDk3LDU5LDEsOTM3LDk5LDExNCwxMTEsMTEwLDU5LDEsOTI3LDExMiwxMDIsNTksMyw1NTM0OSw1NjY0NiwxMDEsMTEwLDY3LDExNywxMTQsMTA4LDEyMSw0LDIsNjgsODEsNDI3Miw0Mjg1LDExMSwxMTcsOTgsMTA4LDEwMSw4MSwxMTcsMTExLDExNiwxMDEsNTksMSw4MjIwLDExNywxMTEsMTE2LDEwMSw1OSwxLDgyMTYsNTksMSwxMDgzNiw0LDIsOTksMTA4LDQzMDEsNDMwNiwxMTQsNTksMyw1NTM0OSw1NjQ5MCw5NywxMTUsMTA0LDUsMjE2LDEsNTksNDMxNCwxLDIxNiwxMDUsNCwyLDEwOCwxMDksNDMyMyw0MzMyLDEwMCwxMDEsNSwyMTMsMSw1OSw0MzMwLDEsMjEzLDEwMSwxMTUsNTksMSwxMDgwNywxMDksMTA4LDUsMjE0LDEsNTksNDM0NCwxLDIxNCwxMDEsMTE0LDQsMiw2Niw4MCw0MzU0LDQzODAsNCwyLDk3LDExNCw0MzYwLDQzNjQsMTE0LDU5LDEsODI1NCw5Nyw5OSw0LDIsMTAxLDEwNyw0MzcyLDQzNzUsNTksMSw5MTgyLDEwMSwxMTYsNTksMSw5MTQwLDk3LDExNCwxMDEsMTEwLDExNiwxMDQsMTAxLDExNSwxMDUsMTE1LDU5LDEsOTE4MCw0LDksOTcsOTksMTAyLDEwNCwxMDUsMTA4LDExMSwxMTQsMTE1LDQ0MTMsNDQyMiw0NDI2LDQ0MzEsNDQzNSw0NDM4LDQ0NDgsNDQ3MSw0NTYxLDExNCwxMTYsMTA1LDk3LDEwOCw2OCw1OSwxLDg3MDYsMTIxLDU5LDEsMTA1NSwxMTQsNTksMyw1NTM0OSw1NjU5NSwxMDUsNTksMSw5MzQsNTksMSw5MjgsMTE3LDExNSw3NywxMDUsMTEwLDExNywxMTUsNTksMSwxNzcsNCwyLDEwNSwxMTIsNDQ1NCw0NDY3LDExMCw5OSw5NywxMTQsMTAxLDExMiwxMDgsOTcsMTEwLDEwMSw1OSwxLDg0NjAsMTAyLDU5LDEsODQ3Myw0LDQsNTksMTAxLDEwNSwxMTEsNDQ4MSw0NDgzLDQ1MjYsNDUzMSwxLDEwOTM5LDk5LDEwMSwxMDAsMTAxLDExNSw0LDQsNTksNjksODMsODQsNDQ5OCw0NTAwLDQ1MDcsNDUxOSwxLDg4MjYsMTEzLDExNyw5NywxMDgsNTksMSwxMDkyNywxMDgsOTcsMTEwLDExNiw2OSwxMTMsMTE3LDk3LDEwOCw1OSwxLDg4MjgsMTA1LDEwOCwxMDAsMTAxLDU5LDEsODgzMCwxMDksMTAxLDU5LDEsODI0Myw0LDIsMTAwLDExMiw0NTM3LDQ1NDMsMTE3LDk5LDExNiw1OSwxLDg3MTksMTExLDExNCwxMTYsMTA1LDExMSwxMTAsNCwyLDU5LDk3LDQ1NTUsNDU1NywxLDg3NTksMTA4LDU5LDEsODczMyw0LDIsOTksMTA1LDQ1NjcsNDU3MiwxMTQsNTksMyw1NTM0OSw1NjQ5MSw1OSwxLDkzNiw0LDQsODUsMTAyLDExMSwxMTUsNDU4NSw0NTk0LDQ1OTksNDYwNCw3OSw4NCw1LDM0LDEsNTksNDU5MiwxLDM0LDExNCw1OSwzLDU1MzQ5LDU2NTk2LDExMiwxMDIsNTksMSw4NDc0LDk5LDExNCw1OSwzLDU1MzQ5LDU2NDkyLDQsMTIsNjYsNjksOTcsOTksMTAxLDEwMiwxMDQsMTA1LDExMSwxMTQsMTE1LDExNyw0NjM2LDQ2NDIsNDY1MCw0NjgxLDQ3MDQsNDc2Myw0NzY3LDQ3NzEsNTA0Nyw1MDY5LDUwODEsNTA5NCw5NywxMTQsMTE0LDU5LDEsMTA1MTIsNzEsNSwxNzQsMSw1OSw0NjQ4LDEsMTc0LDQsMyw5OSwxMTAsMTE0LDQ2NTgsNDY2NCw0NjY4LDExNywxMTYsMTAxLDU5LDEsMzQwLDEwMyw1OSwxLDEwMjE5LDExNCw0LDIsNTksMTE2LDQ2NzUsNDY3NywxLDg2MDgsMTA4LDU5LDEsMTA1MTgsNCwzLDk3LDEwMSwxMjEsNDY4OSw0Njk1LDQ3MDEsMTE0LDExMSwxMTAsNTksMSwzNDQsMTAwLDEwNSwxMDgsNTksMSwzNDIsNTksMSwxMDU2LDQsMiw1OSwxMTgsNDcxMCw0NzEyLDEsODQ3NiwxMDEsMTE0LDExNSwxMDEsNCwyLDY5LDg1LDQ3MjIsNDc0OCw0LDIsMTA4LDExMyw0NzI4LDQ3MzYsMTAxLDEwOSwxMDEsMTEwLDExNiw1OSwxLDg3MTUsMTE3LDEwNSwxMDgsMTA1LDk4LDExNCwxMDUsMTE3LDEwOSw1OSwxLDg2NTEsMTEyLDY5LDExMywxMTcsMTA1LDEwOCwxMDUsOTgsMTE0LDEwNSwxMTcsMTA5LDU5LDEsMTA2MDcsMTE0LDU5LDEsODQ3NiwxMTEsNTksMSw5MjksMTAzLDEwNCwxMTYsNCw4LDY1LDY3LDY4LDcwLDg0LDg1LDg2LDk3LDQ3OTIsNDg0MCw0ODQ5LDQ5MDUsNDkxMiw0OTcyLDUwMjIsNTA0MCw0LDIsMTEwLDExNCw0Nzk4LDQ4MTEsMTAzLDEwOCwxMDEsNjYsMTE0LDk3LDk5LDEwNywxMDEsMTE2LDU5LDEsMTAyMTcsMTE0LDExMSwxMTksNCwzLDU5LDY2LDc2LDQ4MjIsNDgyNCw0ODI5LDEsODU5NCw5NywxMTQsNTksMSw4Njc3LDEwMSwxMDIsMTE2LDY1LDExNCwxMTQsMTExLDExOSw1OSwxLDg2NDQsMTAxLDEwNSwxMDgsMTA1LDExMCwxMDMsNTksMSw4OTY5LDExMSw0LDIsMTE3LDExOSw0ODU2LDQ4NjksOTgsMTA4LDEwMSw2NiwxMTQsOTcsOTksMTA3LDEwMSwxMTYsNTksMSwxMDIxNSwxMTAsNCwyLDg0LDg2LDQ4NzYsNDg4NywxMDEsMTAxLDg2LDEwMSw5OSwxMTYsMTExLDExNCw1OSwxLDEwNTg5LDEwMSw5OSwxMTYsMTExLDExNCw0LDIsNTksNjYsNDg5OCw0OTAwLDEsODY0Miw5NywxMTQsNTksMSwxMDU4MSwxMDgsMTExLDExMSwxMTQsNTksMSw4OTcxLDQsMiwxMDEsMTE0LDQ5MTgsNDk0NCwxMDEsNCwzLDU5LDY1LDg2LDQ5MjcsNDkyOSw0OTM2LDEsODg2NiwxMTQsMTE0LDExMSwxMTksNTksMSw4NjE0LDEwMSw5OSwxMTYsMTExLDExNCw1OSwxLDEwNTg3LDEwNSw5NywxMTAsMTAzLDEwOCwxMDEsNCwzLDU5LDY2LDY5LDQ5NTgsNDk2MCw0OTY1LDEsODg4Myw5NywxMTQsNTksMSwxMDcwNCwxMTMsMTE3LDk3LDEwOCw1OSwxLDg4ODUsMTEyLDQsMyw2OCw4NCw4Niw0OTgxLDQ5OTMsNTAwNCwxMTEsMTE5LDExMCw4NiwxMDEsOTksMTE2LDExMSwxMTQsNTksMSwxMDU3NSwxMDEsMTAxLDg2LDEwMSw5OSwxMTYsMTExLDExNCw1OSwxLDEwNTg4LDEwMSw5OSwxMTYsMTExLDExNCw0LDIsNTksNjYsNTAxNSw1MDE3LDEsODYzOCw5NywxMTQsNTksMSwxMDU4MCwxMDEsOTksMTE2LDExMSwxMTQsNCwyLDU5LDY2LDUwMzMsNTAzNSwxLDg2NDAsOTcsMTE0LDU5LDEsMTA1NzksMTE0LDExNCwxMTEsMTE5LDU5LDEsODY1OCw0LDIsMTEyLDExNyw1MDUzLDUwNTcsMTAyLDU5LDEsODQ3NywxMTAsMTAwLDczLDEwOSwxMTIsMTA4LDEwNSwxMDEsMTE1LDU5LDEsMTA2MDgsMTA1LDEwMywxMDQsMTE2LDk3LDExNCwxMTQsMTExLDExOSw1OSwxLDg2NjcsNCwyLDk5LDEwNCw1MDg3LDUwOTEsMTE0LDU5LDEsODQ3NSw1OSwxLDg2MjUsMTA4LDEwMSw2OCwxMDEsMTA4LDk3LDEyMSwxMDEsMTAwLDU5LDEsMTA3NDAsNCwxMyw3Miw3OSw5Nyw5OSwxMDIsMTA0LDEwNSwxMDksMTExLDExMywxMTUsMTE2LDExNyw1MTM0LDUxNTAsNTE1Nyw1MTY0LDUxOTgsNTIwMyw1MjU5LDUyNjUsNTI3Nyw1MjgzLDUzNzQsNTM4MCw1Mzg1LDQsMiw2Nyw5OSw1MTQwLDUxNDYsNzIsOTksMTIxLDU5LDEsMTA2NSwxMjEsNTksMSwxMDY0LDcwLDg0LDk5LDEyMSw1OSwxLDEwNjgsOTksMTE3LDExNiwxMDEsNTksMSwzNDYsNCw1LDU5LDk3LDEwMSwxMDUsMTIxLDUxNzYsNTE3OCw1MTg0LDUxOTAsNTE5NSwxLDEwOTQwLDExNCwxMTEsMTEwLDU5LDEsMzUyLDEwMCwxMDUsMTA4LDU5LDEsMzUwLDExNCw5OSw1OSwxLDM0OCw1OSwxLDEwNTcsMTE0LDU5LDMsNTUzNDksNTY1OTgsMTExLDExNCwxMTYsNCw0LDY4LDc2LDgyLDg1LDUyMTYsNTIyNyw1MjM4LDUyNTAsMTExLDExOSwxMTAsNjUsMTE0LDExNCwxMTEsMTE5LDU5LDEsODU5NSwxMDEsMTAyLDExNiw2NSwxMTQsMTE0LDExMSwxMTksNTksMSw4NTkyLDEwNSwxMDMsMTA0LDExNiw2NSwxMTQsMTE0LDExMSwxMTksNTksMSw4NTk0LDExMiw2NSwxMTQsMTE0LDExMSwxMTksNTksMSw4NTkzLDEwMywxMDksOTcsNTksMSw5MzEsOTcsMTA4LDEwOCw2NywxMDUsMTE0LDk5LDEwOCwxMDEsNTksMSw4NzI4LDExMiwxMDIsNTksMyw1NTM0OSw1NjY1MCw0LDIsMTE0LDExNyw1Mjg5LDUyOTMsMTE2LDU5LDEsODczMCw5NywxMTQsMTAxLDQsNCw1OSw3Myw4Myw4NSw1MzA2LDUzMDgsNTMyMiw1MzY3LDEsOTYzMywxMTAsMTE2LDEwMSwxMTQsMTE1LDEwMSw5OSwxMTYsMTA1LDExMSwxMTAsNTksMSw4ODUxLDExNyw0LDIsOTgsMTEyLDUzMjksNTM0NywxMTUsMTAxLDExNiw0LDIsNTksNjksNTMzOCw1MzQwLDEsODg0NywxMTMsMTE3LDk3LDEwOCw1OSwxLDg4NDksMTAxLDExNCwxMTUsMTAxLDExNiw0LDIsNTksNjksNTM1OCw1MzYwLDEsODg0OCwxMTMsMTE3LDk3LDEwOCw1OSwxLDg4NTAsMTEwLDEwNSwxMTEsMTEwLDU5LDEsODg1Miw5OSwxMTQsNTksMyw1NTM0OSw1NjQ5NCw5NywxMTQsNTksMSw4OTAyLDQsNCw5OCw5OSwxMDksMTEyLDUzOTUsNTQyMCw1NDc1LDU0NzgsNCwyLDU5LDExNSw1NDAxLDU0MDMsMSw4OTEyLDEwMSwxMTYsNCwyLDU5LDY5LDU0MTEsNTQxMywxLDg5MTIsMTEzLDExNyw5NywxMDgsNTksMSw4ODM4LDQsMiw5OSwxMDQsNTQyNiw1NDY4LDEwMSwxMDEsMTAwLDExNSw0LDQsNTksNjksODMsODQsNTQ0MCw1NDQyLDU0NDksNTQ2MSwxLDg4MjcsMTEzLDExNyw5NywxMDgsNTksMSwxMDkyOCwxMDgsOTcsMTEwLDExNiw2OSwxMTMsMTE3LDk3LDEwOCw1OSwxLDg4MjksMTA1LDEwOCwxMDAsMTAxLDU5LDEsODgzMSw4NCwxMDQsOTcsMTE2LDU5LDEsODcxNSw1OSwxLDg3MjEsNCwzLDU5LDEwMSwxMTUsNTQ4Niw1NDg4LDU1MDcsMSw4OTEzLDExNCwxMTUsMTAxLDExNiw0LDIsNTksNjksNTQ5OCw1NTAwLDEsODgzNSwxMTMsMTE3LDk3LDEwOCw1OSwxLDg4MzksMTAxLDExNiw1OSwxLDg5MTMsNCwxMSw3Miw4Miw4Myw5Nyw5OSwxMDIsMTA0LDEwNSwxMTEsMTE0LDExNSw1NTM2LDU1NDYsNTU1Miw1NTY3LDU1NzksNTYwMiw1NjA3LDU2NTUsNTY5NSw1NzAxLDU3MTEsNzksODIsNzgsNSwyMjIsMSw1OSw1NTQ0LDEsMjIyLDY1LDY4LDY5LDU5LDEsODQ4Miw0LDIsNzIsOTksNTU1OCw1NTYzLDk5LDEyMSw1OSwxLDEwMzUsMTIxLDU5LDEsMTA2Miw0LDIsOTgsMTE3LDU1NzMsNTU3Niw1OSwxLDksNTksMSw5MzIsNCwzLDk3LDEwMSwxMjEsNTU4Nyw1NTkzLDU1OTksMTE0LDExMSwxMTAsNTksMSwzNTYsMTAwLDEwNSwxMDgsNTksMSwzNTQsNTksMSwxMDU4LDExNCw1OSwzLDU1MzQ5LDU2NTk5LDQsMiwxMDEsMTA1LDU2MTMsNTYzMSw0LDIsMTE0LDExNiw1NjE5LDU2MjcsMTAxLDEwMiwxMTEsMTE0LDEwMSw1OSwxLDg3NTYsOTcsNTksMSw5MjAsNCwyLDk5LDExMCw1NjM3LDU2NDcsMTA3LDgzLDExMiw5Nyw5OSwxMDEsNTksMyw4Mjg3LDgyMDIsODMsMTEyLDk3LDk5LDEwMSw1OSwxLDgyMDEsMTA4LDEwMCwxMDEsNCw0LDU5LDY5LDcwLDg0LDU2NjgsNTY3MCw1Njc3LDU2ODgsMSw4NzY0LDExMywxMTcsOTcsMTA4LDU5LDEsODc3MSwxMTcsMTA4LDEwOCw2OSwxMTMsMTE3LDk3LDEwOCw1OSwxLDg3NzMsMTA1LDEwOCwxMDAsMTAxLDU5LDEsODc3NiwxMTIsMTAyLDU5LDMsNTUzNDksNTY2NTEsMTA1LDExMiwxMDgsMTAxLDY4LDExMSwxMTYsNTksMSw4NDExLDQsMiw5OSwxMTYsNTcxNyw1NzIyLDExNCw1OSwzLDU1MzQ5LDU2NDk1LDExNCwxMTEsMTA3LDU5LDEsMzU4LDQsMTQsOTcsOTgsOTksMTAwLDEwMiwxMDMsMTA5LDExMCwxMTEsMTEyLDExNCwxMTUsMTE2LDExNyw1NzU4LDU3ODksNTgwNSw1ODIzLDU4MzAsNTgzNSw1ODQ2LDU4NTIsNTkyMSw1OTM3LDYwODksNjA5NSw2MTAxLDYxMDgsNCwyLDk5LDExNCw1NzY0LDU3NzQsMTE3LDExNiwxMDEsNSwyMTgsMSw1OSw1NzcyLDEsMjE4LDExNCw0LDIsNTksMTExLDU3ODEsNTc4MywxLDg2MDcsOTksMTA1LDExNCw1OSwxLDEwNTY5LDExNCw0LDIsOTksMTAxLDU3OTYsNTgwMCwxMjEsNTksMSwxMDM4LDExOCwxMDEsNTksMSwzNjQsNCwyLDEwNSwxMjEsNTgxMSw1ODIwLDExNCw5OSw1LDIxOSwxLDU5LDU4MTgsMSwyMTksNTksMSwxMDU5LDk4LDEwOCw5Nyw5OSw1OSwxLDM2OCwxMTQsNTksMyw1NTM0OSw1NjYwMCwxMTQsOTcsMTE4LDEwMSw1LDIxNywxLDU5LDU4NDQsMSwyMTcsOTcsOTksMTE0LDU5LDEsMzYyLDQsMiwxMDAsMTA1LDU4NTgsNTkwNSwxMDEsMTE0LDQsMiw2Niw4MCw1ODY2LDU4OTIsNCwyLDk3LDExNCw1ODcyLDU4NzYsMTE0LDU5LDEsOTUsOTcsOTksNCwyLDEwMSwxMDcsNTg4NCw1ODg3LDU5LDEsOTE4MywxMDEsMTE2LDU5LDEsOTE0MSw5NywxMTQsMTAxLDExMCwxMTYsMTA0LDEwMSwxMTUsMTA1LDExNSw1OSwxLDkxODEsMTExLDExMCw0LDIsNTksODAsNTkxMyw1OTE1LDEsODg5OSwxMDgsMTE3LDExNSw1OSwxLDg4NDYsNCwyLDEwMywxMTIsNTkyNyw1OTMyLDExMSwxMTAsNTksMSwzNzAsMTAyLDU5LDMsNTUzNDksNTY2NTIsNCw4LDY1LDY4LDY5LDg0LDk3LDEwMCwxMTIsMTE1LDU5NTUsNTk4NSw1OTk2LDYwMDksNjAyNiw2MDMzLDYwNDQsNjA3NSwxMTQsMTE0LDExMSwxMTksNCwzLDU5LDY2LDY4LDU5NjcsNTk2OSw1OTc0LDEsODU5Myw5NywxMTQsNTksMSwxMDUxNCwxMTEsMTE5LDExMCw2NSwxMTQsMTE0LDExMSwxMTksNTksMSw4NjQ1LDExMSwxMTksMTEwLDY1LDExNCwxMTQsMTExLDExOSw1OSwxLDg1OTcsMTEzLDExNywxMDUsMTA4LDEwNSw5OCwxMTQsMTA1LDExNywxMDksNTksMSwxMDYwNiwxMDEsMTAxLDQsMiw1OSw2NSw2MDE3LDYwMTksMSw4ODY5LDExNCwxMTQsMTExLDExOSw1OSwxLDg2MTMsMTE0LDExNCwxMTEsMTE5LDU5LDEsODY1NywxMTEsMTE5LDExMCw5NywxMTQsMTE0LDExMSwxMTksNTksMSw4NjYxLDEwMSwxMTQsNCwyLDc2LDgyLDYwNTIsNjA2MywxMDEsMTAyLDExNiw2NSwxMTQsMTE0LDExMSwxMTksNTksMSw4NTk4LDEwNSwxMDMsMTA0LDExNiw2NSwxMTQsMTE0LDExMSwxMTksNTksMSw4NTk5LDEwNSw0LDIsNTksMTA4LDYwODIsNjA4NCwxLDk3OCwxMTEsMTEwLDU5LDEsOTMzLDEwNSwxMTAsMTAzLDU5LDEsMzY2LDk5LDExNCw1OSwzLDU1MzQ5LDU2NDk2LDEwNSwxMDgsMTAwLDEwMSw1OSwxLDM2MCwxMDksMTA4LDUsMjIwLDEsNTksNjExNSwxLDIyMCw0LDksNjgsOTgsOTksMTAwLDEwMSwxMDIsMTExLDExNSwxMTgsNjEzNyw2MTQzLDYxNDgsNjE1Miw2MTY2LDYyNTAsNjI1NSw2MjYxLDYyNjcsOTcsMTE1LDEwNCw1OSwxLDg4NzUsOTcsMTE0LDU5LDEsMTA5ODcsMTIxLDU5LDEsMTA0Miw5NywxMTUsMTA0LDQsMiw1OSwxMDgsNjE2MSw2MTYzLDEsODg3Myw1OSwxLDEwOTgyLDQsMiwxMDEsMTE0LDYxNzIsNjE3NSw1OSwxLDg4OTcsNCwzLDk4LDExNiwxMjEsNjE4Myw2MTg4LDYyMzgsOTcsMTE0LDU5LDEsODIxNCw0LDIsNTksMTA1LDYxOTQsNjE5NiwxLDgyMTQsOTksOTcsMTA4LDQsNCw2Niw3Niw4Myw4NCw2MjA5LDYyMTQsNjIyMCw2MjMxLDk3LDExNCw1OSwxLDg3MzksMTA1LDExMCwxMDEsNTksMSwxMjQsMTAxLDExMiw5NywxMTQsOTcsMTE2LDExMSwxMTQsNTksMSwxMDA3MiwxMDUsMTA4LDEwMCwxMDEsNTksMSw4NzY4LDg0LDEwNCwxMDUsMTEwLDgzLDExMiw5Nyw5OSwxMDEsNTksMSw4MjAyLDExNCw1OSwzLDU1MzQ5LDU2NjAxLDExMiwxMDIsNTksMyw1NTM0OSw1NjY1Myw5OSwxMTQsNTksMyw1NTM0OSw1NjQ5NywxMDAsOTcsMTE1LDEwNCw1OSwxLDg4NzQsNCw1LDk5LDEwMSwxMDIsMTExLDExNSw2Mjg2LDYyOTIsNjI5OCw2MzAzLDYzMDksMTA1LDExNCw5OSw1OSwxLDM3MiwxMDAsMTAzLDEwMSw1OSwxLDg4OTYsMTE0LDU5LDMsNTUzNDksNTY2MDIsMTEyLDEwMiw1OSwzLDU1MzQ5LDU2NjU0LDk5LDExNCw1OSwzLDU1MzQ5LDU2NDk4LDQsNCwxMDIsMTA1LDExMSwxMTUsNjMyNSw2MzMwLDYzMzMsNjMzOSwxMTQsNTksMyw1NTM0OSw1NjYwMyw1OSwxLDkyNiwxMTIsMTAyLDU5LDMsNTUzNDksNTY2NTUsOTksMTE0LDU5LDMsNTUzNDksNTY0OTksNCw5LDY1LDczLDg1LDk3LDk5LDEwMiwxMTEsMTE1LDExNyw2MzY1LDYzNzAsNjM3NSw2MzgwLDYzOTEsNjQwNSw2NDEwLDY0MTYsNjQyMiw5OSwxMjEsNTksMSwxMDcxLDk5LDEyMSw1OSwxLDEwMzEsOTksMTIxLDU5LDEsMTA3MCw5OSwxMTcsMTE2LDEwMSw1LDIyMSwxLDU5LDYzODksMSwyMjEsNCwyLDEwNSwxMjEsNjM5Nyw2NDAyLDExNCw5OSw1OSwxLDM3NCw1OSwxLDEwNjcsMTE0LDU5LDMsNTUzNDksNTY2MDQsMTEyLDEwMiw1OSwzLDU1MzQ5LDU2NjU2LDk5LDExNCw1OSwzLDU1MzQ5LDU2NTAwLDEwOSwxMDgsNTksMSwzNzYsNCw4LDcyLDk3LDk5LDEwMCwxMDEsMTAyLDExMSwxMTUsNjQ0NSw2NDUwLDY0NTcsNjQ3Miw2NDc3LDY1MDEsNjUwNSw2NTEwLDk5LDEyMSw1OSwxLDEwNDYsOTksMTE3LDExNiwxMDEsNTksMSwzNzcsNCwyLDk3LDEyMSw2NDYzLDY0NjksMTE0LDExMSwxMTAsNTksMSwzODEsNTksMSwxMDQ3LDExMSwxMTYsNTksMSwzNzksNCwyLDExNCwxMTYsNjQ4Myw2NDk3LDExMSw4NywxMDUsMTAwLDExNiwxMDQsODMsMTEyLDk3LDk5LDEwMSw1OSwxLDgyMDMsOTcsNTksMSw5MTgsMTE0LDU5LDEsODQ4OCwxMTIsMTAyLDU5LDEsODQ4NCw5OSwxMTQsNTksMyw1NTM0OSw1NjUwMSw0LDE2LDk3LDk4LDk5LDEwMSwxMDIsMTAzLDEwOCwxMDksMTEwLDExMSwxMTIsMTE0LDExNSwxMTYsMTE3LDExOSw2NTUwLDY1NjEsNjU2OCw2NjEyLDY2MjIsNjYzNCw2NjQ1LDY2NzIsNjY5OSw2ODU0LDY4NzAsNjkyMyw2OTMzLDY5NjMsNjk3NCw2OTgzLDk5LDExNywxMTYsMTAxLDUsMjI1LDEsNTksNjU1OSwxLDIyNSwxMTQsMTAxLDExOCwxMDEsNTksMSwyNTksNCw2LDU5LDY5LDEwMCwxMDUsMTE3LDEyMSw2NTgyLDY1ODQsNjU4OCw2NTkxLDY2MDAsNjYwOSwxLDg3NjYsNTksMyw4NzY2LDgxOSw1OSwxLDg3NjcsMTE0LDk5LDUsMjI2LDEsNTksNjU5OCwxLDIyNiwxMTYsMTAxLDUsMTgwLDEsNTksNjYwNywxLDE4MCw1OSwxLDEwNzIsMTA4LDEwNSwxMDMsNSwyMzAsMSw1OSw2NjIwLDEsMjMwLDQsMiw1OSwxMTQsNjYyOCw2NjMwLDEsODI4OSw1OSwzLDU1MzQ5LDU2NjA2LDExNCw5NywxMTgsMTAxLDUsMjI0LDEsNTksNjY0MywxLDIyNCw0LDIsMTAxLDExMiw2NjUxLDY2NjcsNCwyLDEwMiwxMTIsNjY1Nyw2NjYzLDExNSwxMjEsMTA5LDU5LDEsODUwMSwxMDQsNTksMSw4NTAxLDEwNCw5Nyw1OSwxLDk0NSw0LDIsOTcsMTEyLDY2NzgsNjY5Miw0LDIsOTksMTA4LDY2ODQsNjY4OCwxMTQsNTksMSwyNTcsMTAzLDU5LDEsMTA4MTUsNSwzOCwxLDU5LDY2OTcsMSwzOCw0LDIsMTAwLDEwMyw2NzA1LDY3MzcsNCw1LDU5LDk3LDEwMCwxMTUsMTE4LDY3MTcsNjcxOSw2NzI0LDY3MjcsNjczNCwxLDg3NDMsMTEwLDEwMCw1OSwxLDEwODM3LDU5LDEsMTA4NDQsMTA4LDExMSwxMTIsMTAxLDU5LDEsMTA4NDAsNTksMSwxMDg0Miw0LDcsNTksMTAxLDEwOCwxMDksMTE0LDExNSwxMjIsNjc1Myw2NzU1LDY3NTgsNjc2Miw2ODE0LDY4MzUsNjg0OCwxLDg3MzYsNTksMSwxMDY2MCwxMDEsNTksMSw4NzM2LDExNSwxMDAsNCwyLDU5LDk3LDY3NzAsNjc3MiwxLDg3MzcsNCw4LDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsNjc5MCw2NzkzLDY3OTYsNjc5OSw2ODAyLDY4MDUsNjgwOCw2ODExLDU5LDEsMTA2NjQsNTksMSwxMDY2NSw1OSwxLDEwNjY2LDU5LDEsMTA2NjcsNTksMSwxMDY2OCw1OSwxLDEwNjY5LDU5LDEsMTA2NzAsNTksMSwxMDY3MSwxMTYsNCwyLDU5LDExOCw2ODIxLDY4MjMsMSw4NzM1LDk4LDQsMiw1OSwxMDAsNjgzMCw2ODMyLDEsODg5NCw1OSwxLDEwNjUzLDQsMiwxMTIsMTE2LDY4NDEsNjg0NSwxMDQsNTksMSw4NzM4LDU5LDEsMTk3LDk3LDExNCwxMTQsNTksMSw5MDg0LDQsMiwxMDMsMTEyLDY4NjAsNjg2NSwxMTEsMTEwLDU5LDEsMjYxLDEwMiw1OSwzLDU1MzQ5LDU2NjU4LDQsNyw1OSw2OSw5NywxMDEsMTA1LDExMSwxMTIsNjg4Niw2ODg4LDY4OTEsNjg5Nyw2OTAwLDY5MDQsNjkwOCwxLDg3NzYsNTksMSwxMDg2NCw5OSwxMDUsMTE0LDU5LDEsMTA4NjMsNTksMSw4Nzc4LDEwMCw1OSwxLDg3NzksMTE1LDU5LDEsMzksMTE0LDExMSwxMjAsNCwyLDU5LDEwMSw2OTE3LDY5MTksMSw4Nzc2LDExMyw1OSwxLDg3NzgsMTA1LDExMCwxMDMsNSwyMjksMSw1OSw2OTMxLDEsMjI5LDQsMyw5OSwxMTYsMTIxLDY5NDEsNjk0Niw2OTQ5LDExNCw1OSwzLDU1MzQ5LDU2NTAyLDU5LDEsNDIsMTA5LDExMiw0LDIsNTksMTAxLDY5NTcsNjk1OSwxLDg3NzYsMTEzLDU5LDEsODc4MSwxMDUsMTA4LDEwMCwxMDEsNSwyMjcsMSw1OSw2OTcyLDEsMjI3LDEwOSwxMDgsNSwyMjgsMSw1OSw2OTgxLDEsMjI4LDQsMiw5OSwxMDUsNjk4OSw2OTk3LDExMSwxMTAsMTA1LDExMCwxMTYsNTksMSw4NzU1LDExMCwxMTYsNTksMSwxMDc2OSw0LDE2LDc4LDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwNSwxMDcsMTA4LDExMCwxMTEsMTEyLDExNCwxMTUsMTE3LDcwMzYsNzA0MSw3MTE5LDcxMzUsNzE0OSw3MTU1LDcyMTksNzIyNCw3MzQ3LDczNTQsNzQ2Myw3NDg5LDc3ODYsNzc5Myw3ODE0LDc4NjYsMTExLDExNiw1OSwxLDEwOTg5LDQsMiw5OSwxMTQsNzA0Nyw3MDk0LDEwNyw0LDQsOTksMTAxLDExMiwxMTUsNzA1OCw3MDY0LDcwNzMsNzA4MCwxMTEsMTEwLDEwMyw1OSwxLDg3ODAsMTEyLDExNSwxMDUsMTA4LDExMSwxMTAsNTksMSwxMDE0LDExNCwxMDUsMTA5LDEwMSw1OSwxLDgyNDUsMTA1LDEwOSw0LDIsNTksMTAxLDcwODgsNzA5MCwxLDg3NjUsMTEzLDU5LDEsODkwOSw0LDIsMTE4LDExOSw3MTAwLDcxMDUsMTAxLDEwMSw1OSwxLDg4OTMsMTAxLDEwMCw0LDIsNTksMTAzLDcxMTMsNzExNSwxLDg5NjUsMTAxLDU5LDEsODk2NSwxMTQsMTA3LDQsMiw1OSwxMTYsNzEyNyw3MTI5LDEsOTE0MSw5OCwxMTQsMTA3LDU5LDEsOTE0Miw0LDIsMTExLDEyMSw3MTQxLDcxNDYsMTEwLDEwMyw1OSwxLDg3ODAsNTksMSwxMDczLDExMywxMTcsMTExLDU5LDEsODIyMiw0LDUsOTksMTA5LDExMiwxMTQsMTE2LDcxNjcsNzE4MSw3MTg4LDcxOTMsNzE5OSw5NywxMTcsMTE1LDQsMiw1OSwxMDEsNzE3Niw3MTc4LDEsODc1Nyw1OSwxLDg3NTcsMTEyLDExNiwxMjEsMTE4LDU5LDEsMTA2NzIsMTE1LDEwNSw1OSwxLDEwMTQsMTEwLDExMSwxMTcsNTksMSw4NDkyLDQsMyw5NywxMDQsMTE5LDcyMDcsNzIxMCw3MjEzLDU5LDEsOTQ2LDU5LDEsODUwMiwxMDEsMTAxLDExMCw1OSwxLDg4MTIsMTE0LDU5LDMsNTUzNDksNTY2MDcsMTAzLDQsNyw5OSwxMTEsMTE1LDExNiwxMTcsMTE4LDExOSw3MjQxLDcyNjIsNzI4OCw3MzA1LDczMjgsNzMzNSw3MzQwLDQsMyw5NywxMDUsMTE3LDcyNDksNzI1Myw3MjU4LDExMiw1OSwxLDg4OTgsMTE0LDk5LDU5LDEsOTcxMSwxMTIsNTksMSw4ODk5LDQsMywxMDAsMTEyLDExNiw3MjcwLDcyNzUsNzI4MSwxMTEsMTE2LDU5LDEsMTA3NTIsMTA4LDExNywxMTUsNTksMSwxMDc1MywxMDUsMTA5LDEwMSwxMTUsNTksMSwxMDc1NCw0LDIsMTEzLDExNiw3Mjk0LDczMDAsOTksMTE3LDExMiw1OSwxLDEwNzU4LDk3LDExNCw1OSwxLDk3MzMsMTE0LDEwNSw5NywxMTAsMTAzLDEwOCwxMDEsNCwyLDEwMCwxMTcsNzMxOCw3MzI0LDExMSwxMTksMTEwLDU5LDEsOTY2MSwxMTIsNTksMSw5NjUxLDExMiwxMDgsMTE3LDExNSw1OSwxLDEwNzU2LDEwMSwxMDEsNTksMSw4ODk3LDEwMSwxMDAsMTAzLDEwMSw1OSwxLDg4OTYsOTcsMTE0LDExMSwxMTksNTksMSwxMDUwOSw0LDMsOTcsMTA3LDExMSw3MzYyLDc0MzYsNzQ1OCw0LDIsOTksMTEwLDczNjgsNzQzMiwxMDcsNCwzLDEwOCwxMTUsMTE2LDczNzcsNzM4Niw3Mzk0LDExMSwxMjIsMTAxLDExMCwxMDMsMTAxLDU5LDEsMTA3MzEsMTEzLDExNyw5NywxMTQsMTAxLDU5LDEsOTY0MiwxMTQsMTA1LDk3LDExMCwxMDMsMTA4LDEwMSw0LDQsNTksMTAwLDEwOCwxMTQsNzQxMSw3NDEzLDc0MTksNzQyNSwxLDk2NTIsMTExLDExOSwxMTAsNTksMSw5NjYyLDEwMSwxMDIsMTE2LDU5LDEsOTY2NiwxMDUsMTAzLDEwNCwxMTYsNTksMSw5NjU2LDEwNyw1OSwxLDkyNTEsNCwyLDQ5LDUxLDc0NDIsNzQ1NCw0LDIsNTAsNTIsNzQ0OCw3NDUxLDU5LDEsOTYxOCw1OSwxLDk2MTcsNTIsNTksMSw5NjE5LDk5LDEwNyw1OSwxLDk2MDgsNCwyLDEwMSwxMTEsNzQ2OSw3NDg1LDQsMiw1OSwxMTMsNzQ3NSw3NDc4LDMsNjEsODQyMSwxMTcsMTA1LDExOCw1OSwzLDg4MDEsODQyMSwxMTYsNTksMSw4OTc2LDQsNCwxMTIsMTE2LDExOSwxMjAsNzQ5OSw3NTA0LDc1MTcsNzUyMywxMDIsNTksMyw1NTM0OSw1NjY1OSw0LDIsNTksMTE2LDc1MTAsNzUxMiwxLDg4NjksMTExLDEwOSw1OSwxLDg4NjksMTE2LDEwNSwxMDEsNTksMSw4OTA0LDQsMTIsNjgsNzIsODUsODYsOTgsMTAwLDEwNCwxMDksMTEyLDExNiwxMTcsMTE4LDc1NDksNzU3MSw3NTk3LDc2MTksNzY1NSw3NjYwLDc2ODIsNzcwOCw3NzE1LDc3MjEsNzcyOCw3NzUwLDQsNCw3Niw4MiwxMDgsMTE0LDc1NTksNzU2Miw3NTY1LDc1NjgsNTksMSw5NTU5LDU5LDEsOTU1Niw1OSwxLDk1NTgsNTksMSw5NTU1LDQsNSw1OSw2OCw4NSwxMDAsMTE3LDc1ODMsNzU4NSw3NTg4LDc1OTEsNzU5NCwxLDk1NTIsNTksMSw5NTc0LDU5LDEsOTU3Nyw1OSwxLDk1NzIsNTksMSw5NTc1LDQsNCw3Niw4MiwxMDgsMTE0LDc2MDcsNzYxMCw3NjEzLDc2MTYsNTksMSw5NTY1LDU5LDEsOTU2Miw1OSwxLDk1NjQsNTksMSw5NTYxLDQsNyw1OSw3Miw3Niw4MiwxMDQsMTA4LDExNCw3NjM1LDc2MzcsNzY0MCw3NjQzLDc2NDYsNzY0OSw3NjUyLDEsOTU1Myw1OSwxLDk1ODAsNTksMSw5NTcxLDU5LDEsOTU2OCw1OSwxLDk1NzksNTksMSw5NTcwLDU5LDEsOTU2NywxMTEsMTIwLDU5LDEsMTA2OTcsNCw0LDc2LDgyLDEwOCwxMTQsNzY3MCw3NjczLDc2NzYsNzY3OSw1OSwxLDk1NTcsNTksMSw5NTU0LDU5LDEsOTQ4OCw1OSwxLDk0ODQsNCw1LDU5LDY4LDg1LDEwMCwxMTcsNzY5NCw3Njk2LDc2OTksNzcwMiw3NzA1LDEsOTQ3Miw1OSwxLDk1NzMsNTksMSw5NTc2LDU5LDEsOTUxNiw1OSwxLDk1MjQsMTA1LDExMCwxMTcsMTE1LDU5LDEsODg2MywxMDgsMTE3LDExNSw1OSwxLDg4NjIsMTA1LDEwOSwxMDEsMTE1LDU5LDEsODg2NCw0LDQsNzYsODIsMTA4LDExNCw3NzM4LDc3NDEsNzc0NCw3NzQ3LDU5LDEsOTU2Myw1OSwxLDk1NjAsNTksMSw5NDk2LDU5LDEsOTQ5Miw0LDcsNTksNzIsNzYsODIsMTA0LDEwOCwxMTQsNzc2Niw3NzY4LDc3NzEsNzc3NCw3Nzc3LDc3ODAsNzc4MywxLDk0NzQsNTksMSw5NTc4LDU5LDEsOTU2OSw1OSwxLDk1NjYsNTksMSw5NTMyLDU5LDEsOTUwOCw1OSwxLDk1MDAsMTE0LDEwNSwxMDksMTAxLDU5LDEsODI0NSw0LDIsMTAxLDExOCw3Nzk5LDc4MDQsMTE4LDEwMSw1OSwxLDcyOCw5OCw5NywxMTQsNSwxNjYsMSw1OSw3ODEyLDEsMTY2LDQsNCw5OSwxMDEsMTA1LDExMSw3ODI0LDc4MjksNzgzNCw3ODQ2LDExNCw1OSwzLDU1MzQ5LDU2NTAzLDEwOSwxMDUsNTksMSw4MjcxLDEwOSw0LDIsNTksMTAxLDc4NDEsNzg0MywxLDg3NjUsNTksMSw4OTA5LDEwOCw0LDMsNTksOTgsMTA0LDc4NTUsNzg1Nyw3ODYwLDEsOTIsNTksMSwxMDY5MywxMTUsMTE3LDk4LDU5LDEsMTAxODQsNCwyLDEwOCwxMDksNzg3Miw3ODg1LDEwOCw0LDIsNTksMTAxLDc4NzksNzg4MSwxLDgyMjYsMTE2LDU5LDEsODIyNiwxMTIsNCwzLDU5LDY5LDEwMSw3ODk0LDc4OTYsNzg5OSwxLDg3ODIsNTksMSwxMDkyNiw0LDIsNTksMTEzLDc5MDUsNzkwNywxLDg3ODMsNTksMSw4NzgzLDQsMTUsOTcsOTksMTAwLDEwMSwxMDIsMTA0LDEwNSwxMDgsMTExLDExNCwxMTUsMTE2LDExNywxMTksMTIxLDc5NDIsODAyMSw4MDc1LDgwODAsODEyMSw4MTI2LDgxNTcsODI3OSw4Mjk1LDg0MzAsODQ0Niw4NDg1LDg0OTEsODcwNyw4NzI2LDQsMyw5OSwxMTIsMTE0LDc5NTAsNzk1Niw4MDA3LDExNywxMTYsMTAxLDU5LDEsMjYzLDQsNiw1OSw5Nyw5OCw5OSwxMDAsMTE1LDc5NzAsNzk3Miw3OTc3LDc5ODQsNzk5OCw4MDAzLDEsODc0NSwxMTAsMTAwLDU5LDEsMTA4MjAsMTE0LDk5LDExNywxMTIsNTksMSwxMDgyNSw0LDIsOTcsMTE3LDc5OTAsNzk5NCwxMTIsNTksMSwxMDgyNywxMTIsNTksMSwxMDgyMywxMTEsMTE2LDU5LDEsMTA4MTYsNTksMyw4NzQ1LDY1MDI0LDQsMiwxMDEsMTExLDgwMTMsODAxNywxMTYsNTksMSw4MjU3LDExMCw1OSwxLDcxMSw0LDQsOTcsMTAxLDEwNSwxMTcsODAzMSw4MDQ2LDgwNTYsODA2MSw0LDIsMTEyLDExNCw4MDM3LDgwNDEsMTE1LDU5LDEsMTA4MjksMTExLDExMCw1OSwxLDI2OSwxMDAsMTA1LDEwOCw1LDIzMSwxLDU5LDgwNTQsMSwyMzEsMTE0LDk5LDU5LDEsMjY1LDExMiwxMTUsNCwyLDU5LDExNSw4MDY5LDgwNzEsMSwxMDgyOCwxMDksNTksMSwxMDgzMiwxMTEsMTE2LDU5LDEsMjY3LDQsMywxMDAsMTA5LDExMCw4MDg4LDgwOTcsODEwNCwxMDUsMTA4LDUsMTg0LDEsNTksODA5NSwxLDE4NCwxMTIsMTE2LDEyMSwxMTgsNTksMSwxMDY3NCwxMTYsNSwxNjIsMiw1OSwxMDEsODExMiw4MTE0LDEsMTYyLDExNCwxMDAsMTExLDExNiw1OSwxLDE4MywxMTQsNTksMyw1NTM0OSw1NjYwOCw0LDMsOTksMTAxLDEwNSw4MTM0LDgxMzgsODE1NCwxMjEsNTksMSwxMDk1LDk5LDEwNyw0LDIsNTksMTA5LDgxNDYsODE0OCwxLDEwMDAzLDk3LDExNCwxMDcsNTksMSwxMDAwMyw1OSwxLDk2NywxMTQsNCw3LDU5LDY5LDk5LDEwMSwxMDIsMTA5LDExNSw4MTc0LDgxNzYsODE3OSw4MjU4LDgyNjEsODI2OCw4MjczLDEsOTY3NSw1OSwxLDEwNjkxLDQsMyw1OSwxMDEsMTA4LDgxODcsODE4OSw4MTkzLDEsNzEwLDExMyw1OSwxLDg3OTEsMTAxLDQsMiw5NywxMDAsODIwMCw4MjIzLDExNCwxMTQsMTExLDExOSw0LDIsMTA4LDExNCw4MjEwLDgyMTYsMTAxLDEwMiwxMTYsNTksMSw4NjM0LDEwNSwxMDMsMTA0LDExNiw1OSwxLDg2MzUsNCw1LDgyLDgzLDk3LDk5LDEwMCw4MjM1LDgyMzgsODI0MSw4MjQ2LDgyNTIsNTksMSwxNzQsNTksMSw5NDE2LDExNSwxMTYsNTksMSw4ODU5LDEwNSwxMTQsOTksNTksMSw4ODU4LDk3LDExNSwxMDQsNTksMSw4ODYxLDU5LDEsODc5MSwxMTAsMTA1LDExMCwxMTYsNTksMSwxMDc2OCwxMDUsMTAwLDU5LDEsMTA5OTEsOTksMTA1LDExNCw1OSwxLDEwNjkwLDExNyw5OCwxMTUsNCwyLDU5LDExNyw4Mjg4LDgyOTAsMSw5ODI3LDEwNSwxMTYsNTksMSw5ODI3LDQsNCwxMDgsMTA5LDExMCwxMTIsODMwNSw4MzI2LDgzNzYsODQwMCwxMTEsMTEwLDQsMiw1OSwxMDEsODMxMyw4MzE1LDEsNTgsNCwyLDU5LDExMyw4MzIxLDgzMjMsMSw4Nzg4LDU5LDEsODc4OCw0LDIsMTA5LDExMiw4MzMyLDgzNDQsOTcsNCwyLDU5LDExNiw4MzM5LDgzNDEsMSw0NCw1OSwxLDY0LDQsMyw1OSwxMDIsMTA4LDgzNTIsODM1NCw4MzU4LDEsODcwNSwxMTAsNTksMSw4NzI4LDEwMSw0LDIsMTA5LDEyMCw4MzY1LDgzNzEsMTAxLDExMCwxMTYsNTksMSw4NzA1LDEwMSwxMTUsNTksMSw4NDUwLDQsMiwxMDMsMTA1LDgzODIsODM5NSw0LDIsNTksMTAwLDgzODgsODM5MCwxLDg3NzMsMTExLDExNiw1OSwxLDEwODYxLDExMCwxMTYsNTksMSw4NzUwLDQsMywxMDIsMTE0LDEyMSw4NDA4LDg0MTIsODQxNyw1OSwzLDU1MzQ5LDU2NjYwLDExMSwxMDAsNTksMSw4NzIwLDUsMTY5LDIsNTksMTE1LDg0MjQsODQyNiwxLDE2OSwxMTQsNTksMSw4NDcxLDQsMiw5NywxMTEsODQzNiw4NDQxLDExNCwxMTQsNTksMSw4NjI5LDExNSwxMTUsNTksMSwxMDAwNyw0LDIsOTksMTE3LDg0NTIsODQ1NywxMTQsNTksMyw1NTM0OSw1NjUwNCw0LDIsOTgsMTEyLDg0NjMsODQ3NCw0LDIsNTksMTAxLDg0NjksODQ3MSwxLDEwOTU5LDU5LDEsMTA5NjEsNCwyLDU5LDEwMSw4NDgwLDg0ODIsMSwxMDk2MCw1OSwxLDEwOTYyLDEwMCwxMTEsMTE2LDU5LDEsODk0Myw0LDcsMTAwLDEwMSwxMDgsMTEyLDExNCwxMTgsMTE5LDg1MDcsODUyMiw4NTM2LDg1NTAsODYwMCw4Njk3LDg3MDIsOTcsMTE0LDExNCw0LDIsMTA4LDExNCw4NTE2LDg1MTksNTksMSwxMDU1Miw1OSwxLDEwNTQ5LDQsMiwxMTIsMTE1LDg1MjgsODUzMiwxMTQsNTksMSw4OTI2LDk5LDU5LDEsODkyNyw5NywxMTQsMTE0LDQsMiw1OSwxMTIsODU0NSw4NTQ3LDEsODYzMCw1OSwxLDEwNTU3LDQsNiw1OSw5OCw5OSwxMDAsMTExLDExNSw4NTY0LDg1NjYsODU3Myw4NTg3LDg1OTIsODU5NiwxLDg3NDYsMTE0LDk5LDk3LDExMiw1OSwxLDEwODI0LDQsMiw5NywxMTcsODU3OSw4NTgzLDExMiw1OSwxLDEwODIyLDExMiw1OSwxLDEwODI2LDExMSwxMTYsNTksMSw4ODQ1LDExNCw1OSwxLDEwODIxLDU5LDMsODc0Niw2NTAyNCw0LDQsOTcsMTA4LDExNCwxMTgsODYxMCw4NjIzLDg2NjMsODY3MiwxMTQsMTE0LDQsMiw1OSwxMDksODYxOCw4NjIwLDEsODYzMSw1OSwxLDEwNTU2LDEyMSw0LDMsMTAxLDExOCwxMTksODYzMiw4NjUxLDg2NTYsMTEzLDQsMiwxMTIsMTE1LDg2MzksODY0NSwxMTQsMTAxLDk5LDU5LDEsODkyNiwxMTcsOTksOTksNTksMSw4OTI3LDEwMSwxMDEsNTksMSw4OTEwLDEwMSwxMDAsMTAzLDEwMSw1OSwxLDg5MTEsMTAxLDExMCw1LDE2NCwxLDU5LDg2NzAsMSwxNjQsMTAxLDk3LDExNCwxMTQsMTExLDExOSw0LDIsMTA4LDExNCw4Njg0LDg2OTAsMTAxLDEwMiwxMTYsNTksMSw4NjMwLDEwNSwxMDMsMTA0LDExNiw1OSwxLDg2MzEsMTAxLDEwMSw1OSwxLDg5MTAsMTAxLDEwMCw1OSwxLDg5MTEsNCwyLDk5LDEwNSw4NzEzLDg3MjEsMTExLDExMCwxMDUsMTEwLDExNiw1OSwxLDg3NTQsMTEwLDExNiw1OSwxLDg3NTMsMTA4LDk5LDExNiwxMjEsNTksMSw5MDA1LDQsMTksNjUsNzIsOTcsOTgsOTksMTAwLDEwMSwxMDIsMTA0LDEwNSwxMDYsMTA4LDExMSwxMTQsMTE1LDExNiwxMTcsMTE5LDEyMiw4NzczLDg3NzgsODc4Myw4ODIxLDg4MzksODg1NCw4ODg3LDg5MTQsODkzMCw4OTQ0LDkwMzYsOTA0MSw5MDU4LDkxOTcsOTIyNyw5MjU4LDkyODEsOTI5Nyw5MzA1LDExNCwxMTQsNTksMSw4NjU5LDk3LDExNCw1OSwxLDEwNTk3LDQsNCwxMDMsMTA4LDExNCwxMTUsODc5Myw4Nzk5LDg4MDUsODgwOSwxMDMsMTAxLDExNCw1OSwxLDgyMjQsMTAxLDExNiwxMDQsNTksMSw4NTA0LDExNCw1OSwxLDg1OTUsMTA0LDQsMiw1OSwxMTgsODgxNiw4ODE4LDEsODIwOCw1OSwxLDg4NjcsNCwyLDEwNywxMDgsODgyNyw4ODM0LDk3LDExNCwxMTEsMTE5LDU5LDEsMTA1MTEsOTcsOTksNTksMSw3MzMsNCwyLDk3LDEyMSw4ODQ1LDg4NTEsMTE0LDExMSwxMTAsNTksMSwyNzEsNTksMSwxMDc2LDQsMyw1OSw5NywxMTEsODg2Miw4ODY0LDg4ODAsMSw4NTE4LDQsMiwxMDMsMTE0LDg4NzAsODg3NiwxMDMsMTAxLDExNCw1OSwxLDgyMjUsMTE0LDU5LDEsODY1MCwxMTYsMTE1LDEwMSwxMTMsNTksMSwxMDg3MSw0LDMsMTAzLDEwOCwxMDksODg5NSw4OTAyLDg5MDcsNSwxNzYsMSw1OSw4OTAwLDEsMTc2LDExNiw5Nyw1OSwxLDk0OCwxMTIsMTE2LDEyMSwxMTgsNTksMSwxMDY3Myw0LDIsMTA1LDExNCw4OTIwLDg5MjYsMTE1LDEwNCwxMTYsNTksMSwxMDYyMyw1OSwzLDU1MzQ5LDU2NjA5LDk3LDExNCw0LDIsMTA4LDExNCw4OTM4LDg5NDEsNTksMSw4NjQzLDU5LDEsODY0Miw0LDUsOTcsMTAxLDEwMywxMTUsMTE4LDg5NTYsODk4Niw4OTg5LDg5OTYsOTAwMSwxMDksNCwzLDU5LDExMSwxMTUsODk2NSw4OTY3LDg5ODMsMSw4OTAwLDExMCwxMDAsNCwyLDU5LDExNSw4OTc1LDg5NzcsMSw4OTAwLDExNywxMDUsMTE2LDU5LDEsOTgzMCw1OSwxLDk4MzAsNTksMSwxNjgsOTcsMTA5LDEwOSw5Nyw1OSwxLDk4OSwxMDUsMTEwLDU5LDEsODk0Niw0LDMsNTksMTA1LDExMSw5MDA5LDkwMTEsOTAzMSwxLDI0NywxMDAsMTAxLDUsMjQ3LDIsNTksMTExLDkwMjAsOTAyMiwxLDI0NywxMTAsMTE2LDEwNSwxMDksMTAxLDExNSw1OSwxLDg5MDMsMTEwLDEyMCw1OSwxLDg5MDMsOTksMTIxLDU5LDEsMTEwNiw5OSw0LDIsMTExLDExNCw5MDQ4LDkwNTMsMTE0LDExMCw1OSwxLDg5OTAsMTExLDExMiw1OSwxLDg5NzMsNCw1LDEwOCwxMTIsMTE2LDExNywxMTksOTA3MCw5MDc2LDkwODEsOTEzMCw5MTQ0LDEwOCw5NywxMTQsNTksMSwzNiwxMDIsNTksMyw1NTM0OSw1NjY2MSw0LDUsNTksMTAxLDEwOSwxMTIsMTE1LDkwOTMsOTA5NSw5MTA5LDkxMTYsOTEyMiwxLDcyOSwxMTMsNCwyLDU5LDEwMCw5MTAyLDkxMDQsMSw4Nzg0LDExMSwxMTYsNTksMSw4Nzg1LDEwNSwxMTAsMTE3LDExNSw1OSwxLDg3NjAsMTA4LDExNywxMTUsNTksMSw4NzI0LDExMywxMTcsOTcsMTE0LDEwMSw1OSwxLDg4NjUsOTgsMTA4LDEwMSw5OCw5NywxMTQsMTE5LDEwMSwxMDAsMTAzLDEwMSw1OSwxLDg5NjYsMTEwLDQsMyw5NywxMDAsMTA0LDkxNTMsOTE2MCw5MTcyLDExNCwxMTQsMTExLDExOSw1OSwxLDg1OTUsMTExLDExOSwxMTAsOTcsMTE0LDExNCwxMTEsMTE5LDExNSw1OSwxLDg2NTAsOTcsMTE0LDExMiwxMTEsMTExLDExMCw0LDIsMTA4LDExNCw5MTg0LDkxOTAsMTAxLDEwMiwxMTYsNTksMSw4NjQzLDEwNSwxMDMsMTA0LDExNiw1OSwxLDg2NDIsNCwyLDk4LDk5LDkyMDMsOTIxMSwxMDcsOTcsMTE0LDExMSwxMTksNTksMSwxMDUxMiw0LDIsMTExLDExNCw5MjE3LDkyMjIsMTE0LDExMCw1OSwxLDg5OTEsMTExLDExMiw1OSwxLDg5NzIsNCwzLDk5LDExMSwxMTYsOTIzNSw5MjQ4LDkyNTIsNCwyLDExNCwxMjEsOTI0MSw5MjQ1LDU5LDMsNTUzNDksNTY1MDUsNTksMSwxMTA5LDEwOCw1OSwxLDEwNzQyLDExNCwxMTEsMTA3LDU5LDEsMjczLDQsMiwxMDAsMTE0LDkyNjQsOTI2OSwxMTEsMTE2LDU5LDEsODk0NSwxMDUsNCwyLDU5LDEwMiw5Mjc2LDkyNzgsMSw5NjYzLDU5LDEsOTY2Miw0LDIsOTcsMTA0LDkyODcsOTI5MiwxMTQsMTE0LDU5LDEsODY5Myw5NywxMTQsNTksMSwxMDYwNyw5NywxMTAsMTAzLDEwOCwxMDEsNTksMSwxMDY2Miw0LDIsOTksMTA1LDkzMTEsOTMxNSwxMjEsNTksMSwxMTE5LDEwMywxMTQsOTcsMTE0LDExNCw1OSwxLDEwMjM5LDQsMTgsNjgsOTcsOTksMTAwLDEwMSwxMDIsMTAzLDEwOCwxMDksMTEwLDExMSwxMTIsMTEzLDExNCwxMTUsMTE2LDExNywxMjAsOTM2MSw5Mzc2LDkzOTgsOTQzOSw5NDQ0LDk0NDcsOTQ2Miw5NDk1LDk1MzEsOTU4NSw5NTk4LDk2MTQsOTY1OSw5NzU1LDk3NzEsOTc5Miw5ODA4LDk4MjYsNCwyLDY4LDExMSw5MzY3LDkzNzIsMTExLDExNiw1OSwxLDEwODcxLDExNiw1OSwxLDg3ODUsNCwyLDk5LDExNSw5MzgyLDkzOTIsMTE3LDExNiwxMDEsNSwyMzMsMSw1OSw5MzkwLDEsMjMzLDExNiwxMDEsMTE0LDU5LDEsMTA4NjIsNCw0LDk3LDEwNSwxMTEsMTIxLDk0MDgsOTQxNCw5NDMwLDk0MzYsMTE0LDExMSwxMTAsNTksMSwyODMsMTE0LDQsMiw1OSw5OSw5NDIxLDk0MjMsMSw4NzkwLDUsMjM0LDEsNTksOTQyOCwxLDIzNCwxMDgsMTExLDExMCw1OSwxLDg3ODksNTksMSwxMTAxLDExMSwxMTYsNTksMSwyNzksNTksMSw4NTE5LDQsMiw2OCwxMTQsOTQ1Myw5NDU4LDExMSwxMTYsNTksMSw4Nzg2LDU5LDMsNTUzNDksNTY2MTAsNCwzLDU5LDExNCwxMTUsOTQ3MCw5NDcyLDk0ODIsMSwxMDkwNiw5NywxMTgsMTAxLDUsMjMyLDEsNTksOTQ4MCwxLDIzMiw0LDIsNTksMTAwLDk0ODgsOTQ5MCwxLDEwOTAyLDExMSwxMTYsNTksMSwxMDkwNCw0LDQsNTksMTA1LDEwOCwxMTUsOTUwNSw5NTA3LDk1MTUsOTUxOCwxLDEwOTA1LDExMCwxMTYsMTAxLDExNCwxMTUsNTksMSw5MTkxLDU5LDEsODQ2Nyw0LDIsNTksMTAwLDk1MjQsOTUyNiwxLDEwOTAxLDExMSwxMTYsNTksMSwxMDkwMyw0LDMsOTcsMTEyLDExNSw5NTM5LDk1NDQsOTU2NCw5OSwxMTQsNTksMSwyNzUsMTE2LDEyMSw0LDMsNTksMTE1LDExOCw5NTU0LDk1NTYsOTU2MSwxLDg3MDksMTAxLDExNiw1OSwxLDg3MDksNTksMSw4NzA5LDExMiw0LDIsNDksNTksOTU3MSw5NTgzLDQsMiw1MSw1Miw5NTc3LDk1ODAsNTksMSw4MTk2LDU5LDEsODE5NywxLDgxOTUsNCwyLDEwMywxMTUsOTU5MSw5NTk0LDU5LDEsMzMxLDExMiw1OSwxLDgxOTQsNCwyLDEwMywxMTIsOTYwNCw5NjA5LDExMSwxMTAsNTksMSwyODEsMTAyLDU5LDMsNTUzNDksNTY2NjIsNCwzLDk3LDEwOCwxMTUsOTYyMiw5NjM1LDk2NDAsMTE0LDQsMiw1OSwxMTUsOTYyOSw5NjMxLDEsODkxNywxMDgsNTksMSwxMDcyMywxMTcsMTE1LDU5LDEsMTA4NjUsMTA1LDQsMyw1OSwxMDgsMTE4LDk2NDksOTY1MSw5NjU2LDEsOTQ5LDExMSwxMTAsNTksMSw5NDksNTksMSwxMDEzLDQsNCw5OSwxMTUsMTE3LDExOCw5NjY5LDk2ODYsOTcxNiw5NzQ3LDQsMiwxMDUsMTExLDk2NzUsOTY4MCwxMTQsOTksNTksMSw4NzkwLDEwOCwxMTEsMTEwLDU5LDEsODc4OSw0LDIsMTA1LDEwOCw5NjkyLDk2OTYsMTA5LDU5LDEsODc3MCw5NywxMTAsMTE2LDQsMiwxMDMsMTA4LDk3MDUsOTcxMCwxMTYsMTE0LDU5LDEsMTA5MDIsMTAxLDExNSwxMTUsNTksMSwxMDkwMSw0LDMsOTcsMTAxLDEwNSw5NzI0LDk3MjksOTczNCwxMDgsMTE1LDU5LDEsNjEsMTE1LDExNiw1OSwxLDg3OTksMTE4LDQsMiw1OSw2OCw5NzQxLDk3NDMsMSw4ODAxLDY4LDU5LDEsMTA4NzIsMTEyLDk3LDExNCwxMTUsMTA4LDU5LDEsMTA3MjUsNCwyLDY4LDk3LDk3NjEsOTc2NiwxMTEsMTE2LDU5LDEsODc4NywxMTQsMTE0LDU5LDEsMTA2MDksNCwzLDk5LDEwMCwxMDUsOTc3OSw5NzgzLDk3ODgsMTE0LDU5LDEsODQ5NSwxMTEsMTE2LDU5LDEsODc4NCwxMDksNTksMSw4NzcwLDQsMiw5NywxMDQsOTc5OCw5ODAxLDU5LDEsOTUxLDUsMjQwLDEsNTksOTgwNiwxLDI0MCw0LDIsMTA5LDExNCw5ODE0LDk4MjIsMTA4LDUsMjM1LDEsNTksOTgyMCwxLDIzNSwxMTEsNTksMSw4MzY0LDQsMyw5OSwxMDUsMTEyLDk4MzQsOTgzOCw5ODQzLDEwOCw1OSwxLDMzLDExNSwxMTYsNTksMSw4NzA3LDQsMiwxMDEsMTExLDk4NDksOTg1OSw5OSwxMTYsOTcsMTE2LDEwNSwxMTEsMTEwLDU5LDEsODQ5NiwxMTAsMTAxLDExMCwxMTYsMTA1LDk3LDEwOCwxMDEsNTksMSw4NTE5LDQsMTIsOTcsOTksMTAxLDEwMiwxMDUsMTA2LDEwOCwxMTAsMTExLDExMiwxMTQsMTE1LDk4OTYsOTkxMCw5OTE0LDk5MjEsOTk1NCw5OTYwLDk5NjcsOTk4OSw5OTk0LDEwMDI3LDEwMDM2LDEwMTY0LDEwOCwxMDgsMTA1LDExMCwxMDMsMTAwLDExMSwxMTYsMTE1LDEwMSwxMTMsNTksMSw4Nzg2LDEyMSw1OSwxLDEwOTIsMTA5LDk3LDEwOCwxMDEsNTksMSw5NzkyLDQsMywxMDUsMTA4LDExNCw5OTI5LDk5MzUsOTk1MCwxMDgsMTA1LDEwMyw1OSwxLDY0MjU5LDQsMiwxMDUsMTA4LDk5NDEsOTk0NSwxMDMsNTksMSw2NDI1NiwxMDUsMTAzLDU5LDEsNjQyNjAsNTksMyw1NTM0OSw1NjYxMSwxMDgsMTA1LDEwMyw1OSwxLDY0MjU3LDEwOCwxMDUsMTAzLDU5LDMsMTAyLDEwNiw0LDMsOTcsMTA4LDExNiw5OTc1LDk5NzksOTk4NCwxMTYsNTksMSw5ODM3LDEwNSwxMDMsNTksMSw2NDI1OCwxMTAsMTE1LDU5LDEsOTY0OSwxMTEsMTAyLDU5LDEsNDAyLDQsMiwxMTIsMTE0LDEwMDAwLDEwMDA1LDEwMiw1OSwzLDU1MzQ5LDU2NjYzLDQsMiw5NywxMDcsMTAwMTEsMTAwMTYsMTA4LDEwOCw1OSwxLDg3MDQsNCwyLDU5LDExOCwxMDAyMiwxMDAyNCwxLDg5MTYsNTksMSwxMDk2OSw5NywxMTQsMTE2LDEwNSwxMTAsMTE2LDU5LDEsMTA3NjUsNCwyLDk3LDExMSwxMDA0MiwxMDE1OSw0LDIsOTksMTE1LDEwMDQ4LDEwMTU1LDQsNiw0OSw1MCw1MSw1Miw1Myw1NSwxMDA2MiwxMDEwMiwxMDExNCwxMDEzNSwxMDEzOSwxMDE1MSw0LDYsNTAsNTEsNTIsNTMsNTQsNTYsMTAwNzYsMTAwODMsMTAwODYsMTAwOTMsMTAwOTYsMTAwOTksNSwxODksMSw1OSwxMDA4MSwxLDE4OSw1OSwxLDg1MzEsNSwxODgsMSw1OSwxMDA5MSwxLDE4OCw1OSwxLDg1MzMsNTksMSw4NTM3LDU5LDEsODUzOSw0LDIsNTEsNTMsMTAxMDgsMTAxMTEsNTksMSw4NTMyLDU5LDEsODUzNCw0LDMsNTIsNTMsNTYsMTAxMjIsMTAxMjksMTAxMzIsNSwxOTAsMSw1OSwxMDEyNywxLDE5MCw1OSwxLDg1MzUsNTksMSw4NTQwLDUzLDU5LDEsODUzNiw0LDIsNTQsNTYsMTAxNDUsMTAxNDgsNTksMSw4NTM4LDU5LDEsODU0MSw1Niw1OSwxLDg1NDIsMTA4LDU5LDEsODI2MCwxMTksMTEwLDU5LDEsODk5NCw5OSwxMTQsNTksMyw1NTM0OSw1NjUwNyw0LDE3LDY5LDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwMywxMDUsMTA2LDEwOCwxMTAsMTExLDExNCwxMTUsMTE2LDExOCwxMDIwNiwxMDIxNywxMDI0NywxMDI1NCwxMDI2OCwxMDI3MywxMDM1OCwxMDM2MywxMDM3NCwxMDM4MCwxMDM4NSwxMDQwNiwxMDQ1OCwxMDQ2NCwxMDQ3MCwxMDQ5NywxMDYxMCw0LDIsNTksMTA4LDEwMjEyLDEwMjE0LDEsODgwNyw1OSwxLDEwODkyLDQsMyw5OSwxMDksMTEyLDEwMjI1LDEwMjMxLDEwMjQ0LDExNywxMTYsMTAxLDU5LDEsNTAxLDEwOSw5Nyw0LDIsNTksMTAwLDEwMjM5LDEwMjQxLDEsOTQ3LDU5LDEsOTg5LDU5LDEsMTA4ODYsMTE0LDEwMSwxMTgsMTAxLDU5LDEsMjg3LDQsMiwxMDUsMTIxLDEwMjYwLDEwMjY1LDExNCw5OSw1OSwxLDI4NSw1OSwxLDEwNzUsMTExLDExNiw1OSwxLDI4OSw0LDQsNTksMTA4LDExMywxMTUsMTAyODMsMTAyODUsMTAyODgsMTAzMDgsMSw4ODA1LDU5LDEsODkyMyw0LDMsNTksMTEzLDExNSwxMDI5NiwxMDI5OCwxMDMwMSwxLDg4MDUsNTksMSw4ODA3LDEwOCw5NywxMTAsMTE2LDU5LDEsMTA4NzgsNCw0LDU5LDk5LDEwMCwxMDgsMTAzMTgsMTAzMjAsMTAzMjQsMTAzNDUsMSwxMDg3OCw5OSw1OSwxLDEwOTIxLDExMSwxMTYsNCwyLDU5LDExMSwxMDMzMiwxMDMzNCwxLDEwODgwLDQsMiw1OSwxMDgsMTAzNDAsMTAzNDIsMSwxMDg4Miw1OSwxLDEwODg0LDQsMiw1OSwxMDEsMTAzNTEsMTAzNTQsMyw4OTIzLDY1MDI0LDExNSw1OSwxLDEwOTAwLDExNCw1OSwzLDU1MzQ5LDU2NjEyLDQsMiw1OSwxMDMsMTAzNjksMTAzNzEsMSw4ODExLDU5LDEsODkyMSwxMDksMTAxLDEwOCw1OSwxLDg1MDMsOTksMTIxLDU5LDEsMTEwNyw0LDQsNTksNjksOTcsMTA2LDEwMzk1LDEwMzk3LDEwNDAwLDEwNDAzLDEsODgyMyw1OSwxLDEwODk4LDU5LDEsMTA5MTcsNTksMSwxMDkxNiw0LDQsNjksOTcsMTAxLDExNSwxMDQxNiwxMDQxOSwxMDQzNCwxMDQ1Myw1OSwxLDg4MDksMTEyLDQsMiw1OSwxMTIsMTA0MjYsMTA0MjgsMSwxMDg5MCwxMTQsMTExLDEyMCw1OSwxLDEwODkwLDQsMiw1OSwxMTMsMTA0NDAsMTA0NDIsMSwxMDg4OCw0LDIsNTksMTEzLDEwNDQ4LDEwNDUwLDEsMTA4ODgsNTksMSw4ODA5LDEwNSwxMDksNTksMSw4OTM1LDExMiwxMDIsNTksMyw1NTM0OSw1NjY2NCw5NywxMTgsMTAxLDU5LDEsOTYsNCwyLDk5LDEwNSwxMDQ3NiwxMDQ4MCwxMTQsNTksMSw4NDU4LDEwOSw0LDMsNTksMTAxLDEwOCwxMDQ4OSwxMDQ5MSwxMDQ5NCwxLDg4MTksNTksMSwxMDg5NCw1OSwxLDEwODk2LDUsNjIsNiw1OSw5OSwxMDAsMTA4LDExMywxMTQsMTA1MTIsMTA1MTQsMTA1MjcsMTA1MzIsMTA1MzgsMTA1NDUsMSw2Miw0LDIsOTksMTA1LDEwNTIwLDEwNTIzLDU5LDEsMTA5MTksMTE0LDU5LDEsMTA4NzQsMTExLDExNiw1OSwxLDg5MTksODAsOTcsMTE0LDU5LDEsMTA2NDUsMTE3LDEwMSwxMTUsMTE2LDU5LDEsMTA4NzYsNCw1LDk3LDEwMCwxMDEsMTA4LDExNSwxMDU1NywxMDU3NCwxMDU3OSwxMDU5OSwxMDYwNSw0LDIsMTEyLDExNCwxMDU2MywxMDU3MCwxMTIsMTE0LDExMSwxMjAsNTksMSwxMDg4NiwxMTQsNTksMSwxMDYxNiwxMTEsMTE2LDU5LDEsODkxOSwxMTMsNCwyLDEwOCwxMTMsMTA1ODYsMTA1OTIsMTAxLDExNSwxMTUsNTksMSw4OTIzLDEwOCwxMDEsMTE1LDExNSw1OSwxLDEwODkyLDEwMSwxMTUsMTE1LDU5LDEsODgyMywxMDUsMTA5LDU5LDEsODgxOSw0LDIsMTAxLDExMCwxMDYxNiwxMDYyNiwxMTQsMTE2LDExMCwxMDEsMTEzLDExMyw1OSwzLDg4MDksNjUwMjQsNjksNTksMyw4ODA5LDY1MDI0LDQsMTAsNjUsOTcsOTgsOTksMTAxLDEwMiwxMDcsMTExLDExNSwxMjEsMTA2NTMsMTA2NTgsMTA3MTMsMTA3MTgsMTA3MjQsMTA3NjAsMTA3NjUsMTA3ODYsMTA4NTAsMTA4NzUsMTE0LDExNCw1OSwxLDg2NjAsNCw0LDEwNSwxMDgsMTA5LDExNCwxMDY2OCwxMDY3NCwxMDY3OCwxMDY4NCwxMTQsMTE1LDExMiw1OSwxLDgyMDIsMTAyLDU5LDEsMTg5LDEwNSwxMDgsMTE2LDU5LDEsODQ1OSw0LDIsMTAwLDExNCwxMDY5MCwxMDY5NSw5OSwxMjEsNTksMSwxMDk4LDQsMyw1OSw5OSwxMTksMTA3MDMsMTA3MDUsMTA3MTAsMSw4NTk2LDEwNSwxMTQsNTksMSwxMDU2OCw1OSwxLDg2MjEsOTcsMTE0LDU5LDEsODQ2MywxMDUsMTE0LDk5LDU5LDEsMjkzLDQsMyw5NywxMDgsMTE0LDEwNzMyLDEwNzQ4LDEwNzU0LDExNCwxMTYsMTE1LDQsMiw1OSwxMTcsMTA3NDEsMTA3NDMsMSw5ODI5LDEwNSwxMTYsNTksMSw5ODI5LDEwOCwxMDUsMTEyLDU5LDEsODIzMCw5OSwxMTEsMTEwLDU5LDEsODg4OSwxMTQsNTksMyw1NTM0OSw1NjYxMywxMTUsNCwyLDEwMSwxMTksMTA3NzIsMTA3NzksOTcsMTE0LDExMSwxMTksNTksMSwxMDUzMyw5NywxMTQsMTExLDExOSw1OSwxLDEwNTM0LDQsNSw5NywxMDksMTExLDExMiwxMTQsMTA3OTgsMTA4MDMsMTA4MDksMTA4MzksMTA4NDQsMTE0LDExNCw1OSwxLDg3MDMsMTE2LDEwNCwxMTYsNTksMSw4NzYzLDEwNyw0LDIsMTA4LDExNCwxMDgxNiwxMDgyNywxMDEsMTAyLDExNiw5NywxMTQsMTE0LDExMSwxMTksNTksMSw4NjE3LDEwNSwxMDMsMTA0LDExNiw5NywxMTQsMTE0LDExMSwxMTksNTksMSw4NjE4LDEwMiw1OSwzLDU1MzQ5LDU2NjY1LDk4LDk3LDExNCw1OSwxLDgyMTMsNCwzLDk5LDEwOCwxMTYsMTA4NTgsMTA4NjMsMTA4NjksMTE0LDU5LDMsNTUzNDksNTY1MDksOTcsMTE1LDEwNCw1OSwxLDg0NjMsMTE0LDExMSwxMDcsNTksMSwyOTUsNCwyLDk4LDExMiwxMDg4MSwxMDg4NywxMTcsMTA4LDEwOCw1OSwxLDgyNTksMTA0LDEwMSwxMTAsNTksMSw4MjA4LDQsMTUsOTcsOTksMTAxLDEwMiwxMDMsMTA1LDEwNiwxMDksMTEwLDExMSwxMTIsMTEzLDExNSwxMTYsMTE3LDEwOTI1LDEwOTM2LDEwOTU4LDEwOTc3LDEwOTkwLDExMDAxLDExMDM5LDExMDQ1LDExMTAxLDExMTkyLDExMjIwLDExMjI2LDExMjM3LDExMjg1LDExMjk5LDk5LDExNywxMTYsMTAxLDUsMjM3LDEsNTksMTA5MzQsMSwyMzcsNCwzLDU5LDEwNSwxMjEsMTA5NDQsMTA5NDYsMTA5NTUsMSw4MjkxLDExNCw5OSw1LDIzOCwxLDU5LDEwOTUzLDEsMjM4LDU5LDEsMTA4MCw0LDIsOTksMTIwLDEwOTY0LDEwOTY4LDEyMSw1OSwxLDEwNzcsOTksMTA4LDUsMTYxLDEsNTksMTA5NzUsMSwxNjEsNCwyLDEwMiwxMTQsMTA5ODMsMTA5ODYsNTksMSw4NjYwLDU5LDMsNTUzNDksNTY2MTQsMTE0LDk3LDExOCwxMDEsNSwyMzYsMSw1OSwxMDk5OSwxLDIzNiw0LDQsNTksMTA1LDExMCwxMTEsMTEwMTEsMTEwMTMsMTEwMjgsMTEwMzQsMSw4NTIwLDQsMiwxMDUsMTEwLDExMDE5LDExMDI0LDExMCwxMTYsNTksMSwxMDc2NCwxMTYsNTksMSw4NzQ5LDEwMiwxMDUsMTEwLDU5LDEsMTA3MTYsMTE2LDk3LDU5LDEsODQ4OSwxMDgsMTA1LDEwMyw1OSwxLDMwNyw0LDMsOTcsMTExLDExMiwxMTA1MywxMTA5MiwxMTA5Niw0LDMsOTksMTAzLDExNiwxMTA2MSwxMTA2NSwxMTA4OCwxMTQsNTksMSwyOTksNCwzLDEwMSwxMDgsMTEyLDExMDczLDExMDc2LDExMDgyLDU5LDEsODQ2NSwxMDUsMTEwLDEwMSw1OSwxLDg0NjQsOTcsMTE0LDExNiw1OSwxLDg0NjUsMTA0LDU5LDEsMzA1LDEwMiw1OSwxLDg4ODcsMTAxLDEwMCw1OSwxLDQzNyw0LDUsNTksOTksMTAyLDExMSwxMTYsMTExMTMsMTExMTUsMTExMjEsMTExMzYsMTExNDIsMSw4NzEyLDk3LDExNCwxMDEsNTksMSw4NDUzLDEwNSwxMTAsNCwyLDU5LDExNiwxMTEyOSwxMTEzMSwxLDg3MzQsMTA1LDEwMSw1OSwxLDEwNzE3LDEwMCwxMTEsMTE2LDU5LDEsMzA1LDQsNSw1OSw5OSwxMDEsMTA4LDExMiwxMTE1NCwxMTE1NiwxMTE2MSwxMTE3OSwxMTE4NiwxLDg3NDcsOTcsMTA4LDU5LDEsODg5MCw0LDIsMTAzLDExNCwxMTE2NywxMTE3MywxMDEsMTE0LDExNSw1OSwxLDg0ODQsOTksOTcsMTA4LDU5LDEsODg5MCw5NywxMTQsMTA0LDEwNyw1OSwxLDEwNzc1LDExNCwxMTEsMTAwLDU5LDEsMTA4MTIsNCw0LDk5LDEwMywxMTIsMTE2LDExMjAyLDExMjA2LDExMjExLDExMjE2LDEyMSw1OSwxLDExMDUsMTExLDExMCw1OSwxLDMwMywxMDIsNTksMyw1NTM0OSw1NjY2Niw5Nyw1OSwxLDk1MywxMTQsMTExLDEwMCw1OSwxLDEwODEyLDExNywxMDEsMTE1LDExNiw1LDE5MSwxLDU5LDExMjM1LDEsMTkxLDQsMiw5OSwxMDUsMTEyNDMsMTEyNDgsMTE0LDU5LDMsNTUzNDksNTY1MTAsMTEwLDQsNSw1OSw2OSwxMDAsMTE1LDExOCwxMTI2MSwxMTI2MywxMTI2NiwxMTI3MSwxMTI4MiwxLDg3MTIsNTksMSw4OTUzLDExMSwxMTYsNTksMSw4OTQ5LDQsMiw1OSwxMTgsMTEyNzcsMTEyNzksMSw4OTQ4LDU5LDEsODk0Nyw1OSwxLDg3MTIsNCwyLDU5LDEwNSwxMTI5MSwxMTI5MywxLDgyOTAsMTA4LDEwMCwxMDEsNTksMSwyOTcsNCwyLDEwNywxMDksMTEzMDUsMTEzMTAsOTksMTIxLDU5LDEsMTExMCwxMDgsNSwyMzksMSw1OSwxMTMxNiwxLDIzOSw0LDYsOTksMTAyLDEwOSwxMTEsMTE1LDExNywxMTMzMiwxMTM0NiwxMTM1MSwxMTM1NywxMTM2MywxMTM4MCw0LDIsMTA1LDEyMSwxMTMzOCwxMTM0MywxMTQsOTksNTksMSwzMDksNTksMSwxMDgxLDExNCw1OSwzLDU1MzQ5LDU2NjE1LDk3LDExNiwxMDQsNTksMSw1NjcsMTEyLDEwMiw1OSwzLDU1MzQ5LDU2NjY3LDQsMiw5OSwxMDEsMTEzNjksMTEzNzQsMTE0LDU5LDMsNTUzNDksNTY1MTEsMTE0LDk5LDEyMSw1OSwxLDExMTIsMTA3LDk5LDEyMSw1OSwxLDExMDgsNCw4LDk3LDk5LDEwMiwxMDMsMTA0LDEwNiwxMTEsMTE1LDExNDA0LDExNDE4LDExNDMzLDExNDM4LDExNDQ1LDExNDUwLDExNDU1LDExNDYxLDExMiwxMTIsOTcsNCwyLDU5LDExOCwxMTQxMywxMTQxNSwxLDk1NCw1OSwxLDEwMDgsNCwyLDEwMSwxMjEsMTE0MjQsMTE0MzAsMTAwLDEwNSwxMDgsNTksMSwzMTEsNTksMSwxMDgyLDExNCw1OSwzLDU1MzQ5LDU2NjE2LDExNCwxMDEsMTAxLDExMCw1OSwxLDMxMiw5OSwxMjEsNTksMSwxMDkzLDk5LDEyMSw1OSwxLDExMTYsMTEyLDEwMiw1OSwzLDU1MzQ5LDU2NjY4LDk5LDExNCw1OSwzLDU1MzQ5LDU2NTEyLDQsMjMsNjUsNjYsNjksNzIsOTcsOTgsOTksMTAwLDEwMSwxMDIsMTAzLDEwNCwxMDYsMTA4LDEwOSwxMTAsMTExLDExMiwxMTQsMTE1LDExNiwxMTcsMTE4LDExNTE1LDExNTM4LDExNTQ0LDExNTU1LDExNTYwLDExNzIxLDExNzgwLDExODE4LDExODY4LDEyMTM2LDEyMTYwLDEyMTcxLDEyMjAzLDEyMjA4LDEyMjQ2LDEyMjc1LDEyMzI3LDEyNTA5LDEyNTIzLDEyNTY5LDEyNjQxLDEyNzMyLDEyNzUyLDQsMyw5NywxMTQsMTE2LDExNTIzLDExNTI4LDExNTMyLDExNCwxMTQsNTksMSw4NjY2LDExNCw1OSwxLDg2NTYsOTcsMTA1LDEwOCw1OSwxLDEwNTIzLDk3LDExNCwxMTQsNTksMSwxMDUxMCw0LDIsNTksMTAzLDExNTUwLDExNTUyLDEsODgwNiw1OSwxLDEwODkxLDk3LDExNCw1OSwxLDEwNTk0LDQsOSw5OSwxMDEsMTAzLDEwOSwxMTAsMTEyLDExMywxMTQsMTE2LDExNTgwLDExNTg2LDExNTk0LDExNjAwLDExNjA2LDExNjI0LDExNjI3LDExNjM2LDExNjk0LDExNywxMTYsMTAxLDU5LDEsMzE0LDEwOSwxMTIsMTE2LDEyMSwxMTgsNTksMSwxMDY3NiwxMTQsOTcsMTEwLDU5LDEsODQ2Niw5OCwxMDAsOTcsNTksMSw5NTUsMTAzLDQsMyw1OSwxMDAsMTA4LDExNjE1LDExNjE3LDExNjIwLDEsMTAyMTYsNTksMSwxMDY0MSwxMDEsNTksMSwxMDIxNiw1OSwxLDEwODg1LDExNywxMTEsNSwxNzEsMSw1OSwxMTYzNCwxLDE3MSwxMTQsNCw4LDU5LDk4LDEwMiwxMDQsMTA4LDExMiwxMTUsMTE2LDExNjU1LDExNjU3LDExNjY5LDExNjczLDExNjc3LDExNjgxLDExNjg1LDExNjkwLDEsODU5Miw0LDIsNTksMTAyLDExNjYzLDExNjY1LDEsODY3NiwxMTUsNTksMSwxMDUyNywxMTUsNTksMSwxMDUyNSwxMDcsNTksMSw4NjE3LDExMiw1OSwxLDg2MTksMTA4LDU5LDEsMTA1NTMsMTA1LDEwOSw1OSwxLDEwNjExLDEwOCw1OSwxLDg2MTAsNCwzLDU5LDk3LDEwMSwxMTcwMiwxMTcwNCwxMTcwOSwxLDEwOTIzLDEwNSwxMDgsNTksMSwxMDUyMSw0LDIsNTksMTE1LDExNzE1LDExNzE3LDEsMTA5MjUsNTksMywxMDkyNSw2NTAyNCw0LDMsOTcsOTgsMTE0LDExNzI5LDExNzM0LDExNzM5LDExNCwxMTQsNTksMSwxMDUwOCwxMTQsMTA3LDU5LDEsMTAwOTgsNCwyLDk3LDEwNywxMTc0NSwxMTc1OCw5OSw0LDIsMTAxLDEwNywxMTc1MiwxMTc1NSw1OSwxLDEyMyw1OSwxLDkxLDQsMiwxMDEsMTE1LDExNzY0LDExNzY3LDU5LDEsMTA2MzUsMTA4LDQsMiwxMDAsMTE3LDExNzc0LDExNzc3LDU5LDEsMTA2MzksNTksMSwxMDYzNyw0LDQsOTcsMTAxLDExNywxMjEsMTE3OTAsMTE3OTYsMTE4MTEsMTE4MTUsMTE0LDExMSwxMTAsNTksMSwzMTgsNCwyLDEwMCwxMDUsMTE4MDIsMTE4MDcsMTA1LDEwOCw1OSwxLDMxNiwxMDgsNTksMSw4OTY4LDk4LDU5LDEsMTIzLDU5LDEsMTA4Myw0LDQsOTksMTEzLDExNCwxMTUsMTE4MjgsMTE4MzIsMTE4NDUsMTE4NjQsOTcsNTksMSwxMDU1MCwxMTcsMTExLDQsMiw1OSwxMTQsMTE4NDAsMTE4NDIsMSw4MjIwLDU5LDEsODIyMiw0LDIsMTAwLDExNywxMTg1MSwxMTg1NywxMDQsOTcsMTE0LDU5LDEsMTA1OTksMTE1LDEwNCw5NywxMTQsNTksMSwxMDU3MSwxMDQsNTksMSw4NjI2LDQsNSw1OSwxMDIsMTAzLDExMywxMTUsMTE4ODAsMTE4ODIsMTIwMDgsMTIwMTEsMTIwMzEsMSw4ODA0LDExNiw0LDUsOTcsMTA0LDEwOCwxMTQsMTE2LDExODk1LDExOTEzLDExOTM1LDExOTQ3LDExOTk2LDExNCwxMTQsMTExLDExOSw0LDIsNTksMTE2LDExOTA1LDExOTA3LDEsODU5Miw5NywxMDUsMTA4LDU5LDEsODYxMCw5NywxMTQsMTEyLDExMSwxMTEsMTEwLDQsMiwxMDAsMTE3LDExOTI1LDExOTMxLDExMSwxMTksMTEwLDU5LDEsODYzNywxMTIsNTksMSw4NjM2LDEwMSwxMDIsMTE2LDk3LDExNCwxMTQsMTExLDExOSwxMTUsNTksMSw4NjQ3LDEwNSwxMDMsMTA0LDExNiw0LDMsOTcsMTA0LDExNSwxMTk1OSwxMTk3NCwxMTk4NCwxMTQsMTE0LDExMSwxMTksNCwyLDU5LDExNSwxMTk2OSwxMTk3MSwxLDg1OTYsNTksMSw4NjQ2LDk3LDExNCwxMTIsMTExLDExMSwxMTAsMTE1LDU5LDEsODY1MSwxMTMsMTE3LDEwNSwxMDMsOTcsMTE0LDExNCwxMTEsMTE5LDU5LDEsODYyMSwxMDQsMTE0LDEwMSwxMDEsMTE2LDEwNSwxMDksMTAxLDExNSw1OSwxLDg5MDcsNTksMSw4OTIyLDQsMyw1OSwxMTMsMTE1LDEyMDE5LDEyMDIxLDEyMDI0LDEsODgwNCw1OSwxLDg4MDYsMTA4LDk3LDExMCwxMTYsNTksMSwxMDg3Nyw0LDUsNTksOTksMTAwLDEwMywxMTUsMTIwNDMsMTIwNDUsMTIwNDksMTIwNzAsMTIwODMsMSwxMDg3Nyw5OSw1OSwxLDEwOTIwLDExMSwxMTYsNCwyLDU5LDExMSwxMjA1NywxMjA1OSwxLDEwODc5LDQsMiw1OSwxMTQsMTIwNjUsMTIwNjcsMSwxMDg4MSw1OSwxLDEwODgzLDQsMiw1OSwxMDEsMTIwNzYsMTIwNzksMyw4OTIyLDY1MDI0LDExNSw1OSwxLDEwODk5LDQsNSw5NywxMDAsMTAxLDEwMywxMTUsMTIwOTUsMTIxMDMsMTIxMDgsMTIxMjYsMTIxMzEsMTEyLDExMiwxMTQsMTExLDEyMCw1OSwxLDEwODg1LDExMSwxMTYsNTksMSw4OTE4LDExMyw0LDIsMTAzLDExMywxMjExNSwxMjEyMCwxMTYsMTE0LDU5LDEsODkyMiwxMDMsMTE2LDExNCw1OSwxLDEwODkxLDExNiwxMTQsNTksMSw4ODIyLDEwNSwxMDksNTksMSw4ODE4LDQsMywxMDUsMTA4LDExNCwxMjE0NCwxMjE1MCwxMjE1NiwxMTUsMTA0LDExNiw1OSwxLDEwNjIwLDExMSwxMTEsMTE0LDU5LDEsODk3MCw1OSwzLDU1MzQ5LDU2NjE3LDQsMiw1OSw2OSwxMjE2NiwxMjE2OCwxLDg4MjIsNTksMSwxMDg5Nyw0LDIsOTcsOTgsMTIxNzcsMTIxOTgsMTE0LDQsMiwxMDAsMTE3LDEyMTg0LDEyMTg3LDU5LDEsODYzNyw0LDIsNTksMTA4LDEyMTkzLDEyMTk1LDEsODYzNiw1OSwxLDEwNjAyLDEwOCwxMDcsNTksMSw5NjA0LDk5LDEyMSw1OSwxLDExMTMsNCw1LDU5LDk3LDk5LDEwNCwxMTYsMTIyMjAsMTIyMjIsMTIyMjcsMTIyMzUsMTIyNDEsMSw4ODEwLDExNCwxMTQsNTksMSw4NjQ3LDExMSwxMTQsMTEwLDEwMSwxMTQsNTksMSw4OTkwLDk3LDExNCwxMDAsNTksMSwxMDYwMywxMTQsMTA1LDU5LDEsOTcyMiw0LDIsMTA1LDExMSwxMjI1MiwxMjI1OCwxMDAsMTExLDExNiw1OSwxLDMyMCwxMTcsMTE1LDExNiw0LDIsNTksOTcsMTIyNjcsMTIyNjksMSw5MTM2LDk5LDEwNCwxMDEsNTksMSw5MTM2LDQsNCw2OSw5NywxMDEsMTE1LDEyMjg1LDEyMjg4LDEyMzAzLDEyMzIyLDU5LDEsODgwOCwxMTIsNCwyLDU5LDExMiwxMjI5NSwxMjI5NywxLDEwODg5LDExNCwxMTEsMTIwLDU5LDEsMTA4ODksNCwyLDU5LDExMywxMjMwOSwxMjMxMSwxLDEwODg3LDQsMiw1OSwxMTMsMTIzMTcsMTIzMTksMSwxMDg4Nyw1OSwxLDg4MDgsMTA1LDEwOSw1OSwxLDg5MzQsNCw4LDk3LDk4LDExMCwxMTEsMTEyLDExNiwxMTksMTIyLDEyMzQ1LDEyMzU5LDEyMzY0LDEyNDIxLDEyNDQ2LDEyNDY3LDEyNDc0LDEyNDkwLDQsMiwxMTAsMTE0LDEyMzUxLDEyMzU1LDEwMyw1OSwxLDEwMjIwLDExNCw1OSwxLDg3MDEsMTE0LDEwNyw1OSwxLDEwMjE0LDEwMyw0LDMsMTA4LDEwOSwxMTQsMTIzNzMsMTI0MDEsMTI0MDksMTAxLDEwMiwxMTYsNCwyLDk3LDExNCwxMjM4MiwxMjM4OSwxMTQsMTE0LDExMSwxMTksNTksMSwxMDIyOSwxMDUsMTAzLDEwNCwxMTYsOTcsMTE0LDExNCwxMTEsMTE5LDU5LDEsMTAyMzEsOTcsMTEyLDExNSwxMTYsMTExLDU5LDEsMTAyMzYsMTA1LDEwMywxMDQsMTE2LDk3LDExNCwxMTQsMTExLDExOSw1OSwxLDEwMjMwLDExMiw5NywxMTQsMTE0LDExMSwxMTksNCwyLDEwOCwxMTQsMTI0MzMsMTI0MzksMTAxLDEwMiwxMTYsNTksMSw4NjE5LDEwNSwxMDMsMTA0LDExNiw1OSwxLDg2MjAsNCwzLDk3LDEwMiwxMDgsMTI0NTQsMTI0NTgsMTI0NjIsMTE0LDU5LDEsMTA2MjksNTksMyw1NTM0OSw1NjY2OSwxMTcsMTE1LDU5LDEsMTA3OTcsMTA1LDEwOSwxMDEsMTE1LDU5LDEsMTA4MDQsNCwyLDk3LDk4LDEyNDgwLDEyNDg1LDExNSwxMTYsNTksMSw4NzI3LDk3LDExNCw1OSwxLDk1LDQsMyw1OSwxMDEsMTAyLDEyNDk4LDEyNTAwLDEyNTA2LDEsOTY3NCwxMTAsMTAzLDEwMSw1OSwxLDk2NzQsNTksMSwxMDczMSw5NywxMTQsNCwyLDU5LDEwOCwxMjUxNywxMjUxOSwxLDQwLDExNiw1OSwxLDEwNjQzLDQsNSw5Nyw5OSwxMDQsMTA5LDExNiwxMjUzNSwxMjU0MCwxMjU0OCwxMjU2MSwxMjU2NCwxMTQsMTE0LDU5LDEsODY0NiwxMTEsMTE0LDExMCwxMDEsMTE0LDU5LDEsODk5MSw5NywxMTQsNCwyLDU5LDEwMCwxMjU1NiwxMjU1OCwxLDg2NTEsNTksMSwxMDYwNSw1OSwxLDgyMDYsMTE0LDEwNSw1OSwxLDg4OTUsNCw2LDk3LDk5LDEwNCwxMDUsMTEzLDExNiwxMjU4MywxMjU4OSwxMjU5NCwxMjU5NywxMjYxNCwxMjYzNSwxMTMsMTE3LDExMSw1OSwxLDgyNDksMTE0LDU5LDMsNTUzNDksNTY1MTMsNTksMSw4NjI0LDEwOSw0LDMsNTksMTAxLDEwMywxMjYwNiwxMjYwOCwxMjYxMSwxLDg4MTgsNTksMSwxMDg5Myw1OSwxLDEwODk1LDQsMiw5OCwxMTcsMTI2MjAsMTI2MjMsNTksMSw5MSwxMTEsNCwyLDU5LDExNCwxMjYzMCwxMjYzMiwxLDgyMTYsNTksMSw4MjE4LDExNCwxMTEsMTA3LDU5LDEsMzIyLDUsNjAsOCw1OSw5OSwxMDAsMTA0LDEwNSwxMDgsMTEzLDExNCwxMjY2MCwxMjY2MiwxMjY3NSwxMjY4MCwxMjY4NiwxMjY5MiwxMjY5OCwxMjcwNSwxLDYwLDQsMiw5OSwxMDUsMTI2NjgsMTI2NzEsNTksMSwxMDkxOCwxMTQsNTksMSwxMDg3MywxMTEsMTE2LDU5LDEsODkxOCwxMTQsMTAxLDEwMSw1OSwxLDg5MDcsMTA5LDEwMSwxMTUsNTksMSw4OTA1LDk3LDExNCwxMTQsNTksMSwxMDYxNCwxMTcsMTAxLDExNSwxMTYsNTksMSwxMDg3NSw0LDIsODAsMTA1LDEyNzExLDEyNzE2LDk3LDExNCw1OSwxLDEwNjQ2LDQsMyw1OSwxMDEsMTAyLDEyNzI0LDEyNzI2LDEyNzI5LDEsOTY2Nyw1OSwxLDg4ODQsNTksMSw5NjY2LDExNCw0LDIsMTAwLDExNywxMjczOSwxMjc0NiwxMTUsMTA0LDk3LDExNCw1OSwxLDEwNTcwLDEwNCw5NywxMTQsNTksMSwxMDU5OCw0LDIsMTAxLDExMCwxMjc1OCwxMjc2OCwxMTQsMTE2LDExMCwxMDEsMTEzLDExMyw1OSwzLDg4MDgsNjUwMjQsNjksNTksMyw4ODA4LDY1MDI0LDQsMTQsNjgsOTcsOTksMTAwLDEwMSwxMDIsMTA0LDEwNSwxMDgsMTEwLDExMSwxMTIsMTE1LDExNywxMjgwMywxMjgwOSwxMjg5MywxMjkwOCwxMjkxNCwxMjkyOCwxMjkzMywxMjkzNywxMzAxMSwxMzAyNSwxMzAzMiwxMzA0OSwxMzA1MiwxMzA2OSw2OCwxMTEsMTE2LDU5LDEsODc2Miw0LDQsOTksMTA4LDExMiwxMTQsMTI4MTksMTI4MjcsMTI4NDksMTI4ODcsMTE0LDUsMTc1LDEsNTksMTI4MjUsMSwxNzUsNCwyLDEwMSwxMTYsMTI4MzMsMTI4MzYsNTksMSw5Nzk0LDQsMiw1OSwxMDEsMTI4NDIsMTI4NDQsMSwxMDAxNiwxMTUsMTAxLDU5LDEsMTAwMTYsNCwyLDU5LDExNSwxMjg1NSwxMjg1NywxLDg2MTQsMTE2LDExMSw0LDQsNTksMTAwLDEwOCwxMTcsMTI4NjksMTI4NzEsMTI4NzcsMTI4ODMsMSw4NjE0LDExMSwxMTksMTEwLDU5LDEsODYxNSwxMDEsMTAyLDExNiw1OSwxLDg2MTIsMTEyLDU5LDEsODYxMywxMDcsMTAxLDExNCw1OSwxLDk2NDYsNCwyLDExMSwxMjEsMTI4OTksMTI5MDUsMTA5LDEwOSw5Nyw1OSwxLDEwNzkzLDU5LDEsMTA4NCw5NywxMTUsMTA0LDU5LDEsODIxMiw5NywxMTUsMTE3LDExNCwxMDEsMTAwLDk3LDExMCwxMDMsMTA4LDEwMSw1OSwxLDg3MzcsMTE0LDU5LDMsNTUzNDksNTY2MTgsMTExLDU5LDEsODQ4Nyw0LDMsOTksMTAwLDExMCwxMjk0NSwxMjk1NCwxMjk4NSwxMTQsMTExLDUsMTgxLDEsNTksMTI5NTIsMSwxODEsNCw0LDU5LDk3LDk5LDEwMCwxMjk2NCwxMjk2NiwxMjk3MSwxMjk3NiwxLDg3MzksMTE1LDExNiw1OSwxLDQyLDEwNSwxMTQsNTksMSwxMDk5MiwxMTEsMTE2LDUsMTgzLDEsNTksMTI5ODMsMSwxODMsMTE3LDExNSw0LDMsNTksOTgsMTAwLDEyOTk1LDEyOTk3LDEzMDAwLDEsODcyMiw1OSwxLDg4NjMsNCwyLDU5LDExNywxMzAwNiwxMzAwOCwxLDg3NjAsNTksMSwxMDc5NCw0LDIsOTksMTAwLDEzMDE3LDEzMDIxLDExMiw1OSwxLDEwOTcxLDExNCw1OSwxLDgyMzAsMTEyLDEwOCwxMTcsMTE1LDU5LDEsODcyMyw0LDIsMTAwLDExMiwxMzAzOCwxMzA0NCwxMDEsMTA4LDExNSw1OSwxLDg4NzEsMTAyLDU5LDMsNTUzNDksNTY2NzAsNTksMSw4NzIzLDQsMiw5OSwxMTYsMTMwNTgsMTMwNjMsMTE0LDU5LDMsNTUzNDksNTY1MTQsMTEyLDExMSwxMTUsNTksMSw4NzY2LDQsMyw1OSwxMDgsMTA5LDEzMDc3LDEzMDc5LDEzMDg3LDEsOTU2LDExNiwxMDUsMTA5LDk3LDExMiw1OSwxLDg4ODgsOTcsMTEyLDU5LDEsODg4OCw0LDI0LDcxLDc2LDgyLDg2LDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsMTA1LDEwNiwxMDgsMTA5LDExMSwxMTIsMTE0LDExNSwxMTYsMTE3LDExOCwxMTksMTMxNDIsMTMxNjUsMTMyMTcsMTMyMjksMTMyNDcsMTMzMzAsMTMzNTksMTM0MTQsMTM0MjAsMTM1MDgsMTM1MTMsMTM1NzksMTM2MDIsMTM2MjYsMTM2MzEsMTM3NjIsMTM3NjcsMTM4NTUsMTM5MzYsMTM5OTUsMTQyMTQsMTQyODUsMTQzMTIsMTQ0MzIsNCwyLDEwMywxMTYsMTMxNDgsMTMxNTIsNTksMyw4OTIxLDgyNCw0LDIsNTksMTE4LDEzMTU4LDEzMTYxLDMsODgxMSw4NDAyLDU5LDMsODgxMSw4MjQsNCwzLDEwMSwxMDgsMTE2LDEzMTczLDEzMjAwLDEzMjA0LDEwMiwxMTYsNCwyLDk3LDExNCwxMzE4MSwxMzE4OCwxMTQsMTE0LDExMSwxMTksNTksMSw4NjUzLDEwNSwxMDMsMTA0LDExNiw5NywxMTQsMTE0LDExMSwxMTksNTksMSw4NjU0LDU5LDMsODkyMCw4MjQsNCwyLDU5LDExOCwxMzIxMCwxMzIxMywzLDg4MTAsODQwMiw1OSwzLDg4MTAsODI0LDEwNSwxMDMsMTA0LDExNiw5NywxMTQsMTE0LDExMSwxMTksNTksMSw4NjU1LDQsMiw2OCwxMDAsMTMyMzUsMTMyNDEsOTcsMTE1LDEwNCw1OSwxLDg4NzksOTcsMTE1LDEwNCw1OSwxLDg4NzgsNCw1LDk4LDk5LDExMCwxMTIsMTE2LDEzMjU5LDEzMjY0LDEzMjcwLDEzMjc1LDEzMzA4LDEwOCw5Nyw1OSwxLDg3MTEsMTE3LDExNiwxMDEsNTksMSwzMjQsMTAzLDU5LDMsODczNiw4NDAyLDQsNSw1OSw2OSwxMDUsMTExLDExMiwxMzI4NywxMzI4OSwxMzI5MywxMzI5OCwxMzMwMiwxLDg3NzcsNTksMywxMDg2NCw4MjQsMTAwLDU5LDMsODc3OSw4MjQsMTE1LDU5LDEsMzI5LDExNCwxMTEsMTIwLDU5LDEsODc3NywxMTcsMTE0LDQsMiw1OSw5NywxMzMxNiwxMzMxOCwxLDk4MzgsMTA4LDQsMiw1OSwxMTUsMTMzMjUsMTMzMjcsMSw5ODM4LDU5LDEsODQ2OSw0LDIsMTE1LDExNywxMzMzNiwxMzM0NCwxMTIsNSwxNjAsMSw1OSwxMzM0MiwxLDE2MCwxMDksMTEyLDQsMiw1OSwxMDEsMTMzNTIsMTMzNTUsMyw4NzgyLDgyNCw1OSwzLDg3ODMsODI0LDQsNSw5NywxMDEsMTExLDExNywxMjEsMTMzNzEsMTMzODUsMTMzOTEsMTM0MDcsMTM0MTEsNCwyLDExMiwxMTQsMTMzNzcsMTMzODAsNTksMSwxMDgxOSwxMTEsMTEwLDU5LDEsMzI4LDEwMCwxMDUsMTA4LDU5LDEsMzI2LDExMCwxMDMsNCwyLDU5LDEwMCwxMzM5OSwxMzQwMSwxLDg3NzUsMTExLDExNiw1OSwzLDEwODYxLDgyNCwxMTIsNTksMSwxMDgxOCw1OSwxLDEwODUsOTcsMTE1LDEwNCw1OSwxLDgyMTEsNCw3LDU5LDY1LDk3LDEwMCwxMTMsMTE1LDEyMCwxMzQzNiwxMzQzOCwxMzQ0MywxMzQ2NiwxMzQ3MiwxMzQ3OCwxMzQ5NCwxLDg4MDAsMTE0LDExNCw1OSwxLDg2NjMsMTE0LDQsMiwxMDQsMTE0LDEzNDUwLDEzNDU0LDEwNyw1OSwxLDEwNTMyLDQsMiw1OSwxMTEsMTM0NjAsMTM0NjIsMSw4NTk5LDExOSw1OSwxLDg1OTksMTExLDExNiw1OSwzLDg3ODQsODI0LDExNywxMDUsMTE4LDU5LDEsODgwMiw0LDIsMTAxLDEwNSwxMzQ4NCwxMzQ4OSw5NywxMTQsNTksMSwxMDUzNiwxMDksNTksMyw4NzcwLDgyNCwxMDUsMTE1LDExNiw0LDIsNTksMTE1LDEzNTAzLDEzNTA1LDEsODcwOCw1OSwxLDg3MDgsMTE0LDU5LDMsNTUzNDksNTY2MTksNCw0LDY5LDEwMSwxMTUsMTE2LDEzNTIzLDEzNTI3LDEzNTYzLDEzNTY4LDU5LDMsODgwNyw4MjQsNCwzLDU5LDExMywxMTUsMTM1MzUsMTM1MzcsMTM1NTksMSw4ODE3LDQsMyw1OSwxMTMsMTE1LDEzNTQ1LDEzNTQ3LDEzNTUxLDEsODgxNyw1OSwzLDg4MDcsODI0LDEwOCw5NywxMTAsMTE2LDU5LDMsMTA4NzgsODI0LDU5LDMsMTA4NzgsODI0LDEwNSwxMDksNTksMSw4ODIxLDQsMiw1OSwxMTQsMTM1NzQsMTM1NzYsMSw4ODE1LDU5LDEsODgxNSw0LDMsNjUsOTcsMTEyLDEzNTg3LDEzNTkyLDEzNTk3LDExNCwxMTQsNTksMSw4NjU0LDExNCwxMTQsNTksMSw4NjIyLDk3LDExNCw1OSwxLDEwOTk0LDQsMyw1OSwxMTUsMTE4LDEzNjEwLDEzNjEyLDEzNjIzLDEsODcxNSw0LDIsNTksMTAwLDEzNjE4LDEzNjIwLDEsODk1Niw1OSwxLDg5NTQsNTksMSw4NzE1LDk5LDEyMSw1OSwxLDExMTQsNCw3LDY1LDY5LDk3LDEwMCwxMDEsMTE1LDExNiwxMzY0NywxMzY1MiwxMzY1NiwxMzY2MSwxMzY2NSwxMzczNywxMzc0MiwxMTQsMTE0LDU5LDEsODY1Myw1OSwzLDg4MDYsODI0LDExNCwxMTQsNTksMSw4NjAyLDExNCw1OSwxLDgyMjksNCw0LDU5LDEwMiwxMTMsMTE1LDEzNjc1LDEzNjc3LDEzNzAzLDEzNzI1LDEsODgxNiwxMTYsNCwyLDk3LDExNCwxMzY4NCwxMzY5MSwxMTQsMTE0LDExMSwxMTksNTksMSw4NjAyLDEwNSwxMDMsMTA0LDExNiw5NywxMTQsMTE0LDExMSwxMTksNTksMSw4NjIyLDQsMyw1OSwxMTMsMTE1LDEzNzExLDEzNzEzLDEzNzE3LDEsODgxNiw1OSwzLDg4MDYsODI0LDEwOCw5NywxMTAsMTE2LDU5LDMsMTA4NzcsODI0LDQsMiw1OSwxMTUsMTM3MzEsMTM3MzQsMywxMDg3Nyw4MjQsNTksMSw4ODE0LDEwNSwxMDksNTksMSw4ODIwLDQsMiw1OSwxMTQsMTM3NDgsMTM3NTAsMSw4ODE0LDEwNSw0LDIsNTksMTAxLDEzNzU3LDEzNzU5LDEsODkzOCw1OSwxLDg5NDAsMTA1LDEwMCw1OSwxLDg3NDAsNCwyLDExMiwxMTYsMTM3NzMsMTM3NzgsMTAyLDU5LDMsNTUzNDksNTY2NzEsNSwxNzIsMyw1OSwxMDUsMTEwLDEzNzg3LDEzNzg5LDEzODI5LDEsMTcyLDExMCw0LDQsNTksNjksMTAwLDExOCwxMzgwMCwxMzgwMiwxMzgwNiwxMzgxMiwxLDg3MTMsNTksMyw4OTUzLDgyNCwxMTEsMTE2LDU5LDMsODk0OSw4MjQsNCwzLDk3LDk4LDk5LDEzODIwLDEzODIzLDEzODI2LDU5LDEsODcxMyw1OSwxLDg5NTEsNTksMSw4OTUwLDEwNSw0LDIsNTksMTE4LDEzODM2LDEzODM4LDEsODcxNiw0LDMsOTcsOTgsOTksMTM4NDYsMTM4NDksMTM4NTIsNTksMSw4NzE2LDU5LDEsODk1OCw1OSwxLDg5NTcsNCwzLDk3LDExMSwxMTQsMTM4NjMsMTM4OTIsMTM4OTksMTE0LDQsNCw1OSw5NywxMTUsMTE2LDEzODc0LDEzODc2LDEzODgzLDEzODg4LDEsODc0MiwxMDgsMTA4LDEwMSwxMDgsNTksMSw4NzQyLDEwOCw1OSwzLDExMDA1LDg0MjEsNTksMyw4NzA2LDgyNCwxMDgsMTA1LDExMCwxMTYsNTksMSwxMDc3Miw0LDMsNTksOTksMTAxLDEzOTA3LDEzOTA5LDEzOTE0LDEsODgzMiwxMTcsMTAxLDU5LDEsODkyOCw0LDIsNTksOTksMTM5MjAsMTM5MjMsMywxMDkyNyw4MjQsNCwyLDU5LDEwMSwxMzkyOSwxMzkzMSwxLDg4MzIsMTEzLDU5LDMsMTA5MjcsODI0LDQsNCw2NSw5NywxMDUsMTE2LDEzOTQ2LDEzOTUxLDEzOTcxLDEzOTgyLDExNCwxMTQsNTksMSw4NjU1LDExNCwxMTQsNCwzLDU5LDk5LDExOSwxMzk2MSwxMzk2MywxMzk2NywxLDg2MDMsNTksMywxMDU0Nyw4MjQsNTksMyw4NjA1LDgyNCwxMDMsMTA0LDExNiw5NywxMTQsMTE0LDExMSwxMTksNTksMSw4NjAzLDExNCwxMDUsNCwyLDU5LDEwMSwxMzk5MCwxMzk5MiwxLDg5MzksNTksMSw4OTQxLDQsNyw5OSwxMDQsMTA1LDEwOSwxMTIsMTEzLDExNywxNDAxMSwxNDAzNiwxNDA2MCwxNDA4MCwxNDA4NSwxNDA5MCwxNDEwNiw0LDQsNTksOTksMTAxLDExNCwxNDAyMSwxNDAyMywxNDAyOCwxNDAzMiwxLDg4MzMsMTE3LDEwMSw1OSwxLDg5MjksNTksMywxMDkyOCw4MjQsNTksMyw1NTM0OSw1NjUxNSwxMTEsMTE0LDExNiw0LDIsMTA5LDExMiwxNDA0NSwxNDA1MCwxMDUsMTAwLDU5LDEsODc0MCw5NywxMTQsOTcsMTA4LDEwOCwxMDEsMTA4LDU5LDEsODc0MiwxMDksNCwyLDU5LDEwMSwxNDA2NywxNDA2OSwxLDg3NjksNCwyLDU5LDExMywxNDA3NSwxNDA3NywxLDg3NzIsNTksMSw4NzcyLDEwNSwxMDAsNTksMSw4NzQwLDk3LDExNCw1OSwxLDg3NDIsMTE1LDExNyw0LDIsOTgsMTEyLDE0MDk4LDE0MTAyLDEwMSw1OSwxLDg5MzAsMTAxLDU5LDEsODkzMSw0LDMsOTgsOTksMTEyLDE0MTE0LDE0MTU3LDE0MTcxLDQsNCw1OSw2OSwxMDEsMTE1LDE0MTI0LDE0MTI2LDE0MTMwLDE0MTMzLDEsODgzNiw1OSwzLDEwOTQ5LDgyNCw1OSwxLDg4NDAsMTAxLDExNiw0LDIsNTksMTAxLDE0MTQxLDE0MTQ0LDMsODgzNCw4NDAyLDExMyw0LDIsNTksMTEzLDE0MTUxLDE0MTUzLDEsODg0MCw1OSwzLDEwOTQ5LDgyNCw5OSw0LDIsNTksMTAxLDE0MTY0LDE0MTY2LDEsODgzMywxMTMsNTksMywxMDkyOCw4MjQsNCw0LDU5LDY5LDEwMSwxMTUsMTQxODEsMTQxODMsMTQxODcsMTQxOTAsMSw4ODM3LDU5LDMsMTA5NTAsODI0LDU5LDEsODg0MSwxMDEsMTE2LDQsMiw1OSwxMDEsMTQxOTgsMTQyMDEsMyw4ODM1LDg0MDIsMTEzLDQsMiw1OSwxMTMsMTQyMDgsMTQyMTAsMSw4ODQxLDU5LDMsMTA5NTAsODI0LDQsNCwxMDMsMTA1LDEwOCwxMTQsMTQyMjQsMTQyMjgsMTQyMzgsMTQyNDIsMTA4LDU5LDEsODgyNSwxMDgsMTAwLDEwMSw1LDI0MSwxLDU5LDE0MjM2LDEsMjQxLDEwMyw1OSwxLDg4MjQsMTA1LDk3LDExMCwxMDMsMTA4LDEwMSw0LDIsMTA4LDExNCwxNDI1NCwxNDI2OSwxMDEsMTAyLDExNiw0LDIsNTksMTAxLDE0MjYzLDE0MjY1LDEsODkzOCwxMTMsNTksMSw4OTQwLDEwNSwxMDMsMTA0LDExNiw0LDIsNTksMTAxLDE0Mjc5LDE0MjgxLDEsODkzOSwxMTMsNTksMSw4OTQxLDQsMiw1OSwxMDksMTQyOTEsMTQyOTMsMSw5NTcsNCwzLDU5LDEwMSwxMTUsMTQzMDEsMTQzMDMsMTQzMDgsMSwzNSwxMTQsMTExLDU5LDEsODQ3MCwxMTIsNTksMSw4MTk5LDQsOSw2OCw3Miw5NywxMDAsMTAzLDEwNSwxMDgsMTE0LDExNSwxNDMzMiwxNDMzOCwxNDM0NCwxNDM0OSwxNDM1NSwxNDM2OSwxNDM3NiwxNDQwOCwxNDQyNiw5NywxMTUsMTA0LDU5LDEsODg3Nyw5NywxMTQsMTE0LDU5LDEsMTA1MDAsMTEyLDU5LDMsODc4MSw4NDAyLDk3LDExNSwxMDQsNTksMSw4ODc2LDQsMiwxMDEsMTE2LDE0MzYxLDE0MzY1LDU5LDMsODgwNSw4NDAyLDU5LDMsNjIsODQwMiwxMTAsMTAyLDEwNSwxMTAsNTksMSwxMDcxOCw0LDMsNjUsMTAxLDExNiwxNDM4NCwxNDM4OSwxNDM5MywxMTQsMTE0LDU5LDEsMTA0OTgsNTksMyw4ODA0LDg0MDIsNCwyLDU5LDExNCwxNDM5OSwxNDQwMiwzLDYwLDg0MDIsMTA1LDEwMSw1OSwzLDg4ODQsODQwMiw0LDIsNjUsMTE2LDE0NDE0LDE0NDE5LDExNCwxMTQsNTksMSwxMDQ5OSwxMTQsMTA1LDEwMSw1OSwzLDg4ODUsODQwMiwxMDUsMTA5LDU5LDMsODc2NCw4NDAyLDQsMyw2NSw5NywxMTAsMTQ0NDAsMTQ0NDUsMTQ0NjgsMTE0LDExNCw1OSwxLDg2NjIsMTE0LDQsMiwxMDQsMTE0LDE0NDUyLDE0NDU2LDEwNyw1OSwxLDEwNTMxLDQsMiw1OSwxMTEsMTQ0NjIsMTQ0NjQsMSw4NTk4LDExOSw1OSwxLDg1OTgsMTAxLDk3LDExNCw1OSwxLDEwNTM1LDQsMTgsODMsOTcsOTksMTAwLDEwMSwxMDIsMTAzLDEwNCwxMDUsMTA4LDEwOSwxMTEsMTEyLDExNCwxMTUsMTE2LDExNywxMTgsMTQ1MTIsMTQ1MTUsMTQ1MzUsMTQ1NjAsMTQ1OTcsMTQ2MDMsMTQ2MTgsMTQ2NDMsMTQ2NTcsMTQ2NjIsMTQ3MDEsMTQ3NDEsMTQ3NDcsMTQ3NjksMTQ4NTEsMTQ4NzcsMTQ5MDcsMTQ5MTYsNTksMSw5NDE2LDQsMiw5OSwxMTUsMTQ1MjEsMTQ1MzEsMTE3LDExNiwxMDEsNSwyNDMsMSw1OSwxNDUyOSwxLDI0MywxMTYsNTksMSw4ODU5LDQsMiwxMDUsMTIxLDE0NTQxLDE0NTU3LDExNCw0LDIsNTksOTksMTQ1NDgsMTQ1NTAsMSw4ODU4LDUsMjQ0LDEsNTksMTQ1NTUsMSwyNDQsNTksMSwxMDg2LDQsNSw5Nyw5OCwxMDUsMTExLDExNSwxNDU3MiwxNDU3NywxNDU4MywxNDU4NywxNDU5MSwxMTUsMTA0LDU5LDEsODg2MSwxMDgsOTcsOTksNTksMSwzMzcsMTE4LDU5LDEsMTA4MDgsMTE2LDU5LDEsODg1NywxMTEsMTA4LDEwMCw1OSwxLDEwNjg0LDEwOCwxMDUsMTAzLDU5LDEsMzM5LDQsMiw5OSwxMTQsMTQ2MDksMTQ2MTQsMTA1LDExNCw1OSwxLDEwNjg3LDU5LDMsNTUzNDksNTY2MjAsNCwzLDExMSwxMTQsMTE2LDE0NjI2LDE0NjMwLDE0NjQwLDExMCw1OSwxLDczMSw5NywxMTgsMTAxLDUsMjQyLDEsNTksMTQ2MzgsMSwyNDIsNTksMSwxMDY4OSw0LDIsOTgsMTA5LDE0NjQ5LDE0NjU0LDk3LDExNCw1OSwxLDEwNjc3LDU5LDEsOTM3LDExMCwxMTYsNTksMSw4NzUwLDQsNCw5Nyw5OSwxMDUsMTE2LDE0NjcyLDE0Njc3LDE0NjkzLDE0Njk4LDExNCwxMTQsNTksMSw4NjM0LDQsMiwxMDUsMTE0LDE0NjgzLDE0Njg3LDExNCw1OSwxLDEwNjg2LDExMSwxMTUsMTE1LDU5LDEsMTA2ODMsMTEwLDEwMSw1OSwxLDgyNTQsNTksMSwxMDY4OCw0LDMsOTcsMTAxLDEwNSwxNDcwOSwxNDcxNCwxNDcxOSw5OSwxMTQsNTksMSwzMzMsMTAzLDk3LDU5LDEsOTY5LDQsMyw5OSwxMDAsMTEwLDE0NzI3LDE0NzMzLDE0NzM2LDExNCwxMTEsMTEwLDU5LDEsOTU5LDU5LDEsMTA2NzgsMTE3LDExNSw1OSwxLDg4NTQsMTEyLDEwMiw1OSwzLDU1MzQ5LDU2NjcyLDQsMyw5NywxMDEsMTA4LDE0NzU1LDE0NzU5LDE0NzY0LDExNCw1OSwxLDEwNjc5LDExNCwxMTIsNTksMSwxMDY4MSwxMTcsMTE1LDU5LDEsODg1Myw0LDcsNTksOTcsMTAwLDEwNSwxMTEsMTE1LDExOCwxNDc4NSwxNDc4NywxNDc5MiwxNDgzMSwxNDgzNywxNDg0MSwxNDg0OCwxLDg3NDQsMTE0LDExNCw1OSwxLDg2MzUsNCw0LDU5LDEwMSwxMDIsMTA5LDE0ODAyLDE0ODA0LDE0ODE3LDE0ODI0LDEsMTA4NDUsMTE0LDQsMiw1OSwxMTEsMTQ4MTEsMTQ4MTMsMSw4NTAwLDEwMiw1OSwxLDg1MDAsNSwxNzAsMSw1OSwxNDgyMiwxLDE3MCw1LDE4NiwxLDU5LDE0ODI5LDEsMTg2LDEwMywxMTEsMTAyLDU5LDEsODg4NiwxMTQsNTksMSwxMDgzOCwxMDgsMTExLDExMiwxMDEsNTksMSwxMDgzOSw1OSwxLDEwODQzLDQsMyw5OSwxMDgsMTExLDE0ODU5LDE0ODYzLDE0ODczLDExNCw1OSwxLDg1MDAsOTcsMTE1LDEwNCw1LDI0OCwxLDU5LDE0ODcxLDEsMjQ4LDEwOCw1OSwxLDg4NTYsMTA1LDQsMiwxMDgsMTA5LDE0ODg0LDE0ODkzLDEwMCwxMDEsNSwyNDUsMSw1OSwxNDg5MSwxLDI0NSwxMDEsMTE1LDQsMiw1OSw5NywxNDkwMSwxNDkwMywxLDg4NTUsMTE1LDU5LDEsMTA4MDYsMTA5LDEwOCw1LDI0NiwxLDU5LDE0OTE0LDEsMjQ2LDk4LDk3LDExNCw1OSwxLDkwMjEsNCwxMiw5Nyw5OSwxMDEsMTAyLDEwNCwxMDUsMTA4LDEwOSwxMTEsMTE0LDExNSwxMTcsMTQ5NDgsMTQ5OTIsMTQ5OTYsMTUwMzMsMTUwMzgsMTUwNjgsMTUwOTAsMTUxODksMTUxOTIsMTUyMjIsMTU0MjcsMTU0NDEsMTE0LDQsNCw1OSw5NywxMTUsMTE2LDE0OTU5LDE0OTYxLDE0OTc2LDE0OTg5LDEsODc0MSw1LDE4MiwyLDU5LDEwOCwxNDk2OCwxNDk3MCwxLDE4MiwxMDgsMTAxLDEwOCw1OSwxLDg3NDEsNCwyLDEwNSwxMDgsMTQ5ODIsMTQ5ODYsMTA5LDU5LDEsMTA5OTUsNTksMSwxMTAwNSw1OSwxLDg3MDYsMTIxLDU5LDEsMTA4NywxMTQsNCw1LDk5LDEwNSwxMDksMTEyLDExNiwxNTAwOSwxNTAxNCwxNTAxOSwxNTAyNCwxNTAyNywxMTAsMTE2LDU5LDEsMzcsMTExLDEwMCw1OSwxLDQ2LDEwNSwxMDgsNTksMSw4MjQwLDU5LDEsODg2OSwxMDEsMTEwLDEwNyw1OSwxLDgyNDEsMTE0LDU5LDMsNTUzNDksNTY2MjEsNCwzLDEwNSwxMDksMTExLDE1MDQ2LDE1MDU3LDE1MDYzLDQsMiw1OSwxMTgsMTUwNTIsMTUwNTQsMSw5NjYsNTksMSw5ODEsMTA5LDk3LDExNiw1OSwxLDg0OTksMTEwLDEwMSw1OSwxLDk3NDIsNCwzLDU5LDExNiwxMTgsMTUwNzYsMTUwNzgsMTUwODcsMSw5NjAsOTksMTA0LDEwMiwxMTEsMTE0LDEwNyw1OSwxLDg5MTYsNTksMSw5ODIsNCwyLDk3LDExNywxNTA5NiwxNTExOSwxMTAsNCwyLDk5LDEwNywxNTEwMywxNTExNSwxMDcsNCwyLDU5LDEwNCwxNTExMCwxNTExMiwxLDg0NjMsNTksMSw4NDYyLDExOCw1OSwxLDg0NjMsMTE1LDQsOSw1OSw5Nyw5OCw5OSwxMDAsMTAxLDEwOSwxMTUsMTE2LDE1MTQwLDE1MTQyLDE1MTQ4LDE1MTUxLDE1MTU2LDE1MTY4LDE1MTcxLDE1MTc5LDE1MTg0LDEsNDMsOTksMTA1LDExNCw1OSwxLDEwNzg3LDU5LDEsODg2MiwxMDUsMTE0LDU5LDEsMTA3ODYsNCwyLDExMSwxMTcsMTUxNjIsMTUxNjUsNTksMSw4NzI0LDU5LDEsMTA3ODksNTksMSwxMDg2NiwxMTAsNSwxNzcsMSw1OSwxNTE3NywxLDE3NywxMDUsMTA5LDU5LDEsMTA3OTAsMTE5LDExMSw1OSwxLDEwNzkxLDU5LDEsMTc3LDQsMywxMDUsMTEyLDExNywxNTIwMCwxNTIwOCwxNTIxMywxMTAsMTE2LDEwNSwxMTAsMTE2LDU5LDEsMTA3NzMsMTAyLDU5LDMsNTUzNDksNTY2NzMsMTEwLDEwMCw1LDE2MywxLDU5LDE1MjIwLDEsMTYzLDQsMTAsNTksNjksOTcsOTksMTAxLDEwNSwxMTAsMTExLDExNSwxMTcsMTUyNDQsMTUyNDYsMTUyNDksMTUyNTMsMTUyNTgsMTUzMzQsMTUzNDcsMTUzNjcsMTU0MTYsMTU0MjEsMSw4ODI2LDU5LDEsMTA5MzEsMTEyLDU5LDEsMTA5MzUsMTE3LDEwMSw1OSwxLDg4MjgsNCwyLDU5LDk5LDE1MjY0LDE1MjY2LDEsMTA5MjcsNCw2LDU5LDk3LDk5LDEwMSwxMTAsMTE1LDE1MjgwLDE1MjgyLDE1MjkwLDE1Mjk5LDE1MzAzLDE1MzI5LDEsODgyNiwxMTIsMTEyLDExNCwxMTEsMTIwLDU5LDEsMTA5MzUsMTE3LDExNCwxMDgsMTIxLDEwMSwxMTMsNTksMSw4ODI4LDExMyw1OSwxLDEwOTI3LDQsMyw5NywxMDEsMTE1LDE1MzExLDE1MzE5LDE1MzI0LDExMiwxMTIsMTE0LDExMSwxMjAsNTksMSwxMDkzNywxMTMsMTEzLDU5LDEsMTA5MzMsMTA1LDEwOSw1OSwxLDg5MzYsMTA1LDEwOSw1OSwxLDg4MzAsMTA5LDEwMSw0LDIsNTksMTE1LDE1MzQyLDE1MzQ0LDEsODI0Miw1OSwxLDg0NzMsNCwzLDY5LDk3LDExNSwxNTM1NSwxNTM1OCwxNTM2Miw1OSwxLDEwOTMzLDExMiw1OSwxLDEwOTM3LDEwNSwxMDksNTksMSw4OTM2LDQsMywxMDAsMTAyLDExMiwxNTM3NSwxNTM3OCwxNTQwNCw1OSwxLDg3MTksNCwzLDk3LDEwOCwxMTUsMTUzODYsMTUzOTIsMTUzOTgsMTA4LDk3LDExNCw1OSwxLDkwMDYsMTA1LDExMCwxMDEsNTksMSw4OTc4LDExNywxMTQsMTAyLDU5LDEsODk3OSw0LDIsNTksMTE2LDE1NDEwLDE1NDEyLDEsODczMywxMTEsNTksMSw4NzMzLDEwNSwxMDksNTksMSw4ODMwLDExNCwxMDEsMTA4LDU5LDEsODg4MCw0LDIsOTksMTA1LDE1NDMzLDE1NDM4LDExNCw1OSwzLDU1MzQ5LDU2NTE3LDU5LDEsOTY4LDExMCw5OSwxMTUsMTEyLDU5LDEsODIwMCw0LDYsMTAyLDEwNSwxMTEsMTEyLDExNSwxMTcsMTU0NjIsMTU0NjcsMTU0NzIsMTU0NzgsMTU0ODUsMTU0OTEsMTE0LDU5LDMsNTUzNDksNTY2MjIsMTEwLDExNiw1OSwxLDEwNzY0LDExMiwxMDIsNTksMyw1NTM0OSw1NjY3NCwxMTQsMTA1LDEwOSwxMDEsNTksMSw4Mjc5LDk5LDExNCw1OSwzLDU1MzQ5LDU2NTE4LDQsMyw5NywxMDEsMTExLDE1NDk5LDE1NTIwLDE1NTM0LDExNiw0LDIsMTAxLDEwNSwxNTUwNiwxNTUxNSwxMTQsMTEwLDEwNSwxMTEsMTEwLDExNSw1OSwxLDg0NjEsMTEwLDExNiw1OSwxLDEwNzc0LDExNSwxMTYsNCwyLDU5LDEwMSwxNTUyOCwxNTUzMCwxLDYzLDExMyw1OSwxLDg3OTksMTE2LDUsMzQsMSw1OSwxNTU0MCwxLDM0LDQsMjEsNjUsNjYsNzIsOTcsOTgsOTksMTAwLDEwMSwxMDIsMTA0LDEwNSwxMDgsMTA5LDExMCwxMTEsMTEyLDExNCwxMTUsMTE2LDExNywxMjAsMTU1ODYsMTU2MDksMTU2MTUsMTU2MjAsMTU3OTYsMTU4NTUsMTU4OTMsMTU5MzEsMTU5NzcsMTYwMDEsMTYwMzksMTYxODMsMTYyMDQsMTYyMjIsMTYyMjgsMTYyODUsMTYzMTIsMTYzMTgsMTYzNjMsMTY0MDgsMTY0MTYsNCwzLDk3LDExNCwxMTYsMTU1OTQsMTU1OTksMTU2MDMsMTE0LDExNCw1OSwxLDg2NjcsMTE0LDU5LDEsODY1OCw5NywxMDUsMTA4LDU5LDEsMTA1MjQsOTcsMTE0LDExNCw1OSwxLDEwNTExLDk3LDExNCw1OSwxLDEwNTk2LDQsNyw5OSwxMDAsMTAxLDExMCwxMTMsMTE0LDExNiwxNTYzNiwxNTY1MSwxNTY1NiwxNTY2NCwxNTY4NywxNTY5NiwxNTc3MCw0LDIsMTAxLDExNywxNTY0MiwxNTY0Niw1OSwzLDg3NjUsODE3LDExNiwxMDEsNTksMSwzNDEsMTA1LDk5LDU5LDEsODczMCwxMDksMTEyLDExNiwxMjEsMTE4LDU5LDEsMTA2NzUsMTAzLDQsNCw1OSwxMDAsMTAxLDEwOCwxNTY3NSwxNTY3NywxNTY4MCwxNTY4MywxLDEwMjE3LDU5LDEsMTA2NDIsNTksMSwxMDY2MSwxMDEsNTksMSwxMDIxNywxMTcsMTExLDUsMTg3LDEsNTksMTU2OTQsMSwxODcsMTE0LDQsMTEsNTksOTcsOTgsOTksMTAyLDEwNCwxMDgsMTEyLDExNSwxMTYsMTE5LDE1NzIxLDE1NzIzLDE1NzI3LDE1NzM5LDE1NzQyLDE1NzQ2LDE1NzUwLDE1NzU0LDE1NzU4LDE1NzYzLDE1NzY3LDEsODU5NCwxMTIsNTksMSwxMDYxMyw0LDIsNTksMTAyLDE1NzMzLDE1NzM1LDEsODY3NywxMTUsNTksMSwxMDUyOCw1OSwxLDEwNTQ3LDExNSw1OSwxLDEwNTI2LDEwNyw1OSwxLDg2MTgsMTEyLDU5LDEsODYyMCwxMDgsNTksMSwxMDU2NSwxMDUsMTA5LDU5LDEsMTA2MTIsMTA4LDU5LDEsODYxMSw1OSwxLDg2MDUsNCwyLDk3LDEwNSwxNTc3NiwxNTc4MSwxMDUsMTA4LDU5LDEsMTA1MjIsMTExLDQsMiw1OSwxMTAsMTU3ODgsMTU3OTAsMSw4NzU4LDk3LDEwOCwxMTUsNTksMSw4NDc0LDQsMyw5Nyw5OCwxMTQsMTU4MDQsMTU4MDksMTU4MTQsMTE0LDExNCw1OSwxLDEwNTA5LDExNCwxMDcsNTksMSwxMDA5OSw0LDIsOTcsMTA3LDE1ODIwLDE1ODMzLDk5LDQsMiwxMDEsMTA3LDE1ODI3LDE1ODMwLDU5LDEsMTI1LDU5LDEsOTMsNCwyLDEwMSwxMTUsMTU4MzksMTU4NDIsNTksMSwxMDYzNiwxMDgsNCwyLDEwMCwxMTcsMTU4NDksMTU4NTIsNTksMSwxMDYzOCw1OSwxLDEwNjQwLDQsNCw5NywxMDEsMTE3LDEyMSwxNTg2NSwxNTg3MSwxNTg4NiwxNTg5MCwxMTQsMTExLDExMCw1OSwxLDM0NSw0LDIsMTAwLDEwNSwxNTg3NywxNTg4MiwxMDUsMTA4LDU5LDEsMzQzLDEwOCw1OSwxLDg5NjksOTgsNTksMSwxMjUsNTksMSwxMDg4LDQsNCw5OSwxMDgsMTEzLDExNSwxNTkwMywxNTkwNywxNTkxNCwxNTkyNyw5Nyw1OSwxLDEwNTUxLDEwMCwxMDQsOTcsMTE0LDU5LDEsMTA2MDEsMTE3LDExMSw0LDIsNTksMTE0LDE1OTIyLDE1OTI0LDEsODIyMSw1OSwxLDgyMjEsMTA0LDU5LDEsODYyNyw0LDMsOTcsOTksMTAzLDE1OTM5LDE1OTY2LDE1OTcwLDEwOCw0LDQsNTksMTA1LDExMiwxMTUsMTU5NTAsMTU5NTIsMTU5NTcsMTU5NjMsMSw4NDc2LDExMCwxMDEsNTksMSw4NDc1LDk3LDExNCwxMTYsNTksMSw4NDc2LDU5LDEsODQ3NywxMTYsNTksMSw5NjQ1LDUsMTc0LDEsNTksMTU5NzUsMSwxNzQsNCwzLDEwNSwxMDgsMTE0LDE1OTg1LDE1OTkxLDE1OTk3LDExNSwxMDQsMTE2LDU5LDEsMTA2MjEsMTExLDExMSwxMTQsNTksMSw4OTcxLDU5LDMsNTUzNDksNTY2MjMsNCwyLDk3LDExMSwxNjAwNywxNjAyOCwxMTQsNCwyLDEwMCwxMTcsMTYwMTQsMTYwMTcsNTksMSw4NjQxLDQsMiw1OSwxMDgsMTYwMjMsMTYwMjUsMSw4NjQwLDU5LDEsMTA2MDQsNCwyLDU5LDExOCwxNjAzNCwxNjAzNiwxLDk2MSw1OSwxLDEwMDksNCwzLDEwMywxMTAsMTE1LDE2MDQ3LDE2MTY3LDE2MTcxLDEwNCwxMTYsNCw2LDk3LDEwNCwxMDgsMTE0LDExNSwxMTYsMTYwNjMsMTYwODEsMTYxMDMsMTYxMzAsMTYxNDMsMTYxNTUsMTE0LDExNCwxMTEsMTE5LDQsMiw1OSwxMTYsMTYwNzMsMTYwNzUsMSw4NTk0LDk3LDEwNSwxMDgsNTksMSw4NjExLDk3LDExNCwxMTIsMTExLDExMSwxMTAsNCwyLDEwMCwxMTcsMTYwOTMsMTYwOTksMTExLDExOSwxMTAsNTksMSw4NjQxLDExMiw1OSwxLDg2NDAsMTAxLDEwMiwxMTYsNCwyLDk3LDEwNCwxNjExMiwxNjEyMCwxMTQsMTE0LDExMSwxMTksMTE1LDU5LDEsODY0NCw5NywxMTQsMTEyLDExMSwxMTEsMTEwLDExNSw1OSwxLDg2NTIsMTA1LDEwMywxMDQsMTE2LDk3LDExNCwxMTQsMTExLDExOSwxMTUsNTksMSw4NjQ5LDExMywxMTcsMTA1LDEwMyw5NywxMTQsMTE0LDExMSwxMTksNTksMSw4NjA1LDEwNCwxMTQsMTAxLDEwMSwxMTYsMTA1LDEwOSwxMDEsMTE1LDU5LDEsODkwOCwxMDMsNTksMSw3MzAsMTA1LDExMCwxMDMsMTAwLDExMSwxMTYsMTE1LDEwMSwxMTMsNTksMSw4Nzg3LDQsMyw5NywxMDQsMTA5LDE2MTkxLDE2MTk2LDE2MjAxLDExNCwxMTQsNTksMSw4NjQ0LDk3LDExNCw1OSwxLDg2NTIsNTksMSw4MjA3LDExMSwxMTcsMTE1LDExNiw0LDIsNTksOTcsMTYyMTQsMTYyMTYsMSw5MTM3LDk5LDEwNCwxMDEsNTksMSw5MTM3LDEwOSwxMDUsMTAwLDU5LDEsMTA5OTAsNCw0LDk3LDk4LDExMiwxMTYsMTYyMzgsMTYyNTIsMTYyNTcsMTYyNzgsNCwyLDExMCwxMTQsMTYyNDQsMTYyNDgsMTAzLDU5LDEsMTAyMjEsMTE0LDU5LDEsODcwMiwxMTQsMTA3LDU5LDEsMTAyMTUsNCwzLDk3LDEwMiwxMDgsMTYyNjUsMTYyNjksMTYyNzMsMTE0LDU5LDEsMTA2MzAsNTksMyw1NTM0OSw1NjY3NSwxMTcsMTE1LDU5LDEsMTA3OTgsMTA1LDEwOSwxMDEsMTE1LDU5LDEsMTA4MDUsNCwyLDk3LDExMiwxNjI5MSwxNjMwNCwxMTQsNCwyLDU5LDEwMywxNjI5OCwxNjMwMCwxLDQxLDExNiw1OSwxLDEwNjQ0LDExMSwxMDgsMTA1LDExMCwxMTYsNTksMSwxMDc3MCw5NywxMTQsMTE0LDU5LDEsODY0OSw0LDQsOTcsOTksMTA0LDExMywxNjMyOCwxNjMzNCwxNjMzOSwxNjM0MiwxMTMsMTE3LDExMSw1OSwxLDgyNTAsMTE0LDU5LDMsNTUzNDksNTY1MTksNTksMSw4NjI1LDQsMiw5OCwxMTcsMTYzNDgsMTYzNTEsNTksMSw5MywxMTEsNCwyLDU5LDExNCwxNjM1OCwxNjM2MCwxLDgyMTcsNTksMSw4MjE3LDQsMywxMDQsMTA1LDExNCwxNjM3MSwxNjM3NywxNjM4MywxMTQsMTAxLDEwMSw1OSwxLDg5MDgsMTA5LDEwMSwxMTUsNTksMSw4OTA2LDEwNSw0LDQsNTksMTAxLDEwMiwxMDgsMTYzOTQsMTYzOTYsMTYzOTksMTY0MDIsMSw5NjU3LDU5LDEsODg4NSw1OSwxLDk2NTYsMTE2LDExNCwxMDUsNTksMSwxMDcwMiwxMDgsMTE3LDEwNCw5NywxMTQsNTksMSwxMDYwMCw1OSwxLDg0NzgsNCwxOSw5Nyw5OCw5OSwxMDAsMTAxLDEwMiwxMDQsMTA1LDEwOCwxMDksMTExLDExMiwxMTMsMTE0LDExNSwxMTYsMTE3LDExOSwxMjIsMTY0NTksMTY0NjYsMTY0NzIsMTY1NzIsMTY1OTAsMTY2NzIsMTY2ODcsMTY3NDYsMTY4NDQsMTY4NTAsMTY5MjQsMTY5NjMsMTY5ODgsMTcxMTUsMTcxMjEsMTcxNTQsMTcyMDYsMTc2MTQsMTc2NTYsOTksMTE3LDExNiwxMDEsNTksMSwzNDcsMTEzLDExNywxMTEsNTksMSw4MjE4LDQsMTAsNTksNjksOTcsOTksMTAxLDEwNSwxMTAsMTEyLDExNSwxMjEsMTY0OTQsMTY0OTYsMTY0OTksMTY1MTMsMTY1MTgsMTY1MzEsMTY1MzYsMTY1NTYsMTY1NjQsMTY1NjksMSw4ODI3LDU5LDEsMTA5MzIsNCwyLDExMiwxMTQsMTY1MDUsMTY1MDgsNTksMSwxMDkzNiwxMTEsMTEwLDU5LDEsMzUzLDExNywxMDEsNTksMSw4ODI5LDQsMiw1OSwxMDAsMTY1MjQsMTY1MjYsMSwxMDkyOCwxMDUsMTA4LDU5LDEsMzUxLDExNCw5OSw1OSwxLDM0OSw0LDMsNjksOTcsMTE1LDE2NTQ0LDE2NTQ3LDE2NTUxLDU5LDEsMTA5MzQsMTEyLDU5LDEsMTA5MzgsMTA1LDEwOSw1OSwxLDg5MzcsMTExLDEwOCwxMDUsMTEwLDExNiw1OSwxLDEwNzcxLDEwNSwxMDksNTksMSw4ODMxLDU5LDEsMTA4OSwxMTEsMTE2LDQsMyw1OSw5OCwxMDEsMTY1ODIsMTY1ODQsMTY1ODcsMSw4OTAxLDU5LDEsODg2NSw1OSwxLDEwODU0LDQsNyw2NSw5Nyw5OSwxMDksMTE1LDExNiwxMjAsMTY2MDYsMTY2MTEsMTY2MzQsMTY2NDIsMTY2NDYsMTY2NTIsMTY2NjgsMTE0LDExNCw1OSwxLDg2NjQsMTE0LDQsMiwxMDQsMTE0LDE2NjE4LDE2NjIyLDEwNyw1OSwxLDEwNTMzLDQsMiw1OSwxMTEsMTY2MjgsMTY2MzAsMSw4NjAwLDExOSw1OSwxLDg2MDAsMTE2LDUsMTY3LDEsNTksMTY2NDAsMSwxNjcsMTA1LDU5LDEsNTksMTE5LDk3LDExNCw1OSwxLDEwNTM3LDEwOSw0LDIsMTA1LDExMCwxNjY1OSwxNjY2NSwxMTAsMTE3LDExNSw1OSwxLDg3MjYsNTksMSw4NzI2LDExNiw1OSwxLDEwMDM4LDExNCw0LDIsNTksMTExLDE2Njc5LDE2NjgyLDMsNTUzNDksNTY2MjQsMTE5LDExMCw1OSwxLDg5OTQsNCw0LDk3LDk5LDExMSwxMjEsMTY2OTcsMTY3MDIsMTY3MTYsMTY3MzksMTE0LDExMiw1OSwxLDk4MzksNCwyLDEwNCwxMjEsMTY3MDgsMTY3MTMsOTksMTIxLDU5LDEsMTA5Nyw1OSwxLDEwOTYsMTE0LDExNiw0LDIsMTA5LDExMiwxNjcyNCwxNjcyOSwxMDUsMTAwLDU5LDEsODczOSw5NywxMTQsOTcsMTA4LDEwOCwxMDEsMTA4LDU5LDEsODc0MSw1LDE3MywxLDU5LDE2NzQ0LDEsMTczLDQsMiwxMDMsMTA5LDE2NzUyLDE2NzcwLDEwOSw5Nyw0LDMsNTksMTAyLDExOCwxNjc2MiwxNjc2NCwxNjc2NywxLDk2Myw1OSwxLDk2Miw1OSwxLDk2Miw0LDgsNTksMTAwLDEwMSwxMDMsMTA4LDExMCwxMTIsMTE0LDE2Nzg4LDE2NzkwLDE2Nzk1LDE2ODA2LDE2ODE3LDE2ODI4LDE2ODMyLDE2ODM4LDEsODc2NCwxMTEsMTE2LDU5LDEsMTA4NTgsNCwyLDU5LDExMywxNjgwMSwxNjgwMywxLDg3NzEsNTksMSw4NzcxLDQsMiw1OSw2OSwxNjgxMiwxNjgxNCwxLDEwOTEwLDU5LDEsMTA5MTIsNCwyLDU5LDY5LDE2ODIzLDE2ODI1LDEsMTA5MDksNTksMSwxMDkxMSwxMDEsNTksMSw4Nzc0LDEwOCwxMTcsMTE1LDU5LDEsMTA3ODgsOTcsMTE0LDExNCw1OSwxLDEwNjEwLDk3LDExNCwxMTQsNTksMSw4NTkyLDQsNCw5NywxMDEsMTA1LDExNiwxNjg2MCwxNjg4MywxNjg5MSwxNjkwNCw0LDIsMTA4LDExNSwxNjg2NiwxNjg3OCwxMDgsMTE1LDEwMSwxMTYsMTA5LDEwNSwxMTAsMTE3LDExNSw1OSwxLDg3MjYsMTA0LDExMiw1OSwxLDEwODAzLDExMiw5NywxMTQsMTE1LDEwOCw1OSwxLDEwNzI0LDQsMiwxMDAsMTA4LDE2ODk3LDE2OTAwLDU5LDEsODczOSwxMDEsNTksMSw4OTk1LDQsMiw1OSwxMDEsMTY5MTAsMTY5MTIsMSwxMDkyMiw0LDIsNTksMTE1LDE2OTE4LDE2OTIwLDEsMTA5MjQsNTksMywxMDkyNCw2NTAyNCw0LDMsMTAyLDEwOCwxMTIsMTY5MzIsMTY5MzgsMTY5NTgsMTE2LDk5LDEyMSw1OSwxLDExMDAsNCwyLDU5LDk4LDE2OTQ0LDE2OTQ2LDEsNDcsNCwyLDU5LDk3LDE2OTUyLDE2OTU0LDEsMTA2OTIsMTE0LDU5LDEsOTAyMywxMDIsNTksMyw1NTM0OSw1NjY3Niw5Nyw0LDIsMTAwLDExNCwxNjk3MCwxNjk4NSwxMDEsMTE1LDQsMiw1OSwxMTcsMTY5NzgsMTY5ODAsMSw5ODI0LDEwNSwxMTYsNTksMSw5ODI0LDU5LDEsODc0MSw0LDMsOTksMTE1LDExNywxNjk5NiwxNzAyOCwxNzA4OSw0LDIsOTcsMTE3LDE3MDAyLDE3MDE1LDExMiw0LDIsNTksMTE1LDE3MDA5LDE3MDExLDEsODg1MSw1OSwzLDg4NTEsNjUwMjQsMTEyLDQsMiw1OSwxMTUsMTcwMjIsMTcwMjQsMSw4ODUyLDU5LDMsODg1Miw2NTAyNCwxMTcsNCwyLDk4LDExMiwxNzAzNSwxNzA2Miw0LDMsNTksMTAxLDExNSwxNzA0MywxNzA0NSwxNzA0OCwxLDg4NDcsNTksMSw4ODQ5LDEwMSwxMTYsNCwyLDU5LDEwMSwxNzA1NiwxNzA1OCwxLDg4NDcsMTEzLDU5LDEsODg0OSw0LDMsNTksMTAxLDExNSwxNzA3MCwxNzA3MiwxNzA3NSwxLDg4NDgsNTksMSw4ODUwLDEwMSwxMTYsNCwyLDU5LDEwMSwxNzA4MywxNzA4NSwxLDg4NDgsMTEzLDU5LDEsODg1MCw0LDMsNTksOTcsMTAyLDE3MDk3LDE3MDk5LDE3MTEyLDEsOTYzMywxMTQsNCwyLDEwMSwxMDIsMTcxMDYsMTcxMDksNTksMSw5NjMzLDU5LDEsOTY0Miw1OSwxLDk2NDIsOTcsMTE0LDExNCw1OSwxLDg1OTQsNCw0LDk5LDEwMSwxMDksMTE2LDE3MTMxLDE3MTM2LDE3MTQyLDE3MTQ4LDExNCw1OSwzLDU1MzQ5LDU2NTIwLDExNiwxMDksMTEwLDU5LDEsODcyNiwxMDUsMTA4LDEwMSw1OSwxLDg5OTUsOTcsMTE0LDEwMiw1OSwxLDg5MDIsNCwyLDk3LDExNCwxNzE2MCwxNzE3MiwxMTQsNCwyLDU5LDEwMiwxNzE2NywxNzE2OSwxLDk3MzQsNTksMSw5NzMzLDQsMiw5NywxMTAsMTcxNzgsMTcyMDIsMTA1LDEwMywxMDQsMTE2LDQsMiwxMDEsMTEyLDE3MTg4LDE3MTk3LDExMiwxMTUsMTA1LDEwOCwxMTEsMTEwLDU5LDEsMTAxMywxMDQsMTA1LDU5LDEsOTgxLDExNSw1OSwxLDE3NSw0LDUsOTgsOTksMTA5LDExMCwxMTIsMTcyMTgsMTczNTEsMTc0MjAsMTc0MjMsMTc0MjcsNCw5LDU5LDY5LDEwMCwxMDEsMTA5LDExMCwxMTIsMTE0LDExNSwxNzIzOCwxNzI0MCwxNzI0MywxNzI0OCwxNzI2MSwxNzI2NywxNzI3OSwxNzI4NSwxNzI5MSwxLDg4MzQsNTksMSwxMDk0OSwxMTEsMTE2LDU5LDEsMTA5NDEsNCwyLDU5LDEwMCwxNzI1NCwxNzI1NiwxLDg4MzgsMTExLDExNiw1OSwxLDEwOTQ3LDExNywxMDgsMTE2LDU5LDEsMTA5NDUsNCwyLDY5LDEwMSwxNzI3MywxNzI3Niw1OSwxLDEwOTU1LDU5LDEsODg0MiwxMDgsMTE3LDExNSw1OSwxLDEwOTQzLDk3LDExNCwxMTQsNTksMSwxMDYxNyw0LDMsMTAxLDEwNSwxMTcsMTcyOTksMTczMzUsMTczMzksMTE2LDQsMyw1OSwxMDEsMTEwLDE3MzA4LDE3MzEwLDE3MzIyLDEsODgzNCwxMTMsNCwyLDU5LDExMywxNzMxNywxNzMxOSwxLDg4MzgsNTksMSwxMDk0OSwxMDEsMTEzLDQsMiw1OSwxMTMsMTczMzAsMTczMzIsMSw4ODQyLDU5LDEsMTA5NTUsMTA5LDU5LDEsMTA5NTEsNCwyLDk4LDExMiwxNzM0NSwxNzM0OCw1OSwxLDEwOTY1LDU5LDEsMTA5NjMsOTksNCw2LDU5LDk3LDk5LDEwMSwxMTAsMTE1LDE3MzY2LDE3MzY4LDE3Mzc2LDE3Mzg1LDE3Mzg5LDE3NDE1LDEsODgyNywxMTIsMTEyLDExNCwxMTEsMTIwLDU5LDEsMTA5MzYsMTE3LDExNCwxMDgsMTIxLDEwMSwxMTMsNTksMSw4ODI5LDExMyw1OSwxLDEwOTI4LDQsMyw5NywxMDEsMTE1LDE3Mzk3LDE3NDA1LDE3NDEwLDExMiwxMTIsMTE0LDExMSwxMjAsNTksMSwxMDkzOCwxMTMsMTEzLDU5LDEsMTA5MzQsMTA1LDEwOSw1OSwxLDg5MzcsMTA1LDEwOSw1OSwxLDg4MzEsNTksMSw4NzIxLDEwMyw1OSwxLDk4MzQsNCwxMyw0OSw1MCw1MSw1OSw2OSwxMDAsMTAxLDEwNCwxMDgsMTA5LDExMCwxMTIsMTE1LDE3NDU1LDE3NDYyLDE3NDY5LDE3NDc2LDE3NDc4LDE3NDgxLDE3NDk2LDE3NTA5LDE3NTI0LDE3NTMwLDE3NTM2LDE3NTQ4LDE3NTU0LDUsMTg1LDEsNTksMTc0NjAsMSwxODUsNSwxNzgsMSw1OSwxNzQ2NywxLDE3OCw1LDE3OSwxLDU5LDE3NDc0LDEsMTc5LDEsODgzNSw1OSwxLDEwOTUwLDQsMiwxMTEsMTE1LDE3NDg3LDE3NDkxLDExNiw1OSwxLDEwOTQyLDExNyw5OCw1OSwxLDEwOTY4LDQsMiw1OSwxMDAsMTc1MDIsMTc1MDQsMSw4ODM5LDExMSwxMTYsNTksMSwxMDk0OCwxMTUsNCwyLDExMSwxMTcsMTc1MTYsMTc1MjAsMTA4LDU5LDEsMTAxODUsOTgsNTksMSwxMDk2Nyw5NywxMTQsMTE0LDU5LDEsMTA2MTksMTE3LDEwOCwxMTYsNTksMSwxMDk0Niw0LDIsNjksMTAxLDE3NTQyLDE3NTQ1LDU5LDEsMTA5NTYsNTksMSw4ODQzLDEwOCwxMTcsMTE1LDU5LDEsMTA5NDQsNCwzLDEwMSwxMDUsMTE3LDE3NTYyLDE3NTk4LDE3NjAyLDExNiw0LDMsNTksMTAxLDExMCwxNzU3MSwxNzU3MywxNzU4NSwxLDg4MzUsMTEzLDQsMiw1OSwxMTMsMTc1ODAsMTc1ODIsMSw4ODM5LDU5LDEsMTA5NTAsMTAxLDExMyw0LDIsNTksMTEzLDE3NTkzLDE3NTk1LDEsODg0Myw1OSwxLDEwOTU2LDEwOSw1OSwxLDEwOTUyLDQsMiw5OCwxMTIsMTc2MDgsMTc2MTEsNTksMSwxMDk2NCw1OSwxLDEwOTY2LDQsMyw2NSw5NywxMTAsMTc2MjIsMTc2MjcsMTc2NTAsMTE0LDExNCw1OSwxLDg2NjUsMTE0LDQsMiwxMDQsMTE0LDE3NjM0LDE3NjM4LDEwNyw1OSwxLDEwNTM0LDQsMiw1OSwxMTEsMTc2NDQsMTc2NDYsMSw4NjAxLDExOSw1OSwxLDg2MDEsMTE5LDk3LDExNCw1OSwxLDEwNTM4LDEwOCwxMDUsMTAzLDUsMjIzLDEsNTksMTc2NjQsMSwyMjMsNCwxMyw5Nyw5OCw5OSwxMDAsMTAxLDEwMiwxMDQsMTA1LDExMSwxMTIsMTE0LDExNSwxMTksMTc2OTQsMTc3MDksMTc3MTQsMTc3MzcsMTc3NDIsMTc3NDksMTc3NTQsMTc4NjAsMTc5MDUsMTc5NTcsMTc5NjQsMTgwOTAsMTgxMjIsNCwyLDExNCwxMTcsMTc3MDAsMTc3MDYsMTAzLDEwMSwxMTYsNTksMSw4OTgyLDU5LDEsOTY0LDExNCwxMDcsNTksMSw5MTQwLDQsMyw5NywxMDEsMTIxLDE3NzIyLDE3NzI4LDE3NzM0LDExNCwxMTEsMTEwLDU5LDEsMzU3LDEwMCwxMDUsMTA4LDU5LDEsMzU1LDU5LDEsMTA5MCwxMTEsMTE2LDU5LDEsODQxMSwxMDgsMTE0LDEwMSw5OSw1OSwxLDg5ODEsMTE0LDU5LDMsNTUzNDksNTY2MjUsNCw0LDEwMSwxMDUsMTA3LDExMSwxNzc2NCwxNzgwNSwxNzgzNiwxNzg1MSw0LDIsMTE0LDExNiwxNzc3MCwxNzc4NiwxMDEsNCwyLDUyLDEwMiwxNzc3NywxNzc4MCw1OSwxLDg3NTYsMTExLDExNCwxMDEsNTksMSw4NzU2LDk3LDQsMyw1OSwxMTUsMTE4LDE3Nzk1LDE3Nzk3LDE3ODAyLDEsOTUyLDEyMSwxMDksNTksMSw5NzcsNTksMSw5NzcsNCwyLDk5LDExMCwxNzgxMSwxNzgzMSwxMDcsNCwyLDk3LDExNSwxNzgxOCwxNzgyNiwxMTIsMTEyLDExNCwxMTEsMTIwLDU5LDEsODc3NiwxMDUsMTA5LDU5LDEsODc2NCwxMTUsMTEyLDU5LDEsODIwMSw0LDIsOTcsMTE1LDE3ODQyLDE3ODQ2LDExMiw1OSwxLDg3NzYsMTA1LDEwOSw1OSwxLDg3NjQsMTE0LDExMCw1LDI1NCwxLDU5LDE3ODU4LDEsMjU0LDQsMywxMDgsMTA5LDExMCwxNzg2OCwxNzg3MywxNzkwMSwxMDAsMTAxLDU5LDEsNzMyLDEwMSwxMTUsNSwyMTUsMyw1OSw5OCwxMDAsMTc4ODQsMTc4ODYsMTc4OTgsMSwyMTUsNCwyLDU5LDk3LDE3ODkyLDE3ODk0LDEsODg2NCwxMTQsNTksMSwxMDgwMSw1OSwxLDEwODAwLDExNiw1OSwxLDg3NDksNCwzLDEwMSwxMTIsMTE1LDE3OTEzLDE3OTE3LDE3OTUzLDk3LDU5LDEsMTA1MzYsNCw0LDU5LDk4LDk5LDEwMiwxNzkyNywxNzkyOSwxNzkzNCwxNzkzOSwxLDg4NjgsMTExLDExNiw1OSwxLDkwMTQsMTA1LDExNCw1OSwxLDEwOTkzLDQsMiw1OSwxMTEsMTc5NDUsMTc5NDgsMyw1NTM0OSw1NjY3NywxMTQsMTA3LDU5LDEsMTA5NzAsOTcsNTksMSwxMDUzNywxMTQsMTA1LDEwOSwxMDEsNTksMSw4MjQ0LDQsMyw5NywxMDUsMTEyLDE3OTcyLDE3OTc3LDE4MDgyLDEwMCwxMDEsNTksMSw4NDgyLDQsNyw5NywxMDAsMTAxLDEwOSwxMTIsMTE1LDExNiwxNzk5MywxODA1MSwxODA1NiwxODA1OSwxODA2NiwxODA3MiwxODA3NiwxMTAsMTAzLDEwOCwxMDEsNCw1LDU5LDEwMCwxMDgsMTEzLDExNCwxODAwOSwxODAxMSwxODAxNywxODAzMiwxODAzNSwxLDk2NTMsMTExLDExOSwxMTAsNTksMSw5NjYzLDEwMSwxMDIsMTE2LDQsMiw1OSwxMDEsMTgwMjYsMTgwMjgsMSw5NjY3LDExMyw1OSwxLDg4ODQsNTksMSw4Nzk2LDEwNSwxMDMsMTA0LDExNiw0LDIsNTksMTAxLDE4MDQ1LDE4MDQ3LDEsOTY1NywxMTMsNTksMSw4ODg1LDExMSwxMTYsNTksMSw5NzA4LDU5LDEsODc5NiwxMDUsMTEwLDExNywxMTUsNTksMSwxMDgxMCwxMDgsMTE3LDExNSw1OSwxLDEwODA5LDk4LDU5LDEsMTA3MDEsMTA1LDEwOSwxMDEsNTksMSwxMDgxMSwxMDEsMTIyLDEwNSwxMTcsMTA5LDU5LDEsOTE4Niw0LDMsOTksMTA0LDExNiwxODA5OCwxODExMSwxODExNiw0LDIsMTE0LDEyMSwxODEwNCwxODEwOCw1OSwzLDU1MzQ5LDU2NTIxLDU5LDEsMTA5NCw5OSwxMjEsNTksMSwxMTE1LDExNCwxMTEsMTA3LDU5LDEsMzU5LDQsMiwxMDUsMTExLDE4MTI4LDE4MTMzLDEyMCwxMTYsNTksMSw4ODEyLDEwNCwxMDEsOTcsMTAwLDQsMiwxMDgsMTE0LDE4MTQzLDE4MTU0LDEwMSwxMDIsMTE2LDk3LDExNCwxMTQsMTExLDExOSw1OSwxLDg2MDYsMTA1LDEwMywxMDQsMTE2LDk3LDExNCwxMTQsMTExLDExOSw1OSwxLDg2MDgsNCwxOCw2NSw3Miw5Nyw5OCw5OSwxMDAsMTAyLDEwMywxMDQsMTA4LDEwOSwxMTEsMTEyLDExNCwxMTUsMTE2LDExNywxMTksMTgyMDQsMTgyMDksMTgyMTQsMTgyMzQsMTgyNTAsMTgyNjgsMTgyOTIsMTgzMDgsMTgzMTksMTgzNDMsMTgzNzksMTgzOTcsMTg0MTMsMTg1MDQsMTg1NDcsMTg1NTMsMTg1ODQsMTg2MDMsMTE0LDExNCw1OSwxLDg2NTcsOTcsMTE0LDU5LDEsMTA1OTUsNCwyLDk5LDExNCwxODIyMCwxODIzMCwxMTcsMTE2LDEwMSw1LDI1MCwxLDU5LDE4MjI4LDEsMjUwLDExNCw1OSwxLDg1OTMsMTE0LDQsMiw5OSwxMDEsMTgyNDEsMTgyNDUsMTIxLDU5LDEsMTExOCwxMTgsMTAxLDU5LDEsMzY1LDQsMiwxMDUsMTIxLDE4MjU2LDE4MjY1LDExNCw5OSw1LDI1MSwxLDU5LDE4MjYzLDEsMjUxLDU5LDEsMTA5MSw0LDMsOTcsOTgsMTA0LDE4Mjc2LDE4MjgxLDE4Mjg3LDExNCwxMTQsNTksMSw4NjQ1LDEwOCw5Nyw5OSw1OSwxLDM2OSw5NywxMTQsNTksMSwxMDYwNiw0LDIsMTA1LDExNCwxODI5OCwxODMwNCwxMTUsMTA0LDExNiw1OSwxLDEwNjIyLDU5LDMsNTUzNDksNTY2MjYsMTE0LDk3LDExOCwxMDEsNSwyNDksMSw1OSwxODMxNywxLDI0OSw0LDIsOTcsOTgsMTgzMjUsMTgzMzgsMTE0LDQsMiwxMDgsMTE0LDE4MzMyLDE4MzM1LDU5LDEsODYzOSw1OSwxLDg2MzgsMTA4LDEwNyw1OSwxLDk2MDAsNCwyLDk5LDExNiwxODM0OSwxODM3NCw0LDIsMTExLDExNCwxODM1NSwxODM2OSwxMTQsMTEwLDQsMiw1OSwxMDEsMTgzNjMsMTgzNjUsMSw4OTg4LDExNCw1OSwxLDg5ODgsMTExLDExMiw1OSwxLDg5NzUsMTE0LDEwNSw1OSwxLDk3MjAsNCwyLDk3LDEwOCwxODM4NSwxODM5MCw5OSwxMTQsNTksMSwzNjMsNSwxNjgsMSw1OSwxODM5NSwxLDE2OCw0LDIsMTAzLDExMiwxODQwMywxODQwOCwxMTEsMTEwLDU5LDEsMzcxLDEwMiw1OSwzLDU1MzQ5LDU2Njc4LDQsNiw5NywxMDAsMTA0LDEwOCwxMTUsMTE3LDE4NDI3LDE4NDM0LDE4NDQ1LDE4NDcwLDE4NDc1LDE4NDk0LDExNCwxMTQsMTExLDExOSw1OSwxLDg1OTMsMTExLDExOSwxMTAsOTcsMTE0LDExNCwxMTEsMTE5LDU5LDEsODU5Nyw5NywxMTQsMTEyLDExMSwxMTEsMTEwLDQsMiwxMDgsMTE0LDE4NDU3LDE4NDYzLDEwMSwxMDIsMTE2LDU5LDEsODYzOSwxMDUsMTAzLDEwNCwxMTYsNTksMSw4NjM4LDExNywxMTUsNTksMSw4ODQ2LDEwNSw0LDMsNTksMTA0LDEwOCwxODQ4NCwxODQ4NiwxODQ4OSwxLDk2NSw1OSwxLDk3OCwxMTEsMTEwLDU5LDEsOTY1LDExMiw5NywxMTQsMTE0LDExMSwxMTksMTE1LDU5LDEsODY0OCw0LDMsOTksMTA1LDExNiwxODUxMiwxODUzNywxODU0Miw0LDIsMTExLDExNCwxODUxOCwxODUzMiwxMTQsMTEwLDQsMiw1OSwxMDEsMTg1MjYsMTg1MjgsMSw4OTg5LDExNCw1OSwxLDg5ODksMTExLDExMiw1OSwxLDg5NzQsMTEwLDEwMyw1OSwxLDM2NywxMTQsMTA1LDU5LDEsOTcyMSw5OSwxMTQsNTksMyw1NTM0OSw1NjUyMiw0LDMsMTAwLDEwNSwxMTQsMTg1NjEsMTg1NjYsMTg1NzIsMTExLDExNiw1OSwxLDg5NDQsMTA4LDEwMCwxMDEsNTksMSwzNjEsMTA1LDQsMiw1OSwxMDIsMTg1NzksMTg1ODEsMSw5NjUzLDU5LDEsOTY1Miw0LDIsOTcsMTA5LDE4NTkwLDE4NTk1LDExNCwxMTQsNTksMSw4NjQ4LDEwOCw1LDI1MiwxLDU5LDE4NjAxLDEsMjUyLDk3LDExMCwxMDMsMTA4LDEwMSw1OSwxLDEwNjYzLDQsMTUsNjUsNjYsNjgsOTcsOTksMTAwLDEwMSwxMDIsMTA4LDExMCwxMTEsMTEyLDExNCwxMTUsMTIyLDE4NjQzLDE4NjQ4LDE4NjYxLDE4NjY3LDE4ODQ3LDE4ODUxLDE4ODU3LDE4OTA0LDE4OTA5LDE4OTE1LDE4OTMxLDE4OTM3LDE4OTQzLDE4OTQ5LDE4OTk2LDExNCwxMTQsNTksMSw4NjYxLDk3LDExNCw0LDIsNTksMTE4LDE4NjU2LDE4NjU4LDEsMTA5ODQsNTksMSwxMDk4NSw5NywxMTUsMTA0LDU5LDEsODg3Miw0LDIsMTEwLDExNCwxODY3MywxODY3OSwxMDMsMTE0LDExNiw1OSwxLDEwNjUyLDQsNywxMDEsMTA3LDExMCwxMTIsMTE0LDExNSwxMTYsMTg2OTUsMTg3MDQsMTg3MTEsMTg3MjAsMTg3NDIsMTg3NTQsMTg4MTAsMTEyLDExNSwxMDUsMTA4LDExMSwxMTAsNTksMSwxMDEzLDk3LDExMiwxMTIsOTcsNTksMSwxMDA4LDExMSwxMTYsMTA0LDEwNSwxMTAsMTAzLDU5LDEsODcwOSw0LDMsMTA0LDEwNSwxMTQsMTg3MjgsMTg3MzIsMTg3MzUsMTA1LDU5LDEsOTgxLDU5LDEsOTgyLDExMSwxMTIsMTE2LDExMSw1OSwxLDg3MzMsNCwyLDU5LDEwNCwxODc0OCwxODc1MCwxLDg1OTcsMTExLDU5LDEsMTAwOSw0LDIsMTA1LDExNywxODc2MCwxODc2NiwxMDMsMTA5LDk3LDU5LDEsOTYyLDQsMiw5OCwxMTIsMTg3NzIsMTg3OTEsMTE1LDEwMSwxMTYsMTEwLDEwMSwxMTMsNCwyLDU5LDExMywxODc4NCwxODc4NywzLDg4NDIsNjUwMjQsNTksMywxMDk1NSw2NTAyNCwxMTUsMTAxLDExNiwxMTAsMTAxLDExMyw0LDIsNTksMTEzLDE4ODAzLDE4ODA2LDMsODg0Myw2NTAyNCw1OSwzLDEwOTU2LDY1MDI0LDQsMiwxMDQsMTE0LDE4ODE2LDE4ODIyLDEwMSwxMTYsOTcsNTksMSw5NzcsMTA1LDk3LDExMCwxMDMsMTA4LDEwMSw0LDIsMTA4LDExNCwxODgzNCwxODg0MCwxMDEsMTAyLDExNiw1OSwxLDg4ODIsMTA1LDEwMywxMDQsMTE2LDU5LDEsODg4MywxMjEsNTksMSwxMDc0LDk3LDExNSwxMDQsNTksMSw4ODY2LDQsMywxMDEsMTA4LDExNCwxODg2NSwxODg4NCwxODg5MCw0LDMsNTksOTgsMTAxLDE4ODczLDE4ODc1LDE4ODgwLDEsODc0NCw5NywxMTQsNTksMSw4ODkxLDExMyw1OSwxLDg3OTQsMTA4LDEwNSwxMTIsNTksMSw4OTQyLDQsMiw5OCwxMTYsMTg4OTYsMTg5MDEsOTcsMTE0LDU5LDEsMTI0LDU5LDEsMTI0LDExNCw1OSwzLDU1MzQ5LDU2NjI3LDExNiwxMTQsMTA1LDU5LDEsODg4MiwxMTUsMTE3LDQsMiw5OCwxMTIsMTg5MjMsMTg5MjcsNTksMyw4ODM0LDg0MDIsNTksMyw4ODM1LDg0MDIsMTEyLDEwMiw1OSwzLDU1MzQ5LDU2Njc5LDExNCwxMTEsMTEyLDU5LDEsODczMywxMTYsMTE0LDEwNSw1OSwxLDg4ODMsNCwyLDk5LDExNywxODk1NSwxODk2MCwxMTQsNTksMyw1NTM0OSw1NjUyMyw0LDIsOTgsMTEyLDE4OTY2LDE4OTgxLDExMCw0LDIsNjksMTAxLDE4OTczLDE4OTc3LDU5LDMsMTA5NTUsNjUwMjQsNTksMyw4ODQyLDY1MDI0LDExMCw0LDIsNjksMTAxLDE4OTg4LDE4OTkyLDU5LDMsMTA5NTYsNjUwMjQsNTksMyw4ODQzLDY1MDI0LDEwNSwxMDMsMTIyLDk3LDEwMyw1OSwxLDEwNjUwLDQsNyw5OSwxMDEsMTAyLDExMSwxMTIsMTE0LDExNSwxOTAyMCwxOTAyNiwxOTA2MSwxOTA2NiwxOTA3MiwxOTA3NSwxOTA4OSwxMDUsMTE0LDk5LDU5LDEsMzczLDQsMiwxMDAsMTA1LDE5MDMyLDE5MDU1LDQsMiw5OCwxMDMsMTkwMzgsMTkwNDMsOTcsMTE0LDU5LDEsMTA4NDcsMTAxLDQsMiw1OSwxMTMsMTkwNTAsMTkwNTIsMSw4NzQzLDU5LDEsODc5MywxMDEsMTE0LDExMiw1OSwxLDg0NzIsMTE0LDU5LDMsNTUzNDksNTY2MjgsMTEyLDEwMiw1OSwzLDU1MzQ5LDU2NjgwLDU5LDEsODQ3Miw0LDIsNTksMTAxLDE5MDgxLDE5MDgzLDEsODc2OCw5NywxMTYsMTA0LDU5LDEsODc2OCw5OSwxMTQsNTksMyw1NTM0OSw1NjUyNCw0LDE0LDk5LDEwMCwxMDIsMTA0LDEwNSwxMDgsMTA5LDExMCwxMTEsMTE0LDExNSwxMTcsMTE4LDExOSwxOTEyNSwxOTE0NiwxOTE1MiwxOTE1NywxOTE3MywxOTE3NiwxOTE5MiwxOTE5NywxOTIwMiwxOTIzNiwxOTI1MiwxOTI2OSwxOTI4NiwxOTI5MSw0LDMsOTcsMTA1LDExNywxOTEzMywxOTEzNywxOTE0MiwxMTIsNTksMSw4ODk4LDExNCw5OSw1OSwxLDk3MTEsMTEyLDU5LDEsODg5OSwxMTYsMTE0LDEwNSw1OSwxLDk2NjEsMTE0LDU5LDMsNTUzNDksNTY2MjksNCwyLDY1LDk3LDE5MTYzLDE5MTY4LDExNCwxMTQsNTksMSwxMDIzNCwxMTQsMTE0LDU5LDEsMTAyMzEsNTksMSw5NTgsNCwyLDY1LDk3LDE5MTgyLDE5MTg3LDExNCwxMTQsNTksMSwxMDIzMiwxMTQsMTE0LDU5LDEsMTAyMjksOTcsMTEyLDU5LDEsMTAyMzYsMTA1LDExNSw1OSwxLDg5NTUsNCwzLDEwMCwxMTIsMTE2LDE5MjEwLDE5MjE1LDE5MjMwLDExMSwxMTYsNTksMSwxMDc1Miw0LDIsMTAyLDEwOCwxOTIyMSwxOTIyNSw1OSwzLDU1MzQ5LDU2NjgxLDExNywxMTUsNTksMSwxMDc1MywxMDUsMTA5LDEwMSw1OSwxLDEwNzU0LDQsMiw2NSw5NywxOTI0MiwxOTI0NywxMTQsMTE0LDU5LDEsMTAyMzMsMTE0LDExNCw1OSwxLDEwMjMwLDQsMiw5OSwxMTMsMTkyNTgsMTkyNjMsMTE0LDU5LDMsNTUzNDksNTY1MjUsOTksMTE3LDExMiw1OSwxLDEwNzU4LDQsMiwxMTIsMTE2LDE5Mjc1LDE5MjgxLDEwOCwxMTcsMTE1LDU5LDEsMTA3NTYsMTE0LDEwNSw1OSwxLDk2NTEsMTAxLDEwMSw1OSwxLDg4OTcsMTAxLDEwMCwxMDMsMTAxLDU5LDEsODg5Niw0LDgsOTcsOTksMTAxLDEwMiwxMDUsMTExLDExNSwxMTcsMTkzMTYsMTkzMzUsMTkzNDksMTkzNTcsMTkzNjIsMTkzNjcsMTkzNzMsMTkzNzksOTksNCwyLDExNywxMjEsMTkzMjMsMTkzMzIsMTE2LDEwMSw1LDI1MywxLDU5LDE5MzMwLDEsMjUzLDU5LDEsMTEwMyw0LDIsMTA1LDEyMSwxOTM0MSwxOTM0NiwxMTQsOTksNTksMSwzNzUsNTksMSwxMDk5LDExMCw1LDE2NSwxLDU5LDE5MzU1LDEsMTY1LDExNCw1OSwzLDU1MzQ5LDU2NjMwLDk5LDEyMSw1OSwxLDExMTEsMTEyLDEwMiw1OSwzLDU1MzQ5LDU2NjgyLDk5LDExNCw1OSwzLDU1MzQ5LDU2NTI2LDQsMiw5OSwxMDksMTkzODUsMTkzODksMTIxLDU5LDEsMTEwMiwxMDgsNSwyNTUsMSw1OSwxOTM5NSwxLDI1NSw0LDEwLDk3LDk5LDEwMCwxMDEsMTAyLDEwNCwxMDUsMTExLDExNSwxMTksMTk0MTksMTk0MjYsMTk0NDEsMTk0NDYsMTk0NjIsMTk0NjcsMTk0NzIsMTk0ODAsMTk0ODYsMTk0OTIsOTksMTE3LDExNiwxMDEsNTksMSwzNzgsNCwyLDk3LDEyMSwxOTQzMiwxOTQzOCwxMTQsMTExLDExMCw1OSwxLDM4Miw1OSwxLDEwNzksMTExLDExNiw1OSwxLDM4MCw0LDIsMTAxLDExNiwxOTQ1MiwxOTQ1OCwxMTYsMTE0LDEwMiw1OSwxLDg0ODgsOTcsNTksMSw5NTAsMTE0LDU5LDMsNTUzNDksNTY2MzEsOTksMTIxLDU5LDEsMTA3OCwxMDMsMTE0LDk3LDExNCwxMTQsNTksMSw4NjY5LDExMiwxMDIsNTksMyw1NTM0OSw1NjY4Myw5OSwxMTQsNTksMyw1NTM0OSw1NjUyNyw0LDIsMTA2LDExMCwxOTQ5OCwxOTUwMSw1OSwxLDgyMDUsMTA2LDU5LDEsODIwNF0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZTUvbGliL3Rva2VuaXplci9uYW1lZF9lbnRpdHlfZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMTc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBVTklDT0RFID0gcmVxdWlyZSgnLi4vY29tbW9uL3VuaWNvZGUnKTtcblxuLy9BbGlhc2VzXG52YXIgJCA9IFVOSUNPREUuQ09ERV9QT0lOVFM7XG5cbi8vVXRpbHNcblxuLy9PUFRJTUlaQVRJT046IHRoZXNlIHV0aWxpdHkgZnVuY3Rpb25zIHNob3VsZCBub3QgYmUgbW92ZWQgb3V0IG9mIHRoaXMgbW9kdWxlLiBWOCBDcmFua3NoYWZ0IHdpbGwgbm90IGlubGluZVxuLy90aGlzIGZ1bmN0aW9ucyBpZiB0aGV5IHdpbGwgYmUgc2l0dWF0ZWQgaW4gYW5vdGhlciBtb2R1bGUgZHVlIHRvIGNvbnRleHQgc3dpdGNoLlxuLy9BbHdheXMgcGVyZm9ybSBpbmxpbmluZyBjaGVjayBiZWZvcmUgbW9kaWZ5aW5nIHRoaXMgZnVuY3Rpb25zICgnbm9kZSAtLXRyYWNlLWlubGluaW5nJykuXG5mdW5jdGlvbiBpc1N1cnJvZ2F0ZVBhaXIoY3AxLCBjcDIpIHtcbiAgICByZXR1cm4gY3AxID49IDB4RDgwMCAmJiBjcDEgPD0gMHhEQkZGICYmIGNwMiA+PSAweERDMDAgJiYgY3AyIDw9IDB4REZGRjtcbn1cblxuZnVuY3Rpb24gZ2V0U3Vycm9nYXRlUGFpckNvZGVQb2ludChjcDEsIGNwMikge1xuICAgIHJldHVybiAoY3AxIC0gMHhEODAwKSAqIDB4NDAwICsgMHgyNDAwICsgY3AyO1xufVxuXG5cbi8vQ29uc3RcbnZhciBERUZBVUxUX0JVRkZFUl9XQVRFUkxJTkUgPSAxIDw8IDE2O1xuXG5cbi8vUHJlcHJvY2Vzc29yXG4vL05PVEU6IEhUTUwgaW5wdXQgcHJlcHJvY2Vzc2luZ1xuLy8oc2VlOiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtKVxudmFyIFByZXByb2Nlc3NvciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaHRtbCA9IG51bGw7XG5cbiAgICB0aGlzLnBvcyA9IC0xO1xuICAgIHRoaXMubGFzdEdhcFBvcyA9IC0xO1xuICAgIHRoaXMubGFzdENoYXJQb3MgPSAtMTtcbiAgICB0aGlzLmRyb3BwZWRCdWZmZXJTaXplID0gMDtcblxuICAgIHRoaXMuZ2FwU3RhY2sgPSBbXTtcblxuICAgIHRoaXMuc2tpcE5leHROZXdMaW5lID0gZmFsc2U7XG5cbiAgICB0aGlzLmxhc3RDaHVua1dyaXR0ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmVuZE9mQ2h1bmtIaXQgPSBmYWxzZTtcbiAgICB0aGlzLmJ1ZmZlcldhdGVybGluZSA9IERFRkFVTFRfQlVGRkVSX1dBVEVSTElORTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcmVwcm9jZXNzb3IucHJvdG90eXBlLCAnc291cmNlUG9zJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcm9wcGVkQnVmZmVyU2l6ZSArIHRoaXMucG9zO1xuICAgIH1cbn0pO1xuXG5QcmVwcm9jZXNzb3IucHJvdG90eXBlLmRyb3BQYXJzZWRDaHVuayA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wb3MgPiB0aGlzLmJ1ZmZlcldhdGVybGluZSkge1xuICAgICAgICB0aGlzLmxhc3RDaGFyUG9zIC09IHRoaXMucG9zO1xuICAgICAgICB0aGlzLmRyb3BwZWRCdWZmZXJTaXplICs9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLmh0bWwgPSB0aGlzLmh0bWwuc3Vic3RyaW5nKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmxhc3RHYXBQb3MgPSAtMTtcbiAgICAgICAgdGhpcy5nYXBTdGFjayA9IFtdO1xuICAgIH1cbn07XG5cblByZXByb2Nlc3Nvci5wcm90b3R5cGUuX2FkZEdhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmdhcFN0YWNrLnB1c2godGhpcy5sYXN0R2FwUG9zKTtcbiAgICB0aGlzLmxhc3RHYXBQb3MgPSB0aGlzLnBvcztcbn07XG5cblByZXByb2Nlc3Nvci5wcm90b3R5cGUuX3Byb2Nlc3NIaWdoUmFuZ2VDb2RlUG9pbnQgPSBmdW5jdGlvbiAoY3ApIHtcbiAgICAvL05PVEU6IHRyeSB0byBwZWVrIGEgc3Vycm9nYXRlIHBhaXJcbiAgICBpZiAodGhpcy5wb3MgIT09IHRoaXMubGFzdENoYXJQb3MpIHtcbiAgICAgICAgdmFyIG5leHRDcCA9IHRoaXMuaHRtbC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG5cbiAgICAgICAgaWYgKGlzU3Vycm9nYXRlUGFpcihjcCwgbmV4dENwKSkge1xuICAgICAgICAgICAgLy9OT1RFOiB3ZSBoYXZlIGEgc3Vycm9nYXRlIHBhaXIuIFBlZWsgcGFpciBjaGFyYWN0ZXIgYW5kIHJlY2FsY3VsYXRlIGNvZGUgcG9pbnQuXG4gICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICAgICAgY3AgPSBnZXRTdXJyb2dhdGVQYWlyQ29kZVBvaW50KGNwLCBuZXh0Q3ApO1xuXG4gICAgICAgICAgICAvL05PVEU6IGFkZCBnYXAgdGhhdCBzaG91bGQgYmUgYXZvaWRlZCBkdXJpbmcgcmV0cmVhdFxuICAgICAgICAgICAgdGhpcy5fYWRkR2FwKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOT1RFOiB3ZSd2ZSBoaXQgdGhlIGVuZCBvZiBjaHVuaywgc3RvcCBwcm9jZXNzaW5nIGF0IHRoaXMgcG9pbnRcbiAgICBlbHNlIGlmICghdGhpcy5sYXN0Q2h1bmtXcml0dGVuKSB7XG4gICAgICAgIHRoaXMuZW5kT2ZDaHVua0hpdCA9IHRydWU7XG4gICAgICAgIHJldHVybiAkLkVPRjtcbiAgICB9XG5cbiAgICByZXR1cm4gY3A7XG59O1xuXG5QcmVwcm9jZXNzb3IucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBpc0xhc3RDaHVuaykge1xuICAgIGlmICh0aGlzLmh0bWwpXG4gICAgICAgIHRoaXMuaHRtbCArPSBjaHVuaztcblxuICAgIGVsc2VcbiAgICAgICAgdGhpcy5odG1sID0gY2h1bms7XG5cbiAgICB0aGlzLmxhc3RDaGFyUG9zID0gdGhpcy5odG1sLmxlbmd0aCAtIDE7XG4gICAgdGhpcy5lbmRPZkNodW5rSGl0ID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0Q2h1bmtXcml0dGVuID0gaXNMYXN0Q2h1bms7XG59O1xuXG5QcmVwcm9jZXNzb3IucHJvdG90eXBlLmluc2VydEh0bWxBdEN1cnJlbnRQb3MgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLmh0bWwgPSB0aGlzLmh0bWwuc3Vic3RyaW5nKDAsIHRoaXMucG9zICsgMSkgK1xuICAgICAgICAgICAgICAgIGNodW5rICtcbiAgICAgICAgICAgICAgICB0aGlzLmh0bWwuc3Vic3RyaW5nKHRoaXMucG9zICsgMSwgdGhpcy5odG1sLmxlbmd0aCk7XG5cbiAgICB0aGlzLmxhc3RDaGFyUG9zID0gdGhpcy5odG1sLmxlbmd0aCAtIDE7XG4gICAgdGhpcy5lbmRPZkNodW5rSGl0ID0gZmFsc2U7XG59O1xuXG5cblByZXByb2Nlc3Nvci5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBvcysrO1xuXG4gICAgaWYgKHRoaXMucG9zID4gdGhpcy5sYXN0Q2hhclBvcykge1xuICAgICAgICBpZiAoIXRoaXMubGFzdENodW5rV3JpdHRlbilcbiAgICAgICAgICAgIHRoaXMuZW5kT2ZDaHVua0hpdCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuICQuRU9GO1xuICAgIH1cblxuICAgIHZhciBjcCA9IHRoaXMuaHRtbC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcblxuICAgIC8vTk9URTogYW55IFUrMDAwQSBMSU5FIEZFRUQgKExGKSBjaGFyYWN0ZXJzIHRoYXQgaW1tZWRpYXRlbHkgZm9sbG93IGEgVSswMDBEIENBUlJJQUdFIFJFVFVSTiAoQ1IpIGNoYXJhY3RlclxuICAgIC8vbXVzdCBiZSBpZ25vcmVkLlxuICAgIGlmICh0aGlzLnNraXBOZXh0TmV3TGluZSAmJiBjcCA9PT0gJC5MSU5FX0ZFRUQpIHtcbiAgICAgICAgdGhpcy5za2lwTmV4dE5ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWRkR2FwKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkdmFuY2UoKTtcbiAgICB9XG5cbiAgICAvL05PVEU6IGFsbCBVKzAwMEQgQ0FSUklBR0UgUkVUVVJOIChDUikgY2hhcmFjdGVycyBtdXN0IGJlIGNvbnZlcnRlZCB0byBVKzAwMEEgTElORSBGRUVEIChMRikgY2hhcmFjdGVyc1xuICAgIGlmIChjcCA9PT0gJC5DQVJSSUFHRV9SRVRVUk4pIHtcbiAgICAgICAgdGhpcy5za2lwTmV4dE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gJC5MSU5FX0ZFRUQ7XG4gICAgfVxuXG4gICAgdGhpcy5za2lwTmV4dE5ld0xpbmUgPSBmYWxzZTtcblxuICAgIC8vT1BUSU1JWkFUSU9OOiBmaXJzdCBwZXJmb3JtIGNoZWNrIGlmIHRoZSBjb2RlIHBvaW50IGluIHRoZSBhbGxvd2VkIHJhbmdlIHRoYXQgY292ZXJzIG1vc3QgY29tbW9uXG4gICAgLy9IVE1MIGlucHV0IChlLmcuIEFTQ0lJIGNvZGVzKSB0byBhdm9pZCBwZXJmb3JtYW5jZS1jb3N0IG9wZXJhdGlvbnMgZm9yIGhpZ2gtcmFuZ2UgY29kZSBwb2ludHMuXG4gICAgcmV0dXJuIGNwID49IDB4RDgwMCA/IHRoaXMuX3Byb2Nlc3NIaWdoUmFuZ2VDb2RlUG9pbnQoY3ApIDogY3A7XG59O1xuXG5QcmVwcm9jZXNzb3IucHJvdG90eXBlLnJldHJlYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucG9zID09PSB0aGlzLmxhc3RHYXBQb3MpIHtcbiAgICAgICAgdGhpcy5sYXN0R2FwUG9zID0gdGhpcy5nYXBTdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5wb3MtLTtcbiAgICB9XG5cbiAgICB0aGlzLnBvcy0tO1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlNS9saWIvdG9rZW5pemVyL3ByZXByb2Nlc3Nvci5qc1xuLy8gbW9kdWxlIGlkID0gMTc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBkb2N0eXBlID0gcmVxdWlyZSgnLi4vY29tbW9uL2RvY3R5cGUnKSxcbiAgICBET0NVTUVOVF9NT0RFID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWwnKS5ET0NVTUVOVF9NT0RFO1xuXG5cbi8vQ29udmVyc2lvbiB0YWJsZXMgZm9yIERPTSBMZXZlbDEgc3RydWN0dXJlIGVtdWxhdGlvblxudmFyIG5vZGVUeXBlcyA9IHtcbiAgICBlbGVtZW50OiAxLFxuICAgIHRleHQ6IDMsXG4gICAgY2RhdGE6IDQsXG4gICAgY29tbWVudDogOFxufTtcblxudmFyIG5vZGVQcm9wZXJ0eVNob3J0aGFuZHMgPSB7XG4gICAgdGFnTmFtZTogJ25hbWUnLFxuICAgIGNoaWxkTm9kZXM6ICdjaGlsZHJlbicsXG4gICAgcGFyZW50Tm9kZTogJ3BhcmVudCcsXG4gICAgcHJldmlvdXNTaWJsaW5nOiAncHJldicsXG4gICAgbmV4dFNpYmxpbmc6ICduZXh0JyxcbiAgICBub2RlVmFsdWU6ICdkYXRhJ1xufTtcblxuLy9Ob2RlXG52YXIgTm9kZSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IHByb3BzW2tleV07XG4gICAgfVxufTtcblxuTm9kZS5wcm90b3R5cGUgPSB7XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuWzBdIHx8IG51bGw7XG4gICAgfSxcblxuICAgIGdldCBsYXN0Q2hpbGQoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gICAgfSxcblxuICAgIGdldCBub2RlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVUeXBlc1t0aGlzLnR5cGVdIHx8IG5vZGVUeXBlcy5lbGVtZW50O1xuICAgIH1cbn07XG5cbk9iamVjdC5rZXlzKG5vZGVQcm9wZXJ0eVNob3J0aGFuZHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBzaG9ydGhhbmQgPSBub2RlUHJvcGVydHlTaG9ydGhhbmRzW2tleV07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsIGtleSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3Nob3J0aGFuZF0gfHwgbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzW3Nob3J0aGFuZF0gPSB2YWw7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuXG4vL05vZGUgY29uc3RydWN0aW9uXG5leHBvcnRzLmNyZWF0ZURvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgTm9kZSh7XG4gICAgICAgIHR5cGU6ICdyb290JyxcbiAgICAgICAgbmFtZTogJ3Jvb3QnLFxuICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgIHByZXY6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgJ3gtbW9kZSc6IERPQ1VNRU5UX01PREUuTk9fUVVJUktTXG4gICAgfSk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHtcbiAgICAgICAgdHlwZTogJ3Jvb3QnLFxuICAgICAgICBuYW1lOiAncm9vdCcsXG4gICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgcHJldjogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZXNwYWNlVVJJLCBhdHRycykge1xuICAgIHZhciBhdHRyaWJzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgYXR0cmlic05hbWVzcGFjZSA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIGF0dHJpYnNQcmVmaXggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXR0ck5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuXG4gICAgICAgIGF0dHJpYnNbYXR0ck5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gICAgICAgIGF0dHJpYnNOYW1lc3BhY2VbYXR0ck5hbWVdID0gYXR0cnNbaV0ubmFtZXNwYWNlO1xuICAgICAgICBhdHRyaWJzUHJlZml4W2F0dHJOYW1lXSA9IGF0dHJzW2ldLnByZWZpeDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE5vZGUoe1xuICAgICAgICB0eXBlOiB0YWdOYW1lID09PSAnc2NyaXB0JyB8fCB0YWdOYW1lID09PSAnc3R5bGUnID8gdGFnTmFtZSA6ICd0YWcnLFxuICAgICAgICBuYW1lOiB0YWdOYW1lLFxuICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZVVSSSxcbiAgICAgICAgYXR0cmliczogYXR0cmlicyxcbiAgICAgICAgJ3gtYXR0cmlic05hbWVzcGFjZSc6IGF0dHJpYnNOYW1lc3BhY2UsXG4gICAgICAgICd4LWF0dHJpYnNQcmVmaXgnOiBhdHRyaWJzUHJlZml4LFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgcHJldjogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgIH0pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVDb21tZW50Tm9kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHtcbiAgICAgICAgdHlwZTogJ2NvbW1lbnQnLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgIHByZXY6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICB9KTtcbn07XG5cbnZhciBjcmVhdGVUZXh0Tm9kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgTm9kZSh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgZGF0YTogdmFsdWUsXG4gICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgcHJldjogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgIH0pO1xufTtcblxuXG4vL1RyZWUgbXV0YXRpb25cbnZhciBhcHBlbmRDaGlsZCA9IGV4cG9ydHMuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAocGFyZW50Tm9kZSwgbmV3Tm9kZSkge1xuICAgIHZhciBwcmV2ID0gcGFyZW50Tm9kZS5jaGlsZHJlbltwYXJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKHByZXYpIHtcbiAgICAgICAgcHJldi5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgbmV3Tm9kZS5wcmV2ID0gcHJldjtcbiAgICB9XG5cbiAgICBwYXJlbnROb2RlLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgbmV3Tm9kZS5wYXJlbnQgPSBwYXJlbnROb2RlO1xufTtcblxudmFyIGluc2VydEJlZm9yZSA9IGV4cG9ydHMuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICB2YXIgaW5zZXJ0aW9uSWR4ID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5pbmRleE9mKHJlZmVyZW5jZU5vZGUpLFxuICAgICAgICBwcmV2ID0gcmVmZXJlbmNlTm9kZS5wcmV2O1xuXG4gICAgaWYgKHByZXYpIHtcbiAgICAgICAgcHJldi5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgbmV3Tm9kZS5wcmV2ID0gcHJldjtcbiAgICB9XG5cbiAgICByZWZlcmVuY2VOb2RlLnByZXYgPSBuZXdOb2RlO1xuICAgIG5ld05vZGUubmV4dCA9IHJlZmVyZW5jZU5vZGU7XG5cbiAgICBwYXJlbnROb2RlLmNoaWxkcmVuLnNwbGljZShpbnNlcnRpb25JZHgsIDAsIG5ld05vZGUpO1xuICAgIG5ld05vZGUucGFyZW50ID0gcGFyZW50Tm9kZTtcbn07XG5cbmV4cG9ydHMuc2V0VGVtcGxhdGVDb250ZW50ID0gZnVuY3Rpb24gKHRlbXBsYXRlRWxlbWVudCwgY29udGVudEVsZW1lbnQpIHtcbiAgICBhcHBlbmRDaGlsZCh0ZW1wbGF0ZUVsZW1lbnQsIGNvbnRlbnRFbGVtZW50KTtcbn07XG5cbmV4cG9ydHMuZ2V0VGVtcGxhdGVDb250ZW50ID0gZnVuY3Rpb24gKHRlbXBsYXRlRWxlbWVudCkge1xuICAgIHJldHVybiB0ZW1wbGF0ZUVsZW1lbnQuY2hpbGRyZW5bMF07XG59O1xuXG5leHBvcnRzLnNldERvY3VtZW50VHlwZSA9IGZ1bmN0aW9uIChkb2N1bWVudCwgbmFtZSwgcHVibGljSWQsIHN5c3RlbUlkKSB7XG4gICAgdmFyIGRhdGEgPSBkb2N0eXBlLnNlcmlhbGl6ZUNvbnRlbnQobmFtZSwgcHVibGljSWQsIHN5c3RlbUlkKSxcbiAgICAgICAgZG9jdHlwZU5vZGUgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2N1bWVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZG9jdW1lbnQuY2hpbGRyZW5baV0udHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgZG9jdW1lbnQuY2hpbGRyZW5baV0ubmFtZSA9PT0gJyFkb2N0eXBlJykge1xuICAgICAgICAgICAgZG9jdHlwZU5vZGUgPSBkb2N1bWVudC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRvY3R5cGVOb2RlKSB7XG4gICAgICAgIGRvY3R5cGVOb2RlLmRhdGEgPSBkYXRhO1xuICAgICAgICBkb2N0eXBlTm9kZVsneC1uYW1lJ10gPSBuYW1lO1xuICAgICAgICBkb2N0eXBlTm9kZVsneC1wdWJsaWNJZCddID0gcHVibGljSWQ7XG4gICAgICAgIGRvY3R5cGVOb2RlWyd4LXN5c3RlbUlkJ10gPSBzeXN0ZW1JZDtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgICAgYXBwZW5kQ2hpbGQoZG9jdW1lbnQsIG5ldyBOb2RlKHtcbiAgICAgICAgICAgIHR5cGU6ICdkaXJlY3RpdmUnLFxuICAgICAgICAgICAgbmFtZTogJyFkb2N0eXBlJyxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAneC1uYW1lJzogbmFtZSxcbiAgICAgICAgICAgICd4LXB1YmxpY0lkJzogcHVibGljSWQsXG4gICAgICAgICAgICAneC1zeXN0ZW1JZCc6IHN5c3RlbUlkXG4gICAgICAgIH0pKTtcbiAgICB9XG5cbn07XG5cbmV4cG9ydHMuc2V0RG9jdW1lbnRNb2RlID0gZnVuY3Rpb24gKGRvY3VtZW50LCBtb2RlKSB7XG4gICAgZG9jdW1lbnRbJ3gtbW9kZSddID0gbW9kZTtcbn07XG5cbmV4cG9ydHMuZ2V0RG9jdW1lbnRNb2RlID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50Wyd4LW1vZGUnXTtcbn07XG5cbmV4cG9ydHMuZGV0YWNoTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgIHZhciBpZHggPSBub2RlLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKG5vZGUpLFxuICAgICAgICAgICAgcHJldiA9IG5vZGUucHJldixcbiAgICAgICAgICAgIG5leHQgPSBub2RlLm5leHQ7XG5cbiAgICAgICAgbm9kZS5wcmV2ID0gbnVsbDtcbiAgICAgICAgbm9kZS5uZXh0ID0gbnVsbDtcblxuICAgICAgICBpZiAocHJldilcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG5cbiAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuXG4gICAgICAgIG5vZGUucGFyZW50LmNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xuICAgICAgICBub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxufTtcblxuZXhwb3J0cy5pbnNlcnRUZXh0ID0gZnVuY3Rpb24gKHBhcmVudE5vZGUsIHRleHQpIHtcbiAgICB2YXIgbGFzdENoaWxkID0gcGFyZW50Tm9kZS5jaGlsZHJlbltwYXJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQudHlwZSA9PT0gJ3RleHQnKVxuICAgICAgICBsYXN0Q2hpbGQuZGF0YSArPSB0ZXh0O1xuICAgIGVsc2VcbiAgICAgICAgYXBwZW5kQ2hpbGQocGFyZW50Tm9kZSwgY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xufTtcblxuZXhwb3J0cy5pbnNlcnRUZXh0QmVmb3JlID0gZnVuY3Rpb24gKHBhcmVudE5vZGUsIHRleHQsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICB2YXIgcHJldk5vZGUgPSBwYXJlbnROb2RlLmNoaWxkcmVuW3BhcmVudE5vZGUuY2hpbGRyZW4uaW5kZXhPZihyZWZlcmVuY2VOb2RlKSAtIDFdO1xuXG4gICAgaWYgKHByZXZOb2RlICYmIHByZXZOb2RlLnR5cGUgPT09ICd0ZXh0JylcbiAgICAgICAgcHJldk5vZGUuZGF0YSArPSB0ZXh0O1xuICAgIGVsc2VcbiAgICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudE5vZGUsIGNyZWF0ZVRleHROb2RlKHRleHQpLCByZWZlcmVuY2VOb2RlKTtcbn07XG5cbmV4cG9ydHMuYWRvcHRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHJlY2lwaWVudCwgYXR0cnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhdHRyTmFtZSA9IGF0dHJzW2ldLm5hbWU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZWNpcGllbnQuYXR0cmlic1thdHRyTmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZWNpcGllbnQuYXR0cmlic1thdHRyTmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcbiAgICAgICAgICAgIHJlY2lwaWVudFsneC1hdHRyaWJzTmFtZXNwYWNlJ11bYXR0ck5hbWVdID0gYXR0cnNbaV0ubmFtZXNwYWNlO1xuICAgICAgICAgICAgcmVjaXBpZW50Wyd4LWF0dHJpYnNQcmVmaXgnXVthdHRyTmFtZV0gPSBhdHRyc1tpXS5wcmVmaXg7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8vVHJlZSB0cmF2ZXJzaW5nXG5leHBvcnRzLmdldEZpcnN0Q2hpbGQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlLmNoaWxkcmVuWzBdO1xufTtcblxuZXhwb3J0cy5nZXRDaGlsZE5vZGVzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5jaGlsZHJlbjtcbn07XG5cbmV4cG9ydHMuZ2V0UGFyZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUucGFyZW50O1xufTtcblxuZXhwb3J0cy5nZXRBdHRyTGlzdCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIGF0dHJMaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGVsZW1lbnQuYXR0cmlicykge1xuICAgICAgICBhdHRyTGlzdC5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogZWxlbWVudC5hdHRyaWJzW25hbWVdLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiBlbGVtZW50Wyd4LWF0dHJpYnNOYW1lc3BhY2UnXVtuYW1lXSxcbiAgICAgICAgICAgIHByZWZpeDogZWxlbWVudFsneC1hdHRyaWJzUHJlZml4J11bbmFtZV1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0dHJMaXN0O1xufTtcblxuXG4vL05vZGUgZGF0YVxuZXhwb3J0cy5nZXRUYWdOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5uYW1lO1xufTtcblxuZXhwb3J0cy5nZXROYW1lc3BhY2VVUkkgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50Lm5hbWVzcGFjZTtcbn07XG5cbmV4cG9ydHMuZ2V0VGV4dE5vZGVDb250ZW50ID0gZnVuY3Rpb24gKHRleHROb2RlKSB7XG4gICAgcmV0dXJuIHRleHROb2RlLmRhdGE7XG59O1xuXG5leHBvcnRzLmdldENvbW1lbnROb2RlQ29udGVudCA9IGZ1bmN0aW9uIChjb21tZW50Tm9kZSkge1xuICAgIHJldHVybiBjb21tZW50Tm9kZS5kYXRhO1xufTtcblxuZXhwb3J0cy5nZXREb2N1bWVudFR5cGVOb2RlTmFtZSA9IGZ1bmN0aW9uIChkb2N0eXBlTm9kZSkge1xuICAgIHJldHVybiBkb2N0eXBlTm9kZVsneC1uYW1lJ107XG59O1xuXG5leHBvcnRzLmdldERvY3VtZW50VHlwZU5vZGVQdWJsaWNJZCA9IGZ1bmN0aW9uIChkb2N0eXBlTm9kZSkge1xuICAgIHJldHVybiBkb2N0eXBlTm9kZVsneC1wdWJsaWNJZCddO1xufTtcblxuZXhwb3J0cy5nZXREb2N1bWVudFR5cGVOb2RlU3lzdGVtSWQgPSBmdW5jdGlvbiAoZG9jdHlwZU5vZGUpIHtcbiAgICByZXR1cm4gZG9jdHlwZU5vZGVbJ3gtc3lzdGVtSWQnXTtcbn07XG5cblxuLy9Ob2RlIHR5cGVzXG5leHBvcnRzLmlzVGV4dE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICd0ZXh0Jztcbn07XG5cbmV4cG9ydHMuaXNDb21tZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2NvbW1lbnQnO1xufTtcblxuZXhwb3J0cy5pc0RvY3VtZW50VHlwZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdkaXJlY3RpdmUnICYmIG5vZGUubmFtZSA9PT0gJyFkb2N0eXBlJztcbn07XG5cbmV4cG9ydHMuaXNFbGVtZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuICEhbm9kZS5hdHRyaWJzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZTUvbGliL3RyZWVfYWRhcHRlcnMvaHRtbHBhcnNlcjIuanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuL1N1YmplY3QnKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIEBjbGFzcyBBc3luY1N1YmplY3Q8VD5cbiAqL1xudmFyIEFzeW5jU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzeW5jU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3luY1N1YmplY3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNOZXh0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgfVxuICAgIEFzeW5jU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHRoaXMudGhyb3duRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc0NvbXBsZXRlZCAmJiB0aGlzLmhhc05leHQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuX3N1YnNjcmliZS5jYWxsKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgQXN5bmNTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuaGFzTmV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFzeW5jU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5oYXNOZXh0KSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmNvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNTdWJqZWN0O1xufShTdWJqZWN0XzEuU3ViamVjdCkpO1xuZXhwb3J0cy5Bc3luY1N1YmplY3QgPSBBc3luY1N1YmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3luY1N1YmplY3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvQXN5bmNTdWJqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBBbiBleGVjdXRpb24gY29udGV4dCBhbmQgYSBkYXRhIHN0cnVjdHVyZSB0byBvcmRlciB0YXNrcyBhbmQgc2NoZWR1bGUgdGhlaXJcbiAqIGV4ZWN1dGlvbi4gUHJvdmlkZXMgYSBub3Rpb24gb2YgKHBvdGVudGlhbGx5IHZpcnR1YWwpIHRpbWUsIHRocm91Z2ggdGhlXG4gKiBgbm93KClgIGdldHRlciBtZXRob2QuXG4gKlxuICogRWFjaCB1bml0IG9mIHdvcmsgaW4gYSBTY2hlZHVsZXIgaXMgY2FsbGVkIGFuIHtAbGluayBBY3Rpb259LlxuICpcbiAqIGBgYHRzXG4gKiBjbGFzcyBTY2hlZHVsZXIge1xuICogICBub3coKTogbnVtYmVyO1xuICogICBzY2hlZHVsZSh3b3JrLCBkZWxheT8sIHN0YXRlPyk6IFN1YnNjcmlwdGlvbjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBjbGFzcyBTY2hlZHVsZXJcbiAqL1xudmFyIFNjaGVkdWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2NoZWR1bGVyKFNjaGVkdWxlckFjdGlvbiwgbm93KSB7XG4gICAgICAgIGlmIChub3cgPT09IHZvaWQgMCkgeyBub3cgPSBTY2hlZHVsZXIubm93OyB9XG4gICAgICAgIHRoaXMuU2NoZWR1bGVyQWN0aW9uID0gU2NoZWR1bGVyQWN0aW9uO1xuICAgICAgICB0aGlzLm5vdyA9IG5vdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGEgZnVuY3Rpb24sIGB3b3JrYCwgZm9yIGV4ZWN1dGlvbi4gTWF5IGhhcHBlbiBhdCBzb21lIHBvaW50IGluXG4gICAgICogdGhlIGZ1dHVyZSwgYWNjb3JkaW5nIHRvIHRoZSBgZGVsYXlgIHBhcmFtZXRlciwgaWYgc3BlY2lmaWVkLiBNYXkgYmUgcGFzc2VkXG4gICAgICogc29tZSBjb250ZXh0IG9iamVjdCwgYHN0YXRlYCwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGB3b3JrYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBnaXZlbiBhcmd1bWVudHMgd2lsbCBiZSBwcm9jZXNzZWQgYW4gc3RvcmVkIGFzIGFuIEFjdGlvbiBvYmplY3QgaW4gYVxuICAgICAqIHF1ZXVlIG9mIGFjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0YXRlOiA/VCk6ID9TdWJzY3JpcHRpb259IHdvcmsgQSBmdW5jdGlvbiByZXByZXNlbnRpbmcgYVxuICAgICAqIHRhc2ssIG9yIHNvbWUgdW5pdCBvZiB3b3JrIHRvIGJlIGV4ZWN1dGVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheV0gVGltZSB0byB3YWl0IGJlZm9yZSBleGVjdXRpbmcgdGhlIHdvcmssIHdoZXJlIHRoZVxuICAgICAqIHRpbWUgdW5pdCBpcyBpbXBsaWNpdCBhbmQgZGVmaW5lZCBieSB0aGUgU2NoZWR1bGVyIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0ge1R9IFtzdGF0ZV0gU29tZSBjb250ZXh0dWFsIGRhdGEgdGhhdCB0aGUgYHdvcmtgIGZ1bmN0aW9uIHVzZXMgd2hlblxuICAgICAqIGNhbGxlZCBieSB0aGUgU2NoZWR1bGVyLlxuICAgICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn0gQSBzdWJzY3JpcHRpb24gaW4gb3JkZXIgdG8gYmUgYWJsZSB0byB1bnN1YnNjcmliZVxuICAgICAqIHRoZSBzY2hlZHVsZWQgd29yay5cbiAgICAgKi9cbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHdvcmssIGRlbGF5LCBzdGF0ZSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLlNjaGVkdWxlckFjdGlvbih0aGlzLCB3b3JrKS5zY2hlZHVsZShzdGF0ZSwgZGVsYXkpO1xuICAgIH07XG4gICAgU2NoZWR1bGVyLm5vdyA9IERhdGUubm93ID8gRGF0ZS5ub3cgOiBmdW5jdGlvbiAoKSB7IHJldHVybiArbmV3IERhdGUoKTsgfTtcbiAgICByZXR1cm4gU2NoZWR1bGVyO1xufSgpKTtcbmV4cG9ydHMuU2NoZWR1bGVyID0gU2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2NoZWR1bGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL1NjaGVkdWxlci5qc1xuLy8gbW9kdWxlIGlkID0gMTgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVmZXJfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvZGVmZXInKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmRlZmVyID0gZGVmZXJfMS5kZWZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2RlZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxODJcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBmcm9tUHJvbWlzZV8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuZnJvbVByb21pc2UgPSBmcm9tUHJvbWlzZV8xLmZyb21Qcm9taXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbVByb21pc2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvYWRkL29ic2VydmFibGUvZnJvbVByb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDE4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlTWFwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9tZXJnZU1hcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm1lcmdlTWFwID0gbWVyZ2VNYXBfMS5tZXJnZU1hcDtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5mbGF0TWFwID0gbWVyZ2VNYXBfMS5tZXJnZU1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlTWFwLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9tZXJnZU1hcC5qc1xuLy8gbW9kdWxlIGlkID0gMTg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIERlZmVyT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmVyT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZlck9ic2VydmFibGUob2JzZXJ2YWJsZUZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZUZhY3RvcnkgPSBvYnNlcnZhYmxlRmFjdG9yeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQsIG9uIHN1YnNjcmliZSwgY2FsbHMgYW4gT2JzZXJ2YWJsZSBmYWN0b3J5IHRvXG4gICAgICogbWFrZSBhbiBPYnNlcnZhYmxlIGZvciBlYWNoIG5ldyBPYnNlcnZlci5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5DcmVhdGVzIHRoZSBPYnNlcnZhYmxlIGxhemlseSwgdGhhdCBpcywgb25seSB3aGVuIGl0XG4gICAgICogaXMgc3Vic2NyaWJlZC5cbiAgICAgKiA8L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL2RlZmVyLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogYGRlZmVyYCBhbGxvd3MgeW91IHRvIGNyZWF0ZSB0aGUgT2JzZXJ2YWJsZSBvbmx5IHdoZW4gdGhlIE9ic2VydmVyXG4gICAgICogc3Vic2NyaWJlcywgYW5kIGNyZWF0ZSBhIGZyZXNoIE9ic2VydmFibGUgZm9yIGVhY2ggT2JzZXJ2ZXIuIEl0IHdhaXRzIHVudGlsXG4gICAgICogYW4gT2JzZXJ2ZXIgc3Vic2NyaWJlcyB0byBpdCwgYW5kIHRoZW4gaXQgZ2VuZXJhdGVzIGFuIE9ic2VydmFibGUsXG4gICAgICogdHlwaWNhbGx5IHdpdGggYW4gT2JzZXJ2YWJsZSBmYWN0b3J5IGZ1bmN0aW9uLiBJdCBkb2VzIHRoaXMgYWZyZXNoIGZvciBlYWNoXG4gICAgICogc3Vic2NyaWJlciwgc28gYWx0aG91Z2ggZWFjaCBzdWJzY3JpYmVyIG1heSB0aGluayBpdCBpcyBzdWJzY3JpYmluZyB0byB0aGVcbiAgICAgKiBzYW1lIE9ic2VydmFibGUsIGluIGZhY3QgZWFjaCBzdWJzY3JpYmVyIGdldHMgaXRzIG93biBpbmRpdmlkdWFsXG4gICAgICogT2JzZXJ2YWJsZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN1YnNjcmliZSB0byBlaXRoZXIgYW4gT2JzZXJ2YWJsZSBvZiBjbGlja3Mgb3IgYW4gT2JzZXJ2YWJsZSBvZiBpbnRlcnZhbCwgYXQgcmFuZG9tPC9jYXB0aW9uPlxuICAgICAqIHZhciBjbGlja3NPckludGVydmFsID0gUnguT2JzZXJ2YWJsZS5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICogICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAqICAgICByZXR1cm4gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgcmV0dXJuIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogY2xpY2tzT3JJbnRlcnZhbC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmcgYmVoYXZpb3I6XG4gICAgICogLy8gSWYgdGhlIHJlc3VsdCBvZiBNYXRoLnJhbmRvbSgpIGlzIGdyZWF0ZXIgdGhhbiAwLjUgaXQgd2lsbCBsaXN0ZW5cbiAgICAgKiAvLyBmb3IgY2xpY2tzIGFueXdoZXJlIG9uIHRoZSBcImRvY3VtZW50XCI7IHdoZW4gZG9jdW1lbnQgaXMgY2xpY2tlZCBpdFxuICAgICAqIC8vIHdpbGwgbG9nIGEgTW91c2VFdmVudCBvYmplY3QgdG8gdGhlIGNvbnNvbGUuIElmIHRoZSByZXN1bHQgaXMgbGVzc1xuICAgICAqIC8vIHRoYW4gMC41IGl0IHdpbGwgZW1pdCBhc2NlbmRpbmcgbnVtYmVycywgb25lIGV2ZXJ5IHNlY29uZCgxMDAwbXMpLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiBTdWJzY3JpYmFibGVPclByb21pc2V9IG9ic2VydmFibGVGYWN0b3J5IFRoZSBPYnNlcnZhYmxlXG4gICAgICogZmFjdG9yeSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggT2JzZXJ2ZXIgdGhhdCBzdWJzY3JpYmVzIHRvIHRoZSBvdXRwdXRcbiAgICAgKiBPYnNlcnZhYmxlLiBNYXkgYWxzbyByZXR1cm4gYSBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGNvbnZlcnRlZCBvbiB0aGUgZmx5XG4gICAgICogdG8gYW4gT2JzZXJ2YWJsZS5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHdob3NlIE9ic2VydmVycycgc3Vic2NyaXB0aW9ucyB0cmlnZ2VyXG4gICAgICogYW4gaW52b2NhdGlvbiBvZiB0aGUgZ2l2ZW4gT2JzZXJ2YWJsZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGRlZmVyXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBEZWZlck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKG9ic2VydmFibGVGYWN0b3J5KSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJPYnNlcnZhYmxlKG9ic2VydmFibGVGYWN0b3J5KTtcbiAgICB9O1xuICAgIERlZmVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMub2JzZXJ2YWJsZUZhY3RvcnkpO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmVyT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRGVmZXJPYnNlcnZhYmxlID0gRGVmZXJPYnNlcnZhYmxlO1xudmFyIERlZmVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZlclN1YnNjcmliZXIoZGVzdGluYXRpb24sIGZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLnRyeURlZmVyKCk7XG4gICAgfVxuICAgIERlZmVyU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5RGVmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsRmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX2NhbGxGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5mYWN0b3J5KCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWZlclN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVmZXJPYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvRGVmZXJPYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODVcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNOdW1lcmljXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzTnVtZXJpYycpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbnZhciBpc0RhdGVfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNEYXRlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIFRpbWVyT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRpbWVyT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lck9ic2VydmFibGUoZHVlVGltZSwgcGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgaWYgKGR1ZVRpbWUgPT09IHZvaWQgMCkgeyBkdWVUaW1lID0gMDsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wZXJpb2QgPSAtMTtcbiAgICAgICAgdGhpcy5kdWVUaW1lID0gMDtcbiAgICAgICAgaWYgKGlzTnVtZXJpY18xLmlzTnVtZXJpYyhwZXJpb2QpKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmlvZCA9IE51bWJlcihwZXJpb2QpIDwgMSAmJiAxIHx8IE51bWJlcihwZXJpb2QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIocGVyaW9kKSkge1xuICAgICAgICAgICAgc2NoZWR1bGVyID0gcGVyaW9kO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihzY2hlZHVsZXIpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSBpc0RhdGVfMS5pc0RhdGUoZHVlVGltZSkgP1xuICAgICAgICAgICAgKCtkdWVUaW1lIC0gdGhpcy5zY2hlZHVsZXIubm93KCkpIDpcbiAgICAgICAgICAgIGR1ZVRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IHN0YXJ0cyBlbWl0dGluZyBhZnRlciBhbiBgaW5pdGlhbERlbGF5YCBhbmRcbiAgICAgKiBlbWl0cyBldmVyIGluY3JlYXNpbmcgbnVtYmVycyBhZnRlciBlYWNoIGBwZXJpb2RgIG9mIHRpbWUgdGhlcmVhZnRlci5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdHMgbGlrZSB7QGxpbmsgaW50ZXJ2YWx9LCBidXQgeW91IGNhbiBzcGVjaWZ5IHdoZW5cbiAgICAgKiBzaG91bGQgdGhlIGVtaXNzaW9ucyBzdGFydC48L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL3RpbWVyLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogYHRpbWVyYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbiBpbmZpbml0ZSBzZXF1ZW5jZSBvZiBhc2NlbmRpbmdcbiAgICAgKiBpbnRlZ2Vycywgd2l0aCBhIGNvbnN0YW50IGludGVydmFsIG9mIHRpbWUsIGBwZXJpb2RgIG9mIHlvdXIgY2hvb3NpbmdcbiAgICAgKiBiZXR3ZWVuIHRob3NlIGVtaXNzaW9ucy4gVGhlIGZpcnN0IGVtaXNzaW9uIGhhcHBlbnMgYWZ0ZXIgdGhlIHNwZWNpZmllZFxuICAgICAqIGBpbml0aWFsRGVsYXlgLiBUaGUgaW5pdGlhbCBkZWxheSBtYXkgYmUgYSB7QGxpbmsgRGF0ZX0uIEJ5IGRlZmF1bHQsIHRoaXNcbiAgICAgKiBvcGVyYXRvciB1c2VzIHRoZSBgYXN5bmNgIElTY2hlZHVsZXIgdG8gcHJvdmlkZSBhIG5vdGlvbiBvZiB0aW1lLCBidXQgeW91XG4gICAgICogbWF5IHBhc3MgYW55IElTY2hlZHVsZXIgdG8gaXQuIElmIGBwZXJpb2RgIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBvdXRwdXRcbiAgICAgKiBPYnNlcnZhYmxlIGVtaXRzIG9ubHkgb25lIHZhbHVlLCBgMGAuIE90aGVyd2lzZSwgaXQgZW1pdHMgYW4gaW5maW5pdGVcbiAgICAgKiBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIGFzY2VuZGluZyBudW1iZXJzLCBvbmUgZXZlcnkgc2Vjb25kICgxMDAwbXMpLCBzdGFydGluZyBhZnRlciAzIHNlY29uZHM8L2NhcHRpb24+XG4gICAgICogdmFyIG51bWJlcnMgPSBSeC5PYnNlcnZhYmxlLnRpbWVyKDMwMDAsIDEwMDApO1xuICAgICAqIG51bWJlcnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgb25lIG51bWJlciBhZnRlciBmaXZlIHNlY29uZHM8L2NhcHRpb24+XG4gICAgICogdmFyIG51bWJlcnMgPSBSeC5PYnNlcnZhYmxlLnRpbWVyKDUwMDApO1xuICAgICAqIG51bWJlcnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgaW50ZXJ2YWx9XG4gICAgICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxEYXRlfSBpbml0aWFsRGVsYXkgVGhlIGluaXRpYWwgZGVsYXkgdGltZSB0byB3YWl0IGJlZm9yZVxuICAgICAqIGVtaXR0aW5nIHRoZSBmaXJzdCB2YWx1ZSBvZiBgMGAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwZXJpb2RdIFRoZSBwZXJpb2Qgb2YgdGltZSBiZXR3ZWVuIGVtaXNzaW9ucyBvZiB0aGVcbiAgICAgKiBzdWJzZXF1ZW50IG51bWJlcnMuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBJU2NoZWR1bGVyIHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBlbWlzc2lvbiBvZiB2YWx1ZXMsIGFuZCBwcm92aWRpbmcgYSBub3Rpb24gb2YgXCJ0aW1lXCIuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGEgYDBgIGFmdGVyIHRoZVxuICAgICAqIGBpbml0aWFsRGVsYXlgIGFuZCBldmVyIGluY3JlYXNpbmcgbnVtYmVycyBhZnRlciBlYWNoIGBwZXJpb2RgIG9mIHRpbWVcbiAgICAgKiB0aGVyZWFmdGVyLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIHRpbWVyXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBUaW1lck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGluaXRpYWxEZWxheSwgcGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgaWYgKGluaXRpYWxEZWxheSA9PT0gdm9pZCAwKSB7IGluaXRpYWxEZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lck9ic2VydmFibGUoaW5pdGlhbERlbGF5LCBwZXJpb2QsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBUaW1lck9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgsIHBlcmlvZCA9IHN0YXRlLnBlcmlvZCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzO1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQoaW5kZXgpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwZXJpb2QgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBhY3Rpb24uc2NoZWR1bGUoc3RhdGUsIHBlcmlvZCk7XG4gICAgfTtcbiAgICBUaW1lck9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwZXJpb2QgPSBfYS5wZXJpb2QsIGR1ZVRpbWUgPSBfYS5kdWVUaW1lLCBzY2hlZHVsZXIgPSBfYS5zY2hlZHVsZXI7XG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoVGltZXJPYnNlcnZhYmxlLmRpc3BhdGNoLCBkdWVUaW1lLCB7XG4gICAgICAgICAgICBpbmRleDogaW5kZXgsIHBlcmlvZDogcGVyaW9kLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVyT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuVGltZXJPYnNlcnZhYmxlID0gVGltZXJPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGltZXJPYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29ic2VydmFibGUvVGltZXJPYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODZcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIERlZmVyT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9EZWZlck9ic2VydmFibGUnKTtcbmV4cG9ydHMuZGVmZXIgPSBEZWZlck9ic2VydmFibGVfMS5EZWZlck9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9kZWZlci5qc1xuLy8gbW9kdWxlIGlkID0gMTg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG5mdW5jdGlvbiByYWNlKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgb25seSBhcmd1bWVudCBpcyBhbiBhcnJheSwgaXQgd2FzIG1vc3QgbGlrZWx5IGNhbGxlZCB3aXRoXG4gICAgLy8gYHJhY2UoW29iczEsIG9iczIsIC4uLl0pYFxuICAgIGlmIChvYnNlcnZhYmxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKGlzQXJyYXlfMS5pc0FycmF5KG9ic2VydmFibGVzWzBdKSkge1xuICAgICAgICAgICAgb2JzZXJ2YWJsZXMgPSBvYnNlcnZhYmxlc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlc1swXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZShvYnNlcnZhYmxlcykubGlmdChuZXcgUmFjZU9wZXJhdG9yKCkpO1xufVxuZXhwb3J0cy5yYWNlID0gcmFjZTtcbnZhciBSYWNlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJhY2VPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgUmFjZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUmFjZVN1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFJhY2VPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLlJhY2VPcGVyYXRvciA9IFJhY2VPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgUmFjZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSYWNlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSYWNlU3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaGFzRmlyc3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgUmFjZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlcy5wdXNoKG9ic2VydmFibGUpO1xuICAgIH07XG4gICAgUmFjZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGVzID0gdGhpcy5vYnNlcnZhYmxlcztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmFibGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4gJiYgIXRoaXMuaGFzRmlyc3Q7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlID0gb2JzZXJ2YWJsZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZSwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZhYmxlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJhY2VTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNGaXJzdCkge1xuICAgICAgICAgICAgdGhpcy5oYXNGaXJzdCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpICE9PSBvdXRlckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLnN1YnNjcmlwdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIFJhY2VTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuUmFjZVN1YnNjcmliZXIgPSBSYWNlU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS9yYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODhcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFRpbWVyT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9UaW1lck9ic2VydmFibGUnKTtcbmV4cG9ydHMudGltZXIgPSBUaW1lck9ic2VydmFibGVfMS5UaW1lck9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb2JzZXJ2YWJsZS90aW1lci5qc1xuLy8gbW9kdWxlIGlkID0gMTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG4vLyBIQUNLOiB0aGlzIGlzIGhlcmUgZm9yIGJhY2t3YXJkIGNvbXBhdGFiaWxpdHlcbi8vIFRPRE8oYmVubGVzaCk6IHJlbW92ZSB0aGlzIGluIHY2LlxuZXhwb3J0cy50b1Byb21pc2UgPSBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudG9Qcm9taXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9Qcm9taXNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9yL3RvUHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG52YXIgYXVkaXRfMSA9IHJlcXVpcmUoJy4vYXVkaXQnKTtcbnZhciB0aW1lcl8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS90aW1lcicpO1xuLyoqXG4gKiBJZ25vcmVzIHNvdXJjZSB2YWx1ZXMgZm9yIGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzLCB0aGVuIGVtaXRzIHRoZSBtb3N0IHJlY2VudFxuICogdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHRoZW4gcmVwZWF0cyB0aGlzIHByb2Nlc3MuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPldoZW4gaXQgc2VlcyBhIHNvdXJjZSB2YWx1ZXMsIGl0IGlnbm9yZXMgdGhhdCBwbHVzXG4gKiB0aGUgbmV4dCBvbmVzIGZvciBgZHVyYXRpb25gIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gaXQgZW1pdHMgdGhlIG1vc3QgcmVjZW50XG4gKiB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYXVkaXRUaW1lLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBhdWRpdFRpbWVgIGlzIHNpbWlsYXIgdG8gYHRocm90dGxlVGltZWAsIGJ1dCBlbWl0cyB0aGUgbGFzdCB2YWx1ZSBmcm9tIHRoZVxuICogc2lsZW5jZWQgdGltZSB3aW5kb3csIGluc3RlYWQgb2YgdGhlIGZpcnN0IHZhbHVlLiBgYXVkaXRUaW1lYCBlbWl0cyB0aGUgbW9zdFxuICogcmVjZW50IHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBhcyBzb29uIGFzXG4gKiBpdHMgaW50ZXJuYWwgdGltZXIgYmVjb21lcyBkaXNhYmxlZCwgYW5kIGlnbm9yZXMgc291cmNlIHZhbHVlcyB3aGlsZSB0aGVcbiAqIHRpbWVyIGlzIGVuYWJsZWQuIEluaXRpYWxseSwgdGhlIHRpbWVyIGlzIGRpc2FibGVkLiBBcyBzb29uIGFzIHRoZSBmaXJzdFxuICogc291cmNlIHZhbHVlIGFycml2ZXMsIHRoZSB0aW1lciBpcyBlbmFibGVkLiBBZnRlciBgZHVyYXRpb25gIG1pbGxpc2Vjb25kcyAob3JcbiAqIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZCBpbnRlcm5hbGx5IGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYCkgaGFzIHBhc3NlZCxcbiAqIHRoZSB0aW1lciBpcyBkaXNhYmxlZCwgdGhlbiB0aGUgbW9zdCByZWNlbnQgc291cmNlIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlXG4gKiBvdXRwdXQgT2JzZXJ2YWJsZSwgYW5kIHRoaXMgcHJvY2VzcyByZXBlYXRzIGZvciB0aGUgbmV4dCBzb3VyY2UgdmFsdWUuXG4gKiBPcHRpb25hbGx5IHRha2VzIGEge0BsaW5rIElTY2hlZHVsZXJ9IGZvciBtYW5hZ2luZyB0aW1lcnMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBjbGlja3MgYXQgYSByYXRlIG9mIGF0IG1vc3Qgb25lIGNsaWNrIHBlciBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5hdWRpdFRpbWUoMTAwMCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0fVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2VUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gKiBAc2VlIHtAbGluayBzYW1wbGVUaW1lfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGVUaW1lfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBUaW1lIHRvIHdhaXQgYmVmb3JlIGVtaXR0aW5nIHRoZSBtb3N0IHJlY2VudCBzb3VyY2VcbiAqIHZhbHVlLCBtZWFzdXJlZCBpbiBtaWxsaXNlY29uZHMgb3IgdGhlIHRpbWUgdW5pdCBkZXRlcm1pbmVkIGludGVybmFsbHlcbiAqIGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYC5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPWFzeW5jXSBUaGUge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3JcbiAqIG1hbmFnaW5nIHRoZSB0aW1lcnMgdGhhdCBoYW5kbGUgdGhlIHJhdGUtbGltaXRpbmcgYmVoYXZpb3IuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgcGVyZm9ybXMgcmF0ZS1saW1pdGluZyBvZlxuICogZW1pc3Npb25zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBhdWRpdFRpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGF1ZGl0VGltZShkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICByZXR1cm4gYXVkaXRfMS5hdWRpdChmdW5jdGlvbiAoKSB7IHJldHVybiB0aW1lcl8xLnRpbWVyKGR1cmF0aW9uLCBzY2hlZHVsZXIpOyB9KTtcbn1cbmV4cG9ydHMuYXVkaXRUaW1lID0gYXVkaXRUaW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXVkaXRUaW1lLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9hdWRpdFRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDE5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEJ1ZmZlcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyB1bnRpbCBgY2xvc2luZ05vdGlmaWVyYCBlbWl0cy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29sbGVjdHMgdmFsdWVzIGZyb20gdGhlIHBhc3QgYXMgYW4gYXJyYXksIGFuZCBlbWl0c1xuICogdGhhdCBhcnJheSBvbmx5IHdoZW4gYW5vdGhlciBPYnNlcnZhYmxlIGVtaXRzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2J1ZmZlci5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBCdWZmZXJzIHRoZSBpbmNvbWluZyBPYnNlcnZhYmxlIHZhbHVlcyB1bnRpbCB0aGUgZ2l2ZW4gYGNsb3NpbmdOb3RpZmllcmBcbiAqIE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSwgYXQgd2hpY2ggcG9pbnQgaXQgZW1pdHMgdGhlIGJ1ZmZlciBvbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlIGFuZCBzdGFydHMgYSBuZXcgYnVmZmVyIGludGVybmFsbHksIGF3YWl0aW5nIHRoZSBuZXh0IHRpbWVcbiAqIGBjbG9zaW5nTm90aWZpZXJgIGVtaXRzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk9uIGV2ZXJ5IGNsaWNrLCBlbWl0IGFycmF5IG9mIG1vc3QgcmVjZW50IGludGVydmFsIGV2ZW50czwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGJ1ZmZlcmVkID0gaW50ZXJ2YWwuYnVmZmVyKGNsaWNrcyk7XG4gKiBidWZmZXJlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYnVmZmVyQ291bnR9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUaW1lfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyV2hlbn1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd31cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGU8YW55Pn0gY2xvc2luZ05vdGlmaWVyIEFuIE9ic2VydmFibGUgdGhhdCBzaWduYWxzIHRoZVxuICogYnVmZmVyIHRvIGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUW10+fSBBbiBPYnNlcnZhYmxlIG9mIGJ1ZmZlcnMsIHdoaWNoIGFyZSBhcnJheXMgb2ZcbiAqIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBidWZmZXIoY2xvc2luZ05vdGlmaWVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJ1ZmZlck9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgQnVmZmVyT3BlcmF0b3IoY2xvc2luZ05vdGlmaWVyKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuYnVmZmVyID0gYnVmZmVyO1xudmFyIEJ1ZmZlck9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXJPcGVyYXRvcihjbG9zaW5nTm90aWZpZXIpIHtcbiAgICAgICAgdGhpcy5jbG9zaW5nTm90aWZpZXIgPSBjbG9zaW5nTm90aWZpZXI7XG4gICAgfVxuICAgIEJ1ZmZlck9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQnVmZmVyU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmNsb3NpbmdOb3RpZmllcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlck9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQnVmZmVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlclN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnVmZmVyU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY2xvc2luZ05vdGlmaWVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBjbG9zaW5nTm90aWZpZXIpKTtcbiAgICB9XG4gICAgQnVmZmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgfTtcbiAgICBCdWZmZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGJ1ZmZlcik7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL2J1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMTkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogQnVmZmVycyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIHVudGlsIHRoZSBzaXplIGhpdHMgdGhlIG1heGltdW1cbiAqIGBidWZmZXJTaXplYCBnaXZlbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29sbGVjdHMgdmFsdWVzIGZyb20gdGhlIHBhc3QgYXMgYW4gYXJyYXksIGFuZCBlbWl0c1xuICogdGhhdCBhcnJheSBvbmx5IHdoZW4gaXRzIHNpemUgcmVhY2hlcyBgYnVmZmVyU2l6ZWAuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYnVmZmVyQ291bnQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQnVmZmVycyBhIG51bWJlciBvZiB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgYGJ1ZmZlclNpemVgIHRoZW5cbiAqIGVtaXRzIHRoZSBidWZmZXIgYW5kIGNsZWFycyBpdCwgYW5kIHN0YXJ0cyBhIG5ldyBidWZmZXIgZWFjaFxuICogYHN0YXJ0QnVmZmVyRXZlcnlgIHZhbHVlcy4gSWYgYHN0YXJ0QnVmZmVyRXZlcnlgIGlzIG5vdCBwcm92aWRlZCBvciBpc1xuICogYG51bGxgLCB0aGVuIG5ldyBidWZmZXJzIGFyZSBzdGFydGVkIGltbWVkaWF0ZWx5IGF0IHRoZSBzdGFydCBvZiB0aGUgc291cmNlXG4gKiBhbmQgd2hlbiBlYWNoIGJ1ZmZlciBjbG9zZXMgYW5kIGlzIGVtaXR0ZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbGFzdCB0d28gY2xpY2sgZXZlbnRzIGFzIGFuIGFycmF5PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJDb3VudCgyKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljaywgZW1pdCB0aGUgbGFzdCB0d28gY2xpY2sgZXZlbnRzIGFzIGFuIGFycmF5PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJDb3VudCgyLCAxKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUaW1lfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyV2hlbn1cbiAqIEBzZWUge0BsaW5rIHBhaXJ3aXNlfVxuICogQHNlZSB7QGxpbmsgd2luZG93Q291bnR9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlclNpemUgVGhlIG1heGltdW0gc2l6ZSBvZiB0aGUgYnVmZmVyIGVtaXR0ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0QnVmZmVyRXZlcnldIEludGVydmFsIGF0IHdoaWNoIHRvIHN0YXJ0IGEgbmV3IGJ1ZmZlci5cbiAqIEZvciBleGFtcGxlIGlmIGBzdGFydEJ1ZmZlckV2ZXJ5YCBpcyBgMmAsIHRoZW4gYSBuZXcgYnVmZmVyIHdpbGwgYmUgc3RhcnRlZFxuICogb24gZXZlcnkgb3RoZXIgdmFsdWUgZnJvbSB0aGUgc291cmNlLiBBIG5ldyBidWZmZXIgaXMgc3RhcnRlZCBhdCB0aGVcbiAqIGJlZ2lubmluZyBvZiB0aGUgc291cmNlIGJ5IGRlZmF1bHQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIE9ic2VydmFibGUgb2YgYXJyYXlzIG9mIGJ1ZmZlcmVkIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyQ291bnRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlckNvdW50KGJ1ZmZlclNpemUsIHN0YXJ0QnVmZmVyRXZlcnkpIHtcbiAgICBpZiAoc3RhcnRCdWZmZXJFdmVyeSA9PT0gdm9pZCAwKSB7IHN0YXJ0QnVmZmVyRXZlcnkgPSBudWxsOyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJ1ZmZlckNvdW50T3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBCdWZmZXJDb3VudE9wZXJhdG9yKGJ1ZmZlclNpemUsIHN0YXJ0QnVmZmVyRXZlcnkpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5idWZmZXJDb3VudCA9IGJ1ZmZlckNvdW50O1xudmFyIEJ1ZmZlckNvdW50T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlckNvdW50T3BlcmF0b3IoYnVmZmVyU2l6ZSwgc3RhcnRCdWZmZXJFdmVyeSkge1xuICAgICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplO1xuICAgICAgICB0aGlzLnN0YXJ0QnVmZmVyRXZlcnkgPSBzdGFydEJ1ZmZlckV2ZXJ5O1xuICAgICAgICBpZiAoIXN0YXJ0QnVmZmVyRXZlcnkgfHwgYnVmZmVyU2l6ZSA9PT0gc3RhcnRCdWZmZXJFdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyQ2xhc3MgPSBCdWZmZXJDb3VudFN1YnNjcmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJDbGFzcyA9IEJ1ZmZlclNraXBDb3VudFN1YnNjcmliZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQnVmZmVyQ291bnRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IHRoaXMuc3Vic2NyaWJlckNsYXNzKHN1YnNjcmliZXIsIHRoaXMuYnVmZmVyU2l6ZSwgdGhpcy5zdGFydEJ1ZmZlckV2ZXJ5KSk7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyQ291bnRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEJ1ZmZlckNvdW50U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlckNvdW50U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWZmZXJDb3VudFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGJ1ZmZlclNpemUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIH1cbiAgICBCdWZmZXJDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSB0aGlzLmJ1ZmZlclNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlckNvdW50U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQnVmZmVyU2tpcENvdW50U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlclNraXBDb3VudFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnVmZmVyU2tpcENvdW50U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgYnVmZmVyU2l6ZSwgc3RhcnRCdWZmZXJFdmVyeSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemU7XG4gICAgICAgIHRoaXMuc3RhcnRCdWZmZXJFdmVyeSA9IHN0YXJ0QnVmZmVyRXZlcnk7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB9XG4gICAgQnVmZmVyU2tpcENvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgYnVmZmVyU2l6ZSA9IF9hLmJ1ZmZlclNpemUsIHN0YXJ0QnVmZmVyRXZlcnkgPSBfYS5zdGFydEJ1ZmZlckV2ZXJ5LCBidWZmZXJzID0gX2EuYnVmZmVycywgY291bnQgPSBfYS5jb3VudDtcbiAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICBpZiAoY291bnQgJSBzdGFydEJ1ZmZlckV2ZXJ5ID09PSAwKSB7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goW10pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBidWZmZXJzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbaV07XG4gICAgICAgICAgICBidWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gYnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJTa2lwQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGJ1ZmZlcnMgPSBfYS5idWZmZXJzLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICB3aGlsZSAoYnVmZmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVycy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyU2tpcENvdW50U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlckNvdW50LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9idWZmZXJDb3VudC5qc1xuLy8gbW9kdWxlIGlkID0gMTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEJ1ZmZlcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBmb3IgYSBzcGVjaWZpYyB0aW1lIHBlcmlvZC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29sbGVjdHMgdmFsdWVzIGZyb20gdGhlIHBhc3QgYXMgYW4gYXJyYXksIGFuZCBlbWl0c1xuICogdGhvc2UgYXJyYXlzIHBlcmlvZGljYWxseSBpbiB0aW1lLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2J1ZmZlclRpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQnVmZmVycyB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIGZvciBhIHNwZWNpZmljIHRpbWUgZHVyYXRpb24gYGJ1ZmZlclRpbWVTcGFuYC5cbiAqIFVubGVzcyB0aGUgb3B0aW9uYWwgYXJndW1lbnQgYGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWxgIGlzIGdpdmVuLCBpdCBlbWl0cyBhbmRcbiAqIHJlc2V0cyB0aGUgYnVmZmVyIGV2ZXJ5IGBidWZmZXJUaW1lU3BhbmAgbWlsbGlzZWNvbmRzLiBJZlxuICogYGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWxgIGlzIGdpdmVuLCB0aGlzIG9wZXJhdG9yIG9wZW5zIHRoZSBidWZmZXIgZXZlcnlcbiAqIGBidWZmZXJDcmVhdGlvbkludGVydmFsYCBtaWxsaXNlY29uZHMgYW5kIGNsb3NlcyAoZW1pdHMgYW5kIHJlc2V0cykgdGhlXG4gKiBidWZmZXIgZXZlcnkgYGJ1ZmZlclRpbWVTcGFuYCBtaWxsaXNlY29uZHMuIFdoZW4gdGhlIG9wdGlvbmFsIGFyZ3VtZW50XG4gKiBgbWF4QnVmZmVyU2l6ZWAgaXMgc3BlY2lmaWVkLCB0aGUgYnVmZmVyIHdpbGwgYmUgY2xvc2VkIGVpdGhlciBhZnRlclxuICogYGJ1ZmZlclRpbWVTcGFuYCBtaWxsaXNlY29uZHMgb3Igd2hlbiBpdCBjb250YWlucyBgbWF4QnVmZmVyU2l6ZWAgZWxlbWVudHMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RXZlcnkgc2Vjb25kLCBlbWl0IGFuIGFycmF5IG9mIHRoZSByZWNlbnQgY2xpY2sgZXZlbnRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJUaW1lKDEwMDApO1xuICogYnVmZmVyZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkV2ZXJ5IDUgc2Vjb25kcywgZW1pdCB0aGUgY2xpY2sgZXZlbnRzIGZyb20gdGhlIG5leHQgMiBzZWNvbmRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJUaW1lKDIwMDAsIDUwMDApO1xuICogYnVmZmVyZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlckNvdW50fVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyV2hlbn1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RpbWV9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlclRpbWVTcGFuIFRoZSBhbW91bnQgb2YgdGltZSB0byBmaWxsIGVhY2ggYnVmZmVyIGFycmF5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtidWZmZXJDcmVhdGlvbkludGVydmFsXSBUaGUgaW50ZXJ2YWwgYXQgd2hpY2ggdG8gc3RhcnQgbmV3XG4gKiBidWZmZXJzLlxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhCdWZmZXJTaXplXSBUaGUgbWF4aW11bSBidWZmZXIgc2l6ZS5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPWFzeW5jXSBUaGUgc2NoZWR1bGVyIG9uIHdoaWNoIHRvIHNjaGVkdWxlIHRoZVxuICogaW50ZXJ2YWxzIHRoYXQgZGV0ZXJtaW5lIGJ1ZmZlciBib3VuZGFyaWVzLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUW10+fSBBbiBvYnNlcnZhYmxlIG9mIGFycmF5cyBvZiBidWZmZXJlZCB2YWx1ZXMuXG4gKiBAbWV0aG9kIGJ1ZmZlclRpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRpbWUoYnVmZmVyVGltZVNwYW4pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYztcbiAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICBzY2hlZHVsZXIgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBsZW5ndGgtLTtcbiAgICB9XG4gICAgdmFyIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwgPSBudWxsO1xuICAgIGlmIChsZW5ndGggPj0gMikge1xuICAgICAgICBidWZmZXJDcmVhdGlvbkludGVydmFsID0gYXJndW1lbnRzWzFdO1xuICAgIH1cbiAgICB2YXIgbWF4QnVmZmVyU2l6ZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBpZiAobGVuZ3RoID49IDMpIHtcbiAgICAgICAgbWF4QnVmZmVyU2l6ZSA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJ1ZmZlclRpbWVPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IEJ1ZmZlclRpbWVPcGVyYXRvcihidWZmZXJUaW1lU3BhbiwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgbWF4QnVmZmVyU2l6ZSwgc2NoZWR1bGVyKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuYnVmZmVyVGltZSA9IGJ1ZmZlclRpbWU7XG52YXIgQnVmZmVyVGltZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXJUaW1lT3BlcmF0b3IoYnVmZmVyVGltZVNwYW4sIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwsIG1heEJ1ZmZlclNpemUsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmJ1ZmZlclRpbWVTcGFuID0gYnVmZmVyVGltZVNwYW47XG4gICAgICAgIHRoaXMuYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCA9IGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMubWF4QnVmZmVyU2l6ZSA9IG1heEJ1ZmZlclNpemU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBCdWZmZXJUaW1lT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBCdWZmZXJUaW1lU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmJ1ZmZlclRpbWVTcGFuLCB0aGlzLmJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwsIHRoaXMubWF4QnVmZmVyU2l6ZSwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJUaW1lT3BlcmF0b3I7XG59KCkpO1xudmFyIENvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnRleHQoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgfVxuICAgIHJldHVybiBDb250ZXh0O1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQnVmZmVyVGltZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdWZmZXJUaW1lU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWZmZXJUaW1lU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgYnVmZmVyVGltZVNwYW4sIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwsIG1heEJ1ZmZlclNpemUsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuYnVmZmVyVGltZVNwYW4gPSBidWZmZXJUaW1lU3BhbjtcbiAgICAgICAgdGhpcy5idWZmZXJDcmVhdGlvbkludGVydmFsID0gYnVmZmVyQ3JlYXRpb25JbnRlcnZhbDtcbiAgICAgICAgdGhpcy5tYXhCdWZmZXJTaXplID0gbWF4QnVmZmVyU2l6ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBbXTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLm9wZW5Db250ZXh0KCk7XG4gICAgICAgIHRoaXMudGltZXNwYW5Pbmx5ID0gYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCA9PSBudWxsIHx8IGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwgPCAwO1xuICAgICAgICBpZiAodGhpcy50aW1lc3Bhbk9ubHkpIHtcbiAgICAgICAgICAgIHZhciB0aW1lU3Bhbk9ubHlTdGF0ZSA9IHsgc3Vic2NyaWJlcjogdGhpcywgY29udGV4dDogY29udGV4dCwgYnVmZmVyVGltZVNwYW46IGJ1ZmZlclRpbWVTcGFuIH07XG4gICAgICAgICAgICB0aGlzLmFkZChjb250ZXh0LmNsb3NlQWN0aW9uID0gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoQnVmZmVyVGltZVNwYW5Pbmx5LCBidWZmZXJUaW1lU3BhbiwgdGltZVNwYW5Pbmx5U3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjbG9zZVN0YXRlID0geyBzdWJzY3JpYmVyOiB0aGlzLCBjb250ZXh0OiBjb250ZXh0IH07XG4gICAgICAgICAgICB2YXIgY3JlYXRpb25TdGF0ZSA9IHsgYnVmZmVyVGltZVNwYW46IGJ1ZmZlclRpbWVTcGFuLCBidWZmZXJDcmVhdGlvbkludGVydmFsOiBidWZmZXJDcmVhdGlvbkludGVydmFsLCBzdWJzY3JpYmVyOiB0aGlzLCBzY2hlZHVsZXI6IHNjaGVkdWxlciB9O1xuICAgICAgICAgICAgdGhpcy5hZGQoY29udGV4dC5jbG9zZUFjdGlvbiA9IHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEJ1ZmZlckNsb3NlLCBidWZmZXJUaW1lU3BhbiwgY2xvc2VTdGF0ZSkpO1xuICAgICAgICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoQnVmZmVyQ3JlYXRpb24sIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwsIGNyZWF0aW9uU3RhdGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBCdWZmZXJUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgdmFyIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGZpbGxlZEJ1ZmZlckNvbnRleHQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dHNbaV07XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gY29udGV4dC5idWZmZXI7XG4gICAgICAgICAgICBidWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSB0aGlzLm1heEJ1ZmZlclNpemUpIHtcbiAgICAgICAgICAgICAgICBmaWxsZWRCdWZmZXJDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsbGVkQnVmZmVyQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5vbkJ1ZmZlckZ1bGwoZmlsbGVkQnVmZmVyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlclRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuY29udGV4dHMubGVuZ3RoID0gMDtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fZXJyb3IuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH07XG4gICAgQnVmZmVyVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29udGV4dHMgPSBfYS5jb250ZXh0cywgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgd2hpbGUgKGNvbnRleHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoY29udGV4dC5idWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBCdWZmZXJUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRleHRzID0gbnVsbDtcbiAgICB9O1xuICAgIEJ1ZmZlclRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5vbkJ1ZmZlckZ1bGwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNsb3NlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgdmFyIGNsb3NlQWN0aW9uID0gY29udGV4dC5jbG9zZUFjdGlvbjtcbiAgICAgICAgY2xvc2VBY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoY2xvc2VBY3Rpb24pO1xuICAgICAgICBpZiAoIXRoaXMuY2xvc2VkICYmIHRoaXMudGltZXNwYW5Pbmx5KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5vcGVuQ29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlclRpbWVTcGFuID0gdGhpcy5idWZmZXJUaW1lU3BhbjtcbiAgICAgICAgICAgIHZhciB0aW1lU3Bhbk9ubHlTdGF0ZSA9IHsgc3Vic2NyaWJlcjogdGhpcywgY29udGV4dDogY29udGV4dCwgYnVmZmVyVGltZVNwYW46IGJ1ZmZlclRpbWVTcGFuIH07XG4gICAgICAgICAgICB0aGlzLmFkZChjb250ZXh0LmNsb3NlQWN0aW9uID0gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hCdWZmZXJUaW1lU3Bhbk9ubHksIGJ1ZmZlclRpbWVTcGFuLCB0aW1lU3Bhbk9ubHlTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUub3BlbkNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9O1xuICAgIEJ1ZmZlclRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbG9zZUNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoY29udGV4dC5idWZmZXIpO1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB2YXIgc3BsaWNlSW5kZXggPSBjb250ZXh0cyA/IGNvbnRleHRzLmluZGV4T2YoY29udGV4dCkgOiAtMTtcbiAgICAgICAgaWYgKHNwbGljZUluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGNvbnRleHRzLnNwbGljZShjb250ZXh0cy5pbmRleE9mKGNvbnRleHQpLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlclRpbWVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZnVuY3Rpb24gZGlzcGF0Y2hCdWZmZXJUaW1lU3Bhbk9ubHkoc3RhdGUpIHtcbiAgICB2YXIgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgdmFyIHByZXZDb250ZXh0ID0gc3RhdGUuY29udGV4dDtcbiAgICBpZiAocHJldkNvbnRleHQpIHtcbiAgICAgICAgc3Vic2NyaWJlci5jbG9zZUNvbnRleHQocHJldkNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgIHN0YXRlLmNvbnRleHQgPSBzdWJzY3JpYmVyLm9wZW5Db250ZXh0KCk7XG4gICAgICAgIHN0YXRlLmNvbnRleHQuY2xvc2VBY3Rpb24gPSB0aGlzLnNjaGVkdWxlKHN0YXRlLCBzdGF0ZS5idWZmZXJUaW1lU3Bhbik7XG4gICAgfVxufVxuZnVuY3Rpb24gZGlzcGF0Y2hCdWZmZXJDcmVhdGlvbihzdGF0ZSkge1xuICAgIHZhciBidWZmZXJDcmVhdGlvbkludGVydmFsID0gc3RhdGUuYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgYnVmZmVyVGltZVNwYW4gPSBzdGF0ZS5idWZmZXJUaW1lU3Bhbiwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXIsIHNjaGVkdWxlciA9IHN0YXRlLnNjaGVkdWxlcjtcbiAgICB2YXIgY29udGV4dCA9IHN1YnNjcmliZXIub3BlbkNvbnRleHQoKTtcbiAgICB2YXIgYWN0aW9uID0gdGhpcztcbiAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgIHN1YnNjcmliZXIuYWRkKGNvbnRleHQuY2xvc2VBY3Rpb24gPSBzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hCdWZmZXJDbG9zZSwgYnVmZmVyVGltZVNwYW4sIHsgc3Vic2NyaWJlcjogc3Vic2NyaWJlciwgY29udGV4dDogY29udGV4dCB9KSk7XG4gICAgICAgIGFjdGlvbi5zY2hlZHVsZShzdGF0ZSwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGlzcGF0Y2hCdWZmZXJDbG9zZShhcmcpIHtcbiAgICB2YXIgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyLCBjb250ZXh0ID0gYXJnLmNvbnRleHQ7XG4gICAgc3Vic2NyaWJlci5jbG9zZUNvbnRleHQoY29udGV4dCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXJUaW1lLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9idWZmZXJUaW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG4vKipcbiAqIEJ1ZmZlcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBzdGFydGluZyBmcm9tIGFuIGVtaXNzaW9uIGZyb21cbiAqIGBvcGVuaW5nc2AgYW5kIGVuZGluZyB3aGVuIHRoZSBvdXRwdXQgb2YgYGNsb3NpbmdTZWxlY3RvcmAgZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbGxlY3RzIHZhbHVlcyBmcm9tIHRoZSBwYXN0IGFzIGFuIGFycmF5LiBTdGFydHNcbiAqIGNvbGxlY3Rpbmcgb25seSB3aGVuIGBvcGVuaW5nYCBlbWl0cywgYW5kIGNhbGxzIHRoZSBgY2xvc2luZ1NlbGVjdG9yYFxuICogZnVuY3Rpb24gdG8gZ2V0IGFuIE9ic2VydmFibGUgdGhhdCB0ZWxscyB3aGVuIHRvIGNsb3NlIHRoZSBidWZmZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYnVmZmVyVG9nZ2xlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEJ1ZmZlcnMgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBieSBvcGVuaW5nIHRoZSBidWZmZXIgdmlhIHNpZ25hbHMgZnJvbSBhblxuICogT2JzZXJ2YWJsZSBwcm92aWRlZCB0byBgb3BlbmluZ3NgLCBhbmQgY2xvc2luZyBhbmQgc2VuZGluZyB0aGUgYnVmZmVycyB3aGVuXG4gKiBhIFN1YnNjcmliYWJsZSBvciBQcm9taXNlIHJldHVybmVkIGJ5IHRoZSBgY2xvc2luZ1NlbGVjdG9yYCBmdW5jdGlvbiBlbWl0cy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FdmVyeSBvdGhlciBzZWNvbmQsIGVtaXQgdGhlIGNsaWNrIGV2ZW50cyBmcm9tIHRoZSBuZXh0IDUwMG1zPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBvcGVuaW5ncyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgYnVmZmVyZWQgPSBjbGlja3MuYnVmZmVyVG9nZ2xlKG9wZW5pbmdzLCBpID0+XG4gKiAgIGkgJSAyID8gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApIDogUnguT2JzZXJ2YWJsZS5lbXB0eSgpXG4gKiApO1xuICogYnVmZmVyZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlckNvdW50fVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVGltZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcldoZW59XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUb2dnbGV9XG4gKlxuICogQHBhcmFtIHtTdWJzY3JpYmFibGVPclByb21pc2U8Tz59IG9wZW5pbmdzIEEgU3Vic2NyaWJhYmxlIG9yIFByb21pc2Ugb2Ygbm90aWZpY2F0aW9ucyB0byBzdGFydCBuZXdcbiAqIGJ1ZmZlcnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBPKTogU3Vic2NyaWJhYmxlT3JQcm9taXNlfSBjbG9zaW5nU2VsZWN0b3IgQSBmdW5jdGlvbiB0aGF0IHRha2VzXG4gKiB0aGUgdmFsdWUgZW1pdHRlZCBieSB0aGUgYG9wZW5pbmdzYCBvYnNlcnZhYmxlIGFuZCByZXR1cm5zIGEgU3Vic2NyaWJhYmxlIG9yIFByb21pc2UsXG4gKiB3aGljaCwgd2hlbiBpdCBlbWl0cywgc2lnbmFscyB0aGF0IHRoZSBhc3NvY2lhdGVkIGJ1ZmZlciBzaG91bGQgYmUgZW1pdHRlZFxuICogYW5kIGNsZWFyZWQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIG9ic2VydmFibGUgb2YgYXJyYXlzIG9mIGJ1ZmZlcmVkIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyVG9nZ2xlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBidWZmZXJUb2dnbGUob3BlbmluZ3MsIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiBidWZmZXJUb2dnbGVPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IEJ1ZmZlclRvZ2dsZU9wZXJhdG9yKG9wZW5pbmdzLCBjbG9zaW5nU2VsZWN0b3IpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5idWZmZXJUb2dnbGUgPSBidWZmZXJUb2dnbGU7XG52YXIgQnVmZmVyVG9nZ2xlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlclRvZ2dsZU9wZXJhdG9yKG9wZW5pbmdzLCBjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5vcGVuaW5ncyA9IG9wZW5pbmdzO1xuICAgICAgICB0aGlzLmNsb3NpbmdTZWxlY3RvciA9IGNsb3NpbmdTZWxlY3RvcjtcbiAgICB9XG4gICAgQnVmZmVyVG9nZ2xlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMub3BlbmluZ3MsIHRoaXMuY2xvc2luZ1NlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyVG9nZ2xlT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnVmZmVyVG9nZ2xlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBvcGVuaW5ncywgY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5vcGVuaW5ncyA9IG9wZW5pbmdzO1xuICAgICAgICB0aGlzLmNsb3NpbmdTZWxlY3RvciA9IGNsb3NpbmdTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb250ZXh0cyA9IFtdO1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG9wZW5pbmdzKSk7XG4gICAgfVxuICAgIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHZhciBsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRleHRzW2ldLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB3aGlsZSAoY29udGV4dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0cy5zaGlmdCgpO1xuICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIGNvbnRleHQuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRleHRzID0gbnVsbDtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fZXJyb3IuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH07XG4gICAgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB3aGlsZSAoY29udGV4dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0cy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGNvbnRleHQuYnVmZmVyKTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBjb250ZXh0LmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICBjb250ZXh0LnN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250ZXh0cyA9IG51bGw7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIG91dGVyVmFsdWUgPyB0aGlzLmNsb3NlQnVmZmVyKG91dGVyVmFsdWUpIDogdGhpcy5vcGVuQnVmZmVyKGlubmVyVmFsdWUpO1xuICAgIH07XG4gICAgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5jbG9zZUJ1ZmZlcihpbm5lclN1Yi5jb250ZXh0KTtcbiAgICB9O1xuICAgIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLm9wZW5CdWZmZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjbG9zaW5nU2VsZWN0b3IgPSB0aGlzLmNsb3NpbmdTZWxlY3RvcjtcbiAgICAgICAgICAgIHZhciBjbG9zaW5nTm90aWZpZXIgPSBjbG9zaW5nU2VsZWN0b3IuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xvc2luZ05vdGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cnlTdWJzY3JpYmUoY2xvc2luZ05vdGlmaWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbG9zZUJ1ZmZlciA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIGlmIChjb250ZXh0cyAmJiBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gY29udGV4dC5idWZmZXIsIHN1YnNjcmlwdGlvbiA9IGNvbnRleHQuc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGJ1ZmZlcik7XG4gICAgICAgICAgICBjb250ZXh0cy5zcGxpY2UoY29udGV4dHMuaW5kZXhPZihjb250ZXh0KSwgMSk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLnRyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIChjbG9zaW5nTm90aWZpZXIpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbigpO1xuICAgICAgICB2YXIgY29udGV4dCA9IHsgYnVmZmVyOiBidWZmZXIsIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uIH07XG4gICAgICAgIGNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgY2xvc2luZ05vdGlmaWVyLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKCFpbm5lclN1YnNjcmlwdGlvbiB8fCBpbm5lclN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VCdWZmZXIoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbm5lclN1YnNjcmlwdGlvbi5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuYWRkKGlubmVyU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5hZGQoaW5uZXJTdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyVG9nZ2xlU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXJUb2dnbGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL2J1ZmZlclRvZ2dsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQnVmZmVycyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzLCB1c2luZyBhIGZhY3RvcnkgZnVuY3Rpb24gb2YgY2xvc2luZ1xuICogT2JzZXJ2YWJsZXMgdG8gZGV0ZXJtaW5lIHdoZW4gdG8gY2xvc2UsIGVtaXQsIGFuZCByZXNldCB0aGUgYnVmZmVyLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db2xsZWN0cyB2YWx1ZXMgZnJvbSB0aGUgcGFzdCBhcyBhbiBhcnJheS4gV2hlbiBpdFxuICogc3RhcnRzIGNvbGxlY3RpbmcgdmFsdWVzLCBpdCBjYWxscyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXRcbiAqIHRlbGxzIHdoZW4gdG8gY2xvc2UgdGhlIGJ1ZmZlciBhbmQgcmVzdGFydCBjb2xsZWN0aW5nLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2J1ZmZlcldoZW4ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogT3BlbnMgYSBidWZmZXIgaW1tZWRpYXRlbHksIHRoZW4gY2xvc2VzIHRoZSBidWZmZXIgd2hlbiB0aGUgb2JzZXJ2YWJsZVxuICogcmV0dXJuZWQgYnkgY2FsbGluZyBgY2xvc2luZ1NlbGVjdG9yYCBmdW5jdGlvbiBlbWl0cyBhIHZhbHVlLiBXaGVuIGl0IGNsb3Nlc1xuICogdGhlIGJ1ZmZlciwgaXQgaW1tZWRpYXRlbHkgb3BlbnMgYSBuZXcgYnVmZmVyIGFuZCByZXBlYXRzIHRoZSBwcm9jZXNzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgYW4gYXJyYXkgb2YgdGhlIGxhc3QgY2xpY2tzIGV2ZXJ5IFsxLTVdIHJhbmRvbSBzZWNvbmRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJXaGVuKCgpID0+XG4gKiAgIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCArIE1hdGgucmFuZG9tKCkgKiA0MDAwKVxuICogKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKiBAc2VlIHtAbGluayBidWZmZXJDb3VudH1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRpbWV9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUb2dnbGV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dXaGVufVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogT2JzZXJ2YWJsZX0gY2xvc2luZ1NlbGVjdG9yIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBub1xuICogYXJndW1lbnRzIGFuZCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBzaWduYWxzIGJ1ZmZlciBjbG9zdXJlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUW10+fSBBbiBvYnNlcnZhYmxlIG9mIGFycmF5cyBvZiBidWZmZXJlZCB2YWx1ZXMuXG4gKiBAbWV0aG9kIGJ1ZmZlcldoZW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlcldoZW4oY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBCdWZmZXJXaGVuT3BlcmF0b3IoY2xvc2luZ1NlbGVjdG9yKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuYnVmZmVyV2hlbiA9IGJ1ZmZlcldoZW47XG52YXIgQnVmZmVyV2hlbk9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXJXaGVuT3BlcmF0b3IoY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuY2xvc2luZ1NlbGVjdG9yID0gY2xvc2luZ1NlbGVjdG9yO1xuICAgIH1cbiAgICBCdWZmZXJXaGVuT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBCdWZmZXJXaGVuU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmNsb3NpbmdTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlcldoZW5PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEJ1ZmZlcldoZW5TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnVmZmVyV2hlblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnVmZmVyV2hlblN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY2xvc2luZ1NlbGVjdG9yID0gY2xvc2luZ1NlbGVjdG9yO1xuICAgICAgICB0aGlzLnN1YnNjcmliaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3BlbkJ1ZmZlcigpO1xuICAgIH1cbiAgICBCdWZmZXJXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgfTtcbiAgICBCdWZmZXJXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBCdWZmZXJXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJpbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIEJ1ZmZlcldoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMub3BlbkJ1ZmZlcigpO1xuICAgIH07XG4gICAgQnVmZmVyV2hlblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmluZykge1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcGVuQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlcldoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5vcGVuQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xvc2luZ1N1YnNjcmlwdGlvbiA9IHRoaXMuY2xvc2luZ1N1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGNsb3NpbmdTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGNsb3NpbmdTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgY2xvc2luZ1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB2YXIgY2xvc2luZ05vdGlmaWVyID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLmNsb3NpbmdTZWxlY3RvcikoKTtcbiAgICAgICAgaWYgKGNsb3NpbmdOb3RpZmllciA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xvc2luZ1N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2luZ1N1YnNjcmlwdGlvbiA9IGNsb3NpbmdTdWJzY3JpcHRpb247XG4gICAgICAgICAgICB0aGlzLmFkZChjbG9zaW5nU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY2xvc2luZ1N1YnNjcmlwdGlvbi5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBjbG9zaW5nTm90aWZpZXIpKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlcldoZW5TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlcldoZW4uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL2J1ZmZlcldoZW4uanNcbi8vIG1vZHVsZSBpZCA9IDE5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29tYmluZUxhdGVzdF8xID0gcmVxdWlyZSgnLi4vb3BlcmF0b3JzL2NvbWJpbmVMYXRlc3QnKTtcbmZ1bmN0aW9uIGNvbWJpbmVBbGwocHJvamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgY29tYmluZUxhdGVzdF8xLkNvbWJpbmVMYXRlc3RPcGVyYXRvcihwcm9qZWN0KSk7IH07XG59XG5leHBvcnRzLmNvbWJpbmVBbGwgPSBjb21iaW5lQWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tYmluZUFsbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvY29tYmluZUFsbC5qc1xuLy8gbW9kdWxlIGlkID0gMTk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25jYXRfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvY29uY2F0Jyk7XG52YXIgY29uY2F0XzIgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL2NvbmNhdCcpO1xuZXhwb3J0cy5jb25jYXRTdGF0aWMgPSBjb25jYXRfMi5jb25jYXQ7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDcmVhdGVzIGFuIG91dHB1dCBPYnNlcnZhYmxlIHdoaWNoIHNlcXVlbnRpYWxseSBlbWl0cyBhbGwgdmFsdWVzIGZyb20gZXZlcnlcbiAqIGdpdmVuIGlucHV0IE9ic2VydmFibGUgYWZ0ZXIgdGhlIGN1cnJlbnQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29uY2F0ZW5hdGVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5XG4gKiBzZXF1ZW50aWFsbHkgZW1pdHRpbmcgdGhlaXIgdmFsdWVzLCBvbmUgT2JzZXJ2YWJsZSBhZnRlciB0aGUgb3RoZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEpvaW5zIHRoaXMgT2JzZXJ2YWJsZSB3aXRoIG11bHRpcGxlIG90aGVyIE9ic2VydmFibGVzIGJ5IHN1YnNjcmliaW5nIHRvIHRoZW1cbiAqIG9uZSBhdCBhIHRpbWUsIHN0YXJ0aW5nIHdpdGggdGhlIHNvdXJjZSwgYW5kIG1lcmdpbmcgdGhlaXIgcmVzdWx0cyBpbnRvIHRoZVxuICogb3V0cHV0IE9ic2VydmFibGUuIFdpbGwgd2FpdCBmb3IgZWFjaCBPYnNlcnZhYmxlIHRvIGNvbXBsZXRlIGJlZm9yZSBtb3ZpbmdcbiAqIG9uIHRvIHRoZSBuZXh0LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIGEgdGltZXIgY291bnRpbmcgZnJvbSAwIHRvIDMgd2l0aCBhIHN5bmNocm9ub3VzIHNlcXVlbmNlIGZyb20gMSB0byAxMDwvY2FwdGlvbj5cbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg0KTtcbiAqIHZhciBzZXF1ZW5jZSA9IFJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgMTApO1xuICogdmFyIHJlc3VsdCA9IHRpbWVyLmNvbmNhdChzZXF1ZW5jZSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIHJlc3VsdHMgaW46XG4gKiAvLyAxMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAyIC0xMDAwbXMtPiAzIC1pbW1lZGlhdGUtPiAxIC4uLiAxMFxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIDMgT2JzZXJ2YWJsZXM8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIxID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcbiAqIHZhciB0aW1lcjIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDIwMDApLnRha2UoNik7XG4gKiB2YXIgdGltZXIzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLnRha2UoMTApO1xuICogdmFyIHJlc3VsdCA9IHRpbWVyMS5jb25jYXQodGltZXIyLCB0aW1lcjMpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyByZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyAoUHJpbnRzIHRvIGNvbnNvbGUgc2VxdWVudGlhbGx5KVxuICogLy8gLTEwMDBtcy0+IDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IC4uLiA5XG4gKiAvLyAtMjAwMG1zLT4gMCAtMjAwMG1zLT4gMSAtMjAwMG1zLT4gLi4uIDVcbiAqIC8vIC01MDBtcy0+IDAgLTUwMG1zLT4gMSAtNTAwbXMtPiAuLi4gOVxuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcFRvfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBvdGhlciBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbmNhdGVuYXRlIGFmdGVyIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gQW4gb3B0aW9uYWwgSVNjaGVkdWxlciB0byBzY2hlZHVsZSBlYWNoXG4gKiBPYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFsbCB2YWx1ZXMgb2YgZWFjaCBwYXNzZWQgT2JzZXJ2YWJsZSBtZXJnZWQgaW50byBhXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgaW4gb3JkZXIsIGluIHNlcmlhbCBmYXNoaW9uLlxuICogQG1ldGhvZCBjb25jYXRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0LmNhbGwoY29uY2F0XzEuY29uY2F0LmFwcGx5KHZvaWQgMCwgW3NvdXJjZV0uY29uY2F0KG9ic2VydmFibGVzKSkpOyB9O1xufVxuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL2NvbmNhdC5qc1xuLy8gbW9kdWxlIGlkID0gMTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25jYXRNYXBfMSA9IHJlcXVpcmUoJy4vY29uY2F0TWFwJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgc2FtZSBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBtdWx0aXBsZVxuICogdGltZXMgaW4gYSBzZXJpYWxpemVkIGZhc2hpb24gb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGNvbmNhdE1hcH0sIGJ1dCBtYXBzIGVhY2ggdmFsdWVcbiAqIGFsd2F5cyB0byB0aGUgc2FtZSBpbm5lciBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbmNhdE1hcFRvLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIE1hcHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gdGhlIGdpdmVuIE9ic2VydmFibGUgYGlubmVyT2JzZXJ2YWJsZWAgcmVnYXJkbGVzc1xuICogb2YgdGhlIHNvdXJjZSB2YWx1ZSwgYW5kIHRoZW4gZmxhdHRlbnMgdGhvc2UgcmVzdWx0aW5nIE9ic2VydmFibGVzIGludG8gb25lXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgd2hpY2ggaXMgdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBFYWNoIG5ldyBgaW5uZXJPYnNlcnZhYmxlYFxuICogaW5zdGFuY2UgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgaXMgY29uY2F0ZW5hdGVkIHdpdGggdGhlIHByZXZpb3VzXG4gKiBgaW5uZXJPYnNlcnZhYmxlYCBpbnN0YW5jZS5cbiAqXG4gKiBfX1dhcm5pbmc6X18gaWYgc291cmNlIHZhbHVlcyBhcnJpdmUgZW5kbGVzc2x5IGFuZCBmYXN0ZXIgdGhhbiB0aGVpclxuICogY29ycmVzcG9uZGluZyBpbm5lciBPYnNlcnZhYmxlcyBjYW4gY29tcGxldGUsIGl0IHdpbGwgcmVzdWx0IGluIG1lbW9yeSBpc3N1ZXNcbiAqIGFzIGlubmVyIE9ic2VydmFibGVzIGFtYXNzIGluIGFuIHVuYm91bmRlZCBidWZmZXIgd2FpdGluZyBmb3IgdGhlaXIgdHVybiB0b1xuICogYmUgc3Vic2NyaWJlZCB0by5cbiAqXG4gKiBOb3RlOiBgY29uY2F0TWFwVG9gIGlzIGVxdWl2YWxlbnQgdG8gYG1lcmdlTWFwVG9gIHdpdGggY29uY3VycmVuY3kgcGFyYW1ldGVyXG4gKiBzZXQgdG8gYDFgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkZvciBlYWNoIGNsaWNrIGV2ZW50LCB0aWNrIGV2ZXJ5IHNlY29uZCBmcm9tIDAgdG8gMywgd2l0aCBubyBjb25jdXJyZW5jeTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmNvbmNhdE1hcFRvKFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg0KSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIChyZXN1bHRzIGFyZSBub3QgY29uY3VycmVudClcbiAqIC8vIEZvciBldmVyeSBjbGljayBvbiB0aGUgXCJkb2N1bWVudFwiIGl0IHdpbGwgZW1pdCB2YWx1ZXMgMCB0byAzIHNwYWNlZFxuICogLy8gb24gYSAxMDAwbXMgaW50ZXJ2YWxcbiAqIC8vIG9uZSBjbGljayA9IDEwMDBtcy0+IDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IDIgLTEwMDBtcy0+IDNcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXR9XG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcFRvfVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwVG99XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IGlubmVyT2JzZXJ2YWJsZSBBbiBPYnNlcnZhYmxlIHRvIHJlcGxhY2UgZWFjaCB2YWx1ZSBmcm9tXG4gKiB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBvZiB2YWx1ZXMgbWVyZ2VkIHRvZ2V0aGVyIGJ5IGpvaW5pbmcgdGhlXG4gKiBwYXNzZWQgb2JzZXJ2YWJsZSB3aXRoIGl0c2VsZiwgb25lIGFmdGVyIHRoZSBvdGhlciwgZm9yIGVhY2ggdmFsdWUgZW1pdHRlZFxuICogZnJvbSB0aGUgc291cmNlLlxuICogQG1ldGhvZCBjb25jYXRNYXBUb1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gY29uY2F0TWFwVG8oaW5uZXJPYnNlcnZhYmxlLCByZXN1bHRTZWxlY3Rvcikge1xuICAgIHJldHVybiBjb25jYXRNYXBfMS5jb25jYXRNYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5uZXJPYnNlcnZhYmxlOyB9LCByZXN1bHRTZWxlY3Rvcik7XG59XG5leHBvcnRzLmNvbmNhdE1hcFRvID0gY29uY2F0TWFwVG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXRNYXBUby5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvY29uY2F0TWFwVG8uanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGVtaXNzaW9ucyBvbiB0aGUgc291cmNlIGFuZCBlbWl0cyB0aGF0IG51bWJlciB3aGVuIHRoZVxuICogc291cmNlIGNvbXBsZXRlcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+VGVsbHMgaG93IG1hbnkgdmFsdWVzIHdlcmUgZW1pdHRlZCwgd2hlbiB0aGUgc291cmNlXG4gKiBjb21wbGV0ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY291bnQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGNvdW50YCB0cmFuc2Zvcm1zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB2YWx1ZXMgaW50byBhbiBPYnNlcnZhYmxlIHRoYXRcbiAqIGVtaXRzIGEgc2luZ2xlIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZVxuICogc291cmNlIE9ic2VydmFibGUuIElmIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0ZXJtaW5hdGVzIHdpdGggYW4gZXJyb3IsIGBjb3VudGBcbiAqIHdpbGwgcGFzcyB0aGlzIGVycm9yIG5vdGlmaWNhdGlvbiBhbG9uZyB3aXRob3V0IGVtaXR0aW5nIGEgdmFsdWUgZmlyc3QuIElmXG4gKiB0aGUgc291cmNlIE9ic2VydmFibGUgZG9lcyBub3QgdGVybWluYXRlIGF0IGFsbCwgYGNvdW50YCB3aWxsIG5laXRoZXIgZW1pdFxuICogYSB2YWx1ZSBub3IgdGVybWluYXRlLiBUaGlzIG9wZXJhdG9yIHRha2VzIGFuIG9wdGlvbmFsIGBwcmVkaWNhdGVgIGZ1bmN0aW9uXG4gKiBhcyBhcmd1bWVudCwgaW4gd2hpY2ggY2FzZSB0aGUgb3V0cHV0IGVtaXNzaW9uIHdpbGwgcmVwcmVzZW50IHRoZSBudW1iZXIgb2ZcbiAqIHNvdXJjZSB2YWx1ZXMgdGhhdCBtYXRjaGVkIGB0cnVlYCB3aXRoIHRoZSBgcHJlZGljYXRlYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db3VudHMgaG93IG1hbnkgc2Vjb25kcyBoYXZlIHBhc3NlZCBiZWZvcmUgdGhlIGZpcnN0IGNsaWNrIGhhcHBlbmVkPC9jYXB0aW9uPlxuICogdmFyIHNlY29uZHMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBzZWNvbmRzQmVmb3JlQ2xpY2sgPSBzZWNvbmRzLnRha2VVbnRpbChjbGlja3MpO1xuICogdmFyIHJlc3VsdCA9IHNlY29uZHNCZWZvcmVDbGljay5jb3VudCgpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db3VudHMgaG93IG1hbnkgb2RkIG51bWJlcnMgYXJlIHRoZXJlIGJldHdlZW4gMSBhbmQgNzwvY2FwdGlvbj5cbiAqIHZhciBudW1iZXJzID0gUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCA3KTtcbiAqIHZhciByZXN1bHQgPSBudW1iZXJzLmNvdW50KGkgPT4gaSAlIDIgPT09IDEpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluOlxuICogLy8gNFxuICpcbiAqIEBzZWUge0BsaW5rIG1heH1cbiAqIEBzZWUge0BsaW5rIG1pbn1cbiAqIEBzZWUge0BsaW5rIHJlZHVjZX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpOiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPik6IGJvb2xlYW59IFtwcmVkaWNhdGVdIEFcbiAqIGJvb2xlYW4gZnVuY3Rpb24gdG8gc2VsZWN0IHdoYXQgdmFsdWVzIGFyZSB0byBiZSBjb3VudGVkLiBJdCBpcyBwcm92aWRlZCB3aXRoXG4gKiBhcmd1bWVudHMgb2Y6XG4gKiAtIGB2YWx1ZWA6IHRoZSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIC0gYGluZGV4YDogdGhlICh6ZXJvLWJhc2VkKSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogLSBgc291cmNlYDogdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGluc3RhbmNlIGl0c2VsZi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2Ygb25lIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIGNvdW50IGFzXG4gKiBkZXNjcmliZWQgYWJvdmUuXG4gKiBAbWV0aG9kIGNvdW50XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjb3VudChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IENvdW50T3BlcmF0b3IocHJlZGljYXRlLCBzb3VyY2UpKTsgfTtcbn1cbmV4cG9ydHMuY291bnQgPSBjb3VudDtcbnZhciBDb3VudE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb3VudE9wZXJhdG9yKHByZWRpY2F0ZSwgc291cmNlKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgQ291bnRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IENvdW50U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBDb3VudE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQ291bnRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ291bnRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvdW50U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5wcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeVByZWRpY2F0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeVByZWRpY2F0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUodmFsdWUsIHRoaXMuaW5kZXgrKywgdGhpcy5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5jb3VudCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBDb3VudFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3VudC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvY291bnQuanNcbi8vIG1vZHVsZSBpZCA9IDIwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb25seSBhZnRlciBhIHBhcnRpY3VsYXIgdGltZSBzcGFuXG4gKiBkZXRlcm1pbmVkIGJ5IGFub3RoZXIgT2JzZXJ2YWJsZSBoYXMgcGFzc2VkIHdpdGhvdXQgYW5vdGhlciBzb3VyY2UgZW1pc3Npb24uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZGVib3VuY2VUaW1lfSwgYnV0IHRoZSB0aW1lIHNwYW4gb2ZcbiAqIGVtaXNzaW9uIHNpbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSBhIHNlY29uZCBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlYm91bmNlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBkZWJvdW5jZWAgZGVsYXlzIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IGRyb3BzIHByZXZpb3VzXG4gKiBwZW5kaW5nIGRlbGF5ZWQgZW1pc3Npb25zIGlmIGEgbmV3IHZhbHVlIGFycml2ZXMgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogVGhpcyBvcGVyYXRvciBrZWVwcyB0cmFjayBvZiB0aGUgbW9zdCByZWNlbnQgdmFsdWUgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLCBhbmQgc3Bhd25zIGEgZHVyYXRpb24gT2JzZXJ2YWJsZSBieSBjYWxsaW5nIHRoZVxuICogYGR1cmF0aW9uU2VsZWN0b3JgIGZ1bmN0aW9uLiBUaGUgdmFsdWUgaXMgZW1pdHRlZCBvbmx5IHdoZW4gdGhlIGR1cmF0aW9uXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUgb3IgY29tcGxldGVzLCBhbmQgaWYgbm8gb3RoZXIgdmFsdWUgd2FzIGVtaXR0ZWQgb25cbiAqIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBzaW5jZSB0aGUgZHVyYXRpb24gT2JzZXJ2YWJsZSB3YXMgc3Bhd25lZC4gSWYgYSBuZXdcbiAqIHZhbHVlIGFwcGVhcnMgYmVmb3JlIHRoZSBkdXJhdGlvbiBPYnNlcnZhYmxlIGVtaXRzLCB0aGUgcHJldmlvdXMgdmFsdWUgd2lsbFxuICogYmUgZHJvcHBlZCBhbmQgd2lsbCBub3QgYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogTGlrZSB7QGxpbmsgZGVib3VuY2VUaW1lfSwgdGhpcyBpcyBhIHJhdGUtbGltaXRpbmcgb3BlcmF0b3IsIGFuZCBhbHNvIGFcbiAqIGRlbGF5LWxpa2Ugb3BlcmF0b3Igc2luY2Ugb3V0cHV0IGVtaXNzaW9ucyBkbyBub3QgbmVjZXNzYXJpbHkgb2NjdXIgYXQgdGhlXG4gKiBzYW1lIHRpbWUgYXMgdGhleSBkaWQgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIG1vc3QgcmVjZW50IGNsaWNrIGFmdGVyIGEgYnVyc3Qgb2YgY2xpY2tzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZGVib3VuY2UoKCkgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0fVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2VUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVsYXlXaGVufVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGV9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IFN1YnNjcmliYWJsZU9yUHJvbWlzZX0gZHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uXG4gKiB0aGF0IHJlY2VpdmVzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIGZvciBjb21wdXRpbmcgdGhlIHRpbWVvdXRcbiAqIGR1cmF0aW9uIGZvciBlYWNoIHNvdXJjZSB2YWx1ZSwgcmV0dXJuZWQgYXMgYW4gT2JzZXJ2YWJsZSBvciBhIFByb21pc2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZGVsYXlzIHRoZSBlbWlzc2lvbnMgb2YgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIE9ic2VydmFibGUgcmV0dXJuZWQgYnlcbiAqIGBkdXJhdGlvblNlbGVjdG9yYCwgYW5kIG1heSBkcm9wIHNvbWUgdmFsdWVzIGlmIHRoZXkgb2NjdXIgdG9vIGZyZXF1ZW50bHkuXG4gKiBAbWV0aG9kIGRlYm91bmNlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZWJvdW5jZShkdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBEZWJvdW5jZU9wZXJhdG9yKGR1cmF0aW9uU2VsZWN0b3IpKTsgfTtcbn1cbmV4cG9ydHMuZGVib3VuY2UgPSBkZWJvdW5jZTtcbnZhciBEZWJvdW5jZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZU9wZXJhdG9yKGR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICB9XG4gICAgRGVib3VuY2VPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlYm91bmNlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmR1cmF0aW9uU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWJvdW5jZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGVib3VuY2VTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVib3VuY2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlYm91bmNlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZHVyYXRpb25TZWxlY3RvciA9IGR1cmF0aW9uU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kdXJhdGlvblN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIERlYm91bmNlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmR1cmF0aW9uU2VsZWN0b3IuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5TmV4dCh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlYm91bmNlU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXRWYWx1ZSgpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBEZWJvdW5jZVN1YnNjcmliZXIucHJvdG90eXBlLl90cnlOZXh0ID0gZnVuY3Rpb24gKHZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5kdXJhdGlvblN1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShzdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgZHVyYXRpb24pO1xuICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMuZHVyYXRpb25TdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJvdW5jZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5lbWl0VmFsdWUoKTtcbiAgICB9O1xuICAgIERlYm91bmNlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdFZhbHVlKCk7XG4gICAgfTtcbiAgICBEZWJvdW5jZVN1YnNjcmliZXIucHJvdG90eXBlLmVtaXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5kdXJhdGlvblN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR1cmF0aW9uU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9uZXh0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVib3VuY2VTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9kZWJvdW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMjAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG4vKipcbiAqIEVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb25seSBhZnRlciBhIHBhcnRpY3VsYXIgdGltZSBzcGFuXG4gKiBoYXMgcGFzc2VkIHdpdGhvdXQgYW5vdGhlciBzb3VyY2UgZW1pc3Npb24uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZGVsYXl9LCBidXQgcGFzc2VzIG9ubHkgdGhlIG1vc3RcbiAqIHJlY2VudCB2YWx1ZSBmcm9tIGVhY2ggYnVyc3Qgb2YgZW1pc3Npb25zLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlYm91bmNlVGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgZGVib3VuY2VUaW1lYCBkZWxheXMgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBidXQgZHJvcHNcbiAqIHByZXZpb3VzIHBlbmRpbmcgZGVsYXllZCBlbWlzc2lvbnMgaWYgYSBuZXcgdmFsdWUgYXJyaXZlcyBvbiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGlzIG9wZXJhdG9yIGtlZXBzIHRyYWNrIG9mIHRoZSBtb3N0IHJlY2VudCB2YWx1ZSBmcm9tIHRoZVxuICogc291cmNlIE9ic2VydmFibGUsIGFuZCBlbWl0cyB0aGF0IG9ubHkgd2hlbiBgZHVlVGltZWAgZW5vdWdoIHRpbWUgaGFzIHBhc3NlZFxuICogd2l0aG91dCBhbnkgb3RoZXIgdmFsdWUgYXBwZWFyaW5nIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgYSBuZXcgdmFsdWVcbiAqIGFwcGVhcnMgYmVmb3JlIGBkdWVUaW1lYCBzaWxlbmNlIG9jY3VycywgdGhlIHByZXZpb3VzIHZhbHVlIHdpbGwgYmUgZHJvcHBlZFxuICogYW5kIHdpbGwgbm90IGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIFRoaXMgaXMgYSByYXRlLWxpbWl0aW5nIG9wZXJhdG9yLCBiZWNhdXNlIGl0IGlzIGltcG9zc2libGUgZm9yIG1vcmUgdGhhbiBvbmVcbiAqIHZhbHVlIHRvIGJlIGVtaXR0ZWQgaW4gYW55IHRpbWUgd2luZG93IG9mIGR1cmF0aW9uIGBkdWVUaW1lYCwgYnV0IGl0IGlzIGFsc29cbiAqIGEgZGVsYXktbGlrZSBvcGVyYXRvciBzaW5jZSBvdXRwdXQgZW1pc3Npb25zIGRvIG5vdCBvY2N1ciBhdCB0aGUgc2FtZSB0aW1lIGFzXG4gKiB0aGV5IGRpZCBvbiB0aGUgc291cmNlIE9ic2VydmFibGUuIE9wdGlvbmFsbHkgdGFrZXMgYSB7QGxpbmsgSVNjaGVkdWxlcn0gZm9yXG4gKiBtYW5hZ2luZyB0aW1lcnMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbW9zdCByZWNlbnQgY2xpY2sgYWZ0ZXIgYSBidXJzdCBvZiBjbGlja3M8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5kZWJvdW5jZVRpbWUoMTAwMCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0VGltZX1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlfVxuICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gKiBAc2VlIHtAbGluayBzYW1wbGVUaW1lfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGVUaW1lfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdWVUaW1lIFRoZSB0aW1lb3V0IGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyAob3IgdGhlIHRpbWVcbiAqIHVuaXQgZGV0ZXJtaW5lZCBpbnRlcm5hbGx5IGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYCkgZm9yIHRoZSB3aW5kb3cgb2ZcbiAqIHRpbWUgcmVxdWlyZWQgdG8gd2FpdCBmb3IgZW1pc3Npb24gc2lsZW5jZSBiZWZvcmUgZW1pdHRpbmcgdGhlIG1vc3QgcmVjZW50XG4gKiBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSB0aW1lb3V0IGZvciBlYWNoIHZhbHVlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGRlbGF5cyB0aGUgZW1pc3Npb25zIG9mIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgdGhlIHNwZWNpZmllZCBgZHVlVGltZWAsIGFuZCBtYXkgZHJvcCBzb21lIHZhbHVlcyBpZiB0aGV5IG9jY3VyXG4gKiB0b28gZnJlcXVlbnRseS5cbiAqIEBtZXRob2QgZGVib3VuY2VUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZWJvdW5jZVRpbWUoZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IERlYm91bmNlVGltZU9wZXJhdG9yKGR1ZVRpbWUsIHNjaGVkdWxlcikpOyB9O1xufVxuZXhwb3J0cy5kZWJvdW5jZVRpbWUgPSBkZWJvdW5jZVRpbWU7XG52YXIgRGVib3VuY2VUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlYm91bmNlVGltZU9wZXJhdG9yKGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSBkdWVUaW1lO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgRGVib3VuY2VUaW1lT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZHVlVGltZSwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWJvdW5jZVRpbWVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERlYm91bmNlVGltZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlYm91bmNlVGltZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IGR1ZVRpbWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmRlYm91bmNlZFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNsZWFyRGVib3VuY2UoKTtcbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCB0aGlzLmR1ZVRpbWUsIHRoaXMpKTtcbiAgICB9O1xuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWROZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLmRlYm91bmNlZE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJEZWJvdW5jZSgpO1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMubGFzdFZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuY2xlYXJEZWJvdW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlYm91bmNlZFN1YnNjcmlwdGlvbiA9IHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoZGVib3VuY2VkU3Vic2NyaXB0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShkZWJvdW5jZWRTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgZGVib3VuY2VkU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlZFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZnVuY3Rpb24gZGlzcGF0Y2hOZXh0KHN1YnNjcmliZXIpIHtcbiAgICBzdWJzY3JpYmVyLmRlYm91bmNlZE5leHQoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlVGltZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvZGVib3VuY2VUaW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIGlzRGF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0RhdGUnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgTm90aWZpY2F0aW9uXzEgPSByZXF1aXJlKCcuLi9Ob3RpZmljYXRpb24nKTtcbi8qKlxuICogRGVsYXlzIHRoZSBlbWlzc2lvbiBvZiBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBieSBhIGdpdmVuIHRpbWVvdXQgb3JcbiAqIHVudGlsIGEgZ2l2ZW4gRGF0ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+VGltZSBzaGlmdHMgZWFjaCBpdGVtIGJ5IHNvbWUgc3BlY2lmaWVkIGFtb3VudCBvZlxuICogbWlsbGlzZWNvbmRzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlbGF5LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIElmIHRoZSBkZWxheSBhcmd1bWVudCBpcyBhIE51bWJlciwgdGhpcyBvcGVyYXRvciB0aW1lIHNoaWZ0cyB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGJ5IHRoYXQgYW1vdW50IG9mIHRpbWUgZXhwcmVzc2VkIGluIG1pbGxpc2Vjb25kcy4gVGhlIHJlbGF0aXZlXG4gKiB0aW1lIGludGVydmFscyBiZXR3ZWVuIHRoZSB2YWx1ZXMgYXJlIHByZXNlcnZlZC5cbiAqXG4gKiBJZiB0aGUgZGVsYXkgYXJndW1lbnQgaXMgYSBEYXRlLCB0aGlzIG9wZXJhdG9yIHRpbWUgc2hpZnRzIHRoZSBzdGFydCBvZiB0aGVcbiAqIE9ic2VydmFibGUgZXhlY3V0aW9uIHVudGlsIHRoZSBnaXZlbiBkYXRlIG9jY3Vycy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWxheSBlYWNoIGNsaWNrIGJ5IG9uZSBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGRlbGF5ZWRDbGlja3MgPSBjbGlja3MuZGVsYXkoMTAwMCk7IC8vIGVhY2ggY2xpY2sgZW1pdHRlZCBhZnRlciAxIHNlY29uZFxuICogZGVsYXllZENsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RGVsYXkgYWxsIGNsaWNrcyB1bnRpbCBhIGZ1dHVyZSBkYXRlIGhhcHBlbnM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGRhdGUgPSBuZXcgRGF0ZSgnTWFyY2ggMTUsIDIwNTAgMTI6MDA6MDAnKTsgLy8gaW4gdGhlIGZ1dHVyZVxuICogdmFyIGRlbGF5ZWRDbGlja3MgPSBjbGlja3MuZGVsYXkoZGF0ZSk7IC8vIGNsaWNrIGVtaXR0ZWQgb25seSBhZnRlciB0aGF0IGRhdGVcbiAqIGRlbGF5ZWRDbGlja3Muc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlVGltZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5V2hlbn1cbiAqXG4gKiBAcGFyYW0ge251bWJlcnxEYXRlfSBkZWxheSBUaGUgZGVsYXkgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIChhIGBudW1iZXJgKSBvclxuICogYSBgRGF0ZWAgdW50aWwgd2hpY2ggdGhlIGVtaXNzaW9uIG9mIHRoZSBzb3VyY2UgaXRlbXMgaXMgZGVsYXllZC5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPWFzeW5jXSBUaGUgSVNjaGVkdWxlciB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSB0aW1lLXNoaWZ0IGZvciBlYWNoIGl0ZW0uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZGVsYXlzIHRoZSBlbWlzc2lvbnMgb2YgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSB0aGUgc3BlY2lmaWVkIHRpbWVvdXQgb3IgRGF0ZS5cbiAqIEBtZXRob2QgZGVsYXlcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRlbGF5KGRlbGF5LCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHZhciBhYnNvbHV0ZURlbGF5ID0gaXNEYXRlXzEuaXNEYXRlKGRlbGF5KTtcbiAgICB2YXIgZGVsYXlGb3IgPSBhYnNvbHV0ZURlbGF5ID8gKCtkZWxheSAtIHNjaGVkdWxlci5ub3coKSkgOiBNYXRoLmFicyhkZWxheSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBEZWxheU9wZXJhdG9yKGRlbGF5Rm9yLCBzY2hlZHVsZXIpKTsgfTtcbn1cbmV4cG9ydHMuZGVsYXkgPSBkZWxheTtcbnZhciBEZWxheU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWxheU9wZXJhdG9yKGRlbGF5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgRGVsYXlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlbGF5U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmRlbGF5LCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIERlbGF5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEZWxheVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWxheVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVsYXlTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkZWxheSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVycm9yZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgRGVsYXlTdWJzY3JpYmVyLmRpc3BhdGNoID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzdGF0ZS5zb3VyY2U7XG4gICAgICAgIHZhciBxdWV1ZSA9IHNvdXJjZS5xdWV1ZTtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHN0YXRlLnNjaGVkdWxlcjtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gc3RhdGUuZGVzdGluYXRpb247XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwICYmIChxdWV1ZVswXS50aW1lIC0gc2NoZWR1bGVyLm5vdygpKSA8PSAwKSB7XG4gICAgICAgICAgICBxdWV1ZS5zaGlmdCgpLm5vdGlmaWNhdGlvbi5vYnNlcnZlKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGRlbGF5XzEgPSBNYXRoLm1heCgwLCBxdWV1ZVswXS50aW1lIC0gc2NoZWR1bGVyLm5vdygpKTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUsIGRlbGF5XzEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc291cmNlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9zY2hlZHVsZSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoRGVsYXlTdWJzY3JpYmVyLmRpc3BhdGNoLCB0aGlzLmRlbGF5LCB7XG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMsIGRlc3RpbmF0aW9uOiB0aGlzLmRlc3RpbmF0aW9uLCBzY2hlZHVsZXI6IHNjaGVkdWxlclxuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBEZWxheVN1YnNjcmliZXIucHJvdG90eXBlLnNjaGVkdWxlTm90aWZpY2F0aW9uID0gZnVuY3Rpb24gKG5vdGlmaWNhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5lcnJvcmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyBEZWxheU1lc3NhZ2Uoc2NoZWR1bGVyLm5vdygpICsgdGhpcy5kZWxheSwgbm90aWZpY2F0aW9uKTtcbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZU5leHQodmFsdWUpKTtcbiAgICB9O1xuICAgIERlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmVycm9yZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIERlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSgpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWxheVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG52YXIgRGVsYXlNZXNzYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWxheU1lc3NhZ2UodGltZSwgbm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gRGVsYXlNZXNzYWdlO1xufSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGF5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9kZWxheS5qc1xuLy8gbW9kdWxlIGlkID0gMjAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBEZWxheXMgdGhlIGVtaXNzaW9uIG9mIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJ5IGEgZ2l2ZW4gdGltZSBzcGFuXG4gKiBkZXRlcm1pbmVkIGJ5IHRoZSBlbWlzc2lvbnMgb2YgYW5vdGhlciBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGRlbGF5fSwgYnV0IHRoZSB0aW1lIHNwYW4gb2YgdGhlXG4gKiBkZWxheSBkdXJhdGlvbiBpcyBkZXRlcm1pbmVkIGJ5IGEgc2Vjb25kIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZGVsYXlXaGVuLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBkZWxheVdoZW5gIHRpbWUgc2hpZnRzIGVhY2ggZW1pdHRlZCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBieSBhXG4gKiB0aW1lIHNwYW4gZGV0ZXJtaW5lZCBieSBhbm90aGVyIE9ic2VydmFibGUuIFdoZW4gdGhlIHNvdXJjZSBlbWl0cyBhIHZhbHVlLFxuICogdGhlIGBkZWxheUR1cmF0aW9uU2VsZWN0b3JgIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBzb3VyY2UgdmFsdWUgYXNcbiAqIGFyZ3VtZW50LCBhbmQgc2hvdWxkIHJldHVybiBhbiBPYnNlcnZhYmxlLCBjYWxsZWQgdGhlIFwiZHVyYXRpb25cIiBPYnNlcnZhYmxlLlxuICogVGhlIHNvdXJjZSB2YWx1ZSBpcyBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBvbmx5IHdoZW4gdGhlIGR1cmF0aW9uXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUgb3IgY29tcGxldGVzLlxuICpcbiAqIE9wdGlvbmFsbHksIGBkZWxheVdoZW5gIHRha2VzIGEgc2Vjb25kIGFyZ3VtZW50LCBgc3Vic2NyaXB0aW9uRGVsYXlgLCB3aGljaFxuICogaXMgYW4gT2JzZXJ2YWJsZS4gV2hlbiBgc3Vic2NyaXB0aW9uRGVsYXlgIGVtaXRzIGl0cyBmaXJzdCB2YWx1ZSBvclxuICogY29tcGxldGVzLCB0aGUgc291cmNlIE9ic2VydmFibGUgaXMgc3Vic2NyaWJlZCB0byBhbmQgc3RhcnRzIGJlaGF2aW5nIGxpa2VcbiAqIGRlc2NyaWJlZCBpbiB0aGUgcHJldmlvdXMgcGFyYWdyYXBoLiBJZiBgc3Vic2NyaXB0aW9uRGVsYXlgIGlzIG5vdCBwcm92aWRlZCxcbiAqIGBkZWxheVdoZW5gIHdpbGwgc3Vic2NyaWJlIHRvIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhcyBzb29uIGFzIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUgaXMgc3Vic2NyaWJlZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWxheSBlYWNoIGNsaWNrIGJ5IGEgcmFuZG9tIGFtb3VudCBvZiB0aW1lLCBiZXR3ZWVuIDAgYW5kIDUgc2Vjb25kczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgZGVsYXllZENsaWNrcyA9IGNsaWNrcy5kZWxheVdoZW4oZXZlbnQgPT5cbiAqICAgUnguT2JzZXJ2YWJsZS5pbnRlcnZhbChNYXRoLnJhbmRvbSgpICogNTAwMClcbiAqICk7XG4gKiBkZWxheWVkQ2xpY2tzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQpOiBPYnNlcnZhYmxlfSBkZWxheUR1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvbiB0aGF0XG4gKiByZXR1cm5zIGFuIE9ic2VydmFibGUgZm9yIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHdoaWNoXG4gKiBpcyB0aGVuIHVzZWQgdG8gZGVsYXkgdGhlIGVtaXNzaW9uIG9mIHRoYXQgaXRlbSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGVcbiAqIHVudGlsIHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGZyb20gdGhpcyBmdW5jdGlvbiBlbWl0cyBhIHZhbHVlLlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBzdWJzY3JpcHRpb25EZWxheSBBbiBPYnNlcnZhYmxlIHRoYXQgdHJpZ2dlcnMgdGhlXG4gKiBzdWJzY3JpcHRpb24gdG8gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIG9uY2UgaXQgZW1pdHMgYW55IHZhbHVlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGRlbGF5cyB0aGUgZW1pc3Npb25zIG9mIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgYW4gYW1vdW50IG9mIHRpbWUgc3BlY2lmaWVkIGJ5IHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGJ5XG4gKiBgZGVsYXlEdXJhdGlvblNlbGVjdG9yYC5cbiAqIEBtZXRob2QgZGVsYXlXaGVuXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZWxheVdoZW4oZGVsYXlEdXJhdGlvblNlbGVjdG9yLCBzdWJzY3JpcHRpb25EZWxheSkge1xuICAgIGlmIChzdWJzY3JpcHRpb25EZWxheSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25EZWxheU9ic2VydmFibGUoc291cmNlLCBzdWJzY3JpcHRpb25EZWxheSlcbiAgICAgICAgICAgICAgICAubGlmdChuZXcgRGVsYXlXaGVuT3BlcmF0b3IoZGVsYXlEdXJhdGlvblNlbGVjdG9yKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgRGVsYXlXaGVuT3BlcmF0b3IoZGVsYXlEdXJhdGlvblNlbGVjdG9yKSk7IH07XG59XG5leHBvcnRzLmRlbGF5V2hlbiA9IGRlbGF5V2hlbjtcbnZhciBEZWxheVdoZW5PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVsYXlXaGVuT3BlcmF0b3IoZGVsYXlEdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuZGVsYXlEdXJhdGlvblNlbGVjdG9yID0gZGVsYXlEdXJhdGlvblNlbGVjdG9yO1xuICAgIH1cbiAgICBEZWxheVdoZW5PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlbGF5V2hlblN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kZWxheUR1cmF0aW9uU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWxheVdoZW5PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERlbGF5V2hlblN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWxheVdoZW5TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlbGF5V2hlblN1YnNjcmliZXIoZGVzdGluYXRpb24sIGRlbGF5RHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVsYXlEdXJhdGlvblNlbGVjdG9yID0gZGVsYXlEdXJhdGlvblNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGF5Tm90aWZpZXJTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgfVxuICAgIERlbGF5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KG91dGVyVmFsdWUpO1xuICAgICAgICB0aGlzLnJlbW92ZVN1YnNjcmlwdGlvbihpbm5lclN1Yik7XG4gICAgICAgIHRoaXMudHJ5Q29tcGxldGUoKTtcbiAgICB9O1xuICAgIERlbGF5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLl9lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnJlbW92ZVN1YnNjcmlwdGlvbihpbm5lclN1Yik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyeUNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGRlbGF5Tm90aWZpZXIgPSB0aGlzLmRlbGF5RHVyYXRpb25TZWxlY3Rvcih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZGVsYXlOb3RpZmllcikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5RGVsYXkoZGVsYXlOb3RpZmllciwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVsYXlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudHJ5Q29tcGxldGUoKTtcbiAgICB9O1xuICAgIERlbGF5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLnJlbW92ZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25JZHggPSB0aGlzLmRlbGF5Tm90aWZpZXJTdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbklkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZXNbc3Vic2NyaXB0aW9uSWR4XTtcbiAgICAgICAgICAgIHRoaXMuZGVsYXlOb3RpZmllclN1YnNjcmlwdGlvbnMuc3BsaWNlKHN1YnNjcmlwdGlvbklkeCwgMSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2Uoc3Vic2NyaXB0aW9uSWR4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS50cnlEZWxheSA9IGZ1bmN0aW9uIChkZWxheU5vdGlmaWVyLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbm90aWZpZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGRlbGF5Tm90aWZpZXIsIHZhbHVlKTtcbiAgICAgICAgaWYgKG5vdGlmaWVyU3Vic2NyaXB0aW9uICYmICFub3RpZmllclN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKG5vdGlmaWVyU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuZGVsYXlOb3RpZmllclN1YnNjcmlwdGlvbnMucHVzaChub3RpZmllclN1YnNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfTtcbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS50cnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGxldGVkICYmIHRoaXMuZGVsYXlOb3RpZmllclN1YnNjcmlwdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWxheVdoZW5TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3Vic2NyaXB0aW9uRGVsYXlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3Vic2NyaXB0aW9uRGVsYXlPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbkRlbGF5T2JzZXJ2YWJsZShzb3VyY2UsIHN1YnNjcmlwdGlvbkRlbGF5KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25EZWxheSA9IHN1YnNjcmlwdGlvbkRlbGF5O1xuICAgIH1cbiAgICBTdWJzY3JpcHRpb25EZWxheU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkRlbGF5LnN1YnNjcmliZShuZXcgU3Vic2NyaXB0aW9uRGVsYXlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uRGVsYXlPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uRGVsYXlTdWJzY3JpYmVyKHBhcmVudCwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuc291cmNlU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHVudXNlZCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvU291cmNlKCk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnBhcmVudC5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9Tb3VyY2UoKTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuc3Vic2NyaWJlVG9Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zb3VyY2VTdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHRoaXMucGFyZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGF5V2hlbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvZGVsYXlXaGVuLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBPYnNlcnZhYmxlIG9mIHtAbGluayBOb3RpZmljYXRpb259IG9iamVjdHMgaW50byB0aGUgZW1pc3Npb25zXG4gKiB0aGF0IHRoZXkgcmVwcmVzZW50LlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5VbndyYXBzIHtAbGluayBOb3RpZmljYXRpb259IG9iamVjdHMgYXMgYWN0dWFsIGBuZXh0YCxcbiAqIGBlcnJvcmAgYW5kIGBjb21wbGV0ZWAgZW1pc3Npb25zLiBUaGUgb3Bwb3NpdGUgb2Yge0BsaW5rIG1hdGVyaWFsaXplfS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kZW1hdGVyaWFsaXplLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBkZW1hdGVyaWFsaXplYCBpcyBhc3N1bWVkIHRvIG9wZXJhdGUgYW4gT2JzZXJ2YWJsZSB0aGF0IG9ubHkgZW1pdHNcbiAqIHtAbGluayBOb3RpZmljYXRpb259IG9iamVjdHMgYXMgYG5leHRgIGVtaXNzaW9ucywgYW5kIGRvZXMgbm90IGVtaXQgYW55XG4gKiBgZXJyb3JgLiBTdWNoIE9ic2VydmFibGUgaXMgdGhlIG91dHB1dCBvZiBhIGBtYXRlcmlhbGl6ZWAgb3BlcmF0aW9uLiBUaG9zZVxuICogbm90aWZpY2F0aW9ucyBhcmUgdGhlbiB1bndyYXBwZWQgdXNpbmcgdGhlIG1ldGFkYXRhIHRoZXkgY29udGFpbiwgYW5kIGVtaXR0ZWRcbiAqIGFzIGBuZXh0YCwgYGVycm9yYCwgYW5kIGBjb21wbGV0ZWAgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIFVzZSB0aGlzIG9wZXJhdG9yIGluIGNvbmp1bmN0aW9uIHdpdGgge0BsaW5rIG1hdGVyaWFsaXplfS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IGFuIE9ic2VydmFibGUgb2YgTm90aWZpY2F0aW9ucyB0byBhbiBhY3R1YWwgT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAqIHZhciBub3RpZkEgPSBuZXcgUnguTm90aWZpY2F0aW9uKCdOJywgJ0EnKTtcbiAqIHZhciBub3RpZkIgPSBuZXcgUnguTm90aWZpY2F0aW9uKCdOJywgJ0InKTtcbiAqIHZhciBub3RpZkUgPSBuZXcgUnguTm90aWZpY2F0aW9uKCdFJywgdm9pZCAwLFxuICogICBuZXcgVHlwZUVycm9yKCd4LnRvVXBwZXJDYXNlIGlzIG5vdCBhIGZ1bmN0aW9uJylcbiAqICk7XG4gKiB2YXIgbWF0ZXJpYWxpemVkID0gUnguT2JzZXJ2YWJsZS5vZihub3RpZkEsIG5vdGlmQiwgbm90aWZFKTtcbiAqIHZhciB1cHBlckNhc2UgPSBtYXRlcmlhbGl6ZWQuZGVtYXRlcmlhbGl6ZSgpO1xuICogdXBwZXJDYXNlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpLCBlID0+IGNvbnNvbGUuZXJyb3IoZSkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW46XG4gKiAvLyBBXG4gKiAvLyBCXG4gKiAvLyBUeXBlRXJyb3I6IHgudG9VcHBlckNhc2UgaXMgbm90IGEgZnVuY3Rpb25cbiAqXG4gKiBAc2VlIHtAbGluayBOb3RpZmljYXRpb259XG4gKiBAc2VlIHtAbGluayBtYXRlcmlhbGl6ZX1cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYW5kIG5vdGlmaWNhdGlvbnNcbiAqIGVtYmVkZGVkIGluIE5vdGlmaWNhdGlvbiBvYmplY3RzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBkZW1hdGVyaWFsaXplXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZW1hdGVyaWFsaXplKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZW1hdGVyaWFsaXplT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBEZU1hdGVyaWFsaXplT3BlcmF0b3IoKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuZGVtYXRlcmlhbGl6ZSA9IGRlbWF0ZXJpYWxpemU7XG52YXIgRGVNYXRlcmlhbGl6ZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZU1hdGVyaWFsaXplT3BlcmF0b3IoKSB7XG4gICAgfVxuICAgIERlTWF0ZXJpYWxpemVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlTWF0ZXJpYWxpemVTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZU1hdGVyaWFsaXplT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEZU1hdGVyaWFsaXplU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlTWF0ZXJpYWxpemVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlTWF0ZXJpYWxpemVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICB9XG4gICAgRGVNYXRlcmlhbGl6ZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlLm9ic2VydmUodGhpcy5kZXN0aW5hdGlvbik7XG4gICAgfTtcbiAgICByZXR1cm4gRGVNYXRlcmlhbGl6ZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZW1hdGVyaWFsaXplLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9kZW1hdGVyaWFsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIFNldF8xID0gcmVxdWlyZSgnLi4vdXRpbC9TZXQnKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYWxsIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgYXJlIGRpc3RpbmN0IGJ5IGNvbXBhcmlzb24gZnJvbSBwcmV2aW91cyBpdGVtcy5cbiAqXG4gKiBJZiBhIGtleVNlbGVjdG9yIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgcHJvamVjdCBlYWNoIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBvYnNlcnZhYmxlIGludG8gYSBuZXcgdmFsdWUgdGhhdCBpdCB3aWxsXG4gKiBjaGVjayBmb3IgZXF1YWxpdHkgd2l0aCBwcmV2aW91c2x5IHByb2plY3RlZCB2YWx1ZXMuIElmIGEga2V5U2VsZWN0b3IgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkLCBpdCB3aWxsIHVzZSBlYWNoIHZhbHVlIGZyb20gdGhlXG4gKiBzb3VyY2Ugb2JzZXJ2YWJsZSBkaXJlY3RseSB3aXRoIGFuIGVxdWFsaXR5IGNoZWNrIGFnYWluc3QgcHJldmlvdXMgdmFsdWVzLlxuICpcbiAqIEluIEphdmFTY3JpcHQgcnVudGltZXMgdGhhdCBzdXBwb3J0IGBTZXRgLCB0aGlzIG9wZXJhdG9yIHdpbGwgdXNlIGEgYFNldGAgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSBvZiB0aGUgZGlzdGluY3QgdmFsdWUgY2hlY2tpbmcuXG4gKlxuICogSW4gb3RoZXIgcnVudGltZXMsIHRoaXMgb3BlcmF0b3Igd2lsbCB1c2UgYSBtaW5pbWFsIGltcGxlbWVudGF0aW9uIG9mIGBTZXRgIHRoYXQgcmVsaWVzIG9uIGFuIGBBcnJheWAgYW5kIGBpbmRleE9mYCB1bmRlciB0aGVcbiAqIGhvb2QsIHNvIHBlcmZvcm1hbmNlIHdpbGwgZGVncmFkZSBhcyBtb3JlIHZhbHVlcyBhcmUgY2hlY2tlZCBmb3IgZGlzdGluY3Rpb24uIEV2ZW4gaW4gbmV3ZXIgYnJvd3NlcnMsIGEgbG9uZy1ydW5uaW5nIGBkaXN0aW5jdGBcbiAqIHVzZSBtaWdodCByZXN1bHQgaW4gbWVtb3J5IGxlYWtzLiBUbyBoZWxwIGFsbGV2aWF0ZSB0aGlzIGluIHNvbWUgc2NlbmFyaW9zLCBhbiBvcHRpb25hbCBgZmx1c2hlc2AgcGFyYW1ldGVyIGlzIGFsc28gcHJvdmlkZWQgc29cbiAqIHRoYXQgdGhlIGludGVybmFsIGBTZXRgIGNhbiBiZSBcImZsdXNoZWRcIiwgYmFzaWNhbGx5IGNsZWFyaW5nIGl0IG9mIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BIHNpbXBsZSBleGFtcGxlIHdpdGggbnVtYmVyczwvY2FwdGlvbj5cbiAqIE9ic2VydmFibGUub2YoMSwgMSwgMiwgMiwgMiwgMSwgMiwgMywgNCwgMywgMiwgMSlcbiAqICAgLmRpc3RpbmN0KClcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTsgLy8gMSwgMiwgMywgNFxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkFuIGV4YW1wbGUgdXNpbmcgYSBrZXlTZWxlY3RvciBmdW5jdGlvbjwvY2FwdGlvbj5cbiAqIGludGVyZmFjZSBQZXJzb24ge1xuICogICAgYWdlOiBudW1iZXIsXG4gKiAgICBuYW1lOiBzdHJpbmdcbiAqIH1cbiAqXG4gKiBPYnNlcnZhYmxlLm9mPFBlcnNvbj4oXG4gKiAgICAgeyBhZ2U6IDQsIG5hbWU6ICdGb28nfSxcbiAqICAgICB7IGFnZTogNywgbmFtZTogJ0Jhcid9LFxuICogICAgIHsgYWdlOiA1LCBuYW1lOiAnRm9vJ30pXG4gKiAgICAgLmRpc3RpbmN0KChwOiBQZXJzb24pID0+IHAubmFtZSlcbiAqICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIGRpc3BsYXlzOlxuICogLy8geyBhZ2U6IDQsIG5hbWU6ICdGb28nIH1cbiAqIC8vIHsgYWdlOiA3LCBuYW1lOiAnQmFyJyB9XG4gKlxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbENoYW5nZWR9XG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBba2V5U2VsZWN0b3JdIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIHNlbGVjdCB3aGljaCB2YWx1ZSB5b3Ugd2FudCB0byBjaGVjayBhcyBkaXN0aW5jdC5cbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gW2ZsdXNoZXNdIE9wdGlvbmFsIE9ic2VydmFibGUgZm9yIGZsdXNoaW5nIHRoZSBpbnRlcm5hbCBIYXNoU2V0IG9mIHRoZSBvcGVyYXRvci5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIGRpc3RpbmN0IHZhbHVlcy5cbiAqIEBtZXRob2QgZGlzdGluY3RcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRpc3RpbmN0KGtleVNlbGVjdG9yLCBmbHVzaGVzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBEaXN0aW5jdE9wZXJhdG9yKGtleVNlbGVjdG9yLCBmbHVzaGVzKSk7IH07XG59XG5leHBvcnRzLmRpc3RpbmN0ID0gZGlzdGluY3Q7XG52YXIgRGlzdGluY3RPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RPcGVyYXRvcihrZXlTZWxlY3RvciwgZmx1c2hlcykge1xuICAgICAgICB0aGlzLmtleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZmx1c2hlcyA9IGZsdXNoZXM7XG4gICAgfVxuICAgIERpc3RpbmN0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEaXN0aW5jdFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5rZXlTZWxlY3RvciwgdGhpcy5mbHVzaGVzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlzdGluY3RPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERpc3RpbmN0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpc3RpbmN0U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaXN0aW5jdFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGtleVNlbGVjdG9yLCBmbHVzaGVzKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IG5ldyBTZXRfMS5TZXQoKTtcbiAgICAgICAgaWYgKGZsdXNoZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgZmx1c2hlcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIERpc3RpbmN0U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnZhbHVlcy5jbGVhcigpO1xuICAgIH07XG4gICAgRGlzdGluY3RTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgRGlzdGluY3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5rZXlTZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fdXNlS2V5U2VsZWN0b3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmluYWxpemVOZXh0KHZhbHVlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpc3RpbmN0U3Vic2NyaWJlci5wcm90b3R5cGUuX3VzZUtleVNlbGVjdG9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmtleVNlbGVjdG9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplTmV4dChrZXksIHZhbHVlKTtcbiAgICB9O1xuICAgIERpc3RpbmN0U3Vic2NyaWJlci5wcm90b3R5cGUuX2ZpbmFsaXplTmV4dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgaWYgKCF2YWx1ZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHZhbHVlcy5hZGQoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEaXN0aW5jdFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5EaXN0aW5jdFN1YnNjcmliZXIgPSBEaXN0aW5jdFN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXN0aW5jdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvZGlzdGluY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZGlzdGluY3RVbnRpbENoYW5nZWRfMSA9IHJlcXVpcmUoJy4vZGlzdGluY3RVbnRpbENoYW5nZWQnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFsbCBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IGFyZSBkaXN0aW5jdCBieSBjb21wYXJpc29uIGZyb20gdGhlIHByZXZpb3VzIGl0ZW0sXG4gKiB1c2luZyBhIHByb3BlcnR5IGFjY2Vzc2VkIGJ5IHVzaW5nIHRoZSBrZXkgcHJvdmlkZWQgdG8gY2hlY2sgaWYgdGhlIHR3byBpdGVtcyBhcmUgZGlzdGluY3QuXG4gKlxuICogSWYgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGl0ZW0gdG8gdGVzdCBmb3Igd2hldGhlciBvciBub3QgdGhhdCB2YWx1ZSBzaG91bGQgYmUgZW1pdHRlZC5cbiAqXG4gKiBJZiBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkLCBhbiBlcXVhbGl0eSBjaGVjayBpcyB1c2VkIGJ5IGRlZmF1bHQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QW4gZXhhbXBsZSBjb21wYXJpbmcgdGhlIG5hbWUgb2YgcGVyc29uczwvY2FwdGlvbj5cbiAqXG4gKiAgaW50ZXJmYWNlIFBlcnNvbiB7XG4gKiAgICAgYWdlOiBudW1iZXIsXG4gKiAgICAgbmFtZTogc3RyaW5nXG4gKiAgfVxuICpcbiAqIE9ic2VydmFibGUub2Y8UGVyc29uPihcbiAqICAgICB7IGFnZTogNCwgbmFtZTogJ0Zvbyd9LFxuICogICAgIHsgYWdlOiA3LCBuYW1lOiAnQmFyJ30sXG4gKiAgICAgeyBhZ2U6IDUsIG5hbWU6ICdGb28nfSxcbiAqICAgICB7IGFnZTogNiwgbmFtZTogJ0Zvbyd9KVxuICogICAgIC5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCgnbmFtZScpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vIHsgYWdlOiA0LCBuYW1lOiAnRm9vJyB9XG4gKiAvLyB7IGFnZTogNywgbmFtZTogJ0JhcicgfVxuICogLy8geyBhZ2U6IDUsIG5hbWU6ICdGb28nIH1cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BbiBleGFtcGxlIGNvbXBhcmluZyB0aGUgZmlyc3QgbGV0dGVycyBvZiB0aGUgbmFtZTwvY2FwdGlvbj5cbiAqXG4gKiBpbnRlcmZhY2UgUGVyc29uIHtcbiAqICAgICBhZ2U6IG51bWJlcixcbiAqICAgICBuYW1lOiBzdHJpbmdcbiAqICB9XG4gKlxuICogT2JzZXJ2YWJsZS5vZjxQZXJzb24+KFxuICogICAgIHsgYWdlOiA0LCBuYW1lOiAnRm9vMSd9LFxuICogICAgIHsgYWdlOiA3LCBuYW1lOiAnQmFyJ30sXG4gKiAgICAgeyBhZ2U6IDUsIG5hbWU6ICdGb28yJ30sXG4gKiAgICAgeyBhZ2U6IDYsIG5hbWU6ICdGb28zJ30pXG4gKiAgICAgLmRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkKCduYW1lJywgKHg6IHN0cmluZywgeTogc3RyaW5nKSA9PiB4LnN1YnN0cmluZygwLCAzKSA9PT0geS5zdWJzdHJpbmcoMCwgMykpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vIHsgYWdlOiA0LCBuYW1lOiAnRm9vMScgfVxuICogLy8geyBhZ2U6IDcsIG5hbWU6ICdCYXInIH1cbiAqIC8vIHsgYWdlOiA1LCBuYW1lOiAnRm9vMicgfVxuICpcbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0fVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbENoYW5nZWR9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBTdHJpbmcga2V5IGZvciBvYmplY3QgcHJvcGVydHkgbG9va3VwIG9uIGVhY2ggaXRlbS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjb21wYXJlXSBPcHRpb25hbCBjb21wYXJpc29uIGZ1bmN0aW9uIGNhbGxlZCB0byB0ZXN0IGlmIGFuIGl0ZW0gaXMgZGlzdGluY3QgZnJvbSB0aGUgcHJldmlvdXMgaXRlbSBpbiB0aGUgc291cmNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggZGlzdGluY3QgdmFsdWVzIGJhc2VkIG9uIHRoZSBrZXkgc3BlY2lmaWVkLlxuICogQG1ldGhvZCBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGlzdGluY3RVbnRpbEtleUNoYW5nZWQoa2V5LCBjb21wYXJlKSB7XG4gICAgcmV0dXJuIGRpc3RpbmN0VW50aWxDaGFuZ2VkXzEuZGlzdGluY3RVbnRpbENoYW5nZWQoZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIGNvbXBhcmUgPyBjb21wYXJlKHhba2V5XSwgeVtrZXldKSA6IHhba2V5XSA9PT0geVtrZXldOyB9KTtcbn1cbmV4cG9ydHMuZGlzdGluY3RVbnRpbEtleUNoYW5nZWQgPSBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZC5qc1xuLy8gbW9kdWxlIGlkID0gMjA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcicpO1xuLyoqXG4gKiBFbWl0cyB0aGUgc2luZ2xlIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgYGluZGV4YCBpbiBhIHNlcXVlbmNlIG9mIGVtaXNzaW9uc1xuICogZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkVtaXRzIG9ubHkgdGhlIGktdGggdmFsdWUsIHRoZW4gY29tcGxldGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2VsZW1lbnRBdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgZWxlbWVudEF0YCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgaXRlbSBhdCB0aGUgc3BlY2lmaWVkXG4gKiBgaW5kZXhgIGluIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgb3IgYSBkZWZhdWx0IHZhbHVlIGlmIHRoYXQgYGluZGV4YCBpcyBvdXRcbiAqIG9mIHJhbmdlIGFuZCB0aGUgYGRlZmF1bHRgIGFyZ3VtZW50IGlzIHByb3ZpZGVkLiBJZiB0aGUgYGRlZmF1bHRgIGFyZ3VtZW50IGlzXG4gKiBub3QgZ2l2ZW4gYW5kIHRoZSBgaW5kZXhgIGlzIG91dCBvZiByYW5nZSwgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHdpbGwgZW1pdCBhblxuICogYEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yYCBlcnJvci5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IG9ubHkgdGhlIHRoaXJkIGNsaWNrIGV2ZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZWxlbWVudEF0KDIpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluOlxuICogLy8gY2xpY2sgMSA9IG5vdGhpbmdcbiAqIC8vIGNsaWNrIDIgPSBub3RoaW5nXG4gKiAvLyBjbGljayAzID0gTW91c2VFdmVudCBvYmplY3QgbG9nZ2VkIHRvIGNvbnNvbGVcbiAqXG4gKiBAc2VlIHtAbGluayBmaXJzdH1cbiAqIEBzZWUge0BsaW5rIGxhc3R9XG4gKiBAc2VlIHtAbGluayBza2lwfVxuICogQHNlZSB7QGxpbmsgc2luZ2xlfVxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqXG4gKiBAdGhyb3dzIHtBcmd1bWVudE91dE9mUmFuZ2VFcnJvcn0gV2hlbiB1c2luZyBgZWxlbWVudEF0KGkpYCwgaXQgZGVsaXZlcnMgYW5cbiAqIEFyZ3VtZW50T3V0T3JSYW5nZUVycm9yIHRvIHRoZSBPYnNlcnZlcidzIGBlcnJvcmAgY2FsbGJhY2sgaWYgYGkgPCAwYCBvciB0aGVcbiAqIE9ic2VydmFibGUgaGFzIGNvbXBsZXRlZCBiZWZvcmUgZW1pdHRpbmcgdGhlIGktdGggYG5leHRgIG5vdGlmaWNhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSXMgdGhlIG51bWJlciBgaWAgZm9yIHRoZSBpLXRoIHNvdXJjZSBlbWlzc2lvbiB0aGF0IGhhc1xuICogaGFwcGVuZWQgc2luY2UgdGhlIHN1YnNjcmlwdGlvbiwgc3RhcnRpbmcgZnJvbSB0aGUgbnVtYmVyIGAwYC5cbiAqIEBwYXJhbSB7VH0gW2RlZmF1bHRWYWx1ZV0gVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgZm9yIG1pc3NpbmcgaW5kaWNlcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIHNpbmdsZSBpdGVtLCBpZiBpdCBpcyBmb3VuZC5cbiAqIE90aGVyd2lzZSwgd2lsbCBlbWl0IHRoZSBkZWZhdWx0IHZhbHVlIGlmIGdpdmVuLiBJZiBub3QsIHRoZW4gZW1pdHMgYW4gZXJyb3IuXG4gKiBAbWV0aG9kIGVsZW1lbnRBdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZWxlbWVudEF0KGluZGV4LCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IEVsZW1lbnRBdE9wZXJhdG9yKGluZGV4LCBkZWZhdWx0VmFsdWUpKTsgfTtcbn1cbmV4cG9ydHMuZWxlbWVudEF0ID0gZWxlbWVudEF0O1xudmFyIEVsZW1lbnRBdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbGVtZW50QXRPcGVyYXRvcihpbmRleCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xLkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIEVsZW1lbnRBdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRWxlbWVudEF0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmluZGV4LCB0aGlzLmRlZmF1bHRWYWx1ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRBdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRWxlbWVudEF0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVsZW1lbnRBdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRWxlbWVudEF0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIEVsZW1lbnRBdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXgtLSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHgpO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbGVtZW50QXRTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5kZWZhdWx0VmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh0aGlzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMS5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50QXRTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlbWVudEF0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9lbGVtZW50QXQuanNcbi8vIG1vZHVsZSBpZCA9IDIwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIENvbnZlcnRzIGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUgaW50byBhIGZpcnN0LW9yZGVyIE9ic2VydmFibGUgYnkgZHJvcHBpbmdcbiAqIGlubmVyIE9ic2VydmFibGVzIHdoaWxlIHRoZSBwcmV2aW91cyBpbm5lciBPYnNlcnZhYmxlIGhhcyBub3QgeWV0IGNvbXBsZXRlZC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RmxhdHRlbnMgYW4gT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlcyBieSBkcm9wcGluZyB0aGVcbiAqIG5leHQgaW5uZXIgT2JzZXJ2YWJsZXMgd2hpbGUgdGhlIGN1cnJlbnQgaW5uZXIgaXMgc3RpbGwgZXhlY3V0aW5nLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2V4aGF1c3QucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGV4aGF1c3RgIHN1YnNjcmliZXMgdG8gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIE9ic2VydmFibGVzLCBhbHNvIGtub3duIGFzIGFcbiAqIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlLiBFYWNoIHRpbWUgaXQgb2JzZXJ2ZXMgb25lIG9mIHRoZXNlIGVtaXR0ZWQgaW5uZXJcbiAqIE9ic2VydmFibGVzLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmVnaW5zIGVtaXR0aW5nIHRoZSBpdGVtcyBlbWl0dGVkIGJ5IHRoYXRcbiAqIGlubmVyIE9ic2VydmFibGUuIFNvIGZhciwgaXQgYmVoYXZlcyBsaWtlIHtAbGluayBtZXJnZUFsbH0uIEhvd2V2ZXIsXG4gKiBgZXhoYXVzdGAgaWdub3JlcyBldmVyeSBuZXcgaW5uZXIgT2JzZXJ2YWJsZSBpZiB0aGUgcHJldmlvdXMgT2JzZXJ2YWJsZSBoYXNcbiAqIG5vdCB5ZXQgY29tcGxldGVkLiBPbmNlIHRoYXQgb25lIGNvbXBsZXRlcywgaXQgd2lsbCBhY2NlcHQgYW5kIGZsYXR0ZW4gdGhlXG4gKiBuZXh0IGlubmVyIE9ic2VydmFibGUgYW5kIHJlcGVhdCB0aGlzIHByb2Nlc3MuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UnVuIGEgZmluaXRlIHRpbWVyIGZvciBlYWNoIGNsaWNrLCBvbmx5IGlmIHRoZXJlIGlzIG5vIGN1cnJlbnRseSBhY3RpdmUgdGltZXI8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGhpZ2hlck9yZGVyID0gY2xpY2tzLm1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg1KSk7XG4gKiB2YXIgcmVzdWx0ID0gaGlnaGVyT3JkZXIuZXhoYXVzdCgpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lQWxsfVxuICogQHNlZSB7QGxpbmsgY29uY2F0QWxsfVxuICogQHNlZSB7QGxpbmsgc3dpdGNofVxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0TWFwfVxuICogQHNlZSB7QGxpbmsgemlwQWxsfVxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCB0YWtlcyBhIHNvdXJjZSBvZiBPYnNlcnZhYmxlcyBhbmQgcHJvcGFnYXRlcyB0aGUgZmlyc3Qgb2JzZXJ2YWJsZVxuICogZXhjbHVzaXZlbHkgdW50aWwgaXQgY29tcGxldGVzIGJlZm9yZSBzdWJzY3JpYmluZyB0byB0aGUgbmV4dC5cbiAqIEBtZXRob2QgZXhoYXVzdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZXhoYXVzdCgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFN3aXRjaEZpcnN0T3BlcmF0b3IoKSk7IH07XG59XG5leHBvcnRzLmV4aGF1c3QgPSBleGhhdXN0O1xudmFyIFN3aXRjaEZpcnN0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN3aXRjaEZpcnN0T3BlcmF0b3IoKSB7XG4gICAgfVxuICAgIFN3aXRjaEZpcnN0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hGaXJzdFN1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaEZpcnN0T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTd2l0Y2hGaXJzdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hGaXJzdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoRmlyc3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgICB9XG4gICAgU3dpdGNoRmlyc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1N1YnNjcmlwdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5oYXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoRmlyc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuaGFzU3Vic2NyaXB0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoRmlyc3RTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4aGF1c3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL2V4aGF1c3QuanNcbi8vIG1vZHVsZSBpZCA9IDIwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBpbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlIG9ubHkgaWYgdGhlIHByZXZpb3VzIHByb2plY3RlZCBPYnNlcnZhYmxlIGhhcyBjb21wbGV0ZWQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPk1hcHMgZWFjaCB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlLCB0aGVuIGZsYXR0ZW5zIGFsbCBvZlxuICogdGhlc2UgaW5uZXIgT2JzZXJ2YWJsZXMgdXNpbmcge0BsaW5rIGV4aGF1c3R9Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2V4aGF1c3RNYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiAoc28tY2FsbGVkIFwiaW5uZXJcIikgT2JzZXJ2YWJsZS4gV2hlbiBpdCBwcm9qZWN0cyBhIHNvdXJjZSB2YWx1ZSB0b1xuICogYW4gT2JzZXJ2YWJsZSwgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJlZ2lucyBlbWl0dGluZyB0aGUgaXRlbXMgZW1pdHRlZCBieVxuICogdGhhdCBwcm9qZWN0ZWQgT2JzZXJ2YWJsZS4gSG93ZXZlciwgYGV4aGF1c3RNYXBgIGlnbm9yZXMgZXZlcnkgbmV3IHByb2plY3RlZFxuICogT2JzZXJ2YWJsZSBpZiB0aGUgcHJldmlvdXMgcHJvamVjdGVkIE9ic2VydmFibGUgaGFzIG5vdCB5ZXQgY29tcGxldGVkLiBPbmNlXG4gKiB0aGF0IG9uZSBjb21wbGV0ZXMsIGl0IHdpbGwgYWNjZXB0IGFuZCBmbGF0dGVuIHRoZSBuZXh0IHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBhbmQgcmVwZWF0IHRoaXMgcHJvY2Vzcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5SdW4gYSBmaW5pdGUgdGltZXIgZm9yIGVhY2ggY2xpY2ssIG9ubHkgaWYgdGhlcmUgaXMgbm8gY3VycmVudGx5IGFjdGl2ZSB0aW1lcjwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmV4aGF1c3RNYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoNSkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0fVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgP2luZGV4OiBudW1iZXIpOiBPYnNlcnZhYmxlSW5wdXR9IHByb2plY3QgQSBmdW5jdGlvblxuICogdGhhdCwgd2hlbiBhcHBsaWVkIHRvIGFuIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHJldHVybnMgYW5cbiAqIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBjb250YWluaW5nIHByb2plY3RlZCBPYnNlcnZhYmxlc1xuICogb2YgZWFjaCBpdGVtIG9mIHRoZSBzb3VyY2UsIGlnbm9yaW5nIHByb2plY3RlZCBPYnNlcnZhYmxlcyB0aGF0IHN0YXJ0IGJlZm9yZVxuICogdGhlaXIgcHJlY2VkaW5nIE9ic2VydmFibGUgaGFzIGNvbXBsZXRlZC5cbiAqIEBtZXRob2QgZXhoYXVzdE1hcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZXhoYXVzdE1hcChwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgU3dpdGNoRmlyc3RNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvcikpOyB9O1xufVxuZXhwb3J0cy5leGhhdXN0TWFwID0gZXhoYXVzdE1hcDtcbnZhciBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICB9XG4gICAgU3dpdGNoRmlyc3RNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMucmVzdWx0U2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaGFzU3Vic2NyaXB0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudHJ5TmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5TmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wcm9qZWN0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmhhc1N1YnNjcmlwdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCwgdmFsdWUsIGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnRyeVNlbGVjdFJlc3VsdChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5U2VsZWN0UmVzdWx0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5oYXNTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhoYXVzdE1hcC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvZXhoYXVzdE1hcC5qc1xuLy8gbW9kdWxlIGlkID0gMjEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZWN1cnNpdmVseSBwcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBpblxuICogdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIHNpbWlsYXIgdG8ge0BsaW5rIG1lcmdlTWFwfSwgYnV0IGFwcGxpZXMgdGhlXG4gKiBwcm9qZWN0aW9uIGZ1bmN0aW9uIHRvIGV2ZXJ5IHNvdXJjZSB2YWx1ZSBhcyB3ZWxsIGFzIGV2ZXJ5IG91dHB1dCB2YWx1ZS5cbiAqIEl0J3MgcmVjdXJzaXZlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2V4cGFuZC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBiYXNlZCBvbiBhcHBseWluZyBhIGZ1bmN0aW9uIHRoYXQgeW91XG4gKiBzdXBwbHkgdG8gZWFjaCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB3aGVyZSB0aGF0IGZ1bmN0aW9uXG4gKiByZXR1cm5zIGFuIE9ic2VydmFibGUsIGFuZCB0aGVuIG1lcmdpbmcgdGhvc2UgcmVzdWx0aW5nIE9ic2VydmFibGVzIGFuZFxuICogZW1pdHRpbmcgdGhlIHJlc3VsdHMgb2YgdGhpcyBtZXJnZXIuICpFeHBhbmQqIHdpbGwgcmUtZW1pdCBvbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlIGV2ZXJ5IHNvdXJjZSB2YWx1ZS4gVGhlbiwgZWFjaCBvdXRwdXQgdmFsdWUgaXMgZ2l2ZW4gdG8gdGhlXG4gKiBgcHJvamVjdGAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBpbm5lciBPYnNlcnZhYmxlIHRvIGJlIG1lcmdlZCBvbiB0aGVcbiAqIG91dHB1dCBPYnNlcnZhYmxlLiBUaG9zZSBvdXRwdXQgdmFsdWVzIHJlc3VsdGluZyBmcm9tIHRoZSBwcm9qZWN0aW9uIGFyZSBhbHNvXG4gKiBnaXZlbiB0byB0aGUgYHByb2plY3RgIGZ1bmN0aW9uIHRvIHByb2R1Y2UgbmV3IG91dHB1dCB2YWx1ZXMuIFRoaXMgaXMgaG93XG4gKiAqZXhwYW5kKiBiZWhhdmVzIHJlY3Vyc2l2ZWx5LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlN0YXJ0IGVtaXR0aW5nIHRoZSBwb3dlcnMgb2YgdHdvIG9uIGV2ZXJ5IGNsaWNrLCBhdCBtb3N0IDEwIG9mIHRoZW08L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHBvd2Vyc09mVHdvID0gY2xpY2tzXG4gKiAgIC5tYXBUbygxKVxuICogICAuZXhwYW5kKHggPT4gUnguT2JzZXJ2YWJsZS5vZigyICogeCkuZGVsYXkoMTAwMCkpXG4gKiAgIC50YWtlKDEwKTtcbiAqIHBvd2Vyc09mVHdvLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBPYnNlcnZhYmxlfSBwcm9qZWN0IEEgZnVuY3Rpb25cbiAqIHRoYXQsIHdoZW4gYXBwbGllZCB0byBhbiBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBvciB0aGUgb3V0cHV0IE9ic2VydmFibGUsXG4gKiByZXR1cm5zIGFuIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbnB1dFxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1udWxsXSBUaGUgSVNjaGVkdWxlciB0byB1c2UgZm9yIHN1YnNjcmliaW5nIHRvXG4gKiBlYWNoIHByb2plY3RlZCBpbm5lciBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBzb3VyY2UgdmFsdWVzIGFuZCBhbHNvXG4gKiByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIHByb2plY3Rpb24gZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZSBlbWl0dGVkIG9uIHRoZVxuICogb3V0cHV0IE9ic2VydmFibGUgYW5kIGFuZCBtZXJnaW5nIHRoZSByZXN1bHRzIG9mIHRoZSBPYnNlcnZhYmxlcyBvYnRhaW5lZFxuICogZnJvbSB0aGlzIHRyYW5zZm9ybWF0aW9uLlxuICogQG1ldGhvZCBleHBhbmRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZChwcm9qZWN0LCBjb25jdXJyZW50LCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gdW5kZWZpbmVkOyB9XG4gICAgY29uY3VycmVudCA9IChjb25jdXJyZW50IHx8IDApIDwgMSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IGNvbmN1cnJlbnQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBFeHBhbmRPcGVyYXRvcihwcm9qZWN0LCBjb25jdXJyZW50LCBzY2hlZHVsZXIpKTsgfTtcbn1cbmV4cG9ydHMuZXhwYW5kID0gZXhwYW5kO1xudmFyIEV4cGFuZE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFeHBhbmRPcGVyYXRvcihwcm9qZWN0LCBjb25jdXJyZW50LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIEV4cGFuZE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRXhwYW5kU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMuY29uY3VycmVudCwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBFeHBhbmRPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLkV4cGFuZE9wZXJhdG9yID0gRXhwYW5kT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEV4cGFuZFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHBhbmRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4cGFuZFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIGNvbmN1cnJlbnQsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoY29uY3VycmVudCA8IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBFeHBhbmRTdWJzY3JpYmVyLmRpc3BhdGNoID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyLCByZXN1bHQgPSBhcmcucmVzdWx0LCB2YWx1ZSA9IGFyZy52YWx1ZSwgaW5kZXggPSBhcmcuaW5kZXg7XG4gICAgICAgIHN1YnNjcmliZXIuc3Vic2NyaWJlVG9Qcm9qZWN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZGV4KTtcbiAgICB9O1xuICAgIEV4cGFuZFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPCB0aGlzLmNvbmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2godGhpcy5wcm9qZWN0KSh2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5zY2hlZHVsZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZVRvUHJvamVjdGlvbihyZXN1bHQsIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSB7IHN1YnNjcmliZXI6IHRoaXMsIHJlc3VsdDogcmVzdWx0LCB2YWx1ZTogdmFsdWUsIGluZGV4OiBpbmRleCB9O1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKEV4cGFuZFN1YnNjcmliZXIuZGlzcGF0Y2gsIDAsIHN0YXRlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXhwYW5kU3Vic2NyaWJlci5wcm90b3R5cGUuc3Vic2NyaWJlVG9Qcm9qZWN0aW9uID0gZnVuY3Rpb24gKHJlc3VsdCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlKys7XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0LCB2YWx1ZSwgaW5kZXgpKTtcbiAgICB9O1xuICAgIEV4cGFuZFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5oYXNDb21wbGV0ZWQgJiYgdGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXhwYW5kU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLl9uZXh0KGlubmVyVmFsdWUpO1xuICAgIH07XG4gICAgRXhwYW5kU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuYWN0aXZlLS07XG4gICAgICAgIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQoYnVmZmVyLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlZCAmJiB0aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRXhwYW5kU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG5leHBvcnRzLkV4cGFuZFN1YnNjcmliZXIgPSBFeHBhbmRTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwYW5kLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9leHBhbmQuanNcbi8vIG1vZHVsZSBpZCA9IDIxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCB3aWxsIGNhbGwgYSBzcGVjaWZpZWQgZnVuY3Rpb24gd2hlblxuICogdGhlIHNvdXJjZSB0ZXJtaW5hdGVzIG9uIGNvbXBsZXRlIG9yIGVycm9yLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gc291cmNlIHRlcm1pbmF0ZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgc291cmNlLCBidXQgd2lsbCBjYWxsIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gb24gdGVybWluYXRpb24uXG4gKiBAbWV0aG9kIGZpbmFsbHlcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGZpbmFsaXplKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBGaW5hbGx5T3BlcmF0b3IoY2FsbGJhY2spKTsgfTtcbn1cbmV4cG9ydHMuZmluYWxpemUgPSBmaW5hbGl6ZTtcbnZhciBGaW5hbGx5T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbmFsbHlPcGVyYXRvcihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIEZpbmFsbHlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEZpbmFsbHlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY2FsbGJhY2spKTtcbiAgICB9O1xuICAgIHJldHVybiBGaW5hbGx5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBGaW5hbGx5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpbmFsbHlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpbmFsbHlTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuYWRkKG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oY2FsbGJhY2spKTtcbiAgICB9XG4gICAgcmV0dXJuIEZpbmFsbHlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluYWxpemUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL2ZpbmFsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGZpbmRfMSA9IHJlcXVpcmUoJy4uL29wZXJhdG9ycy9maW5kJyk7XG4vKipcbiAqIEVtaXRzIG9ubHkgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0XG4gKiBtZWV0cyBzb21lIGNvbmRpdGlvbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBmaW5kfSwgYnV0IGVtaXRzIHRoZSBpbmRleCBvZiB0aGVcbiAqIGZvdW5kIHZhbHVlLCBub3QgdGhlIHZhbHVlIGl0c2VsZi48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9maW5kSW5kZXgucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGZpbmRJbmRleGAgc2VhcmNoZXMgZm9yIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IG1hdGNoZXNcbiAqIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9uIGVtYm9kaWVkIGJ5IHRoZSBgcHJlZGljYXRlYCwgYW5kIHJldHVybnMgdGhlXG4gKiAoemVyby1iYXNlZCkgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2UgaW4gdGhlIHNvdXJjZS4gVW5saWtlXG4gKiB7QGxpbmsgZmlyc3R9LCB0aGUgYHByZWRpY2F0ZWAgaXMgcmVxdWlyZWQgaW4gYGZpbmRJbmRleGAsIGFuZCBkb2VzIG5vdCBlbWl0XG4gKiBhbiBlcnJvciBpZiBhIHZhbGlkIHZhbHVlIGlzIG5vdCBmb3VuZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBpbmRleCBvZiBmaXJzdCBjbGljayB0aGF0IGhhcHBlbnMgb24gYSBESVYgZWxlbWVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmZpbmRJbmRleChldiA9PiBldi50YXJnZXQudGFnTmFtZSA9PT0gJ0RJVicpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBmaWx0ZXJ9XG4gKiBAc2VlIHtAbGluayBmaW5kfVxuICogQHNlZSB7QGxpbmsgZmlyc3R9XG4gKiBAc2VlIHtAbGluayB0YWtlfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPik6IGJvb2xlYW59IHByZWRpY2F0ZVxuICogQSBmdW5jdGlvbiBjYWxsZWQgd2l0aCBlYWNoIGl0ZW0gdG8gdGVzdCBmb3IgY29uZGl0aW9uIG1hdGNoaW5nLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIGB0aGlzYFxuICogaW4gdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gdGhhdFxuICogbWF0Y2hlcyB0aGUgY29uZGl0aW9uLlxuICogQG1ldGhvZCBmaW5kXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBmaW5kXzEuRmluZFZhbHVlT3BlcmF0b3IocHJlZGljYXRlLCBzb3VyY2UsIHRydWUsIHRoaXNBcmcpKTsgfTtcbn1cbmV4cG9ydHMuZmluZEluZGV4ID0gZmluZEluZGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZEluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9maW5kSW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIE1hcF8xID0gcmVxdWlyZSgnLi4vdXRpbC9NYXAnKTtcbnZhciBGYXN0TWFwXzEgPSByZXF1aXJlKCcuLi91dGlsL0Zhc3RNYXAnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEdyb3VwcyB0aGUgaXRlbXMgZW1pdHRlZCBieSBhbiBPYnNlcnZhYmxlIGFjY29yZGluZyB0byBhIHNwZWNpZmllZCBjcml0ZXJpb24sXG4gKiBhbmQgZW1pdHMgdGhlc2UgZ3JvdXBlZCBpdGVtcyBhcyBgR3JvdXBlZE9ic2VydmFibGVzYCwgb25lXG4gKiB7QGxpbmsgR3JvdXBlZE9ic2VydmFibGV9IHBlciBncm91cC5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2dyb3VwQnkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+R3JvdXAgb2JqZWN0cyBieSBpZCBhbmQgcmV0dXJuIGFzIGFycmF5PC9jYXB0aW9uPlxuICogT2JzZXJ2YWJsZS5vZjxPYmo+KHtpZDogMSwgbmFtZTogJ2F6ZTEnfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDIsIG5hbWU6ICdzZjInfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDIsIG5hbWU6ICdkZzInfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDEsIG5hbWU6ICdlcmcxJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAxLCBuYW1lOiAnZGYxJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAyLCBuYW1lOiAnc2ZxZmIyJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAzLCBuYW1lOiAncWZzMyd9LFxuICogICAgICAgICAgICAgICAgICAgIHtpZDogMiwgbmFtZTogJ3FzZ3FzZmcyJ31cbiAqICAgICApXG4gKiAgICAgLmdyb3VwQnkocCA9PiBwLmlkKVxuICogICAgIC5mbGF0TWFwKCAoZ3JvdXAkKSA9PiBncm91cCQucmVkdWNlKChhY2MsIGN1cikgPT4gWy4uLmFjYywgY3VyXSwgW10pKVxuICogICAgIC5zdWJzY3JpYmUocCA9PiBjb25zb2xlLmxvZyhwKSk7XG4gKlxuICogLy8gZGlzcGxheXM6XG4gKiAvLyBbIHsgaWQ6IDEsIG5hbWU6ICdhemUxJyB9LFxuICogLy8gICB7IGlkOiAxLCBuYW1lOiAnZXJnMScgfSxcbiAqIC8vICAgeyBpZDogMSwgbmFtZTogJ2RmMScgfSBdXG4gKiAvL1xuICogLy8gWyB7IGlkOiAyLCBuYW1lOiAnc2YyJyB9LFxuICogLy8gICB7IGlkOiAyLCBuYW1lOiAnZGcyJyB9LFxuICogLy8gICB7IGlkOiAyLCBuYW1lOiAnc2ZxZmIyJyB9LFxuICogLy8gICB7IGlkOiAyLCBuYW1lOiAncXNncXNmZzInIH0gXVxuICogLy9cbiAqIC8vIFsgeyBpZDogMywgbmFtZTogJ3FmczMnIH0gXVxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlBpdm90IGRhdGEgb24gdGhlIGlkIGZpZWxkPC9jYXB0aW9uPlxuICogT2JzZXJ2YWJsZS5vZjxPYmo+KHtpZDogMSwgbmFtZTogJ2F6ZTEnfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDIsIG5hbWU6ICdzZjInfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDIsIG5hbWU6ICdkZzInfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDEsIG5hbWU6ICdlcmcxJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAxLCBuYW1lOiAnZGYxJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAyLCBuYW1lOiAnc2ZxZmIyJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAzLCBuYW1lOiAncWZzMSd9LFxuICogICAgICAgICAgICAgICAgICAgIHtpZDogMiwgbmFtZTogJ3FzZ3FzZmcyJ31cbiAqICAgICAgICAgICAgICAgICAgIClcbiAqICAgICAuZ3JvdXBCeShwID0+IHAuaWQsIHAgPT4gcC5uYW1lKVxuICogICAgIC5mbGF0TWFwKCAoZ3JvdXAkKSA9PiBncm91cCQucmVkdWNlKChhY2MsIGN1cikgPT4gWy4uLmFjYywgY3VyXSwgW1wiXCIgKyBncm91cCQua2V5XSkpXG4gKiAgICAgLm1hcChhcnIgPT4gKHsnaWQnOiBwYXJzZUludChhcnJbMF0pLCAndmFsdWVzJzogYXJyLnNsaWNlKDEpfSkpXG4gKiAgICAgLnN1YnNjcmliZShwID0+IGNvbnNvbGUubG9nKHApKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vIHsgaWQ6IDEsIHZhbHVlczogWyAnYXplMScsICdlcmcxJywgJ2RmMScgXSB9XG4gKiAvLyB7IGlkOiAyLCB2YWx1ZXM6IFsgJ3NmMicsICdkZzInLCAnc2ZxZmIyJywgJ3FzZ3FzZmcyJyBdIH1cbiAqIC8vIHsgaWQ6IDMsIHZhbHVlczogWyAncWZzMScgXSB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IEt9IGtleVNlbGVjdG9yIEEgZnVuY3Rpb24gdGhhdCBleHRyYWN0cyB0aGUga2V5XG4gKiBmb3IgZWFjaCBpdGVtLlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IFJ9IFtlbGVtZW50U2VsZWN0b3JdIEEgZnVuY3Rpb24gdGhhdCBleHRyYWN0cyB0aGVcbiAqIHJldHVybiBlbGVtZW50IGZvciBlYWNoIGl0ZW0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGdyb3VwZWQ6IEdyb3VwZWRPYnNlcnZhYmxlPEssUj4pOiBPYnNlcnZhYmxlPGFueT59IFtkdXJhdGlvblNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0byBkZXRlcm1pbmUgaG93IGxvbmcgZWFjaCBncm91cCBzaG91bGRcbiAqIGV4aXN0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxHcm91cGVkT2JzZXJ2YWJsZTxLLFI+Pn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzXG4gKiBHcm91cGVkT2JzZXJ2YWJsZXMsIGVhY2ggb2Ygd2hpY2ggY29ycmVzcG9uZHMgdG8gYSB1bmlxdWUga2V5IHZhbHVlIGFuZCBlYWNoXG4gKiBvZiB3aGljaCBlbWl0cyB0aG9zZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IHNoYXJlIHRoYXQga2V5XG4gKiB2YWx1ZS5cbiAqIEBtZXRob2QgZ3JvdXBCeVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZ3JvdXBCeShrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBkdXJhdGlvblNlbGVjdG9yLCBzdWJqZWN0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IEdyb3VwQnlPcGVyYXRvcihrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBkdXJhdGlvblNlbGVjdG9yLCBzdWJqZWN0U2VsZWN0b3IpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5ncm91cEJ5ID0gZ3JvdXBCeTtcbnZhciBHcm91cEJ5T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyb3VwQnlPcGVyYXRvcihrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBkdXJhdGlvblNlbGVjdG9yLCBzdWJqZWN0U2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgICAgICB0aGlzLmVsZW1lbnRTZWxlY3RvciA9IGVsZW1lbnRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICAgICAgdGhpcy5zdWJqZWN0U2VsZWN0b3IgPSBzdWJqZWN0U2VsZWN0b3I7XG4gICAgfVxuICAgIEdyb3VwQnlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEdyb3VwQnlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMua2V5U2VsZWN0b3IsIHRoaXMuZWxlbWVudFNlbGVjdG9yLCB0aGlzLmR1cmF0aW9uU2VsZWN0b3IsIHRoaXMuc3ViamVjdFNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXBCeU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgR3JvdXBCeVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcm91cEJ5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcm91cEJ5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwga2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3RvciwgZHVyYXRpb25TZWxlY3Rvciwgc3ViamVjdFNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgICAgICB0aGlzLmVsZW1lbnRTZWxlY3RvciA9IGVsZW1lbnRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICAgICAgdGhpcy5zdWJqZWN0U2VsZWN0b3IgPSBzdWJqZWN0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdHRlbXB0ZWRUb1Vuc3Vic2NyaWJlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgIH1cbiAgICBHcm91cEJ5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGtleSA9IHRoaXMua2V5U2VsZWN0b3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ncm91cCh2YWx1ZSwga2V5KTtcbiAgICB9O1xuICAgIEdyb3VwQnlTdWJzY3JpYmVyLnByb3RvdHlwZS5fZ3JvdXAgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG4gICAgICAgIGlmICghZ3JvdXBzKSB7XG4gICAgICAgICAgICBncm91cHMgPSB0aGlzLmdyb3VwcyA9IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gbmV3IEZhc3RNYXBfMS5GYXN0TWFwKCkgOiBuZXcgTWFwXzEuTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzLmdldChrZXkpO1xuICAgICAgICB2YXIgZWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRTZWxlY3Rvcih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgICAgIGdyb3VwID0gdGhpcy5zdWJqZWN0U2VsZWN0b3IgPyB0aGlzLnN1YmplY3RTZWxlY3RvcigpIDogbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG4gICAgICAgICAgICBncm91cHMuc2V0KGtleSwgZ3JvdXApO1xuICAgICAgICAgICAgdmFyIGdyb3VwZWRPYnNlcnZhYmxlID0gbmV3IEdyb3VwZWRPYnNlcnZhYmxlKGtleSwgZ3JvdXAsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGdyb3VwZWRPYnNlcnZhYmxlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uU2VsZWN0b3IobmV3IEdyb3VwZWRPYnNlcnZhYmxlKGtleSwgZ3JvdXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoZHVyYXRpb24uc3Vic2NyaWJlKG5ldyBHcm91cER1cmF0aW9uU3Vic2NyaWJlcihrZXksIGdyb3VwLCB0aGlzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZ3JvdXAuY2xvc2VkKSB7XG4gICAgICAgICAgICBncm91cC5uZXh0KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcm91cEJ5U3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG4gICAgICAgIGlmIChncm91cHMpIHtcbiAgICAgICAgICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCwga2V5KSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgR3JvdXBCeVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuICAgICAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICAgICAgICBncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXAsIGtleSkge1xuICAgICAgICAgICAgICAgIGdyb3VwLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyb3Vwcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIEdyb3VwQnlTdWJzY3JpYmVyLnByb3RvdHlwZS5yZW1vdmVHcm91cCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy5ncm91cHMuZGVsZXRlKGtleSk7XG4gICAgfTtcbiAgICBHcm91cEJ5U3Vic2NyaWJlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdGVkVG9VbnN1YnNjcmliZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwQnlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBHcm91cER1cmF0aW9uU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyKGtleSwgZ3JvdXAsIHBhcmVudCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBncm91cCk7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmdyb3VwID0gZ3JvdXA7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICBHcm91cER1cmF0aW9uU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgR3JvdXBEdXJhdGlvblN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcGFyZW50ID0gX2EucGFyZW50LCBrZXkgPSBfYS5rZXk7XG4gICAgICAgIHRoaXMua2V5ID0gdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlR3JvdXAoa2V5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLyoqXG4gKiBBbiBPYnNlcnZhYmxlIHJlcHJlc2VudGluZyB2YWx1ZXMgYmVsb25naW5nIHRvIHRoZSBzYW1lIGdyb3VwIHJlcHJlc2VudGVkIGJ5XG4gKiBhIGNvbW1vbiBrZXkuIFRoZSB2YWx1ZXMgZW1pdHRlZCBieSBhIEdyb3VwZWRPYnNlcnZhYmxlIGNvbWUgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgY29tbW9uIGtleSBpcyBhdmFpbGFibGUgYXMgdGhlIGZpZWxkIGBrZXlgIG9uIGFcbiAqIEdyb3VwZWRPYnNlcnZhYmxlIGluc3RhbmNlLlxuICpcbiAqIEBjbGFzcyBHcm91cGVkT2JzZXJ2YWJsZTxLLCBUPlxuICovXG52YXIgR3JvdXBlZE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcm91cGVkT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcm91cGVkT2JzZXJ2YWJsZShrZXksIGdyb3VwU3ViamVjdCwgcmVmQ291bnRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmdyb3VwU3ViamVjdCA9IGdyb3VwU3ViamVjdDtcbiAgICAgICAgdGhpcy5yZWZDb3VudFN1YnNjcmlwdGlvbiA9IHJlZkNvdW50U3Vic2NyaXB0aW9uO1xuICAgIH1cbiAgICBHcm91cGVkT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHJlZkNvdW50U3Vic2NyaXB0aW9uID0gX2EucmVmQ291bnRTdWJzY3JpcHRpb24sIGdyb3VwU3ViamVjdCA9IF9hLmdyb3VwU3ViamVjdDtcbiAgICAgICAgaWYgKHJlZkNvdW50U3Vic2NyaXB0aW9uICYmICFyZWZDb3VudFN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5hZGQobmV3IElubmVyUmVmQ291bnRTdWJzY3JpcHRpb24ocmVmQ291bnRTdWJzY3JpcHRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpcHRpb24uYWRkKGdyb3VwU3ViamVjdC5zdWJzY3JpYmUoc3Vic2NyaWJlcikpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwZWRPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Hcm91cGVkT2JzZXJ2YWJsZSA9IEdyb3VwZWRPYnNlcnZhYmxlO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBJbm5lclJlZkNvdW50U3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5uZXJSZWZDb3VudFN1YnNjcmlwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbm5lclJlZkNvdW50U3Vic2NyaXB0aW9uKHBhcmVudCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHBhcmVudC5jb3VudCsrO1xuICAgIH1cbiAgICBJbm5lclJlZkNvdW50U3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudC5jbG9zZWQgJiYgIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBwYXJlbnQuY291bnQgLT0gMTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY291bnQgPT09IDAgJiYgcGFyZW50LmF0dGVtcHRlZFRvVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIElubmVyUmVmQ291bnRTdWJzY3JpcHRpb247XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JvdXBCeS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvZ3JvdXBCeS5qc1xuLy8gbW9kdWxlIGlkID0gMjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBub29wXzEgPSByZXF1aXJlKCcuLi91dGlsL25vb3AnKTtcbi8qKlxuICogSWdub3JlcyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIG9ubHkgcGFzc2VzIGNhbGxzIG9mIGBjb21wbGV0ZWAgb3IgYGVycm9yYC5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2lnbm9yZUVsZW1lbnRzLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIGVtcHR5IE9ic2VydmFibGUgdGhhdCBvbmx5IGNhbGxzIGBjb21wbGV0ZWBcbiAqIG9yIGBlcnJvcmAsIGJhc2VkIG9uIHdoaWNoIG9uZSBpcyBjYWxsZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBpZ25vcmVFbGVtZW50c1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gaWdub3JlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlnbm9yZUVsZW1lbnRzT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBJZ25vcmVFbGVtZW50c09wZXJhdG9yKCkpO1xuICAgIH07XG59XG5leHBvcnRzLmlnbm9yZUVsZW1lbnRzID0gaWdub3JlRWxlbWVudHM7XG52YXIgSWdub3JlRWxlbWVudHNPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSWdub3JlRWxlbWVudHNPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgSWdub3JlRWxlbWVudHNPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlcihzdWJzY3JpYmVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gSWdub3JlRWxlbWVudHNPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJZ25vcmVFbGVtZW50c1N1YnNjcmliZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBJZ25vcmVFbGVtZW50c1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHVudXNlZCkge1xuICAgICAgICBub29wXzEubm9vcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlnbm9yZUVsZW1lbnRzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9pZ25vcmVFbGVtZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMjE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbmZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBJc0VtcHR5T3BlcmF0b3IoKSk7IH07XG59XG5leHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5O1xudmFyIElzRW1wdHlPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSXNFbXB0eU9wZXJhdG9yKCkge1xuICAgIH1cbiAgICBJc0VtcHR5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgSXNFbXB0eVN1YnNjcmliZXIob2JzZXJ2ZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBJc0VtcHR5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBJc0VtcHR5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElzRW1wdHlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElzRW1wdHlTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICB9XG4gICAgSXNFbXB0eVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlzRW1wdHkpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dChpc0VtcHR5KTtcbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIElzRW1wdHlTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLm5vdGlmeUNvbXBsZXRlKGZhbHNlKTtcbiAgICB9O1xuICAgIElzRW1wdHlTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5Q29tcGxldGUodHJ1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gSXNFbXB0eVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0VtcHR5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9pc0VtcHR5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBFbWl0cyB0aGUgZ2l2ZW4gY29uc3RhbnQgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGV2ZXJ5IHRpbWUgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MaWtlIHtAbGluayBtYXB9LCBidXQgaXQgbWFwcyBldmVyeSBzb3VyY2UgdmFsdWUgdG9cbiAqIHRoZSBzYW1lIG91dHB1dCB2YWx1ZSBldmVyeSB0aW1lLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21hcFRvLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFRha2VzIGEgY29uc3RhbnQgYHZhbHVlYCBhcyBhcmd1bWVudCwgYW5kIGVtaXRzIHRoYXQgd2hlbmV2ZXIgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLiBJbiBvdGhlciB3b3JkcywgaWdub3JlcyB0aGUgYWN0dWFsIHNvdXJjZSB2YWx1ZSxcbiAqIGFuZCBzaW1wbHkgdXNlcyB0aGUgZW1pc3Npb24gbW9tZW50IHRvIGtub3cgd2hlbiB0byBlbWl0IHRoZSBnaXZlbiBgdmFsdWVgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBldmVyeSBjbGljayB0byB0aGUgc3RyaW5nICdIaSc8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGdyZWV0aW5ncyA9IGNsaWNrcy5tYXBUbygnSGknKTtcbiAqIGdyZWV0aW5ncy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWFwfVxuICpcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gbWFwIGVhY2ggc291cmNlIHZhbHVlIHRvLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBnaXZlbiBgdmFsdWVgIGV2ZXJ5IHRpbWVcbiAqIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0cyBzb21ldGhpbmcuXG4gKiBAbWV0aG9kIG1hcFRvXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtYXBUbyh2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgTWFwVG9PcGVyYXRvcih2YWx1ZSkpOyB9O1xufVxuZXhwb3J0cy5tYXBUbyA9IG1hcFRvO1xudmFyIE1hcFRvT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcFRvT3BlcmF0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBNYXBUb09wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWFwVG9TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMudmFsdWUpKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBUb09wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWFwVG9TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFwVG9TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hcFRvU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgdmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIE1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwVG9TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwVG8uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL21hcFRvLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIE5vdGlmaWNhdGlvbl8xID0gcmVxdWlyZSgnLi4vTm90aWZpY2F0aW9uJyk7XG4vKipcbiAqIFJlcHJlc2VudHMgYWxsIG9mIHRoZSBub3RpZmljYXRpb25zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFzIGBuZXh0YFxuICogZW1pc3Npb25zIG1hcmtlZCB3aXRoIHRoZWlyIG9yaWdpbmFsIHR5cGVzIHdpdGhpbiB7QGxpbmsgTm90aWZpY2F0aW9ufVxuICogb2JqZWN0cy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+V3JhcHMgYG5leHRgLCBgZXJyb3JgIGFuZCBgY29tcGxldGVgIGVtaXNzaW9ucyBpblxuICoge0BsaW5rIE5vdGlmaWNhdGlvbn0gb2JqZWN0cywgZW1pdHRlZCBhcyBgbmV4dGAgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICogPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWF0ZXJpYWxpemUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG1hdGVyaWFsaXplYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIGBuZXh0YCBub3RpZmljYXRpb24gZm9yIGVhY2hcbiAqIGBuZXh0YCwgYGVycm9yYCwgb3IgYGNvbXBsZXRlYCBlbWlzc2lvbiBvZiB0aGUgc291cmNlIE9ic2VydmFibGUuIFdoZW4gdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0cyBgY29tcGxldGVgLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgd2lsbCBlbWl0IGBuZXh0YCBhc1xuICogYSBOb3RpZmljYXRpb24gb2YgdHlwZSBcImNvbXBsZXRlXCIsIGFuZCB0aGVuIGl0IHdpbGwgZW1pdCBgY29tcGxldGVgIGFzIHdlbGwuXG4gKiBXaGVuIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0cyBgZXJyb3JgLCB0aGUgb3V0cHV0IHdpbGwgZW1pdCBgbmV4dGAgYXMgYVxuICogTm90aWZpY2F0aW9uIG9mIHR5cGUgXCJlcnJvclwiLCBhbmQgdGhlbiBgY29tcGxldGVgLlxuICpcbiAqIFRoaXMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBwcm9kdWNpbmcgbWV0YWRhdGEgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0b1xuICogYmUgY29uc3VtZWQgYXMgYG5leHRgIGVtaXNzaW9ucy4gVXNlIGl0IGluIGNvbmp1bmN0aW9uIHdpdGhcbiAqIHtAbGluayBkZW1hdGVyaWFsaXplfS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IGEgZmF1bHR5IE9ic2VydmFibGUgdG8gYW4gT2JzZXJ2YWJsZSBvZiBOb3RpZmljYXRpb25zPC9jYXB0aW9uPlxuICogdmFyIGxldHRlcnMgPSBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAxMywgJ2QnKTtcbiAqIHZhciB1cHBlckNhc2UgPSBsZXR0ZXJzLm1hcCh4ID0+IHgudG9VcHBlckNhc2UoKSk7XG4gKiB2YXIgbWF0ZXJpYWxpemVkID0gdXBwZXJDYXNlLm1hdGVyaWFsaXplKCk7XG4gKiBtYXRlcmlhbGl6ZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIC0gTm90aWZpY2F0aW9uIHtraW5kOiBcIk5cIiwgdmFsdWU6IFwiQVwiLCBlcnJvcjogdW5kZWZpbmVkLCBoYXNWYWx1ZTogdHJ1ZX1cbiAqIC8vIC0gTm90aWZpY2F0aW9uIHtraW5kOiBcIk5cIiwgdmFsdWU6IFwiQlwiLCBlcnJvcjogdW5kZWZpbmVkLCBoYXNWYWx1ZTogdHJ1ZX1cbiAqIC8vIC0gTm90aWZpY2F0aW9uIHtraW5kOiBcIkVcIiwgdmFsdWU6IHVuZGVmaW5lZCwgZXJyb3I6IFR5cGVFcnJvcjpcbiAqIC8vICAgeC50b1VwcGVyQ2FzZSBpcyBub3QgYSBmdW5jdGlvbiBhdCBNYXBTdWJzY3JpYmVyLmxldHRlcnMubWFwLnhcbiAqIC8vICAgW2FzIHByb2plY3RdIChodHRwOi8vMeKApiwgaGFzVmFsdWU6IGZhbHNlfVxuICpcbiAqIEBzZWUge0BsaW5rIE5vdGlmaWNhdGlvbn1cbiAqIEBzZWUge0BsaW5rIGRlbWF0ZXJpYWxpemV9XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxOb3RpZmljYXRpb248VD4+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHNcbiAqIHtAbGluayBOb3RpZmljYXRpb259IG9iamVjdHMgdGhhdCB3cmFwIHRoZSBvcmlnaW5hbCBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIHdpdGggbWV0YWRhdGEuXG4gKiBAbWV0aG9kIG1hdGVyaWFsaXplXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtYXRlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWF0ZXJpYWxpemVPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IE1hdGVyaWFsaXplT3BlcmF0b3IoKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMubWF0ZXJpYWxpemUgPSBtYXRlcmlhbGl6ZTtcbnZhciBNYXRlcmlhbGl6ZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRlcmlhbGl6ZU9wZXJhdG9yKCkge1xuICAgIH1cbiAgICBNYXRlcmlhbGl6ZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWF0ZXJpYWxpemVTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXRlcmlhbGl6ZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWF0ZXJpYWxpemVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF0ZXJpYWxpemVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hdGVyaWFsaXplU3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgfVxuICAgIE1hdGVyaWFsaXplU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0KHZhbHVlKSk7XG4gICAgfTtcbiAgICBNYXRlcmlhbGl6ZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dChOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlRXJyb3IoZXJyKSk7XG4gICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBNYXRlcmlhbGl6ZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dChOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlQ29tcGxldGUoKSk7XG4gICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWF0ZXJpYWxpemVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0ZXJpYWxpemUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL21hdGVyaWFsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJlZHVjZV8xID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcbi8qKlxuICogVGhlIE1heCBvcGVyYXRvciBvcGVyYXRlcyBvbiBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbnVtYmVycyAob3IgaXRlbXMgdGhhdCBjYW4gYmUgY29tcGFyZWQgd2l0aCBhIHByb3ZpZGVkIGZ1bmN0aW9uKSxcbiAqIGFuZCB3aGVuIHNvdXJjZSBPYnNlcnZhYmxlIGNvbXBsZXRlcyBpdCBlbWl0cyBhIHNpbmdsZSBpdGVtOiB0aGUgaXRlbSB3aXRoIHRoZSBsYXJnZXN0IHZhbHVlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWF4LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkdldCB0aGUgbWF4aW1hbCB2YWx1ZSBvZiBhIHNlcmllcyBvZiBudW1iZXJzPC9jYXB0aW9uPlxuICogUnguT2JzZXJ2YWJsZS5vZig1LCA0LCA3LCAyLCA4KVxuICogICAubWF4KClcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTsgLy8gLT4gOFxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlVzZSBhIGNvbXBhcmVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgbWF4aW1hbCBpdGVtPC9jYXB0aW9uPlxuICogaW50ZXJmYWNlIFBlcnNvbiB7XG4gKiAgIGFnZTogbnVtYmVyLFxuICogICBuYW1lOiBzdHJpbmdcbiAqIH1cbiAqIE9ic2VydmFibGUub2Y8UGVyc29uPih7YWdlOiA3LCBuYW1lOiAnRm9vJ30sXG4gKiAgICAgICAgICAgICAgICAgICAgICAge2FnZTogNSwgbmFtZTogJ0Jhcid9LFxuICogICAgICAgICAgICAgICAgICAgICAgIHthZ2U6IDksIG5hbWU6ICdCZWVyJ30pXG4gKiAgICAgICAgICAgLm1heDxQZXJzb24+KChhOiBQZXJzb24sIGI6IFBlcnNvbikgPT4gYS5hZ2UgPCBiLmFnZSA/IC0xIDogMSlcbiAqICAgICAgICAgICAuc3Vic2NyaWJlKCh4OiBQZXJzb24pID0+IGNvbnNvbGUubG9nKHgubmFtZSkpOyAvLyAtPiAnQmVlcidcbiAqIH1cbiAqXG4gKiBAc2VlIHtAbGluayBtaW59XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSAtIE9wdGlvbmFsIGNvbXBhcmVyIGZ1bmN0aW9uIHRoYXQgaXQgd2lsbCB1c2UgaW5zdGVhZCBvZiBpdHMgZGVmYXVsdCB0byBjb21wYXJlIHRoZVxuICogdmFsdWUgb2YgdHdvIGl0ZW1zLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW0gd2l0aCB0aGUgbGFyZ2VzdCB2YWx1ZS5cbiAqIEBtZXRob2QgbWF4XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtYXgoY29tcGFyZXIpIHtcbiAgICB2YXIgbWF4ID0gKHR5cGVvZiBjb21wYXJlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgPyBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4gY29tcGFyZXIoeCwgeSkgPiAwID8geCA6IHk7IH1cbiAgICAgICAgOiBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCA+IHkgPyB4IDogeTsgfTtcbiAgICByZXR1cm4gcmVkdWNlXzEucmVkdWNlKG1heCk7XG59XG5leHBvcnRzLm1heCA9IG1heDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvbWF4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1lcmdlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL21lcmdlJyk7XG52YXIgbWVyZ2VfMiA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvbWVyZ2UnKTtcbmV4cG9ydHMubWVyZ2VTdGF0aWMgPSBtZXJnZV8yLm1lcmdlO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ3JlYXRlcyBhbiBvdXRwdXQgT2JzZXJ2YWJsZSB3aGljaCBjb25jdXJyZW50bHkgZW1pdHMgYWxsIHZhbHVlcyBmcm9tIGV2ZXJ5XG4gKiBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciBieSBibGVuZGluZ1xuICogdGhlaXIgdmFsdWVzIGludG8gb25lIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG1lcmdlYCBzdWJzY3JpYmVzIHRvIGVhY2ggZ2l2ZW4gaW5wdXQgT2JzZXJ2YWJsZSAoZWl0aGVyIHRoZSBzb3VyY2Ugb3IgYW5cbiAqIE9ic2VydmFibGUgZ2l2ZW4gYXMgYXJndW1lbnQpLCBhbmQgc2ltcGx5IGZvcndhcmRzICh3aXRob3V0IGRvaW5nIGFueVxuICogdHJhbnNmb3JtYXRpb24pIGFsbCB0aGUgdmFsdWVzIGZyb20gYWxsIHRoZSBpbnB1dCBPYnNlcnZhYmxlcyB0byB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgb25seSBjb21wbGV0ZXMgb25jZSBhbGwgaW5wdXQgT2JzZXJ2YWJsZXNcbiAqIGhhdmUgY29tcGxldGVkLiBBbnkgZXJyb3IgZGVsaXZlcmVkIGJ5IGFuIGlucHV0IE9ic2VydmFibGUgd2lsbCBiZSBpbW1lZGlhdGVseVxuICogZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWVyZ2UgdG9nZXRoZXIgdHdvIE9ic2VydmFibGVzOiAxcyBpbnRlcnZhbCBhbmQgY2xpY2tzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgY2xpY2tzT3JUaW1lciA9IGNsaWNrcy5tZXJnZSh0aW1lcik7XG4gKiBjbGlja3NPclRpbWVyLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NZXJnZSB0b2dldGhlciAzIE9ic2VydmFibGVzLCBidXQgb25seSAyIHJ1biBjb25jdXJyZW50bHk8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIxID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcbiAqIHZhciB0aW1lcjIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDIwMDApLnRha2UoNik7XG4gKiB2YXIgdGltZXIzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLnRha2UoMTApO1xuICogdmFyIGNvbmN1cnJlbnQgPSAyOyAvLyB0aGUgYXJndW1lbnRcbiAqIHZhciBtZXJnZWQgPSB0aW1lcjEubWVyZ2UodGltZXIyLCB0aW1lcjMsIGNvbmN1cnJlbnQpO1xuICogbWVyZ2VkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gb3RoZXIgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBtZXJnZSB3aXRoIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5wdXRcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvciBtYW5hZ2luZ1xuICogY29uY3VycmVuY3kgb2YgaW5wdXQgT2JzZXJ2YWJsZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgdGhhdCBhcmUgdGhlIHJlc3VsdCBvZlxuICogZXZlcnkgaW5wdXQgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgbWVyZ2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQuY2FsbChtZXJnZV8xLm1lcmdlLmFwcGx5KHZvaWQgMCwgW3NvdXJjZV0uY29uY2F0KG9ic2VydmFibGVzKSkpOyB9O1xufVxuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL21lcmdlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gdGhlIHNhbWUgT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgbXVsdGlwbGVcbiAqIHRpbWVzIGluIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBtZXJnZU1hcH0sIGJ1dCBtYXBzIGVhY2ggdmFsdWUgYWx3YXlzXG4gKiB0byB0aGUgc2FtZSBpbm5lciBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21lcmdlTWFwVG8ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogTWFwcyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgZ2l2ZW4gT2JzZXJ2YWJsZSBgaW5uZXJPYnNlcnZhYmxlYCByZWdhcmRsZXNzXG4gKiBvZiB0aGUgc291cmNlIHZhbHVlLCBhbmQgdGhlbiBtZXJnZXMgdGhvc2UgcmVzdWx0aW5nIE9ic2VydmFibGVzIGludG8gb25lXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgd2hpY2ggaXMgdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkZvciBlYWNoIGNsaWNrIGV2ZW50LCBzdGFydCBhbiBpbnRlcnZhbCBPYnNlcnZhYmxlIHRpY2tpbmcgZXZlcnkgMSBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5tZXJnZU1hcFRvKFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcFRvfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBpbm5lck9ic2VydmFibGUgQW4gT2JzZXJ2YWJsZSB0byByZXBsYWNlIGVhY2ggdmFsdWUgZnJvbVxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVudD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIE1heGltdW0gbnVtYmVyIG9mIGlucHV0XG4gKiBPYnNlcnZhYmxlcyBiZWluZyBzdWJzY3JpYmVkIHRvIGNvbmN1cnJlbnRseS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZSBnaXZlblxuICogYGlubmVyT2JzZXJ2YWJsZWAgKGFuZCBvcHRpb25hbGx5IHRyYW5zZm9ybWVkIHRocm91Z2ggYHJlc3VsdFNlbGVjdG9yYCkgZXZlcnlcbiAqIHRpbWUgYSB2YWx1ZSBpcyBlbWl0dGVkIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgbWVyZ2VNYXBUb1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VNYXBUbyhpbm5lck9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHRTZWxlY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uY3VycmVudCA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICByZXN1bHRTZWxlY3RvciA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgTWVyZ2VNYXBUb09wZXJhdG9yKGlubmVyT2JzZXJ2YWJsZSwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpKTsgfTtcbn1cbmV4cG9ydHMubWVyZ2VNYXBUbyA9IG1lcmdlTWFwVG87XG4vLyBUT0RPOiBGaWd1cmUgb3V0IGNvcnJlY3Qgc2lnbmF0dXJlIGhlcmU6IGFuIE9wZXJhdG9yPE9ic2VydmFibGU8VD4sIFI+XG4vLyAgICAgICBuZWVkcyB0byBpbXBsZW1lbnQgY2FsbChvYnNlcnZlcjogU3Vic2NyaWJlcjxSPik6IFN1YnNjcmliZXI8T2JzZXJ2YWJsZTxUPj5cbnZhciBNZXJnZU1hcFRvT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lcmdlTWFwVG9PcGVyYXRvcihpc2gsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICB0aGlzLmlzaCA9IGlzaDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgIH1cbiAgICBNZXJnZU1hcFRvT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VNYXBUb1N1YnNjcmliZXIob2JzZXJ2ZXIsIHRoaXMuaXNoLCB0aGlzLnJlc3VsdFNlbGVjdG9yLCB0aGlzLmNvbmN1cnJlbnQpKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXJnZU1hcFRvT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5NZXJnZU1hcFRvT3BlcmF0b3IgPSBNZXJnZU1hcFRvT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE1lcmdlTWFwVG9TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVyZ2VNYXBUb1N1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVyZ2VNYXBUb1N1YnNjcmliZXIoZGVzdGluYXRpb24sIGlzaCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5pc2ggPSBpc2g7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgTWVyZ2VNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA8IHRoaXMuY29uY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdFNlbGVjdG9yID0gdGhpcy5yZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgIHZhciBpc2ggPSB0aGlzLmlzaDtcbiAgICAgICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSsrO1xuICAgICAgICAgICAgdGhpcy5faW5uZXJTdWIoaXNoLCBkZXN0aW5hdGlvbiwgcmVzdWx0U2VsZWN0b3IsIHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLl9pbm5lclN1YiA9IGZ1bmN0aW9uIChpc2gsIGRlc3RpbmF0aW9uLCByZXN1bHRTZWxlY3RvciwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgaXNoLCB2YWx1ZSwgaW5kZXgpKTtcbiAgICB9O1xuICAgIE1lcmdlTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZU1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXN1bHRTZWxlY3RvciA9IF9hLnJlc3VsdFNlbGVjdG9yLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAocmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5U2VsZWN0UmVzdWx0KG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLnRyeVNlbGVjdFJlc3VsdCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHJlc3VsdFNlbGVjdG9yID0gX2EucmVzdWx0U2VsZWN0b3IsIGRlc3RpbmF0aW9uID0gX2EuZGVzdGluYXRpb247XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIE1lcmdlTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgTWVyZ2VNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmFjdGl2ZS0tO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQoYnVmZmVyLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZXJnZU1hcFRvU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG5leHBvcnRzLk1lcmdlTWFwVG9TdWJzY3JpYmVyID0gTWVyZ2VNYXBUb1N1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZU1hcFRvLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9tZXJnZU1hcFRvLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbi8qKlxuICogQXBwbGllcyBhbiBhY2N1bXVsYXRvciBmdW5jdGlvbiBvdmVyIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aGVyZSB0aGVcbiAqIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIGl0c2VsZiByZXR1cm5zIGFuIE9ic2VydmFibGUsIHRoZW4gZWFjaCBpbnRlcm1lZGlhdGVcbiAqIE9ic2VydmFibGUgcmV0dXJuZWQgaXMgbWVyZ2VkIGludG8gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIHNjYW59LCBidXQgdGhlIE9ic2VydmFibGVzIHJldHVybmVkXG4gKiBieSB0aGUgYWNjdW11bGF0b3IgYXJlIG1lcmdlZCBpbnRvIHRoZSBvdXRlciBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db3VudCB0aGUgbnVtYmVyIG9mIGNsaWNrIGV2ZW50czwvY2FwdGlvbj5cbiAqIGNvbnN0IGNsaWNrJCA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNvbnN0IG9uZSQgPSBjbGljayQubWFwVG8oMSk7XG4gKiBjb25zdCBzZWVkID0gMDtcbiAqIGNvbnN0IGNvdW50JCA9IG9uZSQubWVyZ2VTY2FuKChhY2MsIG9uZSkgPT4gUnguT2JzZXJ2YWJsZS5vZihhY2MgKyBvbmUpLCBzZWVkKTtcbiAqIGNvdW50JC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0czpcbiAqIDFcbiAqIDJcbiAqIDNcbiAqIDRcbiAqIC8vIC4uLmFuZCBzbyBvbiBmb3IgZWFjaCBjbGlja1xuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYWNjOiBSLCB2YWx1ZTogVCk6IE9ic2VydmFibGU8Uj59IGFjY3VtdWxhdG9yXG4gKiBUaGUgYWNjdW11bGF0b3IgZnVuY3Rpb24gY2FsbGVkIG9uIGVhY2ggc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHNlZWQgVGhlIGluaXRpYWwgYWNjdW11bGF0aW9uIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2ZcbiAqIGlucHV0IE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn0gQW4gb2JzZXJ2YWJsZSBvZiB0aGUgYWNjdW11bGF0ZWQgdmFsdWVzLlxuICogQG1ldGhvZCBtZXJnZVNjYW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlU2NhbihhY2N1bXVsYXRvciwgc2VlZCwgY29uY3VycmVudCkge1xuICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgTWVyZ2VTY2FuT3BlcmF0b3IoYWNjdW11bGF0b3IsIHNlZWQsIGNvbmN1cnJlbnQpKTsgfTtcbn1cbmV4cG9ydHMubWVyZ2VTY2FuID0gbWVyZ2VTY2FuO1xudmFyIE1lcmdlU2Nhbk9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXJnZVNjYW5PcGVyYXRvcihhY2N1bXVsYXRvciwgc2VlZCwgY29uY3VycmVudCkge1xuICAgICAgICB0aGlzLmFjY3VtdWxhdG9yID0gYWNjdW11bGF0b3I7XG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgfVxuICAgIE1lcmdlU2Nhbk9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VTY2FuU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmFjY3VtdWxhdG9yLCB0aGlzLnNlZWQsIHRoaXMuY29uY3VycmVudCkpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlU2Nhbk9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWVyZ2VTY2FuT3BlcmF0b3IgPSBNZXJnZVNjYW5PcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWVyZ2VTY2FuU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lcmdlU2NhblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVyZ2VTY2FuU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgYWNjdW11bGF0b3IsIGFjYywgY29uY3VycmVudCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcjtcbiAgICAgICAgdGhpcy5hY2MgPSBhY2M7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgTWVyZ2VTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlIDwgdGhpcy5jb25jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICB2YXIgaXNoID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLmFjY3VtdWxhdG9yKSh0aGlzLmFjYywgdmFsdWUpO1xuICAgICAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIGlmIChpc2ggPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgICAgICAgICB0aGlzLl9pbm5lclN1Yihpc2gsIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUuX2lubmVyU3ViID0gZnVuY3Rpb24gKGlzaCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgaXNoLCB2YWx1ZSwgaW5kZXgpKTtcbiAgICB9O1xuICAgIE1lcmdlU2NhblN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5hY2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZVNjYW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMuYWNjID0gaW5uZXJWYWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBNZXJnZVNjYW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMuYWNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlU2NhblN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5NZXJnZVNjYW5TdWJzY3JpYmVyID0gTWVyZ2VTY2FuU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlU2Nhbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvbWVyZ2VTY2FuLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJlZHVjZV8xID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcbi8qKlxuICogVGhlIE1pbiBvcGVyYXRvciBvcGVyYXRlcyBvbiBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbnVtYmVycyAob3IgaXRlbXMgdGhhdCBjYW4gYmUgY29tcGFyZWQgd2l0aCBhIHByb3ZpZGVkIGZ1bmN0aW9uKSxcbiAqIGFuZCB3aGVuIHNvdXJjZSBPYnNlcnZhYmxlIGNvbXBsZXRlcyBpdCBlbWl0cyBhIHNpbmdsZSBpdGVtOiB0aGUgaXRlbSB3aXRoIHRoZSBzbWFsbGVzdCB2YWx1ZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21pbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZXQgdGhlIG1pbmltYWwgdmFsdWUgb2YgYSBzZXJpZXMgb2YgbnVtYmVyczwvY2FwdGlvbj5cbiAqIFJ4Lk9ic2VydmFibGUub2YoNSwgNCwgNywgMiwgOClcbiAqICAgLm1pbigpXG4gKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7IC8vIC0+IDJcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2UgYSBjb21wYXJlciBmdW5jdGlvbiB0byBnZXQgdGhlIG1pbmltYWwgaXRlbTwvY2FwdGlvbj5cbiAqIGludGVyZmFjZSBQZXJzb24ge1xuICogICBhZ2U6IG51bWJlcixcbiAqICAgbmFtZTogc3RyaW5nXG4gKiB9XG4gKiBPYnNlcnZhYmxlLm9mPFBlcnNvbj4oe2FnZTogNywgbmFtZTogJ0Zvbyd9LFxuICogICAgICAgICAgICAgICAgICAgICAgIHthZ2U6IDUsIG5hbWU6ICdCYXInfSxcbiAqICAgICAgICAgICAgICAgICAgICAgICB7YWdlOiA5LCBuYW1lOiAnQmVlcid9KVxuICogICAgICAgICAgIC5taW48UGVyc29uPiggKGE6IFBlcnNvbiwgYjogUGVyc29uKSA9PiBhLmFnZSA8IGIuYWdlID8gLTEgOiAxKVxuICogICAgICAgICAgIC5zdWJzY3JpYmUoKHg6IFBlcnNvbikgPT4gY29uc29sZS5sb2coeC5uYW1lKSk7IC8vIC0+ICdCYXInXG4gKiB9XG4gKlxuICogQHNlZSB7QGxpbmsgbWF4fVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlcl0gLSBPcHRpb25hbCBjb21wYXJlciBmdW5jdGlvbiB0aGF0IGl0IHdpbGwgdXNlIGluc3RlYWQgb2YgaXRzIGRlZmF1bHQgdG8gY29tcGFyZSB0aGVcbiAqIHZhbHVlIG9mIHR3byBpdGVtcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtIHdpdGggdGhlIHNtYWxsZXN0IHZhbHVlLlxuICogQG1ldGhvZCBtaW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1pbihjb21wYXJlcikge1xuICAgIHZhciBtaW4gPSAodHlwZW9mIGNvbXBhcmVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICA/IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiBjb21wYXJlcih4LCB5KSA8IDAgPyB4IDogeTsgfVxuICAgICAgICA6IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4IDwgeSA/IHggOiB5OyB9O1xuICAgIHJldHVybiByZWR1Y2VfMS5yZWR1Y2UobWluKTtcbn1cbmV4cG9ydHMubWluID0gbWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWluLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9taW4uanNcbi8vIG1vZHVsZSBpZCA9IDIyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBGcm9tT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9Gcm9tT2JzZXJ2YWJsZScpO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFdoZW4gYW55IG9mIHRoZSBwcm92aWRlZCBPYnNlcnZhYmxlIGVtaXRzIGFuIGNvbXBsZXRlIG9yIGVycm9yIG5vdGlmaWNhdGlvbiwgaXQgaW1tZWRpYXRlbHkgc3Vic2NyaWJlcyB0byB0aGUgbmV4dCBvbmVcbiAqIHRoYXQgd2FzIHBhc3NlZC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RXhlY3V0ZSBzZXJpZXMgb2YgT2JzZXJ2YWJsZXMgbm8gbWF0dGVyIHdoYXQsIGV2ZW4gaWYgaXQgbWVhbnMgc3dhbGxvd2luZyBlcnJvcnMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvb25FcnJvclJlc3VtZU5leHQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG9uRXJyb3JSZXN1bWVOZXh0YCBpcyBhbiBvcGVyYXRvciB0aGF0IGFjY2VwdHMgYSBzZXJpZXMgb2YgT2JzZXJ2YWJsZXMsIHByb3ZpZGVkIGVpdGhlciBkaXJlY3RseSBhc1xuICogYXJndW1lbnRzIG9yIGFzIGFuIGFycmF5LiBJZiBubyBzaW5nbGUgT2JzZXJ2YWJsZSBpcyBwcm92aWRlZCwgcmV0dXJuZWQgT2JzZXJ2YWJsZSB3aWxsIHNpbXBseSBiZWhhdmUgdGhlIHNhbWVcbiAqIGFzIHRoZSBzb3VyY2UuXG4gKlxuICogYG9uRXJyb3JSZXN1bWVOZXh0YCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBzdGFydHMgYnkgc3Vic2NyaWJpbmcgYW5kIHJlLWVtaXR0aW5nIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIFdoZW4gaXRzIHN0cmVhbSBvZiB2YWx1ZXMgZW5kcyAtIG5vIG1hdHRlciBpZiBPYnNlcnZhYmxlIGNvbXBsZXRlZCBvciBlbWl0dGVkIGFuIGVycm9yIC0gYG9uRXJyb3JSZXN1bWVOZXh0YFxuICogd2lsbCBzdWJzY3JpYmUgdG8gdGhlIGZpcnN0IE9ic2VydmFibGUgdGhhdCB3YXMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBtZXRob2QuIEl0IHdpbGwgc3RhcnQgcmUtZW1pdHRpbmdcbiAqIGl0cyB2YWx1ZXMgYXMgd2VsbCBhbmQgLSBhZ2FpbiAtIHdoZW4gdGhhdCBzdHJlYW0gZW5kcywgYG9uRXJyb3JSZXN1bWVOZXh0YCB3aWxsIHByb2NlZWQgdG8gc3Vic2NyaWJpbmcgeWV0IGFub3RoZXJcbiAqIE9ic2VydmFibGUgaW4gcHJvdmlkZWQgc2VyaWVzLCBubyBtYXR0ZXIgaWYgcHJldmlvdXMgT2JzZXJ2YWJsZSBjb21wbGV0ZWQgb3IgZW5kZWQgd2l0aCBhbiBlcnJvci4gVGhpcyB3aWxsXG4gKiBiZSBoYXBwZW5pbmcgdW50aWwgdGhlcmUgaXMgbm8gbW9yZSBPYnNlcnZhYmxlcyBsZWZ0IGluIHRoZSBzZXJpZXMsIGF0IHdoaWNoIHBvaW50IHJldHVybmVkIE9ic2VydmFibGUgd2lsbFxuICogY29tcGxldGUgLSBldmVuIGlmIHRoZSBsYXN0IHN1YnNjcmliZWQgc3RyZWFtIGVuZGVkIHdpdGggYW4gZXJyb3IuXG4gKlxuICogYG9uRXJyb3JSZXN1bWVOZXh0YCBjYW4gYmUgdGhlcmVmb3JlIHRob3VnaHQgb2YgYXMgdmVyc2lvbiBvZiB7QGxpbmsgY29uY2F0fSBvcGVyYXRvciwgd2hpY2ggaXMgbW9yZSBwZXJtaXNzaXZlXG4gKiB3aGVuIGl0IGNvbWVzIHRvIHRoZSBlcnJvcnMgZW1pdHRlZCBieSBpdHMgaW5wdXQgT2JzZXJ2YWJsZXMuIFdoaWxlIGBjb25jYXRgIHN1YnNjcmliZXMgdG8gdGhlIG5leHQgT2JzZXJ2YWJsZVxuICogaW4gc2VyaWVzIG9ubHkgaWYgcHJldmlvdXMgb25lIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQsIGBvbkVycm9yUmVzdW1lTmV4dGAgc3Vic2NyaWJlcyBldmVuIGlmIGl0IGVuZGVkIHdpdGhcbiAqIGFuIGVycm9yLlxuICpcbiAqIE5vdGUgdGhhdCB5b3UgZG8gbm90IGdldCBhbnkgYWNjZXNzIHRvIGVycm9ycyBlbWl0dGVkIGJ5IHRoZSBPYnNlcnZhYmxlcy4gSW4gcGFydGljdWxhciBkbyBub3RcbiAqIGV4cGVjdCB0aGVzZSBlcnJvcnMgdG8gYXBwZWFyIGluIGVycm9yIGNhbGxiYWNrIHBhc3NlZCB0byB7QGxpbmsgc3Vic2NyaWJlfS4gSWYgeW91IHdhbnQgdG8gdGFrZVxuICogc3BlY2lmaWMgYWN0aW9ucyBiYXNlZCBvbiB3aGF0IGVycm9yIHdhcyBlbWl0dGVkIGJ5IGFuIE9ic2VydmFibGUsIHlvdSBzaG91bGQgdHJ5IG91dCB7QGxpbmsgY2F0Y2h9IGluc3RlYWQuXG4gKlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlN1YnNjcmliZSB0byB0aGUgbmV4dCBPYnNlcnZhYmxlIGFmdGVyIG1hcCBmYWlsczwvY2FwdGlvbj5cbiAqIFJ4Lk9ic2VydmFibGUub2YoMSwgMiwgMywgMClcbiAqICAgLm1hcCh4ID0+IHtcbiAqICAgICAgIGlmICh4ID09PSAwKSB7IHRocm93IEVycm9yKCk7IH1cbiAgICAgICAgIHJldHVybiAxMCAvIHg7XG4gKiAgIH0pXG4gKiAgIC5vbkVycm9yUmVzdW1lTmV4dChSeC5PYnNlcnZhYmxlLm9mKDEsIDIsIDMpKVxuICogICAuc3Vic2NyaWJlKFxuICogICAgIHZhbCA9PiBjb25zb2xlLmxvZyh2YWwpLFxuICogICAgIGVyciA9PiBjb25zb2xlLmxvZyhlcnIpLCAgICAgICAgICAvLyBXaWxsIG5ldmVyIGJlIGNhbGxlZC5cbiAqICAgICAoKSA9PiBjb25zb2xlLmxvZygndGhhdFxcJ3MgaXQhJylcbiAqICAgKTtcbiAqXG4gKiAvLyBMb2dzOlxuICogLy8gMTBcbiAqIC8vIDVcbiAqIC8vIDMuMzMzMzMzMzMzMzMzMzMzNVxuICogLy8gMVxuICogLy8gMlxuICogLy8gM1xuICogLy8gXCJ0aGF0J3MgaXQhXCJcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXR9XG4gKiBAc2VlIHtAbGluayBjYXRjaH1cbiAqXG4gKiBAcGFyYW0gey4uLk9ic2VydmFibGVJbnB1dH0gb2JzZXJ2YWJsZXMgT2JzZXJ2YWJsZXMgcGFzc2VkIGVpdGhlciBkaXJlY3RseSBvciBhcyBhbiBhcnJheS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB2YWx1ZXMgZnJvbSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IC0gaWYgaXQgZXJyb3JzIC0gc3Vic2NyaWJlc1xuICogdG8gdGhlIG5leHQgcGFzc2VkIE9ic2VydmFibGUgYW5kIHNvIG9uLCB1bnRpbCBpdCBjb21wbGV0ZXMgb3IgcnVucyBvdXQgb2YgT2JzZXJ2YWJsZXMuXG4gKiBAbWV0aG9kIG9uRXJyb3JSZXN1bWVOZXh0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dCgpIHtcbiAgICB2YXIgbmV4dFNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBuZXh0U291cmNlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKG5leHRTb3VyY2VzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5XzEuaXNBcnJheShuZXh0U291cmNlc1swXSkpIHtcbiAgICAgICAgbmV4dFNvdXJjZXMgPSBuZXh0U291cmNlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBPbkVycm9yUmVzdW1lTmV4dE9wZXJhdG9yKG5leHRTb3VyY2VzKSk7IH07XG59XG5leHBvcnRzLm9uRXJyb3JSZXN1bWVOZXh0ID0gb25FcnJvclJlc3VtZU5leHQ7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHRTdGF0aWMoKSB7XG4gICAgdmFyIG5leHRTb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgbmV4dFNvdXJjZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSBudWxsO1xuICAgIGlmIChuZXh0U291cmNlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheV8xLmlzQXJyYXkobmV4dFNvdXJjZXNbMF0pKSB7XG4gICAgICAgIG5leHRTb3VyY2VzID0gbmV4dFNvdXJjZXNbMF07XG4gICAgfVxuICAgIHNvdXJjZSA9IG5leHRTb3VyY2VzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIG5ldyBGcm9tT2JzZXJ2YWJsZV8xLkZyb21PYnNlcnZhYmxlKHNvdXJjZSwgbnVsbCkubGlmdChuZXcgT25FcnJvclJlc3VtZU5leHRPcGVyYXRvcihuZXh0U291cmNlcykpO1xufVxuZXhwb3J0cy5vbkVycm9yUmVzdW1lTmV4dFN0YXRpYyA9IG9uRXJyb3JSZXN1bWVOZXh0U3RhdGljO1xudmFyIE9uRXJyb3JSZXN1bWVOZXh0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9uRXJyb3JSZXN1bWVOZXh0T3BlcmF0b3IobmV4dFNvdXJjZXMpIHtcbiAgICAgICAgdGhpcy5uZXh0U291cmNlcyA9IG5leHRTb3VyY2VzO1xuICAgIH1cbiAgICBPbkVycm9yUmVzdW1lTmV4dE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubmV4dFNvdXJjZXMpKTtcbiAgICB9O1xuICAgIHJldHVybiBPbkVycm9yUmVzdW1lTmV4dE9wZXJhdG9yO1xufSgpKTtcbnZhciBPbkVycm9yUmVzdW1lTmV4dFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPbkVycm9yUmVzdW1lTmV4dFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBuZXh0U291cmNlcykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5uZXh0U291cmNlcyA9IG5leHRTb3VyY2VzO1xuICAgIH1cbiAgICBPbkVycm9yUmVzdW1lTmV4dFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvTmV4dFNvdXJjZSgpO1xuICAgIH07XG4gICAgT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvTmV4dFNvdXJjZSgpO1xuICAgIH07XG4gICAgT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9OZXh0U291cmNlKCk7XG4gICAgfTtcbiAgICBPbkVycm9yUmVzdW1lTmV4dFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb05leHRTb3VyY2UoKTtcbiAgICB9O1xuICAgIE9uRXJyb3JSZXN1bWVOZXh0U3Vic2NyaWJlci5wcm90b3R5cGUuc3Vic2NyaWJlVG9OZXh0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMubmV4dFNvdXJjZXMuc2hpZnQoKTtcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgbmV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uRXJyb3JSZXN1bWVOZXh0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9vbkVycm9yUmVzdW1lTmV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMjI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogR3JvdXBzIHBhaXJzIG9mIGNvbnNlY3V0aXZlIGVtaXNzaW9ucyB0b2dldGhlciBhbmQgZW1pdHMgdGhlbSBhcyBhbiBhcnJheSBvZlxuICogdHdvIHZhbHVlcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+UHV0cyB0aGUgY3VycmVudCB2YWx1ZSBhbmQgcHJldmlvdXMgdmFsdWUgdG9nZXRoZXIgYXNcbiAqIGFuIGFycmF5LCBhbmQgZW1pdHMgdGhhdC48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9wYWlyd2lzZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBUaGUgTnRoIGVtaXNzaW9uIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpbGwgY2F1c2UgdGhlIG91dHB1dCBPYnNlcnZhYmxlXG4gKiB0byBlbWl0IGFuIGFycmF5IFsoTi0xKXRoLCBOdGhdIG9mIHRoZSBwcmV2aW91cyBhbmQgdGhlIGN1cnJlbnQgdmFsdWUsIGFzIGFcbiAqIHBhaXIuIEZvciB0aGlzIHJlYXNvbiwgYHBhaXJ3aXNlYCBlbWl0cyBvbiB0aGUgc2Vjb25kIGFuZCBzdWJzZXF1ZW50XG4gKiBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCBub3Qgb24gdGhlIGZpcnN0IGVtaXNzaW9uLCBiZWNhdXNlXG4gKiB0aGVyZSBpcyBubyBwcmV2aW91cyB2YWx1ZSBpbiB0aGF0IGNhc2UuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+T24gZXZlcnkgY2xpY2sgKHN0YXJ0aW5nIGZyb20gdGhlIHNlY29uZCksIGVtaXQgdGhlIHJlbGF0aXZlIGRpc3RhbmNlIHRvIHRoZSBwcmV2aW91cyBjbGljazwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcGFpcnMgPSBjbGlja3MucGFpcndpc2UoKTtcbiAqIHZhciBkaXN0YW5jZSA9IHBhaXJzLm1hcChwYWlyID0+IHtcbiAqICAgdmFyIHgwID0gcGFpclswXS5jbGllbnRYO1xuICogICB2YXIgeTAgPSBwYWlyWzBdLmNsaWVudFk7XG4gKiAgIHZhciB4MSA9IHBhaXJbMV0uY2xpZW50WDtcbiAqICAgdmFyIHkxID0gcGFpclsxXS5jbGllbnRZO1xuICogICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgwIC0geDEsIDIpICsgTWF0aC5wb3coeTAgLSB5MSwgMikpO1xuICogfSk7XG4gKiBkaXN0YW5jZS5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYnVmZmVyfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyQ291bnR9XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxBcnJheTxUPj59IEFuIE9ic2VydmFibGUgb2YgcGFpcnMgKGFzIGFycmF5cykgb2ZcbiAqIGNvbnNlY3V0aXZlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgcGFpcndpc2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHBhaXJ3aXNlKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgUGFpcndpc2VPcGVyYXRvcigpKTsgfTtcbn1cbmV4cG9ydHMucGFpcndpc2UgPSBwYWlyd2lzZTtcbnZhciBQYWlyd2lzZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYWlyd2lzZU9wZXJhdG9yKCkge1xuICAgIH1cbiAgICBQYWlyd2lzZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUGFpcndpc2VTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBQYWlyd2lzZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgUGFpcndpc2VTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFpcndpc2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhaXJ3aXNlU3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaGFzUHJldiA9IGZhbHNlO1xuICAgIH1cbiAgICBQYWlyd2lzZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ByZXYpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChbdGhpcy5wcmV2LCB2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYXNQcmV2ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXYgPSB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBQYWlyd2lzZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWlyd2lzZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvcGFpcndpc2UuanNcbi8vIG1vZHVsZSBpZCA9IDIyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbm90XzEgPSByZXF1aXJlKCcuLi91dGlsL25vdCcpO1xudmFyIGZpbHRlcl8xID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcbi8qKlxuICogU3BsaXRzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBpbnRvIHR3bywgb25lIHdpdGggdmFsdWVzIHRoYXQgc2F0aXNmeSBhXG4gKiBwcmVkaWNhdGUsIGFuZCBhbm90aGVyIHdpdGggdmFsdWVzIHRoYXQgZG9uJ3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGZpbHRlcn0sIGJ1dCByZXR1cm5zIHR3byBPYnNlcnZhYmxlczpcbiAqIG9uZSBsaWtlIHRoZSBvdXRwdXQgb2Yge0BsaW5rIGZpbHRlcn0sIGFuZCB0aGUgb3RoZXIgd2l0aCB2YWx1ZXMgdGhhdCBkaWQgbm90XG4gKiBwYXNzIHRoZSBjb25kaXRpb24uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcGFydGl0aW9uLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBwYXJ0aXRpb25gIG91dHB1dHMgYW4gYXJyYXkgd2l0aCB0d28gT2JzZXJ2YWJsZXMgdGhhdCBwYXJ0aXRpb24gdGhlIHZhbHVlc1xuICogZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhyb3VnaCB0aGUgZ2l2ZW4gYHByZWRpY2F0ZWAgZnVuY3Rpb24uIFRoZSBmaXJzdFxuICogT2JzZXJ2YWJsZSBpbiB0aGF0IGFycmF5IGVtaXRzIHNvdXJjZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBwcmVkaWNhdGUgYXJndW1lbnRcbiAqIHJldHVybnMgdHJ1ZS4gVGhlIHNlY29uZCBPYnNlcnZhYmxlIGVtaXRzIHNvdXJjZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZVxuICogcHJlZGljYXRlIHJldHVybnMgZmFsc2UuIFRoZSBmaXJzdCBiZWhhdmVzIGxpa2Uge0BsaW5rIGZpbHRlcn0gYW5kIHRoZSBzZWNvbmRcbiAqIGJlaGF2ZXMgbGlrZSB7QGxpbmsgZmlsdGVyfSB3aXRoIHRoZSBwcmVkaWNhdGUgbmVnYXRlZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5QYXJ0aXRpb24gY2xpY2sgZXZlbnRzIGludG8gdGhvc2Ugb24gRElWIGVsZW1lbnRzIGFuZCB0aG9zZSBlbHNld2hlcmU8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHBhcnRzID0gY2xpY2tzLnBhcnRpdGlvbihldiA9PiBldi50YXJnZXQudGFnTmFtZSA9PT0gJ0RJVicpO1xuICogdmFyIGNsaWNrc09uRGl2cyA9IHBhcnRzWzBdO1xuICogdmFyIGNsaWNrc0Vsc2V3aGVyZSA9IHBhcnRzWzFdO1xuICogY2xpY2tzT25EaXZzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKCdESVYgY2xpY2tlZDogJywgeCkpO1xuICogY2xpY2tzRWxzZXdoZXJlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKCdPdGhlciBjbGlja2VkOiAnLCB4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZmlsdGVyfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBib29sZWFufSBwcmVkaWNhdGUgQSBmdW5jdGlvbiB0aGF0XG4gKiBldmFsdWF0ZXMgZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgaXQgcmV0dXJucyBgdHJ1ZWAsXG4gKiB0aGUgdmFsdWUgaXMgZW1pdHRlZCBvbiB0aGUgZmlyc3QgT2JzZXJ2YWJsZSBpbiB0aGUgcmV0dXJuZWQgYXJyYXksIGlmXG4gKiBgZmFsc2VgIHRoZSB2YWx1ZSBpcyBlbWl0dGVkIG9uIHRoZSBzZWNvbmQgT2JzZXJ2YWJsZSBpbiB0aGUgYXJyYXkuIFRoZVxuICogYGluZGV4YCBwYXJhbWV0ZXIgaXMgdGhlIG51bWJlciBgaWAgZm9yIHRoZSBpLXRoIHNvdXJjZSBlbWlzc2lvbiB0aGF0IGhhc1xuICogaGFwcGVuZWQgc2luY2UgdGhlIHN1YnNjcmlwdGlvbiwgc3RhcnRpbmcgZnJvbSB0aGUgbnVtYmVyIGAwYC5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gQW4gb3B0aW9uYWwgYXJndW1lbnQgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiBgdGhpc2BcbiAqIGluIHRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge1tPYnNlcnZhYmxlPFQ+LCBPYnNlcnZhYmxlPFQ+XX0gQW4gYXJyYXkgd2l0aCB0d28gT2JzZXJ2YWJsZXM6IG9uZVxuICogd2l0aCB2YWx1ZXMgdGhhdCBwYXNzZWQgdGhlIHByZWRpY2F0ZSwgYW5kIGFub3RoZXIgd2l0aCB2YWx1ZXMgdGhhdCBkaWQgbm90XG4gKiBwYXNzIHRoZSBwcmVkaWNhdGUuXG4gKiBAbWV0aG9kIHBhcnRpdGlvblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcGFydGl0aW9uKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBbXG4gICAgICAgIGZpbHRlcl8xLmZpbHRlcihwcmVkaWNhdGUsIHRoaXNBcmcpKHNvdXJjZSksXG4gICAgICAgIGZpbHRlcl8xLmZpbHRlcihub3RfMS5ub3QocHJlZGljYXRlLCB0aGlzQXJnKSkoc291cmNlKVxuICAgIF07IH07XG59XG5leHBvcnRzLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnRpdGlvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvcGFydGl0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1hcF8xID0gcmVxdWlyZSgnLi9tYXAnKTtcbi8qKlxuICogTWFwcyBlYWNoIHNvdXJjZSB2YWx1ZSAoYW4gb2JqZWN0KSB0byBpdHMgc3BlY2lmaWVkIG5lc3RlZCBwcm9wZXJ0eS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TGlrZSB7QGxpbmsgbWFwfSwgYnV0IG1lYW50IG9ubHkgZm9yIHBpY2tpbmcgb25lIG9mXG4gKiB0aGUgbmVzdGVkIHByb3BlcnRpZXMgb2YgZXZlcnkgZW1pdHRlZCBvYmplY3QuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcGx1Y2sucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogR2l2ZW4gYSBsaXN0IG9mIHN0cmluZ3MgZGVzY3JpYmluZyBhIHBhdGggdG8gYW4gb2JqZWN0IHByb3BlcnR5LCByZXRyaWV2ZXNcbiAqIHRoZSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBuZXN0ZWQgcHJvcGVydHkgZnJvbSBhbGwgdmFsdWVzIGluIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIElmIGEgcHJvcGVydHkgY2FuJ3QgYmUgcmVzb2x2ZWQsIGl0IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICogdGhhdCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgZXZlcnkgY2xpY2sgdG8gdGhlIHRhZ05hbWUgb2YgdGhlIGNsaWNrZWQgdGFyZ2V0IGVsZW1lbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHRhZ05hbWVzID0gY2xpY2tzLnBsdWNrKCd0YXJnZXQnLCAndGFnTmFtZScpO1xuICogdGFnTmFtZXMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIG1hcH1cbiAqXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gcHJvcGVydGllcyBUaGUgbmVzdGVkIHByb3BlcnRpZXMgdG8gcGx1Y2sgZnJvbSBlYWNoIHNvdXJjZVxuICogdmFsdWUgKGFuIG9iamVjdCkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBIG5ldyBPYnNlcnZhYmxlIG9mIHByb3BlcnR5IHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgdmFsdWVzLlxuICogQG1ldGhvZCBwbHVja1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcGx1Y2soKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBwcm9wZXJ0aWVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gcHJvcGVydGllcy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpc3Qgb2YgcHJvcGVydGllcyBjYW5ub3QgYmUgZW1wdHkuJyk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBtYXBfMS5tYXAocGx1Y2tlcihwcm9wZXJ0aWVzLCBsZW5ndGgpKShzb3VyY2UpOyB9O1xufVxuZXhwb3J0cy5wbHVjayA9IHBsdWNrO1xuZnVuY3Rpb24gcGx1Y2tlcihwcm9wcywgbGVuZ3RoKSB7XG4gICAgdmFyIG1hcHBlciA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBjdXJyZW50UHJvcCA9IHg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwID0gY3VycmVudFByb3BbcHJvcHNbaV1dO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wID0gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQcm9wO1xuICAgIH07XG4gICAgcmV0dXJuIG1hcHBlcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWNrLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9wbHVjay5qc1xuLy8gbW9kdWxlIGlkID0gMjI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgbXVsdGljYXN0XzEgPSByZXF1aXJlKCcuL211bHRpY2FzdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmV0dXJucyBhIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSwgd2hpY2ggaXMgYSB2YXJpZXR5IG9mIE9ic2VydmFibGUgdGhhdCB3YWl0cyB1bnRpbCBpdHMgY29ubmVjdCBtZXRob2QgaXMgY2FsbGVkXG4gKiBiZWZvcmUgaXQgYmVnaW5zIGVtaXR0aW5nIGl0ZW1zIHRvIHRob3NlIE9ic2VydmVycyB0aGF0IGhhdmUgc3Vic2NyaWJlZCB0byBpdC5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3B1Ymxpc2gucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSAtIE9wdGlvbmFsIHNlbGVjdG9yIGZ1bmN0aW9uIHdoaWNoIGNhbiB1c2UgdGhlIG11bHRpY2FzdGVkIHNvdXJjZSBzZXF1ZW5jZSBhcyBtYW55IHRpbWVzXG4gKiBhcyBuZWVkZWQsIHdpdGhvdXQgY2F1c2luZyBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gKiBTdWJzY3JpYmVycyB0byB0aGUgZ2l2ZW4gc291cmNlIHdpbGwgcmVjZWl2ZSBhbGwgbm90aWZpY2F0aW9ucyBvZiB0aGUgc291cmNlIGZyb20gdGhlIHRpbWUgb2YgdGhlIHN1YnNjcmlwdGlvbiBvbi5cbiAqIEByZXR1cm4gQSBDb25uZWN0YWJsZU9ic2VydmFibGUgdGhhdCB1cG9uIGNvbm5lY3Rpb24gY2F1c2VzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0byBlbWl0IGl0ZW1zIHRvIGl0cyBPYnNlcnZlcnMuXG4gKiBAbWV0aG9kIHB1Ymxpc2hcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2goc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3IgP1xuICAgICAgICBtdWx0aWNhc3RfMS5tdWx0aWNhc3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7IH0sIHNlbGVjdG9yKSA6XG4gICAgICAgIG11bHRpY2FzdF8xLm11bHRpY2FzdChuZXcgU3ViamVjdF8xLlN1YmplY3QoKSk7XG59XG5leHBvcnRzLnB1Ymxpc2ggPSBwdWJsaXNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvcHVibGlzaC5qc1xuLy8gbW9kdWxlIGlkID0gMjI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBCZWhhdmlvclN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL0JlaGF2aW9yU3ViamVjdCcpO1xudmFyIG11bHRpY2FzdF8xID0gcmVxdWlyZSgnLi9tdWx0aWNhc3QnKTtcbi8qKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJuIHtDb25uZWN0YWJsZU9ic2VydmFibGU8VD59XG4gKiBAbWV0aG9kIHB1Ymxpc2hCZWhhdmlvclxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEJlaGF2aW9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIG11bHRpY2FzdF8xLm11bHRpY2FzdChuZXcgQmVoYXZpb3JTdWJqZWN0XzEuQmVoYXZpb3JTdWJqZWN0KHZhbHVlKSkoc291cmNlKTsgfTtcbn1cbmV4cG9ydHMucHVibGlzaEJlaGF2aW9yID0gcHVibGlzaEJlaGF2aW9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaEJlaGF2aW9yLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9wdWJsaXNoQmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDIyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXN5bmNTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9Bc3luY1N1YmplY3QnKTtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4vbXVsdGljYXN0Jyk7XG5mdW5jdGlvbiBwdWJsaXNoTGFzdCgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gbXVsdGljYXN0XzEubXVsdGljYXN0KG5ldyBBc3luY1N1YmplY3RfMS5Bc3luY1N1YmplY3QoKSkoc291cmNlKTsgfTtcbn1cbmV4cG9ydHMucHVibGlzaExhc3QgPSBwdWJsaXNoTGFzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1Ymxpc2hMYXN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9wdWJsaXNoTGFzdC5qc1xuLy8gbW9kdWxlIGlkID0gMjMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBSZXBsYXlTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9SZXBsYXlTdWJqZWN0Jyk7XG52YXIgbXVsdGljYXN0XzEgPSByZXF1aXJlKCcuL211bHRpY2FzdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZXBsYXkoYnVmZmVyU2l6ZSwgd2luZG93VGltZSwgc2VsZWN0b3JPclNjaGVkdWxlciwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNlbGVjdG9yT3JTY2hlZHVsZXIgJiYgdHlwZW9mIHNlbGVjdG9yT3JTY2hlZHVsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2NoZWR1bGVyID0gc2VsZWN0b3JPclNjaGVkdWxlcjtcbiAgICB9XG4gICAgdmFyIHNlbGVjdG9yID0gdHlwZW9mIHNlbGVjdG9yT3JTY2hlZHVsZXIgPT09ICdmdW5jdGlvbicgPyBzZWxlY3Rvck9yU2NoZWR1bGVyIDogdW5kZWZpbmVkO1xuICAgIHZhciBzdWJqZWN0ID0gbmV3IFJlcGxheVN1YmplY3RfMS5SZXBsYXlTdWJqZWN0KGJ1ZmZlclNpemUsIHdpbmRvd1RpbWUsIHNjaGVkdWxlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIG11bHRpY2FzdF8xLm11bHRpY2FzdChmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJqZWN0OyB9LCBzZWxlY3Rvcikoc291cmNlKTsgfTtcbn1cbmV4cG9ydHMucHVibGlzaFJlcGxheSA9IHB1Ymxpc2hSZXBsYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWJsaXNoUmVwbGF5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9wdWJsaXNoUmVwbGF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIHJhY2VfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvcmFjZScpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgZmlyc3Qgc291cmNlIE9ic2VydmFibGUgdG8gZW1pdCBhbiBpdGVtXG4gKiBmcm9tIHRoZSBjb21iaW5hdGlvbiBvZiB0aGlzIE9ic2VydmFibGUgYW5kIHN1cHBsaWVkIE9ic2VydmFibGVzLlxuICogQHBhcmFtIHsuLi5PYnNlcnZhYmxlc30gLi4ub2JzZXJ2YWJsZXMgU291cmNlcyB1c2VkIHRvIHJhY2UgZm9yIHdoaWNoIE9ic2VydmFibGUgZW1pdHMgZmlyc3QuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgb3V0cHV0IG9mIHRoZSBmaXJzdCBPYnNlcnZhYmxlIHRvIGVtaXQgYW4gaXRlbS5cbiAqIEBtZXRob2QgcmFjZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcmFjZSgpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJhY2VPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAvLyBpZiB0aGUgb25seSBhcmd1bWVudCBpcyBhbiBhcnJheSwgaXQgd2FzIG1vc3QgbGlrZWx5IGNhbGxlZCB3aXRoXG4gICAgICAgIC8vIGBwYWlyKFtvYnMxLCBvYnMyLCAuLi5dKWBcbiAgICAgICAgaWYgKG9ic2VydmFibGVzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5XzEuaXNBcnJheShvYnNlcnZhYmxlc1swXSkpIHtcbiAgICAgICAgICAgIG9ic2VydmFibGVzID0gb2JzZXJ2YWJsZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0LmNhbGwocmFjZV8xLnJhY2UuYXBwbHkodm9pZCAwLCBbc291cmNlXS5jb25jYXQob2JzZXJ2YWJsZXMpKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMucmFjZSA9IHJhY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9yYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgcmVwZWF0cyB0aGUgc3RyZWFtIG9mIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGF0IG1vc3QgY291bnQgdGltZXMuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9yZXBlYXQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF0gVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgc291cmNlIE9ic2VydmFibGUgaXRlbXMgYXJlIHJlcGVhdGVkLCBhIGNvdW50IG9mIDAgd2lsbCB5aWVsZFxuICogYW4gZW1wdHkgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCByZXBlYXRzIHRoZSBzdHJlYW0gb2YgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYXQgbW9zdFxuICogY291bnQgdGltZXMuXG4gKiBAbWV0aG9kIHJlcGVhdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcmVwZWF0KGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB2b2lkIDApIHsgY291bnQgPSAtMTsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGVfMS5FbXB0eU9ic2VydmFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgUmVwZWF0T3BlcmF0b3IoLTEsIHNvdXJjZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBSZXBlYXRPcGVyYXRvcihjb3VudCAtIDEsIHNvdXJjZSkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMucmVwZWF0ID0gcmVwZWF0O1xudmFyIFJlcGVhdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXBlYXRPcGVyYXRvcihjb3VudCwgc291cmNlKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIFJlcGVhdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUmVwZWF0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmNvdW50LCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcGVhdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgUmVwZWF0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlcGVhdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVwZWF0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY291bnQsIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIFJlcGVhdFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCBzb3VyY2UgPSBfYS5zb3VyY2UsIGNvdW50ID0gX2EuY291bnQ7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY291bnQgPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSBjb3VudCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKHRoaXMuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlcGVhdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBlYXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL3JlcGVhdC5qc1xuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIHRoZSBleGNlcHRpb24gb2YgYSBgY29tcGxldGVgLiBJZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGNhbGxzIGBjb21wbGV0ZWAsIHRoaXMgbWV0aG9kIHdpbGwgZW1pdCB0byB0aGUgT2JzZXJ2YWJsZSByZXR1cm5lZCBmcm9tIGBub3RpZmllcmAuIElmIHRoYXQgT2JzZXJ2YWJsZVxuICogY2FsbHMgYGNvbXBsZXRlYCBvciBgZXJyb3JgLCB0aGVuIHRoaXMgbWV0aG9kIHdpbGwgY2FsbCBgY29tcGxldGVgIG9yIGBlcnJvcmAgb24gdGhlIGNoaWxkIHN1YnNjcmlwdGlvbi4gT3RoZXJ3aXNlXG4gKiB0aGlzIG1ldGhvZCB3aWxsIHJlc3Vic2NyaWJlIHRvIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3JlcGVhdFdoZW4ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihub3RpZmljYXRpb25zOiBPYnNlcnZhYmxlKTogT2JzZXJ2YWJsZX0gbm90aWZpZXIgLSBSZWNlaXZlcyBhbiBPYnNlcnZhYmxlIG9mIG5vdGlmaWNhdGlvbnMgd2l0aFxuICogd2hpY2ggYSB1c2VyIGNhbiBgY29tcGxldGVgIG9yIGBlcnJvcmAsIGFib3J0aW5nIHRoZSByZXBldGl0aW9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gVGhlIHNvdXJjZSBPYnNlcnZhYmxlIG1vZGlmaWVkIHdpdGggcmVwZWF0IGxvZ2ljLlxuICogQG1ldGhvZCByZXBlYXRXaGVuXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiByZXBlYXRXaGVuKG5vdGlmaWVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBSZXBlYXRXaGVuT3BlcmF0b3Iobm90aWZpZXIpKTsgfTtcbn1cbmV4cG9ydHMucmVwZWF0V2hlbiA9IHJlcGVhdFdoZW47XG52YXIgUmVwZWF0V2hlbk9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXBlYXRXaGVuT3BlcmF0b3Iobm90aWZpZXIpIHtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgIH1cbiAgICBSZXBlYXRXaGVuT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBSZXBlYXRXaGVuU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5vdGlmaWVyLCBzb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXBlYXRXaGVuT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBSZXBlYXRXaGVuU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlcGVhdFdoZW5TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlcGVhdFdoZW5TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBub3RpZmllciwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5zb3VyY2VJc0JlaW5nU3Vic2NyaWJlZFRvID0gdHJ1ZTtcbiAgICB9XG4gICAgUmVwZWF0V2hlblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VJc0JlaW5nU3Vic2NyaWJlZFRvID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHRoaXMpO1xuICAgIH07XG4gICAgUmVwZWF0V2hlblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZUlzQmVpbmdTdWJzY3JpYmVkVG8gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXBlYXRXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc291cmNlSXNCZWluZ1N1YnNjcmliZWRUbyA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmV0cmllcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlVG9SZXRyaWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSgpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVwZWF0V2hlblN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgbm90aWZpY2F0aW9ucyA9IF9hLm5vdGlmaWNhdGlvbnMsIHJldHJpZXNTdWJzY3JpcHRpb24gPSBfYS5yZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAobm90aWZpY2F0aW9ucykge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0cmllc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0cmllc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJldHJpZXMgPSBudWxsO1xuICAgIH07XG4gICAgUmVwZWF0V2hlblN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZUFuZFJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIG5vdGlmaWNhdGlvbnMgPSBfYS5ub3RpZmljYXRpb25zLCByZXRyaWVzID0gX2EucmV0cmllcywgcmV0cmllc1N1YnNjcmlwdGlvbiA9IF9hLnJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMucmV0cmllcyA9IG51bGw7XG4gICAgICAgIHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBub3RpZmljYXRpb25zO1xuICAgICAgICB0aGlzLnJldHJpZXMgPSByZXRyaWVzO1xuICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSByZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFJlcGVhdFdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5zdWJzY3JpYmVUb1JldHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICB2YXIgcmV0cmllcyA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2godGhpcy5ub3RpZmllcikodGhpcy5ub3RpZmljYXRpb25zKTtcbiAgICAgICAgaWYgKHJldHJpZXMgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXRyaWVzID0gcmV0cmllcztcbiAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXRyaWVzKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXBlYXRXaGVuU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBlYXRXaGVuLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9yZXBlYXRXaGVuLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIHRoZSBleGNlcHRpb24gb2YgYW4gYGVycm9yYC4gSWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlXG4gKiBjYWxscyBgZXJyb3JgLCB0aGlzIG1ldGhvZCB3aWxsIHJlc3Vic2NyaWJlIHRvIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBmb3IgYSBtYXhpbXVtIG9mIGBjb3VudGAgcmVzdWJzY3JpcHRpb25zIChnaXZlblxuICogYXMgYSBudW1iZXIgcGFyYW1ldGVyKSByYXRoZXIgdGhhbiBwcm9wYWdhdGluZyB0aGUgYGVycm9yYCBjYWxsLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcmV0cnkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQW55IGFuZCBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSByZXN1bHRpbmcgT2JzZXJ2YWJsZSwgZXZlbiB0aG9zZSBlbWl0dGVkXG4gKiBkdXJpbmcgZmFpbGVkIHN1YnNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCBpZiBhbiBPYnNlcnZhYmxlIGZhaWxzIGF0IGZpcnN0IGJ1dCBlbWl0cyBbMSwgMl0gdGhlbiBzdWNjZWVkcyB0aGUgc2Vjb25kXG4gKiB0aW1lIGFuZCBlbWl0czogWzEsIDIsIDMsIDQsIDVdIHRoZW4gdGhlIGNvbXBsZXRlIHN0cmVhbSBvZiBlbWlzc2lvbnMgYW5kIG5vdGlmaWNhdGlvbnNcbiAqIHdvdWxkIGJlOiBbMSwgMiwgMSwgMiwgMywgNCwgNSwgYGNvbXBsZXRlYF0uXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBOdW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgYmVmb3JlIGZhaWxpbmcuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIE9ic2VydmFibGUgbW9kaWZpZWQgd2l0aCB0aGUgcmV0cnkgbG9naWMuXG4gKiBAbWV0aG9kIHJldHJ5XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiByZXRyeShjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gdm9pZCAwKSB7IGNvdW50ID0gLTE7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFJldHJ5T3BlcmF0b3IoY291bnQsIHNvdXJjZSkpOyB9O1xufVxuZXhwb3J0cy5yZXRyeSA9IHJldHJ5O1xudmFyIFJldHJ5T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJldHJ5T3BlcmF0b3IoY291bnQsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBSZXRyeU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUmV0cnlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY291bnQsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmV0cnlPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFJldHJ5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJldHJ5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXRyeVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvdW50LCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBSZXRyeVN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCBzb3VyY2UgPSBfYS5zb3VyY2UsIGNvdW50ID0gX2EuY291bnQ7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3VudCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50IC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZS5zdWJzY3JpYmUodGhpcy5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmV0cnlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL3JldHJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IG1pcnJvcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBhbiBgZXJyb3JgLiBJZiB0aGUgc291cmNlIE9ic2VydmFibGVcbiAqIGNhbGxzIGBlcnJvcmAsIHRoaXMgbWV0aG9kIHdpbGwgZW1pdCB0aGUgVGhyb3dhYmxlIHRoYXQgY2F1c2VkIHRoZSBlcnJvciB0byB0aGUgT2JzZXJ2YWJsZSByZXR1cm5lZCBmcm9tIGBub3RpZmllcmAuXG4gKiBJZiB0aGF0IE9ic2VydmFibGUgY2FsbHMgYGNvbXBsZXRlYCBvciBgZXJyb3JgIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCBjYWxsIGBjb21wbGV0ZWAgb3IgYGVycm9yYCBvbiB0aGUgY2hpbGRcbiAqIHN1YnNjcmlwdGlvbi4gT3RoZXJ3aXNlIHRoaXMgbWV0aG9kIHdpbGwgcmVzdWJzY3JpYmUgdG8gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcmV0cnlXaGVuLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyb3JzOiBPYnNlcnZhYmxlKTogT2JzZXJ2YWJsZX0gbm90aWZpZXIgLSBSZWNlaXZlcyBhbiBPYnNlcnZhYmxlIG9mIG5vdGlmaWNhdGlvbnMgd2l0aCB3aGljaCBhXG4gKiB1c2VyIGNhbiBgY29tcGxldGVgIG9yIGBlcnJvcmAsIGFib3J0aW5nIHRoZSByZXRyeS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IFRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBtb2RpZmllZCB3aXRoIHJldHJ5IGxvZ2ljLlxuICogQG1ldGhvZCByZXRyeVdoZW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHJldHJ5V2hlbihub3RpZmllcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgUmV0cnlXaGVuT3BlcmF0b3Iobm90aWZpZXIsIHNvdXJjZSkpOyB9O1xufVxuZXhwb3J0cy5yZXRyeVdoZW4gPSByZXRyeVdoZW47XG52YXIgUmV0cnlXaGVuT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJldHJ5V2hlbk9wZXJhdG9yKG5vdGlmaWVyLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgUmV0cnlXaGVuT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBSZXRyeVdoZW5TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubm90aWZpZXIsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmV0cnlXaGVuT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBSZXRyeVdoZW5TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmV0cnlXaGVuU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXRyeVdoZW5TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBub3RpZmllciwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgUmV0cnlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSB0aGlzLmVycm9ycztcbiAgICAgICAgICAgIHZhciByZXRyaWVzID0gdGhpcy5yZXRyaWVzO1xuICAgICAgICAgICAgdmFyIHJldHJpZXNTdWJzY3JpcHRpb24gPSB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgICAgICBpZiAoIXJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICAgICAgICAgICAgICByZXRyaWVzID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLm5vdGlmaWVyKShlcnJvcnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXRyaWVzID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmVycm9yLmNhbGwodGhpcywgZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0cmllc1N1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmV0cmllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSgpO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgICAgICB0aGlzLnJldHJpZXMgPSByZXRyaWVzO1xuICAgICAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gcmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIGVycm9ycy5uZXh0KGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJldHJ5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZXJyb3JzID0gX2EuZXJyb3JzLCByZXRyaWVzU3Vic2NyaXB0aW9uID0gX2EucmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgICAgZXJyb3JzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldHJpZXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHJpZXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXRyaWVzID0gbnVsbDtcbiAgICB9O1xuICAgIFJldHJ5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZXJyb3JzID0gX2EuZXJyb3JzLCByZXRyaWVzID0gX2EucmV0cmllcywgcmV0cmllc1N1YnNjcmlwdGlvbiA9IF9hLnJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXRyaWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLnJldHJpZXMgPSByZXRyaWVzO1xuICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSByZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnNvdXJjZS5zdWJzY3JpYmUodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gUmV0cnlXaGVuU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeVdoZW4uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL3JldHJ5V2hlbi5qc1xuLy8gbW9kdWxlIGlkID0gMjM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogRW1pdHMgdGhlIG1vc3QgcmVjZW50bHkgZW1pdHRlZCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aGVuZXZlclxuICogYW5vdGhlciBPYnNlcnZhYmxlLCB0aGUgYG5vdGlmaWVyYCwgZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgc2FtcGxlVGltZX0sIGJ1dCBzYW1wbGVzIHdoZW5ldmVyXG4gKiB0aGUgYG5vdGlmaWVyYCBPYnNlcnZhYmxlIGVtaXRzIHNvbWV0aGluZy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zYW1wbGUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogV2hlbmV2ZXIgdGhlIGBub3RpZmllcmAgT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlIG9yIGNvbXBsZXRlcywgYHNhbXBsZWBcbiAqIGxvb2tzIGF0IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgZW1pdHMgd2hpY2hldmVyIHZhbHVlIGl0IGhhcyBtb3N0IHJlY2VudGx5XG4gKiBlbWl0dGVkIHNpbmNlIHRoZSBwcmV2aW91cyBzYW1wbGluZywgdW5sZXNzIHRoZSBzb3VyY2UgaGFzIG5vdCBlbWl0dGVkXG4gKiBhbnl0aGluZyBzaW5jZSB0aGUgcHJldmlvdXMgc2FtcGxpbmcuIFRoZSBgbm90aWZpZXJgIGlzIHN1YnNjcmliZWQgdG8gYXMgc29vblxuICogYXMgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+T24gZXZlcnkgY2xpY2ssIHNhbXBsZSB0aGUgbW9zdCByZWNlbnQgXCJzZWNvbmRzXCIgdGltZXI8L2NhcHRpb24+XG4gKiB2YXIgc2Vjb25kcyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IHNlY29uZHMuc2FtcGxlKGNsaWNrcyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0fVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBzYW1wbGVUaW1lfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGV9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlPGFueT59IG5vdGlmaWVyIFRoZSBPYnNlcnZhYmxlIHRvIHVzZSBmb3Igc2FtcGxpbmcgdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0cyBvZiBzYW1wbGluZyB0aGVcbiAqIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aGVuZXZlciB0aGUgbm90aWZpZXIgT2JzZXJ2YWJsZVxuICogZW1pdHMgdmFsdWUgb3IgY29tcGxldGVzLlxuICogQG1ldGhvZCBzYW1wbGVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZShub3RpZmllcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgU2FtcGxlT3BlcmF0b3Iobm90aWZpZXIpKTsgfTtcbn1cbmV4cG9ydHMuc2FtcGxlID0gc2FtcGxlO1xudmFyIFNhbXBsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTYW1wbGVPcGVyYXRvcihub3RpZmllcikge1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgfVxuICAgIFNhbXBsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICB2YXIgc2FtcGxlU3Vic2NyaWJlciA9IG5ldyBTYW1wbGVTdWJzY3JpYmVyKHN1YnNjcmliZXIpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZShzYW1wbGVTdWJzY3JpYmVyKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHNhbXBsZVN1YnNjcmliZXIsIHRoaXMubm90aWZpZXIpKTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBTYW1wbGVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNhbXBsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTYW1wbGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNhbXBsZVN1YnNjcmliZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIFNhbXBsZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgfTtcbiAgICBTYW1wbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZW1pdFZhbHVlKCk7XG4gICAgfTtcbiAgICBTYW1wbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0VmFsdWUoKTtcbiAgICB9O1xuICAgIFNhbXBsZVN1YnNjcmliZXIucHJvdG90eXBlLmVtaXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNhbXBsZVN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FtcGxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9zYW1wbGUuanNcbi8vIG1vZHVsZSBpZCA9IDIzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuLyoqXG4gKiBFbWl0cyB0aGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGhpblxuICogcGVyaW9kaWMgdGltZSBpbnRlcnZhbHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlNhbXBsZXMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGF0IHBlcmlvZGljIHRpbWVcbiAqIGludGVydmFscywgZW1pdHRpbmcgd2hhdCBpdCBzYW1wbGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NhbXBsZVRpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHNhbXBsZVRpbWVgIHBlcmlvZGljYWxseSBsb29rcyBhdCB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIGVtaXRzIHdoaWNoZXZlclxuICogdmFsdWUgaXQgaGFzIG1vc3QgcmVjZW50bHkgZW1pdHRlZCBzaW5jZSB0aGUgcHJldmlvdXMgc2FtcGxpbmcsIHVubGVzcyB0aGVcbiAqIHNvdXJjZSBoYXMgbm90IGVtaXR0ZWQgYW55dGhpbmcgc2luY2UgdGhlIHByZXZpb3VzIHNhbXBsaW5nLiBUaGUgc2FtcGxpbmdcbiAqIGhhcHBlbnMgcGVyaW9kaWNhbGx5IGluIHRpbWUgZXZlcnkgYHBlcmlvZGAgbWlsbGlzZWNvbmRzIChvciB0aGUgdGltZSB1bml0XG4gKiBkZWZpbmVkIGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYCBhcmd1bWVudCkuIFRoZSBzYW1wbGluZyBzdGFydHMgYXMgc29vbiBhc1xuICogdGhlIG91dHB1dCBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RXZlcnkgc2Vjb25kLCBlbWl0IHRoZSBtb3N0IHJlY2VudCBjbGljayBhdCBtb3N0IG9uY2U8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5zYW1wbGVUaW1lKDEwMDApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdFRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlVGltZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyaW9kIFRoZSBzYW1wbGluZyBwZXJpb2QgZXhwcmVzc2VkIGluIG1pbGxpc2Vjb25kcyBvciB0aGVcbiAqIHRpbWUgdW5pdCBkZXRlcm1pbmVkIGludGVybmFsbHkgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvclxuICogbWFuYWdpbmcgdGhlIHRpbWVycyB0aGF0IGhhbmRsZSB0aGUgc2FtcGxpbmcuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdHMgb2Ygc2FtcGxpbmcgdGhlXG4gKiB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYXQgdGhlIHNwZWNpZmllZCB0aW1lIGludGVydmFsLlxuICogQG1ldGhvZCBzYW1wbGVUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzYW1wbGVUaW1lKHBlcmlvZCwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFNhbXBsZVRpbWVPcGVyYXRvcihwZXJpb2QsIHNjaGVkdWxlcikpOyB9O1xufVxuZXhwb3J0cy5zYW1wbGVUaW1lID0gc2FtcGxlVGltZTtcbnZhciBTYW1wbGVUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNhbXBsZVRpbWVPcGVyYXRvcihwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLnBlcmlvZCA9IHBlcmlvZDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIFNhbXBsZVRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNhbXBsZVRpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucGVyaW9kLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhbXBsZVRpbWVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNhbXBsZVRpbWVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FtcGxlVGltZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FtcGxlVGltZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHBlcmlvZCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wZXJpb2QgPSBwZXJpb2Q7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5vdGlmaWNhdGlvbiwgcGVyaW9kLCB7IHN1YnNjcmliZXI6IHRoaXMsIHBlcmlvZDogcGVyaW9kIH0pKTtcbiAgICB9XG4gICAgU2FtcGxlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgIH07XG4gICAgU2FtcGxlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5sYXN0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2FtcGxlVGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaE5vdGlmaWNhdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlciwgcGVyaW9kID0gc3RhdGUucGVyaW9kO1xuICAgIHN1YnNjcmliZXIubm90aWZ5TmV4dCgpO1xuICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUsIHBlcmlvZCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW1wbGVUaW1lLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9zYW1wbGVUaW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbi8qKlxuICogQ29tcGFyZXMgYWxsIHZhbHVlcyBvZiB0d28gb2JzZXJ2YWJsZXMgaW4gc2VxdWVuY2UgdXNpbmcgYW4gb3B0aW9uYWwgY29tcGFyb3IgZnVuY3Rpb25cbiAqIGFuZCByZXR1cm5zIGFuIG9ic2VydmFibGUgb2YgYSBzaW5nbGUgYm9vbGVhbiB2YWx1ZSByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhlIHR3byBzZXF1ZW5jZXNcbiAqIGFyZSBlcXVhbC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q2hlY2tzIHRvIHNlZSBvZiBhbGwgdmFsdWVzIGVtaXR0ZWQgYnkgYm90aCBvYnNlcnZhYmxlcyBhcmUgZXF1YWwsIGluIG9yZGVyLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NlcXVlbmNlRXF1YWwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHNlcXVlbmNlRXF1YWxgIHN1YnNjcmliZXMgdG8gdHdvIG9ic2VydmFibGVzIGFuZCBidWZmZXJzIGluY29taW5nIHZhbHVlcyBmcm9tIGVhY2ggb2JzZXJ2YWJsZS4gV2hlbmV2ZXIgZWl0aGVyXG4gKiBvYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUsIHRoZSB2YWx1ZSBpcyBidWZmZXJlZCBhbmQgdGhlIGJ1ZmZlcnMgYXJlIHNoaWZ0ZWQgYW5kIGNvbXBhcmVkIGZyb20gdGhlIGJvdHRvbVxuICogdXA7IElmIGFueSB2YWx1ZSBwYWlyIGRvZXNuJ3QgbWF0Y2gsIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlIHdpbGwgZW1pdCBgZmFsc2VgIGFuZCBjb21wbGV0ZS4gSWYgb25lIG9mIHRoZVxuICogb2JzZXJ2YWJsZXMgY29tcGxldGVzLCB0aGUgb3BlcmF0b3Igd2lsbCB3YWl0IGZvciB0aGUgb3RoZXIgb2JzZXJ2YWJsZSB0byBjb21wbGV0ZTsgSWYgdGhlIG90aGVyXG4gKiBvYnNlcnZhYmxlIGVtaXRzIGJlZm9yZSBjb21wbGV0aW5nLCB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZSB3aWxsIGVtaXQgYGZhbHNlYCBhbmQgY29tcGxldGUuIElmIG9uZSBvYnNlcnZhYmxlIG5ldmVyXG4gKiBjb21wbGV0ZXMgb3IgZW1pdHMgYWZ0ZXIgdGhlIG90aGVyIGNvbXBsZXRzLCB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZSB3aWxsIG5ldmVyIGNvbXBsZXRlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPmZpZ3VyZSBvdXQgaWYgdGhlIEtvbmFtaSBjb2RlIG1hdGNoZXM8L2NhcHRpb24+XG4gKiB2YXIgY29kZSA9IFJ4Lk9ic2VydmFibGUuZnJvbShbXG4gKiAgXCJBcnJvd1VwXCIsXG4gKiAgXCJBcnJvd1VwXCIsXG4gKiAgXCJBcnJvd0Rvd25cIixcbiAqICBcIkFycm93RG93blwiLFxuICogIFwiQXJyb3dMZWZ0XCIsXG4gKiAgXCJBcnJvd1JpZ2h0XCIsXG4gKiAgXCJBcnJvd0xlZnRcIixcbiAqICBcIkFycm93UmlnaHRcIixcbiAqICBcIktleUJcIixcbiAqICBcIktleUFcIixcbiAqICBcIkVudGVyXCIgLy8gbm8gc3RhcnQga2V5LCBjbGVhcmx5LlxuICogXSk7XG4gKlxuICogdmFyIGtleXMgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2tleXVwJylcbiAqICAubWFwKGUgPT4gZS5jb2RlKTtcbiAqIHZhciBtYXRjaGVzID0ga2V5cy5idWZmZXJDb3VudCgxMSwgMSlcbiAqICAubWVyZ2VNYXAoXG4gKiAgICBsYXN0MTEgPT5cbiAqICAgICAgUnguT2JzZXJ2YWJsZS5mcm9tKGxhc3QxMSlcbiAqICAgICAgICAuc2VxdWVuY2VFcXVhbChjb2RlKVxuICogICApO1xuICogbWF0Y2hlcy5zdWJzY3JpYmUobWF0Y2hlZCA9PiBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bCBjaGVhdCBhdCBDb250cmE/ICcsIG1hdGNoZWQpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lTGF0ZXN0fVxuICogQHNlZSB7QGxpbmsgemlwfVxuICogQHNlZSB7QGxpbmsgd2l0aExhdGVzdEZyb219XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBjb21wYXJlVG8gVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gY29tcGFyZSB0aGUgc291cmNlIHNlcXVlbmNlIHRvLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NvbXBhcm9yXSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBjb21wYXJlIGVhY2ggdmFsdWUgcGFpclxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiBhIHNpbmdsZSBib29sZWFuIHZhbHVlIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdFxuICogdGhlIHZhbHVlcyBlbWl0dGVkIGJ5IGJvdGggb2JzZXJ2YWJsZXMgd2VyZSBlcXVhbCBpbiBzZXF1ZW5jZS5cbiAqIEBtZXRob2Qgc2VxdWVuY2VFcXVhbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc2VxdWVuY2VFcXVhbChjb21wYXJlVG8sIGNvbXBhcm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBTZXF1ZW5jZUVxdWFsT3BlcmF0b3IoY29tcGFyZVRvLCBjb21wYXJvcikpOyB9O1xufVxuZXhwb3J0cy5zZXF1ZW5jZUVxdWFsID0gc2VxdWVuY2VFcXVhbDtcbnZhciBTZXF1ZW5jZUVxdWFsT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcXVlbmNlRXF1YWxPcGVyYXRvcihjb21wYXJlVG8sIGNvbXBhcm9yKSB7XG4gICAgICAgIHRoaXMuY29tcGFyZVRvID0gY29tcGFyZVRvO1xuICAgICAgICB0aGlzLmNvbXBhcm9yID0gY29tcGFyb3I7XG4gICAgfVxuICAgIFNlcXVlbmNlRXF1YWxPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY29tcGFyZVRvLCB0aGlzLmNvbXBhcm9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VxdWVuY2VFcXVhbE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuU2VxdWVuY2VFcXVhbE9wZXJhdG9yID0gU2VxdWVuY2VFcXVhbE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb21wYXJlVG8sIGNvbXBhcm9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb21wYXJlVG8gPSBjb21wYXJlVG87XG4gICAgICAgIHRoaXMuY29tcGFyb3IgPSBjb21wYXJvcjtcbiAgICAgICAgdGhpcy5fYSA9IFtdO1xuICAgICAgICB0aGlzLl9iID0gW107XG4gICAgICAgIHRoaXMuX29uZUNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRkKGNvbXBhcmVUby5zdWJzY3JpYmUobmV3IFNlcXVlbmNlRXF1YWxDb21wYXJlVG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB0aGlzKSkpO1xuICAgIH1cbiAgICBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX29uZUNvbXBsZXRlICYmIHRoaXMuX2IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VxdWVuY2VFcXVhbFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX29uZUNvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5fYS5sZW5ndGggPT09IDAgJiYgdGhpcy5fYi5sZW5ndGggPT09IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb25lQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlci5wcm90b3R5cGUuY2hlY2tWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYyA9IHRoaXMsIF9hID0gX2MuX2EsIF9iID0gX2MuX2IsIGNvbXBhcm9yID0gX2MuY29tcGFyb3I7XG4gICAgICAgIHdoaWxlIChfYS5sZW5ndGggPiAwICYmIF9iLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBhID0gX2Euc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBiID0gX2Iuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBhcmVFcXVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNvbXBhcm9yKSB7XG4gICAgICAgICAgICAgICAgYXJlRXF1YWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKGNvbXBhcm9yKShhLCBiKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJlRXF1YWwgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZUVxdWFsID0gYSA9PT0gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXJlRXF1YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0QiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fb25lQ29tcGxldGUgJiYgdGhpcy5fYS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9iLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1ZhbHVlcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2VxdWVuY2VFcXVhbFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLlNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyID0gU2VxdWVuY2VFcXVhbFN1YnNjcmliZXI7XG52YXIgU2VxdWVuY2VFcXVhbENvbXBhcmVUb1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXF1ZW5jZUVxdWFsQ29tcGFyZVRvU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXF1ZW5jZUVxdWFsQ29tcGFyZVRvU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcGFyZW50KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIFNlcXVlbmNlRXF1YWxDb21wYXJlVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhcmVudC5uZXh0Qih2YWx1ZSk7XG4gICAgfTtcbiAgICBTZXF1ZW5jZUVxdWFsQ29tcGFyZVRvU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLnBhcmVudC5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgU2VxdWVuY2VFcXVhbENvbXBhcmVUb1N1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuX2NvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VxdWVuY2VFcXVhbENvbXBhcmVUb1N1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXF1ZW5jZUVxdWFsLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9zZXF1ZW5jZUVxdWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFJlcGxheVN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1JlcGxheVN1YmplY3QnKTtcbi8qKlxuICogQG1ldGhvZCBzaGFyZVJlcGxheVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc2hhcmVSZXBsYXkoYnVmZmVyU2l6ZSwgd2luZG93VGltZSwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KHNoYXJlUmVwbGF5T3BlcmF0b3IoYnVmZmVyU2l6ZSwgd2luZG93VGltZSwgc2NoZWR1bGVyKSk7IH07XG59XG5leHBvcnRzLnNoYXJlUmVwbGF5ID0gc2hhcmVSZXBsYXk7XG5mdW5jdGlvbiBzaGFyZVJlcGxheU9wZXJhdG9yKGJ1ZmZlclNpemUsIHdpbmRvd1RpbWUsIHNjaGVkdWxlcikge1xuICAgIHZhciBzdWJqZWN0O1xuICAgIHZhciByZWZDb3VudCA9IDA7XG4gICAgdmFyIHN1YnNjcmlwdGlvbjtcbiAgICB2YXIgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgaXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiBzaGFyZVJlcGxheU9wZXJhdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmVmQ291bnQrKztcbiAgICAgICAgaWYgKCFzdWJqZWN0IHx8IGhhc0Vycm9yKSB7XG4gICAgICAgICAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgc3ViamVjdCA9IG5ldyBSZXBsYXlTdWJqZWN0XzEuUmVwbGF5U3ViamVjdChidWZmZXJTaXplLCB3aW5kb3dUaW1lLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7IHN1YmplY3QubmV4dCh2YWx1ZSk7IH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0LmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5uZXJTdWIgPSBzdWJqZWN0LnN1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlZkNvdW50LS07XG4gICAgICAgICAgICBpbm5lclN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiAmJiByZWZDb3VudCA9PT0gMCAmJiBpc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbn1cbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYXJlUmVwbGF5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9zaGFyZVJlcGxheS5qc1xuLy8gbW9kdWxlIGlkID0gMjQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBFbXB0eUVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL0VtcHR5RXJyb3InKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHNpbmdsZSBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgbWF0Y2hlcyBhIHNwZWNpZmllZFxuICogcHJlZGljYXRlLCBpZiB0aGF0IE9ic2VydmFibGUgZW1pdHMgb25lIHN1Y2ggaXRlbS4gSWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGVtaXRzIG1vcmUgdGhhbiBvbmUgc3VjaCBpdGVtIG9yIG5vXG4gKiBzdWNoIGl0ZW1zLCBub3RpZnkgb2YgYW4gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIG9yIE5vU3VjaEVsZW1lbnRFeGNlcHRpb24gcmVzcGVjdGl2ZWx5LlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2luZ2xlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEB0aHJvd3Mge0VtcHR5RXJyb3J9IERlbGl2ZXJzIGFuIEVtcHR5RXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYFxuICogY2FsbGJhY2sgaWYgdGhlIE9ic2VydmFibGUgY29tcGxldGVzIGJlZm9yZSBhbnkgYG5leHRgIG5vdGlmaWNhdGlvbiB3YXMgc2VudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSAtIEEgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGV2YWx1YXRlIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBzaW5nbGUgaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IG1hdGNoZXNcbiAqIHRoZSBwcmVkaWNhdGUuXG4gLlxuICogQG1ldGhvZCBzaW5nbGVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNpbmdsZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFNpbmdsZU9wZXJhdG9yKHByZWRpY2F0ZSwgc291cmNlKSk7IH07XG59XG5leHBvcnRzLnNpbmdsZSA9IHNpbmdsZTtcbnZhciBTaW5nbGVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2luZ2xlT3BlcmF0b3IocHJlZGljYXRlLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBTaW5nbGVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNpbmdsZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2luZ2xlT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTaW5nbGVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2luZ2xlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaW5nbGVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5zZWVuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIFNpbmdsZVN1YnNjcmliZXIucHJvdG90eXBlLmFwcGx5U2luZ2xlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VlblZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKCdTZXF1ZW5jZSBjb250YWlucyBtb3JlIHRoYW4gb25lIGVsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VlblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2luZ2xlVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2luZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICBpZiAodGhpcy5wcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5TmV4dCh2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHBseVNpbmdsZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2luZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5TmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIHRoaXMuc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlTaW5nbGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaW5nbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID4gMCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh0aGlzLnNlZW5WYWx1ZSA/IHRoaXMuc2luZ2xlVmFsdWUgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKG5ldyBFbXB0eUVycm9yXzEuRW1wdHlFcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTaW5nbGVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2luZ2xlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9zaW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIHRoZSBmaXJzdCBgY291bnRgIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2tpcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgLSBUaGUgbnVtYmVyIG9mIHRpbWVzLCBpdGVtcyBlbWl0dGVkIGJ5IHNvdXJjZSBPYnNlcnZhYmxlIHNob3VsZCBiZSBza2lwcGVkLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAbWV0aG9kIHNraXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNraXAoY291bnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFNraXBPcGVyYXRvcihjb3VudCkpOyB9O1xufVxuZXhwb3J0cy5za2lwID0gc2tpcDtcbnZhciBTa2lwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNraXBPcGVyYXRvcih0b3RhbCkge1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgfVxuICAgIFNraXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNraXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMudG90YWwpKTtcbiAgICB9O1xuICAgIHJldHVybiBTa2lwT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTa2lwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNraXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNraXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB0b3RhbCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuICAgIFNraXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICgrK3RoaXMuY291bnQgPiB0aGlzLnRvdGFsKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoeCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTa2lwU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNraXAuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL3NraXAuanNcbi8vIG1vZHVsZSBpZCA9IDI0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMSA9IHJlcXVpcmUoJy4uL3V0aWwvQXJndW1lbnRPdXRPZlJhbmdlRXJyb3InKTtcbi8qKlxuICogU2tpcCB0aGUgbGFzdCBgY291bnRgIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NraXBMYXN0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBza2lwTGFzdGAgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgYWNjdW11bGF0ZXMgYSBxdWV1ZSB3aXRoIGEgbGVuZ3RoXG4gKiBlbm91Z2ggdG8gc3RvcmUgdGhlIGZpcnN0IGBjb3VudGAgdmFsdWVzLiBBcyBtb3JlIHZhbHVlcyBhcmUgcmVjZWl2ZWQsXG4gKiB2YWx1ZXMgYXJlIHRha2VuIGZyb20gdGhlIGZyb250IG9mIHRoZSBxdWV1ZSBhbmQgcHJvZHVjZWQgb24gdGhlIHJlc3VsdFxuICogc2VxdWVuY2UuIFRoaXMgY2F1c2VzIHZhbHVlcyB0byBiZSBkZWxheWVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlNraXAgdGhlIGxhc3QgMiB2YWx1ZXMgb2YgYW4gT2JzZXJ2YWJsZSB3aXRoIG1hbnkgdmFsdWVzPC9jYXB0aW9uPlxuICogdmFyIG1hbnkgPSBSeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDUpO1xuICogdmFyIHNraXBMYXN0VHdvID0gbWFueS5za2lwTGFzdCgyKTtcbiAqIHNraXBMYXN0VHdvLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluOlxuICogLy8gMSAyIDNcbiAqXG4gKiBAc2VlIHtAbGluayBza2lwfVxuICogQHNlZSB7QGxpbmsgc2tpcFVudGlsfVxuICogQHNlZSB7QGxpbmsgc2tpcFdoaWxlfVxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqXG4gKiBAdGhyb3dzIHtBcmd1bWVudE91dE9mUmFuZ2VFcnJvcn0gV2hlbiB1c2luZyBgc2tpcExhc3QoaSlgLCBpdCB0aHJvd3NcbiAqIEFyZ3VtZW50T3V0T3JSYW5nZUVycm9yIGlmIGBpIDwgMGAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIHRoZSBsYXN0IGNvdW50IHZhbHVlc1xuICogZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHNraXBMYXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBza2lwTGFzdChjb3VudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgU2tpcExhc3RPcGVyYXRvcihjb3VudCkpOyB9O1xufVxuZXhwb3J0cy5za2lwTGFzdCA9IHNraXBMYXN0O1xudmFyIFNraXBMYXN0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNraXBMYXN0T3BlcmF0b3IoX3NraXBDb3VudCkge1xuICAgICAgICB0aGlzLl9za2lwQ291bnQgPSBfc2tpcENvdW50O1xuICAgICAgICBpZiAodGhpcy5fc2tpcENvdW50IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU2tpcExhc3RPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NraXBDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3Qgd2FudCB0byBza2lwIGFueSB2YWx1ZXMgdGhlbiBqdXN0IHN1YnNjcmliZVxuICAgICAgICAgICAgLy8gdG8gU3Vic2NyaWJlciB3aXRob3V0IGFueSBmdXJ0aGVyIGxvZ2ljLlxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTa2lwTGFzdFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5fc2tpcENvdW50KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTa2lwTGFzdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU2tpcExhc3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2tpcExhc3RTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNraXBMYXN0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgX3NraXBDb3VudCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuX3NraXBDb3VudCA9IF9za2lwQ291bnQ7XG4gICAgICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcmluZyA9IG5ldyBBcnJheShfc2tpcENvdW50KTtcbiAgICB9XG4gICAgU2tpcExhc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgc2tpcENvdW50ID0gdGhpcy5fc2tpcENvdW50O1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLl9jb3VudCsrO1xuICAgICAgICBpZiAoY291bnQgPCBza2lwQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JpbmdbY291bnRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gY291bnQgJSBza2lwQ291bnQ7XG4gICAgICAgICAgICB2YXIgcmluZyA9IHRoaXMuX3Jpbmc7XG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSByaW5nW2N1cnJlbnRJbmRleF07XG4gICAgICAgICAgICByaW5nW2N1cnJlbnRJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTa2lwTGFzdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1za2lwTGFzdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvc2tpcExhc3QuanNcbi8vIG1vZHVsZSBpZCA9IDI0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHVudGlsIGEgc2Vjb25kIE9ic2VydmFibGUgZW1pdHMgYW4gaXRlbS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NraXBVbnRpbC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IG5vdGlmaWVyIC0gVGhlIHNlY29uZCBPYnNlcnZhYmxlIHRoYXQgaGFzIHRvIGVtaXQgYW4gaXRlbSBiZWZvcmUgdGhlIHNvdXJjZSBPYnNlcnZhYmxlJ3MgZWxlbWVudHMgYmVnaW4gdG9cbiAqIGJlIG1pcnJvcmVkIGJ5IHRoZSByZXN1bHRpbmcgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBza2lwcyBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB1bnRpbCB0aGUgc2Vjb25kIE9ic2VydmFibGUgZW1pdHNcbiAqIGFuIGl0ZW0sIHRoZW4gZW1pdHMgdGhlIHJlbWFpbmluZyBpdGVtcy5cbiAqIEBtZXRob2Qgc2tpcFVudGlsXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBza2lwVW50aWwobm90aWZpZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFNraXBVbnRpbE9wZXJhdG9yKG5vdGlmaWVyKSk7IH07XG59XG5leHBvcnRzLnNraXBVbnRpbCA9IHNraXBVbnRpbDtcbnZhciBTa2lwVW50aWxPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2tpcFVudGlsT3BlcmF0b3Iobm90aWZpZXIpIHtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgIH1cbiAgICBTa2lwVW50aWxPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNraXBVbnRpbFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5ub3RpZmllcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFNraXBVbnRpbE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU2tpcFVudGlsU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNraXBVbnRpbFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2tpcFVudGlsU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgbm90aWZpZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNJbm5lclN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBub3RpZmllcikpO1xuICAgIH1cbiAgICBTa2lwVW50aWxTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fbmV4dC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2tpcFVudGlsU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0lubmVyU3RvcHBlZCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2tpcFVudGlsU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNraXBVbnRpbFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzSW5uZXJTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2tpcFVudGlsU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1za2lwVW50aWwuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL3NraXBVbnRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgc2tpcHMgYWxsIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFzIGxvbmcgYXMgYSBzcGVjaWZpZWQgY29uZGl0aW9uIGhvbGRzXG4gKiB0cnVlLCBidXQgZW1pdHMgYWxsIGZ1cnRoZXIgc291cmNlIGl0ZW1zIGFzIHNvb24gYXMgdGhlIGNvbmRpdGlvbiBiZWNvbWVzIGZhbHNlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2tpcFdoaWxlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSAtIEEgZnVuY3Rpb24gdG8gdGVzdCBlYWNoIGl0ZW0gZW1pdHRlZCBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBiZWdpbnMgZW1pdHRpbmcgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgd2hlbiB0aGVcbiAqIHNwZWNpZmllZCBwcmVkaWNhdGUgYmVjb21lcyBmYWxzZS5cbiAqIEBtZXRob2Qgc2tpcFdoaWxlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBza2lwV2hpbGUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBTa2lwV2hpbGVPcGVyYXRvcihwcmVkaWNhdGUpKTsgfTtcbn1cbmV4cG9ydHMuc2tpcFdoaWxlID0gc2tpcFdoaWxlO1xudmFyIFNraXBXaGlsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTa2lwV2hpbGVPcGVyYXRvcihwcmVkaWNhdGUpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgfVxuICAgIFNraXBXaGlsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU2tpcFdoaWxlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFNraXBXaGlsZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU2tpcFdoaWxlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNraXBXaGlsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2tpcFdoaWxlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuc2tpcHBpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgU2tpcFdoaWxlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuc2tpcHBpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5Q2FsbFByZWRpY2F0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNraXBwaW5nKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2tpcFdoaWxlU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5Q2FsbFByZWRpY2F0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlKHZhbHVlLCB0aGlzLmluZGV4KyspO1xuICAgICAgICAgICAgdGhpcy5za2lwcGluZyA9IEJvb2xlYW4ocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTa2lwV2hpbGVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2tpcFdoaWxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy9za2lwV2hpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIFNjYWxhck9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvU2NhbGFyT2JzZXJ2YWJsZScpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnKTtcbnZhciBjb25jYXRfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvY29uY2F0Jyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyB5b3Ugc3BlY2lmeSBhcyBhcmd1bWVudHMgYmVmb3JlIGl0IGJlZ2lucyB0byBlbWl0XG4gKiBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N0YXJ0V2l0aC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0gey4uLlR9IHZhbHVlcyAtIEl0ZW1zIHlvdSB3YW50IHRoZSBtb2RpZmllZCBPYnNlcnZhYmxlIHRvIGVtaXQgZmlyc3QuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gLSBBIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAqIHRoZSBlbWlzc2lvbnMgb2YgdGhlIGBuZXh0YCBub3RpZmljYXRpb25zLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyBpbiB0aGUgc3BlY2lmaWVkIEl0ZXJhYmxlIGFuZCB0aGVuIGVtaXRzIHRoZSBpdGVtc1xuICogZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN0YXJ0V2l0aFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc3RhcnRXaXRoKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFycmF5W19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKHNjaGVkdWxlcikpIHtcbiAgICAgICAgICAgIGFycmF5LnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2NoZWR1bGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0XzEuY29uY2F0KG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheVswXSwgc2NoZWR1bGVyKSwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0XzEuY29uY2F0KG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUoYXJyYXksIHNjaGVkdWxlciksIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0XzEuY29uY2F0KG5ldyBFbXB0eU9ic2VydmFibGVfMS5FbXB0eU9ic2VydmFibGUoc2NoZWR1bGVyKSwgc291cmNlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLnN0YXJ0V2l0aCA9IHN0YXJ0V2l0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXJ0V2l0aC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvc3RhcnRXaXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHN3aXRjaE1hcF8xID0gcmVxdWlyZSgnLi9zd2l0Y2hNYXAnKTtcbnZhciBpZGVudGl0eV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pZGVudGl0eScpO1xuZnVuY3Rpb24gc3dpdGNoQWxsKCkge1xuICAgIHJldHVybiBzd2l0Y2hNYXBfMS5zd2l0Y2hNYXAoaWRlbnRpdHlfMS5pZGVudGl0eSk7XG59XG5leHBvcnRzLnN3aXRjaEFsbCA9IHN3aXRjaEFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaEFsbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvc3dpdGNoQWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gdGhlIHNhbWUgT2JzZXJ2YWJsZSB3aGljaCBpcyBmbGF0dGVuZWQgbXVsdGlwbGVcbiAqIHRpbWVzIHdpdGgge0BsaW5rIHN3aXRjaH0gaW4gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIHN3aXRjaE1hcH0sIGJ1dCBtYXBzIGVhY2ggdmFsdWVcbiAqIGFsd2F5cyB0byB0aGUgc2FtZSBpbm5lciBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N3aXRjaE1hcFRvLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIE1hcHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gdGhlIGdpdmVuIE9ic2VydmFibGUgYGlubmVyT2JzZXJ2YWJsZWAgcmVnYXJkbGVzc1xuICogb2YgdGhlIHNvdXJjZSB2YWx1ZSwgYW5kIHRoZW4gZmxhdHRlbnMgdGhvc2UgcmVzdWx0aW5nIE9ic2VydmFibGVzIGludG8gb25lXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgd2hpY2ggaXMgdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGVzXG4gKiBlbWl0cyB2YWx1ZXMgb25seSBmcm9tIHRoZSBtb3N0IHJlY2VudGx5IGVtaXR0ZWQgaW5zdGFuY2Ugb2ZcbiAqIGBpbm5lck9ic2VydmFibGVgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJlcnVuIGFuIGludGVydmFsIE9ic2VydmFibGUgb24gZXZlcnkgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5zd2l0Y2hNYXBUbyhSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwVG99XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcFRvfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBpbm5lck9ic2VydmFibGUgQW4gT2JzZXJ2YWJsZSB0byByZXBsYWNlIGVhY2ggdmFsdWUgZnJvbVxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZSBnaXZlblxuICogYGlubmVyT2JzZXJ2YWJsZWAgKGFuZCBvcHRpb25hbGx5IHRyYW5zZm9ybWVkIHRocm91Z2ggYHJlc3VsdFNlbGVjdG9yYCkgZXZlcnlcbiAqIHRpbWUgYSB2YWx1ZSBpcyBlbWl0dGVkIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYW5kIHRha2luZyBvbmx5IHRoZSB2YWx1ZXNcbiAqIGZyb20gdGhlIG1vc3QgcmVjZW50bHkgcHJvamVjdGVkIGlubmVyIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN3aXRjaE1hcFRvXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzd2l0Y2hNYXBUbyhpbm5lck9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBTd2l0Y2hNYXBUb09wZXJhdG9yKGlubmVyT2JzZXJ2YWJsZSwgcmVzdWx0U2VsZWN0b3IpKTsgfTtcbn1cbmV4cG9ydHMuc3dpdGNoTWFwVG8gPSBzd2l0Y2hNYXBUbztcbnZhciBTd2l0Y2hNYXBUb09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hNYXBUb09wZXJhdG9yKG9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICB9XG4gICAgU3dpdGNoTWFwVG9PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN3aXRjaE1hcFRvU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9ic2VydmFibGUsIHRoaXMucmVzdWx0U2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hNYXBUb09wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3dpdGNoTWFwVG9TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3dpdGNoTWFwVG9TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaE1hcFRvU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgaW5uZXIsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBTd2l0Y2hNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChpbm5lclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZCh0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCB0aGlzLmlubmVyLCB2YWx1ZSwgdGhpcy5pbmRleCsrKSk7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gdGhpcy5pbm5lclN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKCFpbm5lclN1YnNjcmlwdGlvbiB8fCBpbm5lclN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnRyeVJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS50cnlSZXN1bHRTZWxlY3RvciA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHJlc3VsdFNlbGVjdG9yID0gX2EucmVzdWx0U2VsZWN0b3IsIGRlc3RpbmF0aW9uID0gX2EuZGVzdGluYXRpb247XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hNYXBUb1N1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoTWFwVG8uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL3N3aXRjaE1hcFRvLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJyk7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0VtcHR5T2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBFbWl0cyBvbmx5IHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+VGFrZXMgdGhlIGZpcnN0IGBjb3VudGAgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSwgdGhlblxuICogY29tcGxldGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3Rha2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHRha2VgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIGZpcnN0IGBjb3VudGAgdmFsdWVzIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgdGhlIHNvdXJjZSBlbWl0cyBmZXdlciB0aGFuIGBjb3VudGAgdmFsdWVzIHRoZW5cbiAqIGFsbCBvZiBpdHMgdmFsdWVzIGFyZSBlbWl0dGVkLiBBZnRlciB0aGF0LCBpdCBjb21wbGV0ZXMsIHJlZ2FyZGxlc3MgaWYgdGhlXG4gKiBzb3VyY2UgY29tcGxldGVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlRha2UgdGhlIGZpcnN0IDUgc2Vjb25kcyBvZiBhbiBpbmZpbml0ZSAxLXNlY29uZCBpbnRlcnZhbCBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBmaXZlID0gaW50ZXJ2YWwudGFrZSg1KTtcbiAqIGZpdmUuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHRha2VMYXN0fVxuICogQHNlZSB7QGxpbmsgdGFrZVVudGlsfVxuICogQHNlZSB7QGxpbmsgdGFrZVdoaWxlfVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqXG4gKiBAdGhyb3dzIHtBcmd1bWVudE91dE9mUmFuZ2VFcnJvcn0gV2hlbiB1c2luZyBgdGFrZShpKWAsIGl0IGRlbGl2ZXJzIGFuXG4gKiBBcmd1bWVudE91dE9yUmFuZ2VFcnJvciB0byB0aGUgT2JzZXJ2ZXIncyBgZXJyb3JgIGNhbGxiYWNrIGlmIGBpIDwgMGAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IFRoZSBtYXhpbXVtIG51bWJlciBvZiBgbmV4dGAgdmFsdWVzIHRvIGVtaXQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgb25seSB0aGUgZmlyc3QgYGNvdW50YFxuICogdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBvciBhbGwgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIGlmIHRoZSBzb3VyY2UgZW1pdHMgZmV3ZXIgdGhhbiBgY291bnRgIHZhbHVlcy5cbiAqIEBtZXRob2QgdGFrZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGFrZShjb3VudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGVfMS5FbXB0eU9ic2VydmFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgVGFrZU9wZXJhdG9yKGNvdW50KSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy50YWtlID0gdGFrZTtcbnZhciBUYWtlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRha2VPcGVyYXRvcih0b3RhbCkge1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIGlmICh0aGlzLnRvdGFsIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGFrZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy50b3RhbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2VPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRha2VTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFrZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFrZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHRvdGFsKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB9XG4gICAgVGFrZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMudG90YWw7XG4gICAgICAgIHZhciBjb3VudCA9ICsrdGhpcy5jb3VudDtcbiAgICAgICAgaWYgKGNvdW50IDw9IHRvdGFsKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUYWtlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL3Rha2UuanNcbi8vIG1vZHVsZSBpZCA9IDI0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEVtaXRzIHRoZSB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdW50aWwgYSBgbm90aWZpZXJgXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxldHMgdmFsdWVzIHBhc3MgdW50aWwgYSBzZWNvbmQgT2JzZXJ2YWJsZSxcbiAqIGBub3RpZmllcmAsIGVtaXRzIHNvbWV0aGluZy4gVGhlbiwgaXQgY29tcGxldGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3Rha2VVbnRpbC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGFrZVVudGlsYCBzdWJzY3JpYmVzIGFuZCBiZWdpbnMgbWlycm9yaW5nIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSXQgYWxzb1xuICogbW9uaXRvcnMgYSBzZWNvbmQgT2JzZXJ2YWJsZSwgYG5vdGlmaWVyYCB0aGF0IHlvdSBwcm92aWRlLiBJZiB0aGUgYG5vdGlmaWVyYFxuICogZW1pdHMgYSB2YWx1ZSBvciBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiwgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHN0b3BzXG4gKiBtaXJyb3JpbmcgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFuZCBjb21wbGV0ZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VGljayBldmVyeSBzZWNvbmQgdW50aWwgdGhlIGZpcnN0IGNsaWNrIGhhcHBlbnM8L2NhcHRpb24+XG4gKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBpbnRlcnZhbC50YWtlVW50aWwoY2xpY2tzKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqIEBzZWUge0BsaW5rIHRha2VMYXN0fVxuICogQHNlZSB7QGxpbmsgdGFrZVdoaWxlfVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IG5vdGlmaWVyIFRoZSBPYnNlcnZhYmxlIHdob3NlIGZpcnN0IGVtaXR0ZWQgdmFsdWUgd2lsbFxuICogY2F1c2UgdGhlIG91dHB1dCBPYnNlcnZhYmxlIG9mIGB0YWtlVW50aWxgIHRvIHN0b3AgZW1pdHRpbmcgdmFsdWVzIGZyb20gdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSB1bnRpbCBzdWNoIHRpbWUgYXMgYG5vdGlmaWVyYCBlbWl0cyBpdHMgZmlyc3QgdmFsdWUuXG4gKiBAbWV0aG9kIHRha2VVbnRpbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGFrZVVudGlsKG5vdGlmaWVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBUYWtlVW50aWxPcGVyYXRvcihub3RpZmllcikpOyB9O1xufVxuZXhwb3J0cy50YWtlVW50aWwgPSB0YWtlVW50aWw7XG52YXIgVGFrZVVudGlsT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRha2VVbnRpbE9wZXJhdG9yKG5vdGlmaWVyKSB7XG4gICAgICAgIHRoaXMubm90aWZpZXIgPSBub3RpZmllcjtcbiAgICB9XG4gICAgVGFrZVVudGlsT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUYWtlVW50aWxTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubm90aWZpZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWtlVW50aWxPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRha2VVbnRpbFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWtlVW50aWxTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRha2VVbnRpbFN1YnNjcmliZXIoZGVzdGluYXRpb24sIG5vdGlmaWVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG5vdGlmaWVyKSk7XG4gICAgfVxuICAgIFRha2VVbnRpbFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgVGFrZVVudGlsU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9O1xuICAgIHJldHVybiBUYWtlVW50aWxTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2VVbnRpbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvdGFrZVVudGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBFbWl0cyB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgc28gbG9uZyBhcyBlYWNoIHZhbHVlIHNhdGlzZmllc1xuICogdGhlIGdpdmVuIGBwcmVkaWNhdGVgLCBhbmQgdGhlbiBjb21wbGV0ZXMgYXMgc29vbiBhcyB0aGlzIGBwcmVkaWNhdGVgIGlzIG5vdFxuICogc2F0aXNmaWVkLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5UYWtlcyB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIG9ubHkgd2hpbGUgdGhleSBwYXNzIHRoZVxuICogY29uZGl0aW9uIGdpdmVuLiBXaGVuIHRoZSBmaXJzdCB2YWx1ZSBkb2VzIG5vdCBzYXRpc2Z5LCBpdCBjb21wbGV0ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvdGFrZVdoaWxlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB0YWtlV2hpbGVgIHN1YnNjcmliZXMgYW5kIGJlZ2lucyBtaXJyb3JpbmcgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBFYWNoIHZhbHVlXG4gKiBlbWl0dGVkIG9uIHRoZSBzb3VyY2UgaXMgZ2l2ZW4gdG8gdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYVxuICogYm9vbGVhbiwgcmVwcmVzZW50aW5nIGEgY29uZGl0aW9uIHRvIGJlIHNhdGlzZmllZCBieSB0aGUgc291cmNlIHZhbHVlcy4gVGhlXG4gKiBvdXRwdXQgT2JzZXJ2YWJsZSBlbWl0cyB0aGUgc291cmNlIHZhbHVlcyB1bnRpbCBzdWNoIHRpbWUgYXMgdGhlIGBwcmVkaWNhdGVgXG4gKiByZXR1cm5zIGZhbHNlLCBhdCB3aGljaCBwb2ludCBgdGFrZVdoaWxlYCBzdG9wcyBtaXJyb3JpbmcgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBhbmQgY29tcGxldGVzIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IGNsaWNrIGV2ZW50cyBvbmx5IHdoaWxlIHRoZSBjbGllbnRYIHByb3BlcnR5IGlzIGdyZWF0ZXIgdGhhbiAyMDA8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy50YWtlV2hpbGUoZXYgPT4gZXYuY2xpZW50WCA+IDIwMCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHRha2V9XG4gKiBAc2VlIHtAbGluayB0YWtlTGFzdH1cbiAqIEBzZWUge0BsaW5rIHRha2VVbnRpbH1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IGJvb2xlYW59IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIHRoYXRcbiAqIGV2YWx1YXRlcyBhIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFuZCByZXR1cm5zIGEgYm9vbGVhbi5cbiAqIEFsc28gdGFrZXMgdGhlICh6ZXJvLWJhc2VkKSBpbmRleCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIHNvIGxvbmcgYXMgZWFjaCB2YWx1ZSBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBkZWZpbmVkIGJ5IHRoZVxuICogYHByZWRpY2F0ZWAsIHRoZW4gY29tcGxldGVzLlxuICogQG1ldGhvZCB0YWtlV2hpbGVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRha2VXaGlsZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFRha2VXaGlsZU9wZXJhdG9yKHByZWRpY2F0ZSkpOyB9O1xufVxuZXhwb3J0cy50YWtlV2hpbGUgPSB0YWtlV2hpbGU7XG52YXIgVGFrZVdoaWxlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRha2VXaGlsZU9wZXJhdG9yKHByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICB9XG4gICAgVGFrZVdoaWxlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUYWtlV2hpbGVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJlZGljYXRlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZVdoaWxlT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUYWtlV2hpbGVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFrZVdoaWxlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWtlV2hpbGVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIFRha2VXaGlsZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZSh2YWx1ZSwgdGhpcy5pbmRleCsrKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dE9yQ29tcGxldGUodmFsdWUsIHJlc3VsdCk7XG4gICAgfTtcbiAgICBUYWtlV2hpbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0T3JDb21wbGV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcHJlZGljYXRlUmVzdWx0KSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChCb29sZWFuKHByZWRpY2F0ZVJlc3VsdCkpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRha2VXaGlsZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlV2hpbGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL3Rha2VXaGlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG52YXIgdGhyb3R0bGVfMSA9IHJlcXVpcmUoJy4vdGhyb3R0bGUnKTtcbi8qKlxuICogRW1pdHMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgdGhlbiBpZ25vcmVzIHN1YnNlcXVlbnQgc291cmNlXG4gKiB2YWx1ZXMgZm9yIGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzLCB0aGVuIHJlcGVhdHMgdGhpcyBwcm9jZXNzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MZXRzIGEgdmFsdWUgcGFzcywgdGhlbiBpZ25vcmVzIHNvdXJjZSB2YWx1ZXMgZm9yIHRoZVxuICogbmV4dCBgZHVyYXRpb25gIG1pbGxpc2Vjb25kcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90aHJvdHRsZVRpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHRocm90dGxlVGltZWAgZW1pdHMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGVcbiAqIHdoZW4gaXRzIGludGVybmFsIHRpbWVyIGlzIGRpc2FibGVkLCBhbmQgaWdub3JlcyBzb3VyY2UgdmFsdWVzIHdoZW4gdGhlIHRpbWVyXG4gKiBpcyBlbmFibGVkLiBJbml0aWFsbHksIHRoZSB0aW1lciBpcyBkaXNhYmxlZC4gQXMgc29vbiBhcyB0aGUgZmlyc3Qgc291cmNlXG4gKiB2YWx1ZSBhcnJpdmVzLCBpdCBpcyBmb3J3YXJkZWQgdG8gdGhlIG91dHB1dCBPYnNlcnZhYmxlLCBhbmQgdGhlbiB0aGUgdGltZXJcbiAqIGlzIGVuYWJsZWQuIEFmdGVyIGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzIChvciB0aGUgdGltZSB1bml0IGRldGVybWluZWRcbiAqIGludGVybmFsbHkgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgKSBoYXMgcGFzc2VkLCB0aGUgdGltZXIgaXMgZGlzYWJsZWQsXG4gKiBhbmQgdGhpcyBwcm9jZXNzIHJlcGVhdHMgZm9yIHRoZSBuZXh0IHNvdXJjZSB2YWx1ZS4gT3B0aW9uYWxseSB0YWtlcyBhXG4gKiB7QGxpbmsgSVNjaGVkdWxlcn0gZm9yIG1hbmFnaW5nIHRpbWVycy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IGNsaWNrcyBhdCBhIHJhdGUgb2YgYXQgbW9zdCBvbmUgY2xpY2sgcGVyIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnRocm90dGxlVGltZSgxMDAwKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXRUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2VUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gKiBAc2VlIHtAbGluayBzYW1wbGVUaW1lfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGV9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIFRpbWUgdG8gd2FpdCBiZWZvcmUgZW1pdHRpbmcgYW5vdGhlciB2YWx1ZSBhZnRlclxuICogZW1pdHRpbmcgdGhlIGxhc3QgdmFsdWUsIG1lYXN1cmVkIGluIG1pbGxpc2Vjb25kcyBvciB0aGUgdGltZSB1bml0IGRldGVybWluZWRcbiAqIGludGVybmFsbHkgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvclxuICogbWFuYWdpbmcgdGhlIHRpbWVycyB0aGF0IGhhbmRsZSB0aGUgdGhyb3R0bGluZy5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBwZXJmb3JtcyB0aGUgdGhyb3R0bGUgb3BlcmF0aW9uIHRvXG4gKiBsaW1pdCB0aGUgcmF0ZSBvZiBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlLlxuICogQG1ldGhvZCB0aHJvdHRsZVRpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlVGltZShkdXJhdGlvbiwgc2NoZWR1bGVyLCBjb25maWcpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB0aHJvdHRsZV8xLmRlZmF1bHRUaHJvdHRsZUNvbmZpZzsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgVGhyb3R0bGVUaW1lT3BlcmF0b3IoZHVyYXRpb24sIHNjaGVkdWxlciwgY29uZmlnLmxlYWRpbmcsIGNvbmZpZy50cmFpbGluZykpOyB9O1xufVxuZXhwb3J0cy50aHJvdHRsZVRpbWUgPSB0aHJvdHRsZVRpbWU7XG52YXIgVGhyb3R0bGVUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRocm90dGxlVGltZU9wZXJhdG9yKGR1cmF0aW9uLCBzY2hlZHVsZXIsIGxlYWRpbmcsIHRyYWlsaW5nKSB7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMubGVhZGluZyA9IGxlYWRpbmc7XG4gICAgICAgIHRoaXMudHJhaWxpbmcgPSB0cmFpbGluZztcbiAgICB9XG4gICAgVGhyb3R0bGVUaW1lT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZHVyYXRpb24sIHRoaXMuc2NoZWR1bGVyLCB0aGlzLmxlYWRpbmcsIHRoaXMudHJhaWxpbmcpKTtcbiAgICB9O1xuICAgIHJldHVybiBUaHJvdHRsZVRpbWVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRocm90dGxlVGltZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaHJvdHRsZVRpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRocm90dGxlVGltZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGR1cmF0aW9uLCBzY2hlZHVsZXIsIGxlYWRpbmcsIHRyYWlsaW5nKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5sZWFkaW5nID0gbGVhZGluZztcbiAgICAgICAgdGhpcy50cmFpbGluZyA9IHRyYWlsaW5nO1xuICAgICAgICB0aGlzLl9oYXNUcmFpbGluZ1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyYWlsaW5nVmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy50aHJvdHRsZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWlsaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhaWxpbmdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1RyYWlsaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGQodGhpcy50aHJvdHRsZWQgPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIHRoaXMuZHVyYXRpb24sIHsgc3Vic2NyaWJlcjogdGhpcyB9KSk7XG4gICAgICAgICAgICBpZiAodGhpcy5sZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVGhyb3R0bGVUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuY2xlYXJUaHJvdHRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRocm90dGxlZCA9IHRoaXMudGhyb3R0bGVkO1xuICAgICAgICBpZiAodGhyb3R0bGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFpbGluZyAmJiB0aGlzLl9oYXNUcmFpbGluZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMuX3RyYWlsaW5nVmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYWlsaW5nVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1RyYWlsaW5nVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm90dGxlZC51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhyb3R0bGVkKTtcbiAgICAgICAgICAgIHRoaXMudGhyb3R0bGVkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRocm90dGxlVGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaE5leHQoYXJnKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBhcmcuc3Vic2NyaWJlcjtcbiAgICBzdWJzY3JpYmVyLmNsZWFyVGhyb3R0bGUoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRocm90dGxlVGltZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvdGhyb3R0bGVUaW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbmZ1bmN0aW9uIHRpbWVJbnRlcnZhbChzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgVGltZUludGVydmFsT3BlcmF0b3Ioc2NoZWR1bGVyKSk7IH07XG59XG5leHBvcnRzLnRpbWVJbnRlcnZhbCA9IHRpbWVJbnRlcnZhbDtcbnZhciBUaW1lSW50ZXJ2YWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVJbnRlcnZhbCh2YWx1ZSwgaW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgfVxuICAgIHJldHVybiBUaW1lSW50ZXJ2YWw7XG59KCkpO1xuZXhwb3J0cy5UaW1lSW50ZXJ2YWwgPSBUaW1lSW50ZXJ2YWw7XG47XG52YXIgVGltZUludGVydmFsT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVJbnRlcnZhbE9wZXJhdG9yKHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgVGltZUludGVydmFsT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGltZUludGVydmFsU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lSW50ZXJ2YWxPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRpbWVJbnRlcnZhbFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lSW50ZXJ2YWxTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVJbnRlcnZhbFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmxhc3RUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IHNjaGVkdWxlci5ub3coKTtcbiAgICB9XG4gICAgVGltZUludGVydmFsU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICB2YXIgc3BhbiA9IG5vdyAtIHRoaXMubGFzdFRpbWU7XG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSBub3c7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChuZXcgVGltZUludGVydmFsKHZhbHVlLCBzcGFuKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUludGVydmFsU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVJbnRlcnZhbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvdGltZUludGVydmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIGlzRGF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0RhdGUnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgVGltZW91dEVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL1RpbWVvdXRFcnJvcicpO1xuLyoqXG4gKlxuICogRXJyb3JzIGlmIE9ic2VydmFibGUgZG9lcyBub3QgZW1pdCBhIHZhbHVlIGluIGdpdmVuIHRpbWUgc3Bhbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+VGltZW91dHMgb24gT2JzZXJ2YWJsZSB0aGF0IGRvZXNuJ3QgZW1pdCB2YWx1ZXMgZmFzdCBlbm91Z2guPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvdGltZW91dC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGltZW91dGAgb3BlcmF0b3IgYWNjZXB0cyBhcyBhbiBhcmd1bWVudCBlaXRoZXIgYSBudW1iZXIgb3IgYSBEYXRlLlxuICpcbiAqIElmIG51bWJlciB3YXMgcHJvdmlkZWQsIGl0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGJlaGF2ZXMgbGlrZSBhIHNvdXJjZVxuICogT2JzZXJ2YWJsZSwgdW5sZXNzIHRoZXJlIGlzIGEgcGVyaW9kIG9mIHRpbWUgd2hlcmUgdGhlcmUgaXMgbm8gdmFsdWUgZW1pdHRlZC5cbiAqIFNvIGlmIHlvdSBwcm92aWRlIGAxMDBgIGFzIGFyZ3VtZW50IGFuZCBmaXJzdCB2YWx1ZSBjb21lcyBhZnRlciA1MG1zIGZyb21cbiAqIHRoZSBtb21lbnQgb2Ygc3Vic2NyaXB0aW9uLCB0aGlzIHZhbHVlIHdpbGwgYmUgc2ltcGx5IHJlLWVtaXR0ZWQgYnkgdGhlIHJlc3VsdGluZ1xuICogT2JzZXJ2YWJsZS4gSWYgaG93ZXZlciBhZnRlciB0aGF0IDEwMG1zIHBhc3NlcyB3aXRob3V0IGEgc2Vjb25kIHZhbHVlIGJlaW5nIGVtaXR0ZWQsXG4gKiBzdHJlYW0gd2lsbCBlbmQgd2l0aCBhbiBlcnJvciBhbmQgc291cmNlIE9ic2VydmFibGUgd2lsbCBiZSB1bnN1YnNjcmliZWQuXG4gKiBUaGVzZSBjaGVja3MgYXJlIHBlcmZvcm1lZCB0aHJvdWdob3V0IHdob2xlIGxpZmVjeWNsZSBvZiBPYnNlcnZhYmxlIC0gZnJvbSB0aGUgbW9tZW50XG4gKiBpdCB3YXMgc3Vic2NyaWJlZCB0bywgdW50aWwgaXQgY29tcGxldGVzIG9yIGVycm9ycyBpdHNlbGYuIFRodXMgZXZlcnkgdmFsdWUgbXVzdCBiZVxuICogZW1pdHRlZCB3aXRoaW4gc3BlY2lmaWVkIHBlcmlvZCBzaW5jZSBwcmV2aW91cyB2YWx1ZS5cbiAqXG4gKiBJZiBwcm92aWRlZCBhcmd1bWVudCB3YXMgRGF0ZSwgcmV0dXJuZWQgT2JzZXJ2YWJsZSBiZWhhdmVzIGRpZmZlcmVudGx5LiBJdCB0aHJvd3NcbiAqIGlmIE9ic2VydmFibGUgZGlkIG5vdCBjb21wbGV0ZSBiZWZvcmUgcHJvdmlkZWQgRGF0ZS4gVGhpcyBtZWFucyB0aGF0IHBlcmlvZHMgYmV0d2VlblxuICogZW1pc3Npb24gb2YgcGFydGljdWxhciB2YWx1ZXMgZG8gbm90IG1hdHRlciBpbiB0aGlzIGNhc2UuIElmIE9ic2VydmFibGUgZGlkIG5vdCBjb21wbGV0ZVxuICogYmVmb3JlIHByb3ZpZGVkIERhdGUsIHNvdXJjZSBPYnNlcnZhYmxlIHdpbGwgYmUgdW5zdWJzY3JpYmVkLiBPdGhlciB0aGFuIHRoYXQsIHJlc3VsdGluZ1xuICogc3RyZWFtIGJlaGF2ZXMganVzdCBhcyBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiBgdGltZW91dGAgYWNjZXB0cyBhbHNvIGEgU2NoZWR1bGVyIGFzIGEgc2Vjb25kIHBhcmFtZXRlci4gSXQgaXMgdXNlZCB0byBzY2hlZHVsZSBtb21lbnQgKG9yIG1vbWVudHMpXG4gKiB3aGVuIHJldHVybmVkIE9ic2VydmFibGUgd2lsbCBjaGVjayBpZiBzb3VyY2Ugc3RyZWFtIGVtaXR0ZWQgdmFsdWUgb3IgY29tcGxldGVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNoZWNrIGlmIHRpY2tzIGFyZSBlbWl0dGVkIHdpdGhpbiBjZXJ0YWluIHRpbWVzcGFuPC9jYXB0aW9uPlxuICogY29uc3Qgc2Vjb25kcyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKlxuICogc2Vjb25kcy50aW1lb3V0KDExMDApIC8vIExldCdzIHVzZSBiaWdnZXIgdGltZXNwYW4gdG8gYmUgc2FmZSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBgaW50ZXJ2YWxgIG1pZ2h0IGZpcmUgYSBiaXQgbGF0ZXIgdGhlbiBzY2hlZHVsZWQuXG4gKiAuc3Vic2NyaWJlKFxuICogICAgIHZhbHVlID0+IGNvbnNvbGUubG9nKHZhbHVlKSwgLy8gV2lsbCBlbWl0IG51bWJlcnMganVzdCBhcyByZWd1bGFyIGBpbnRlcnZhbGAgd291bGQuXG4gKiAgICAgZXJyID0+IGNvbnNvbGUubG9nKGVycikgLy8gV2lsbCBuZXZlciBiZSBjYWxsZWQuXG4gKiApO1xuICpcbiAqIHNlY29uZHMudGltZW91dCg5MDApLnN1YnNjcmliZShcbiAqICAgICB2YWx1ZSA9PiBjb25zb2xlLmxvZyh2YWx1ZSksIC8vIFdpbGwgbmV2ZXIgYmUgY2FsbGVkLlxuICogICAgIGVyciA9PiBjb25zb2xlLmxvZyhlcnIpIC8vIFdpbGwgZW1pdCBlcnJvciBiZWZvcmUgZXZlbiBmaXJzdCB2YWx1ZSBpcyBlbWl0dGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0IGRpZCBub3QgYXJyaXZlIHdpdGhpbiA5MDBtcyBwZXJpb2QuXG4gKiApO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlVzZSBEYXRlIHRvIGNoZWNrIGlmIE9ic2VydmFibGUgY29tcGxldGVkPC9jYXB0aW9uPlxuICogY29uc3Qgc2Vjb25kcyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKlxuICogc2Vjb25kcy50aW1lb3V0KG5ldyBEYXRlKFwiRGVjZW1iZXIgMTcsIDIwMjAgMDM6MjQ6MDBcIikpXG4gKiAuc3Vic2NyaWJlKFxuICogICAgIHZhbHVlID0+IGNvbnNvbGUubG9nKHZhbHVlKSwgLy8gV2lsbCBlbWl0IHZhbHVlcyBhcyByZWd1bGFyIGBpbnRlcnZhbGAgd291bGRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVudGlsIERlY2VtYmVyIDE3LCAyMDIwIGF0IDAzOjI0OjAwLlxuICogICAgIGVyciA9PiBjb25zb2xlLmxvZyhlcnIpIC8vIE9uIERlY2VtYmVyIDE3LCAyMDIwIGF0IDAzOjI0OjAwIGl0IHdpbGwgZW1pdCBhbiBlcnJvcixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBPYnNlcnZhYmxlIGRpZCBub3QgY29tcGxldGUgYnkgdGhlbi5cbiAqICk7XG4gKlxuICogQHNlZSB7QGxpbmsgdGltZW91dFdpdGh9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ8RGF0ZX0gZHVlIE51bWJlciBzcGVjaWZ5aW5nIHBlcmlvZCB3aXRoaW4gd2hpY2ggT2JzZXJ2YWJsZSBtdXN0IGVtaXQgdmFsdWVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgRGF0ZSBzcGVjaWZ5aW5nIGJlZm9yZSB3aGVuIE9ic2VydmFibGUgc2hvdWxkIGNvbXBsZXRlXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIGNvbnRyb2xsaW5nIHdoZW4gdGltZW91dCBjaGVja3Mgb2NjdXIuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyBiZWhhdmlvdXIgb2Ygc291cmNlLCB1bmxlc3MgdGltZW91dCBjaGVja3MgZmFpbC5cbiAqIEBtZXRob2QgdGltZW91dFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGltZW91dChkdWUsIHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgdmFyIGFic29sdXRlVGltZW91dCA9IGlzRGF0ZV8xLmlzRGF0ZShkdWUpO1xuICAgIHZhciB3YWl0Rm9yID0gYWJzb2x1dGVUaW1lb3V0ID8gKCtkdWUgLSBzY2hlZHVsZXIubm93KCkpIDogTWF0aC5hYnMoZHVlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFRpbWVvdXRPcGVyYXRvcih3YWl0Rm9yLCBhYnNvbHV0ZVRpbWVvdXQsIHNjaGVkdWxlciwgbmV3IFRpbWVvdXRFcnJvcl8xLlRpbWVvdXRFcnJvcigpKSk7IH07XG59XG5leHBvcnRzLnRpbWVvdXQgPSB0aW1lb3V0O1xudmFyIFRpbWVvdXRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZW91dE9wZXJhdG9yKHdhaXRGb3IsIGFic29sdXRlVGltZW91dCwgc2NoZWR1bGVyLCBlcnJvckluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMud2FpdEZvciA9IHdhaXRGb3I7XG4gICAgICAgIHRoaXMuYWJzb2x1dGVUaW1lb3V0ID0gYWJzb2x1dGVUaW1lb3V0O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5lcnJvckluc3RhbmNlID0gZXJyb3JJbnN0YW5jZTtcbiAgICB9XG4gICAgVGltZW91dE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGltZW91dFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5hYnNvbHV0ZVRpbWVvdXQsIHRoaXMud2FpdEZvciwgdGhpcy5zY2hlZHVsZXIsIHRoaXMuZXJyb3JJbnN0YW5jZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVvdXRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRpbWVvdXRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZW91dFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZW91dFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGFic29sdXRlVGltZW91dCwgd2FpdEZvciwgc2NoZWR1bGVyLCBlcnJvckluc3RhbmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5hYnNvbHV0ZVRpbWVvdXQgPSBhYnNvbHV0ZVRpbWVvdXQ7XG4gICAgICAgIHRoaXMud2FpdEZvciA9IHdhaXRGb3I7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmVycm9ySW5zdGFuY2UgPSBlcnJvckluc3RhbmNlO1xuICAgICAgICB0aGlzLmFjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgfVxuICAgIFRpbWVvdXRTdWJzY3JpYmVyLmRpc3BhdGNoVGltZW91dCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHN1YnNjcmliZXIuZXJyb3Ioc3Vic2NyaWJlci5lcnJvckluc3RhbmNlKTtcbiAgICB9O1xuICAgIFRpbWVvdXRTdWJzY3JpYmVyLnByb3RvdHlwZS5zY2hlZHVsZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmFjdGlvbjtcbiAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgLy8gUmVjeWNsZSB0aGUgYWN0aW9uIGlmIHdlJ3ZlIGFscmVhZHkgc2NoZWR1bGVkIG9uZS4gQWxsIHRoZSBwcm9kdWN0aW9uXG4gICAgICAgICAgICAvLyBTY2hlZHVsZXIgQWN0aW9ucyBtdXRhdGUgdGhlaXIgc3RhdGUvZGVsYXkgdGltZSBhbmQgcmV0dXJuIHRoZW1lc2VsdmVzLlxuICAgICAgICAgICAgLy8gVmlydHVhbEFjdGlvbnMgYXJlIGltbXV0YWJsZSwgc28gdGhleSBjcmVhdGUgYW5kIHJldHVybiBhIGNsb25lLiBJbiB0aGlzXG4gICAgICAgICAgICAvLyBjYXNlLCB3ZSBuZWVkIHRvIHNldCB0aGUgYWN0aW9uIHJlZmVyZW5jZSB0byB0aGUgbW9zdCByZWNlbnQgVmlydHVhbEFjdGlvbixcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSB0aGF0J3MgdGhlIG9uZSB3ZSBjbG9uZSBmcm9tIG5leHQgdGltZS5cbiAgICAgICAgICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uLnNjaGVkdWxlKHRoaXMsIHRoaXMud2FpdEZvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZCh0aGlzLmFjdGlvbiA9IHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKFRpbWVvdXRTdWJzY3JpYmVyLmRpc3BhdGNoVGltZW91dCwgdGhpcy53YWl0Rm9yLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVvdXRTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWJzb2x1dGVUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX25leHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBUaW1lb3V0U3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5lcnJvckluc3RhbmNlID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lb3V0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVvdXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL3RpbWVvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDI1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG52YXIgaXNEYXRlXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzRGF0ZScpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqXG4gKiBFcnJvcnMgaWYgT2JzZXJ2YWJsZSBkb2VzIG5vdCBlbWl0IGEgdmFsdWUgaW4gZ2l2ZW4gdGltZSBzcGFuLCBpbiBjYXNlIG9mIHdoaWNoXG4gKiBzdWJzY3JpYmVzIHRvIHRoZSBzZWNvbmQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBhIHZlcnNpb24gb2YgYHRpbWVvdXRgIG9wZXJhdG9yIHRoYXQgbGV0J3MgeW91IHNwZWNpZnkgZmFsbGJhY2sgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90aW1lb3V0V2l0aC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGltZW91dFdpdGhgIGlzIGEgdmFyaWF0aW9uIG9mIGB0aW1lb3V0YCBvcGVyYXRvci4gSXQgYmVoYXZlcyBleGFjdGx5IHRoZSBzYW1lLFxuICogc3RpbGwgYWNjZXB0aW5nIGFzIGEgZmlyc3QgYXJndW1lbnQgZWl0aGVyIGEgbnVtYmVyIG9yIGEgRGF0ZSwgd2hpY2ggY29udHJvbCAtIHJlc3BlY3RpdmVseSAtXG4gKiB3aGVuIHZhbHVlcyBvZiBzb3VyY2UgT2JzZXJ2YWJsZSBzaG91bGQgYmUgZW1pdHRlZCBvciB3aGVuIGl0IHNob3VsZCBjb21wbGV0ZS5cbiAqXG4gKiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgaXQgYWNjZXB0cyBhIHNlY29uZCwgcmVxdWlyZWQgcGFyYW1ldGVyLiBUaGlzIHBhcmFtZXRlclxuICogc2hvdWxkIGJlIGFuIE9ic2VydmFibGUgd2hpY2ggd2lsbCBiZSBzdWJzY3JpYmVkIHdoZW4gc291cmNlIE9ic2VydmFibGUgZmFpbHMgYW55IHRpbWVvdXQgY2hlY2suXG4gKiBTbyB3aGVuZXZlciByZWd1bGFyIGB0aW1lb3V0YCB3b3VsZCBlbWl0IGFuIGVycm9yLCBgdGltZW91dFdpdGhgIHdpbGwgaW5zdGVhZCBzdGFydCByZS1lbWl0dGluZ1xuICogdmFsdWVzIGZyb20gc2Vjb25kIE9ic2VydmFibGUuIE5vdGUgdGhhdCB0aGlzIGZhbGxiYWNrIE9ic2VydmFibGUgaXMgbm90IGNoZWNrZWQgZm9yIHRpbWVvdXRzXG4gKiBpdHNlbGYsIHNvIGl0IGNhbiBlbWl0IHZhbHVlcyBhbmQgY29tcGxldGUgYXQgYXJiaXRyYXJ5IHBvaW50cyBpbiB0aW1lLiBGcm9tIHRoZSBtb21lbnQgb2YgYSBzZWNvbmRcbiAqIHN1YnNjcmlwdGlvbiwgT2JzZXJ2YWJsZSByZXR1cm5lZCBmcm9tIGB0aW1lb3V0V2l0aGAgc2ltcGx5IG1pcnJvcnMgZmFsbGJhY2sgc3RyZWFtLiBXaGVuIHRoYXRcbiAqIHN0cmVhbSBjb21wbGV0ZXMsIGl0IGNvbXBsZXRlcyBhcyB3ZWxsLlxuICpcbiAqIFNjaGVkdWxlciwgd2hpY2ggaW4gY2FzZSBvZiBgdGltZW91dGAgaXMgcHJvdmlkZWQgYXMgYXMgc2Vjb25kIGFyZ3VtZW50LCBjYW4gYmUgc3RpbGwgcHJvdmlkZWRcbiAqIGhlcmUgLSBhcyBhIHRoaXJkLCBvcHRpb25hbCBwYXJhbWV0ZXIuIEl0IHN0aWxsIGlzIHVzZWQgdG8gc2NoZWR1bGUgdGltZW91dCBjaGVja3MgYW5kIC1cbiAqIGFzIGEgY29uc2VxdWVuY2UgLSB3aGVuIHNlY29uZCBPYnNlcnZhYmxlIHdpbGwgYmUgc3Vic2NyaWJlZCwgc2luY2Ugc3Vic2NyaXB0aW9uIGhhcHBlbnNcbiAqIGltbWVkaWF0ZWx5IGFmdGVyIGZhaWxpbmcgY2hlY2suXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QWRkIGZhbGxiYWNrIG9ic2VydmFibGU8L2NhcHRpb24+XG4gKiBjb25zdCBzZWNvbmRzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIGNvbnN0IG1pbnV0ZXMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDYwICogMTAwMCk7XG4gKlxuICogc2Vjb25kcy50aW1lb3V0V2l0aCg5MDAsIG1pbnV0ZXMpXG4gKiAgICAgLnN1YnNjcmliZShcbiAqICAgICAgICAgdmFsdWUgPT4gY29uc29sZS5sb2codmFsdWUpLCAvLyBBZnRlciA5MDBtcywgd2lsbCBzdGFydCBlbWl0dGluZyBgbWludXRlc2AsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgZmlyc3QgdmFsdWUgb2YgYHNlY29uZHNgIHdpbGwgbm90IGFycml2ZSBmYXN0IGVub3VnaC5cbiAqICAgICAgICAgZXJyID0+IGNvbnNvbGUubG9nKGVycikgLy8gV291bGQgYmUgY2FsbGVkIGFmdGVyIDkwMG1zIGluIGNhc2Ugb2YgYHRpbWVvdXRgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgaGVyZSB3aWxsIG5ldmVyIGJlIGNhbGxlZC5cbiAqICAgICApO1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfERhdGV9IGR1ZSBOdW1iZXIgc3BlY2lmeWluZyBwZXJpb2Qgd2l0aGluIHdoaWNoIE9ic2VydmFibGUgbXVzdCBlbWl0IHZhbHVlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIERhdGUgc3BlY2lmeWluZyBiZWZvcmUgd2hlbiBPYnNlcnZhYmxlIHNob3VsZCBjb21wbGV0ZVxuICogQHBhcmFtIHtPYnNlcnZhYmxlPFQ+fSB3aXRoT2JzZXJ2YWJsZSBPYnNlcnZhYmxlIHdoaWNoIHdpbGwgYmUgc3Vic2NyaWJlZCBpZiBzb3VyY2UgZmFpbHMgdGltZW91dCBjaGVjay5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgY29udHJvbGxpbmcgd2hlbiB0aW1lb3V0IGNoZWNrcyBvY2N1ci5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIGJlaGF2aW91ciBvZiBzb3VyY2Ugb3IsIHdoZW4gdGltZW91dCBjaGVjayBmYWlscywgb2YgYW4gT2JzZXJ2YWJsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3NlZCBhcyBhIHNlY29uZCBwYXJhbWV0ZXIuXG4gKiBAbWV0aG9kIHRpbWVvdXRXaXRoXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0aW1lb3V0V2l0aChkdWUsIHdpdGhPYnNlcnZhYmxlLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBhYnNvbHV0ZVRpbWVvdXQgPSBpc0RhdGVfMS5pc0RhdGUoZHVlKTtcbiAgICAgICAgdmFyIHdhaXRGb3IgPSBhYnNvbHV0ZVRpbWVvdXQgPyAoK2R1ZSAtIHNjaGVkdWxlci5ub3coKSkgOiBNYXRoLmFicyhkdWUpO1xuICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IFRpbWVvdXRXaXRoT3BlcmF0b3Iod2FpdEZvciwgYWJzb2x1dGVUaW1lb3V0LCB3aXRoT2JzZXJ2YWJsZSwgc2NoZWR1bGVyKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMudGltZW91dFdpdGggPSB0aW1lb3V0V2l0aDtcbnZhciBUaW1lb3V0V2l0aE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lb3V0V2l0aE9wZXJhdG9yKHdhaXRGb3IsIGFic29sdXRlVGltZW91dCwgd2l0aE9ic2VydmFibGUsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLndhaXRGb3IgPSB3YWl0Rm9yO1xuICAgICAgICB0aGlzLmFic29sdXRlVGltZW91dCA9IGFic29sdXRlVGltZW91dDtcbiAgICAgICAgdGhpcy53aXRoT2JzZXJ2YWJsZSA9IHdpdGhPYnNlcnZhYmxlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgVGltZW91dFdpdGhPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRpbWVvdXRXaXRoU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmFic29sdXRlVGltZW91dCwgdGhpcy53YWl0Rm9yLCB0aGlzLndpdGhPYnNlcnZhYmxlLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVvdXRXaXRoT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUaW1lb3V0V2l0aFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lb3V0V2l0aFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZW91dFdpdGhTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBhYnNvbHV0ZVRpbWVvdXQsIHdhaXRGb3IsIHdpdGhPYnNlcnZhYmxlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmFic29sdXRlVGltZW91dCA9IGFic29sdXRlVGltZW91dDtcbiAgICAgICAgdGhpcy53YWl0Rm9yID0gd2FpdEZvcjtcbiAgICAgICAgdGhpcy53aXRoT2JzZXJ2YWJsZSA9IHdpdGhPYnNlcnZhYmxlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5hY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuICAgIH1cbiAgICBUaW1lb3V0V2l0aFN1YnNjcmliZXIuZGlzcGF0Y2hUaW1lb3V0ID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHdpdGhPYnNlcnZhYmxlID0gc3Vic2NyaWJlci53aXRoT2JzZXJ2YWJsZTtcbiAgICAgICAgc3Vic2NyaWJlci5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk7XG4gICAgICAgIHN1YnNjcmliZXIuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQoc3Vic2NyaWJlciwgd2l0aE9ic2VydmFibGUpKTtcbiAgICB9O1xuICAgIFRpbWVvdXRXaXRoU3Vic2NyaWJlci5wcm90b3R5cGUuc2NoZWR1bGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5hY3Rpb247XG4gICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIFJlY3ljbGUgdGhlIGFjdGlvbiBpZiB3ZSd2ZSBhbHJlYWR5IHNjaGVkdWxlZCBvbmUuIEFsbCB0aGUgcHJvZHVjdGlvblxuICAgICAgICAgICAgLy8gU2NoZWR1bGVyIEFjdGlvbnMgbXV0YXRlIHRoZWlyIHN0YXRlL2RlbGF5IHRpbWUgYW5kIHJldHVybiB0aGVtZXNlbHZlcy5cbiAgICAgICAgICAgIC8vIFZpcnR1YWxBY3Rpb25zIGFyZSBpbW11dGFibGUsIHNvIHRoZXkgY3JlYXRlIGFuZCByZXR1cm4gYSBjbG9uZS4gSW4gdGhpc1xuICAgICAgICAgICAgLy8gY2FzZSwgd2UgbmVlZCB0byBzZXQgdGhlIGFjdGlvbiByZWZlcmVuY2UgdG8gdGhlIG1vc3QgcmVjZW50IFZpcnR1YWxBY3Rpb24sXG4gICAgICAgICAgICAvLyB0byBlbnN1cmUgdGhhdCdzIHRoZSBvbmUgd2UgY2xvbmUgZnJvbSBuZXh0IHRpbWUuXG4gICAgICAgICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbi5zY2hlZHVsZSh0aGlzLCB0aGlzLndhaXRGb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGQodGhpcy5hY3Rpb24gPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShUaW1lb3V0V2l0aFN1YnNjcmliZXIuZGlzcGF0Y2hUaW1lb3V0LCB0aGlzLndhaXRGb3IsIHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGltZW91dFdpdGhTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWJzb2x1dGVUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX25leHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBUaW1lb3V0V2l0aFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IG51bGw7XG4gICAgICAgIHRoaXMud2l0aE9ic2VydmFibGUgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVvdXRXaXRoU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lb3V0V2l0aC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvdGltZW91dFdpdGguanNcbi8vIG1vZHVsZSBpZCA9IDI1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIG1hcF8xID0gcmVxdWlyZSgnLi9tYXAnKTtcbi8qKlxuICogQHBhcmFtIHNjaGVkdWxlclxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUaW1lc3RhbXA8YW55Pj58V2ViU29ja2V0U3ViamVjdDxUPnxPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCB0aW1lc3RhbXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRpbWVzdGFtcChzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHJldHVybiBtYXBfMS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBuZXcgVGltZXN0YW1wKHZhbHVlLCBzY2hlZHVsZXIubm93KCkpOyB9KTtcbiAgICAvLyByZXR1cm4gKHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gc291cmNlLmxpZnQobmV3IFRpbWVzdGFtcE9wZXJhdG9yKHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG52YXIgVGltZXN0YW1wID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lc3RhbXAodmFsdWUsIHRpbWVzdGFtcCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgIH1cbiAgICByZXR1cm4gVGltZXN0YW1wO1xufSgpKTtcbmV4cG9ydHMuVGltZXN0YW1wID0gVGltZXN0YW1wO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXN0YW1wLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy90aW1lc3RhbXAuanNcbi8vIG1vZHVsZSBpZCA9IDI1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcmVkdWNlXzEgPSByZXF1aXJlKCcuL3JlZHVjZScpO1xuZnVuY3Rpb24gdG9BcnJheVJlZHVjZXIoYXJyLCBpdGVtLCBpbmRleCkge1xuICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiB0b0FycmF5KCkge1xuICAgIHJldHVybiByZWR1Y2VfMS5yZWR1Y2UodG9BcnJheVJlZHVjZXIsIFtdKTtcbn1cbmV4cG9ydHMudG9BcnJheSA9IHRvQXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b0FycmF5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy90b0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbi8qKlxuICogQnJhbmNoIG91dCB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIGFzIGEgbmVzdGVkIE9ic2VydmFibGUgd2l0aCBlYWNoXG4gKiBuZXN0ZWQgT2JzZXJ2YWJsZSBlbWl0dGluZyBhdCBtb3N0IGB3aW5kb3dTaXplYCB2YWx1ZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyQ291bnR9LCBidXQgZW1pdHMgYSBuZXN0ZWRcbiAqIE9ic2VydmFibGUgaW5zdGVhZCBvZiBhbiBhcnJheS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy93aW5kb3dDb3VudC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB3aW5kb3dzIG9mIGl0ZW1zIGl0IGNvbGxlY3RzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzIHdpbmRvd3MgZXZlcnkgYHN0YXJ0V2luZG93RXZlcnlgXG4gKiBpdGVtcywgZWFjaCBjb250YWluaW5nIG5vIG1vcmUgdGhhbiBgd2luZG93U2l6ZWAgaXRlbXMuIFdoZW4gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBjb21wbGV0ZXMgb3IgZW5jb3VudGVycyBhbiBlcnJvciwgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzXG4gKiB0aGUgY3VycmVudCB3aW5kb3cgYW5kIHByb3BhZ2F0ZXMgdGhlIG5vdGlmaWNhdGlvbiBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIElmIGBzdGFydFdpbmRvd0V2ZXJ5YCBpcyBub3QgcHJvdmlkZWQsIHRoZW4gbmV3IHdpbmRvd3MgYXJlXG4gKiBzdGFydGVkIGltbWVkaWF0ZWx5IGF0IHRoZSBzdGFydCBvZiB0aGUgc291cmNlIGFuZCB3aGVuIGVhY2ggd2luZG93IGNvbXBsZXRlc1xuICogd2l0aCBzaXplIGB3aW5kb3dTaXplYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5JZ25vcmUgZXZlcnkgM3JkIGNsaWNrIGV2ZW50LCBzdGFydGluZyBmcm9tIHRoZSBmaXJzdCBvbmU8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy53aW5kb3dDb3VudCgzKVxuICogICAubWFwKHdpbiA9PiB3aW4uc2tpcCgxKSkgLy8gc2tpcCBmaXJzdCBvZiBldmVyeSAzIGNsaWNrc1xuICogICAubWVyZ2VBbGwoKTsgLy8gZmxhdHRlbiB0aGUgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5JZ25vcmUgZXZlcnkgM3JkIGNsaWNrIGV2ZW50LCBzdGFydGluZyBmcm9tIHRoZSB0aGlyZCBvbmU8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy53aW5kb3dDb3VudCgyLCAzKVxuICogICAubWVyZ2VBbGwoKTsgLy8gZmxhdHRlbiB0aGUgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB3aW5kb3d9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUaW1lfVxuICogQHNlZSB7QGxpbmsgd2luZG93VG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgd2luZG93V2hlbn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlckNvdW50fVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aW5kb3dTaXplIFRoZSBtYXhpbXVtIG51bWJlciBvZiB2YWx1ZXMgZW1pdHRlZCBieSBlYWNoXG4gKiB3aW5kb3cuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0V2luZG93RXZlcnldIEludGVydmFsIGF0IHdoaWNoIHRvIHN0YXJ0IGEgbmV3IHdpbmRvdy5cbiAqIEZvciBleGFtcGxlIGlmIGBzdGFydFdpbmRvd0V2ZXJ5YCBpcyBgMmAsIHRoZW4gYSBuZXcgd2luZG93IHdpbGwgYmUgc3RhcnRlZFxuICogb24gZXZlcnkgb3RoZXIgdmFsdWUgZnJvbSB0aGUgc291cmNlLiBBIG5ldyB3aW5kb3cgaXMgc3RhcnRlZCBhdCB0aGVcbiAqIGJlZ2lubmluZyBvZiB0aGUgc291cmNlIGJ5IGRlZmF1bHQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+fSBBbiBPYnNlcnZhYmxlIG9mIHdpbmRvd3MsIHdoaWNoIGluIHR1cm5cbiAqIGFyZSBPYnNlcnZhYmxlIG9mIHZhbHVlcy5cbiAqIEBtZXRob2Qgd2luZG93Q291bnRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHdpbmRvd0NvdW50KHdpbmRvd1NpemUsIHN0YXJ0V2luZG93RXZlcnkpIHtcbiAgICBpZiAoc3RhcnRXaW5kb3dFdmVyeSA9PT0gdm9pZCAwKSB7IHN0YXJ0V2luZG93RXZlcnkgPSAwOyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHdpbmRvd0NvdW50T3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBXaW5kb3dDb3VudE9wZXJhdG9yKHdpbmRvd1NpemUsIHN0YXJ0V2luZG93RXZlcnkpKTtcbiAgICB9O1xufVxuZXhwb3J0cy53aW5kb3dDb3VudCA9IHdpbmRvd0NvdW50O1xudmFyIFdpbmRvd0NvdW50T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdpbmRvd0NvdW50T3BlcmF0b3Iod2luZG93U2l6ZSwgc3RhcnRXaW5kb3dFdmVyeSkge1xuICAgICAgICB0aGlzLndpbmRvd1NpemUgPSB3aW5kb3dTaXplO1xuICAgICAgICB0aGlzLnN0YXJ0V2luZG93RXZlcnkgPSBzdGFydFdpbmRvd0V2ZXJ5O1xuICAgIH1cbiAgICBXaW5kb3dDb3VudE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgV2luZG93Q291bnRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMud2luZG93U2l6ZSwgdGhpcy5zdGFydFdpbmRvd0V2ZXJ5KSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93Q291bnRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFdpbmRvd0NvdW50U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdpbmRvd0NvdW50U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXaW5kb3dDb3VudFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHdpbmRvd1NpemUsIHN0YXJ0V2luZG93RXZlcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMud2luZG93U2l6ZSA9IHdpbmRvd1NpemU7XG4gICAgICAgIHRoaXMuc3RhcnRXaW5kb3dFdmVyeSA9IHN0YXJ0V2luZG93RXZlcnk7XG4gICAgICAgIHRoaXMud2luZG93cyA9IFtuZXcgU3ViamVjdF8xLlN1YmplY3QoKV07XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHRoaXMud2luZG93c1swXSk7XG4gICAgfVxuICAgIFdpbmRvd0NvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHN0YXJ0V2luZG93RXZlcnkgPSAodGhpcy5zdGFydFdpbmRvd0V2ZXJ5ID4gMCkgPyB0aGlzLnN0YXJ0V2luZG93RXZlcnkgOiB0aGlzLndpbmRvd1NpemU7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIHZhciB3aW5kb3dTaXplID0gdGhpcy53aW5kb3dTaXplO1xuICAgICAgICB2YXIgd2luZG93cyA9IHRoaXMud2luZG93cztcbiAgICAgICAgdmFyIGxlbiA9IHdpbmRvd3MubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbiAmJiAhdGhpcy5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgd2luZG93c1tpXS5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYyA9IHRoaXMuY291bnQgLSB3aW5kb3dTaXplICsgMTtcbiAgICAgICAgaWYgKGMgPj0gMCAmJiBjICUgc3RhcnRXaW5kb3dFdmVyeSA9PT0gMCAmJiAhdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHdpbmRvd3Muc2hpZnQoKS5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgrK3RoaXMuY291bnQgJSBzdGFydFdpbmRvd0V2ZXJ5ID09PSAwICYmICF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdmFyIHdpbmRvd18xID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG4gICAgICAgICAgICB3aW5kb3dzLnB1c2god2luZG93XzEpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh3aW5kb3dfMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmRvd0NvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgd2luZG93cyA9IHRoaXMud2luZG93cztcbiAgICAgICAgaWYgKHdpbmRvd3MpIHtcbiAgICAgICAgICAgIHdoaWxlICh3aW5kb3dzLmxlbmd0aCA+IDAgJiYgIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93cy5zaGlmdCgpLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgV2luZG93Q291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3aW5kb3dzID0gdGhpcy53aW5kb3dzO1xuICAgICAgICBpZiAod2luZG93cykge1xuICAgICAgICAgICAgd2hpbGUgKHdpbmRvd3MubGVuZ3RoID4gMCAmJiAhdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3dzLnNoaWZ0KCkuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBXaW5kb3dDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMud2luZG93cyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93Q291bnRTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93Q291bnQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL3dpbmRvd0NvdW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyNThcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgaXNOdW1lcmljXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzTnVtZXJpYycpO1xudmFyIGlzU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzU2NoZWR1bGVyJyk7XG5mdW5jdGlvbiB3aW5kb3dUaW1lKHdpbmRvd1RpbWVTcGFuKSB7XG4gICAgdmFyIHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7XG4gICAgdmFyIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgPSBudWxsO1xuICAgIHZhciBtYXhXaW5kb3dTaXplID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKGFyZ3VtZW50c1szXSkpIHtcbiAgICAgICAgc2NoZWR1bGVyID0gYXJndW1lbnRzWzNdO1xuICAgIH1cbiAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihhcmd1bWVudHNbMl0pKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOdW1lcmljXzEuaXNOdW1lcmljKGFyZ3VtZW50c1syXSkpIHtcbiAgICAgICAgbWF4V2luZG93U2l6ZSA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIoYXJndW1lbnRzWzFdKSkge1xuICAgICAgICBzY2hlZHVsZXIgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTnVtZXJpY18xLmlzTnVtZXJpYyhhcmd1bWVudHNbMV0pKSB7XG4gICAgICAgIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB3aW5kb3dUaW1lT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBXaW5kb3dUaW1lT3BlcmF0b3Iod2luZG93VGltZVNwYW4sIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwsIG1heFdpbmRvd1NpemUsIHNjaGVkdWxlcikpO1xuICAgIH07XG59XG5leHBvcnRzLndpbmRvd1RpbWUgPSB3aW5kb3dUaW1lO1xudmFyIFdpbmRvd1RpbWVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2luZG93VGltZU9wZXJhdG9yKHdpbmRvd1RpbWVTcGFuLCB3aW5kb3dDcmVhdGlvbkludGVydmFsLCBtYXhXaW5kb3dTaXplLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy53aW5kb3dUaW1lU3BhbiA9IHdpbmRvd1RpbWVTcGFuO1xuICAgICAgICB0aGlzLndpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgPSB3aW5kb3dDcmVhdGlvbkludGVydmFsO1xuICAgICAgICB0aGlzLm1heFdpbmRvd1NpemUgPSBtYXhXaW5kb3dTaXplO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgV2luZG93VGltZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgV2luZG93VGltZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy53aW5kb3dUaW1lU3BhbiwgdGhpcy53aW5kb3dDcmVhdGlvbkludGVydmFsLCB0aGlzLm1heFdpbmRvd1NpemUsIHRoaXMuc2NoZWR1bGVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93VGltZU9wZXJhdG9yO1xufSgpKTtcbnZhciBDb3VudGVkU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvdW50ZWRTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvdW50ZWRTdWJqZWN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fbnVtYmVyT2ZOZXh0ZWRWYWx1ZXMgPSAwO1xuICAgIH1cbiAgICBDb3VudGVkU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9udW1iZXJPZk5leHRlZFZhbHVlcysrO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ291bnRlZFN1YmplY3QucHJvdG90eXBlLCBcIm51bWJlck9mTmV4dGVkVmFsdWVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbnVtYmVyT2ZOZXh0ZWRWYWx1ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBDb3VudGVkU3ViamVjdDtcbn0oU3ViamVjdF8xLlN1YmplY3QpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgV2luZG93VGltZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXaW5kb3dUaW1lU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXaW5kb3dUaW1lU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgd2luZG93VGltZVNwYW4sIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwsIG1heFdpbmRvd1NpemUsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy53aW5kb3dUaW1lU3BhbiA9IHdpbmRvd1RpbWVTcGFuO1xuICAgICAgICB0aGlzLndpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgPSB3aW5kb3dDcmVhdGlvbkludGVydmFsO1xuICAgICAgICB0aGlzLm1heFdpbmRvd1NpemUgPSBtYXhXaW5kb3dTaXplO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy53aW5kb3dzID0gW107XG4gICAgICAgIHZhciB3aW5kb3cgPSB0aGlzLm9wZW5XaW5kb3coKTtcbiAgICAgICAgaWYgKHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgIT09IG51bGwgJiYgd2luZG93Q3JlYXRpb25JbnRlcnZhbCA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgY2xvc2VTdGF0ZSA9IHsgc3Vic2NyaWJlcjogdGhpcywgd2luZG93OiB3aW5kb3csIGNvbnRleHQ6IG51bGwgfTtcbiAgICAgICAgICAgIHZhciBjcmVhdGlvblN0YXRlID0geyB3aW5kb3dUaW1lU3Bhbjogd2luZG93VGltZVNwYW4sIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWw6IHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwsIHN1YnNjcmliZXI6IHRoaXMsIHNjaGVkdWxlcjogc2NoZWR1bGVyIH07XG4gICAgICAgICAgICB0aGlzLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hXaW5kb3dDbG9zZSwgd2luZG93VGltZVNwYW4sIGNsb3NlU3RhdGUpKTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaFdpbmRvd0NyZWF0aW9uLCB3aW5kb3dDcmVhdGlvbkludGVydmFsLCBjcmVhdGlvblN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGltZVNwYW5Pbmx5U3RhdGUgPSB7IHN1YnNjcmliZXI6IHRoaXMsIHdpbmRvdzogd2luZG93LCB3aW5kb3dUaW1lU3Bhbjogd2luZG93VGltZVNwYW4gfTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaFdpbmRvd1RpbWVTcGFuT25seSwgd2luZG93VGltZVNwYW4sIHRpbWVTcGFuT25seVN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgV2luZG93VGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciB3aW5kb3dzID0gdGhpcy53aW5kb3dzO1xuICAgICAgICB2YXIgbGVuID0gd2luZG93cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB3aW5kb3dfMSA9IHdpbmRvd3NbaV07XG4gICAgICAgICAgICBpZiAoIXdpbmRvd18xLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHdpbmRvd18xLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3dfMS5udW1iZXJPZk5leHRlZFZhbHVlcyA+PSB0aGlzLm1heFdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVdpbmRvdyh3aW5kb3dfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBXaW5kb3dUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgd2luZG93cyA9IHRoaXMud2luZG93cztcbiAgICAgICAgd2hpbGUgKHdpbmRvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd2luZG93cy5zaGlmdCgpLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgV2luZG93VGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdpbmRvd3MgPSB0aGlzLndpbmRvd3M7XG4gICAgICAgIHdoaWxlICh3aW5kb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciB3aW5kb3dfMiA9IHdpbmRvd3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghd2luZG93XzIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93XzIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBXaW5kb3dUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUub3BlbldpbmRvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdpbmRvdyA9IG5ldyBDb3VudGVkU3ViamVjdCgpO1xuICAgICAgICB0aGlzLndpbmRvd3MucHVzaCh3aW5kb3cpO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHdpbmRvdyk7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfTtcbiAgICBXaW5kb3dUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuY2xvc2VXaW5kb3cgPSBmdW5jdGlvbiAod2luZG93KSB7XG4gICAgICAgIHdpbmRvdy5jb21wbGV0ZSgpO1xuICAgICAgICB2YXIgd2luZG93cyA9IHRoaXMud2luZG93cztcbiAgICAgICAgd2luZG93cy5zcGxpY2Uod2luZG93cy5pbmRleE9mKHdpbmRvdyksIDEpO1xuICAgIH07XG4gICAgcmV0dXJuIFdpbmRvd1RpbWVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZnVuY3Rpb24gZGlzcGF0Y2hXaW5kb3dUaW1lU3Bhbk9ubHkoc3RhdGUpIHtcbiAgICB2YXIgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXIsIHdpbmRvd1RpbWVTcGFuID0gc3RhdGUud2luZG93VGltZVNwYW4sIHdpbmRvdyA9IHN0YXRlLndpbmRvdztcbiAgICBpZiAod2luZG93KSB7XG4gICAgICAgIHN1YnNjcmliZXIuY2xvc2VXaW5kb3cod2luZG93KTtcbiAgICB9XG4gICAgc3RhdGUud2luZG93ID0gc3Vic2NyaWJlci5vcGVuV2luZG93KCk7XG4gICAgdGhpcy5zY2hlZHVsZShzdGF0ZSwgd2luZG93VGltZVNwYW4pO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hXaW5kb3dDcmVhdGlvbihzdGF0ZSkge1xuICAgIHZhciB3aW5kb3dUaW1lU3BhbiA9IHN0YXRlLndpbmRvd1RpbWVTcGFuLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlciwgc2NoZWR1bGVyID0gc3RhdGUuc2NoZWR1bGVyLCB3aW5kb3dDcmVhdGlvbkludGVydmFsID0gc3RhdGUud2luZG93Q3JlYXRpb25JbnRlcnZhbDtcbiAgICB2YXIgd2luZG93ID0gc3Vic2NyaWJlci5vcGVuV2luZG93KCk7XG4gICAgdmFyIGFjdGlvbiA9IHRoaXM7XG4gICAgdmFyIGNvbnRleHQgPSB7IGFjdGlvbjogYWN0aW9uLCBzdWJzY3JpcHRpb246IG51bGwgfTtcbiAgICB2YXIgdGltZVNwYW5TdGF0ZSA9IHsgc3Vic2NyaWJlcjogc3Vic2NyaWJlciwgd2luZG93OiB3aW5kb3csIGNvbnRleHQ6IGNvbnRleHQgfTtcbiAgICBjb250ZXh0LnN1YnNjcmlwdGlvbiA9IHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaFdpbmRvd0Nsb3NlLCB3aW5kb3dUaW1lU3BhbiwgdGltZVNwYW5TdGF0ZSk7XG4gICAgYWN0aW9uLmFkZChjb250ZXh0LnN1YnNjcmlwdGlvbik7XG4gICAgYWN0aW9uLnNjaGVkdWxlKHN0YXRlLCB3aW5kb3dDcmVhdGlvbkludGVydmFsKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoV2luZG93Q2xvc2Uoc3RhdGUpIHtcbiAgICB2YXIgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXIsIHdpbmRvdyA9IHN0YXRlLndpbmRvdywgY29udGV4dCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5hY3Rpb24gJiYgY29udGV4dC5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgY29udGV4dC5hY3Rpb24ucmVtb3ZlKGNvbnRleHQuc3Vic2NyaXB0aW9uKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlci5jbG9zZVdpbmRvdyh3aW5kb3cpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93VGltZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9vcGVyYXRvcnMvd2luZG93VGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMjU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEJyYW5jaCBvdXQgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBhcyBhIG5lc3RlZCBPYnNlcnZhYmxlIHN0YXJ0aW5nIGZyb21cbiAqIGFuIGVtaXNzaW9uIGZyb20gYG9wZW5pbmdzYCBhbmQgZW5kaW5nIHdoZW4gdGhlIG91dHB1dCBvZiBgY2xvc2luZ1NlbGVjdG9yYFxuICogZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfSwgYnV0IGVtaXRzIGEgbmVzdGVkXG4gKiBPYnNlcnZhYmxlIGluc3RlYWQgb2YgYW4gYXJyYXkuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvd2luZG93VG9nZ2xlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdpbmRvd3Mgb2YgaXRlbXMgaXQgY29sbGVjdHMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMgd2luZG93cyB0aGF0IGNvbnRhaW4gdGhvc2UgaXRlbXNcbiAqIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJldHdlZW4gdGhlIHRpbWUgd2hlbiB0aGUgYG9wZW5pbmdzYFxuICogT2JzZXJ2YWJsZSBlbWl0cyBhbiBpdGVtIGFuZCB3aGVuIHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGJ5XG4gKiBgY2xvc2luZ1NlbGVjdG9yYCBlbWl0cyBhbiBpdGVtLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkV2ZXJ5IG90aGVyIHNlY29uZCwgZW1pdCB0aGUgY2xpY2sgZXZlbnRzIGZyb20gdGhlIG5leHQgNTAwbXM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIG9wZW5pbmdzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Mud2luZG93VG9nZ2xlKG9wZW5pbmdzLCBpID0+XG4gKiAgIGkgJSAyID8gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApIDogUnguT2JzZXJ2YWJsZS5lbXB0eSgpXG4gKiApLm1lcmdlQWxsKCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHdpbmRvd31cbiAqIEBzZWUge0BsaW5rIHdpbmRvd0NvdW50fVxuICogQHNlZSB7QGxpbmsgd2luZG93VGltZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1doZW59XG4gKiBAc2VlIHtAbGluayBidWZmZXJUb2dnbGV9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlPE8+fSBvcGVuaW5ncyBBbiBvYnNlcnZhYmxlIG9mIG5vdGlmaWNhdGlvbnMgdG8gc3RhcnQgbmV3XG4gKiB3aW5kb3dzLlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogTyk6IE9ic2VydmFibGV9IGNsb3NpbmdTZWxlY3RvciBBIGZ1bmN0aW9uIHRoYXQgdGFrZXNcbiAqIHRoZSB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBgb3BlbmluZ3NgIG9ic2VydmFibGUgYW5kIHJldHVybnMgYW4gT2JzZXJ2YWJsZSxcbiAqIHdoaWNoLCB3aGVuIGl0IGVtaXRzIChlaXRoZXIgYG5leHRgIG9yIGBjb21wbGV0ZWApLCBzaWduYWxzIHRoYXQgdGhlXG4gKiBhc3NvY2lhdGVkIHdpbmRvdyBzaG91bGQgY29tcGxldGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+fSBBbiBvYnNlcnZhYmxlIG9mIHdpbmRvd3MsIHdoaWNoIGluIHR1cm5cbiAqIGFyZSBPYnNlcnZhYmxlcy5cbiAqIEBtZXRob2Qgd2luZG93VG9nZ2xlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB3aW5kb3dUb2dnbGUob3BlbmluZ3MsIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgV2luZG93VG9nZ2xlT3BlcmF0b3Iob3BlbmluZ3MsIGNsb3NpbmdTZWxlY3RvcikpOyB9O1xufVxuZXhwb3J0cy53aW5kb3dUb2dnbGUgPSB3aW5kb3dUb2dnbGU7XG52YXIgV2luZG93VG9nZ2xlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdpbmRvd1RvZ2dsZU9wZXJhdG9yKG9wZW5pbmdzLCBjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5vcGVuaW5ncyA9IG9wZW5pbmdzO1xuICAgICAgICB0aGlzLmNsb3NpbmdTZWxlY3RvciA9IGNsb3NpbmdTZWxlY3RvcjtcbiAgICB9XG4gICAgV2luZG93VG9nZ2xlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMub3BlbmluZ3MsIHRoaXMuY2xvc2luZ1NlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93VG9nZ2xlT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2luZG93VG9nZ2xlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBvcGVuaW5ncywgY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5vcGVuaW5ncyA9IG9wZW5pbmdzO1xuICAgICAgICB0aGlzLmNsb3NpbmdTZWxlY3RvciA9IGNsb3NpbmdTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb250ZXh0cyA9IFtdO1xuICAgICAgICB0aGlzLmFkZCh0aGlzLm9wZW5TdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG9wZW5pbmdzLCBvcGVuaW5ncykpO1xuICAgIH1cbiAgICBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICBpZiAoY29udGV4dHMpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dHNbaV0ud2luZG93Lm5leHQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBudWxsO1xuICAgICAgICBpZiAoY29udGV4dHMpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgY29udGV4dC53aW5kb3cuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2Vycm9yLmNhbGwodGhpcywgZXJyKTtcbiAgICB9O1xuICAgIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgdGhpcy5jb250ZXh0cyA9IG51bGw7XG4gICAgICAgIGlmIChjb250ZXh0cykge1xuICAgICAgICAgICAgdmFyIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGNvbnRleHRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LndpbmRvdy5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgdGhpcy5jb250ZXh0cyA9IG51bGw7XG4gICAgICAgIGlmIChjb250ZXh0cykge1xuICAgICAgICAgICAgdmFyIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGNvbnRleHRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LndpbmRvdy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKG91dGVyVmFsdWUgPT09IHRoaXMub3BlbmluZ3MpIHtcbiAgICAgICAgICAgIHZhciBjbG9zaW5nU2VsZWN0b3IgPSB0aGlzLmNsb3NpbmdTZWxlY3RvcjtcbiAgICAgICAgICAgIHZhciBjbG9zaW5nTm90aWZpZXIgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKGNsb3NpbmdTZWxlY3RvcikoaW5uZXJWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xvc2luZ05vdGlmaWVyID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB3aW5kb3dfMSA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7IHdpbmRvdzogd2luZG93XzEsIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uIH07XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgY2xvc2luZ05vdGlmaWVyLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VXaW5kb3codGhpcy5jb250ZXh0cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyU3Vic2NyaXB0aW9uLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uYWRkKGlubmVyU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHdpbmRvd18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VXaW5kb3codGhpcy5jb250ZXh0cy5pbmRleE9mKG91dGVyVmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV2luZG93VG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgICAgIGlmIChpbm5lciAhPT0gdGhpcy5vcGVuU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlV2luZG93KHRoaXMuY29udGV4dHMuaW5kZXhPZihpbm5lci5jb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLmNsb3NlV2luZG93ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB2YXIgY29udGV4dCA9IGNvbnRleHRzW2luZGV4XTtcbiAgICAgICAgdmFyIHdpbmRvdyA9IGNvbnRleHQud2luZG93LCBzdWJzY3JpcHRpb24gPSBjb250ZXh0LnN1YnNjcmlwdGlvbjtcbiAgICAgICAgY29udGV4dHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgd2luZG93LmNvbXBsZXRlKCk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93VG9nZ2xlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy93aW5kb3dUb2dnbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQnJhbmNoIG91dCB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIGFzIGEgbmVzdGVkIE9ic2VydmFibGUgdXNpbmcgYVxuICogZmFjdG9yeSBmdW5jdGlvbiBvZiBjbG9zaW5nIE9ic2VydmFibGVzIHRvIGRldGVybWluZSB3aGVuIHRvIHN0YXJ0IGEgbmV3XG4gKiB3aW5kb3cuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyV2hlbn0sIGJ1dCBlbWl0cyBhIG5lc3RlZFxuICogT2JzZXJ2YWJsZSBpbnN0ZWFkIG9mIGFuIGFycmF5Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3dpbmRvd1doZW4ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2luZG93cyBvZiBpdGVtcyBpdCBjb2xsZWN0cyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBlbWl0cyBjb25uZWN0ZWQsIG5vbi1vdmVybGFwcGluZyB3aW5kb3dzLlxuICogSXQgZW1pdHMgdGhlIGN1cnJlbnQgd2luZG93IGFuZCBvcGVucyBhIG5ldyBvbmUgd2hlbmV2ZXIgdGhlIE9ic2VydmFibGVcbiAqIHByb2R1Y2VkIGJ5IHRoZSBzcGVjaWZpZWQgYGNsb3NpbmdTZWxlY3RvcmAgZnVuY3Rpb24gZW1pdHMgYW4gaXRlbS4gVGhlIGZpcnN0XG4gKiB3aW5kb3cgaXMgb3BlbmVkIGltbWVkaWF0ZWx5IHdoZW4gc3Vic2NyaWJpbmcgdG8gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgb25seSB0aGUgZmlyc3QgdHdvIGNsaWNrcyBldmVudHMgaW4gZXZlcnkgd2luZG93IG9mIFsxLTVdIHJhbmRvbSBzZWNvbmRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3NcbiAqICAgLndpbmRvd1doZW4oKCkgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwICsgTWF0aC5yYW5kb20oKSAqIDQwMDApKVxuICogICAubWFwKHdpbiA9PiB3aW4udGFrZSgyKSkgLy8gZWFjaCB3aW5kb3cgaGFzIGF0IG1vc3QgMiBlbWlzc2lvbnNcbiAqICAgLm1lcmdlQWxsKCk7IC8vIGZsYXR0ZW4gdGhlIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXNcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgd2luZG93fVxuICogQHNlZSB7QGxpbmsgd2luZG93Q291bnR9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUaW1lfVxuICogQHNlZSB7QGxpbmsgd2luZG93VG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyV2hlbn1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IE9ic2VydmFibGV9IGNsb3NpbmdTZWxlY3RvciBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm9cbiAqIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgc2lnbmFscyAob24gZWl0aGVyIGBuZXh0YCBvclxuICogYGNvbXBsZXRlYCkgd2hlbiB0byBjbG9zZSB0aGUgcHJldmlvdXMgd2luZG93IGFuZCBzdGFydCBhIG5ldyBvbmUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+fSBBbiBvYnNlcnZhYmxlIG9mIHdpbmRvd3MsIHdoaWNoIGluIHR1cm5cbiAqIGFyZSBPYnNlcnZhYmxlcy5cbiAqIEBtZXRob2Qgd2luZG93V2hlblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gd2luZG93V2hlbihjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gd2luZG93V2hlbk9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgV2luZG93T3BlcmF0b3IoY2xvc2luZ1NlbGVjdG9yKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMud2luZG93V2hlbiA9IHdpbmRvd1doZW47XG52YXIgV2luZG93T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdpbmRvd09wZXJhdG9yKGNsb3NpbmdTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmNsb3NpbmdTZWxlY3RvciA9IGNsb3NpbmdTZWxlY3RvcjtcbiAgICB9XG4gICAgV2luZG93T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBXaW5kb3dTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY2xvc2luZ1NlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBXaW5kb3dTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2luZG93U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXaW5kb3dTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMuY2xvc2luZ1NlbGVjdG9yID0gY2xvc2luZ1NlbGVjdG9yO1xuICAgICAgICB0aGlzLm9wZW5XaW5kb3coKTtcbiAgICB9XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLm9wZW5XaW5kb3coaW5uZXJTdWIpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuX2Vycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMub3BlbldpbmRvdyhpbm5lclN1Yik7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLndpbmRvdy5uZXh0KHZhbHVlKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy53aW5kb3cuZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2xvc2luZ05vdGlmaWNhdGlvbigpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLndpbmRvdy5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVDbG9zaW5nTm90aWZpY2F0aW9uKCk7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZUNsb3NpbmdOb3RpZmljYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NpbmdOb3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2luZ05vdGlmaWNhdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5vcGVuV2luZG93ID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIGlmIChpbm5lclN1YiA9PT0gdm9pZCAwKSB7IGlubmVyU3ViID0gbnVsbDsgfVxuICAgICAgICBpZiAoaW5uZXJTdWIpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgICAgIGlubmVyU3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZXaW5kb3cgPSB0aGlzLndpbmRvdztcbiAgICAgICAgaWYgKHByZXZXaW5kb3cpIHtcbiAgICAgICAgICAgIHByZXZXaW5kb3cuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2luZG93ID0gdGhpcy53aW5kb3cgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHdpbmRvdyk7XG4gICAgICAgIHZhciBjbG9zaW5nTm90aWZpZXIgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMuY2xvc2luZ1NlbGVjdG9yKSgpO1xuICAgICAgICBpZiAoY2xvc2luZ05vdGlmaWVyID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgdGhpcy53aW5kb3cuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMuY2xvc2luZ05vdGlmaWNhdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgY2xvc2luZ05vdGlmaWVyKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvd1doZW4uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL3dpbmRvd1doZW4uanNcbi8vIG1vZHVsZSBpZCA9IDI2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDb21iaW5lcyB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCBvdGhlciBPYnNlcnZhYmxlcyB0byBjcmVhdGUgYW4gT2JzZXJ2YWJsZVxuICogd2hvc2UgdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGZyb20gdGhlIGxhdGVzdCB2YWx1ZXMgb2YgZWFjaCwgb25seSB3aGVuIHRoZVxuICogc291cmNlIGVtaXRzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5XaGVuZXZlciB0aGUgc291cmNlIE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSwgaXRcbiAqIGNvbXB1dGVzIGEgZm9ybXVsYSB1c2luZyB0aGF0IHZhbHVlIHBsdXMgdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSBvdGhlciBpbnB1dFxuICogT2JzZXJ2YWJsZXMsIHRoZW4gZW1pdHMgdGhlIG91dHB1dCBvZiB0aGF0IGZvcm11bGEuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvd2l0aExhdGVzdEZyb20ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHdpdGhMYXRlc3RGcm9tYCBjb21iaW5lcyBlYWNoIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlICh0aGVcbiAqIGluc3RhbmNlKSB3aXRoIHRoZSBsYXRlc3QgdmFsdWVzIGZyb20gdGhlIG90aGVyIGlucHV0IE9ic2VydmFibGVzIG9ubHkgd2hlblxuICogdGhlIHNvdXJjZSBlbWl0cyBhIHZhbHVlLCBvcHRpb25hbGx5IHVzaW5nIGEgYHByb2plY3RgIGZ1bmN0aW9uIHRvIGRldGVybWluZVxuICogdGhlIHZhbHVlIHRvIGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBBbGwgaW5wdXQgT2JzZXJ2YWJsZXMgbXVzdFxuICogZW1pdCBhdCBsZWFzdCBvbmUgdmFsdWUgYmVmb3JlIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSB3aWxsIGVtaXQgYSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljayBldmVudCwgZW1pdCBhbiBhcnJheSB3aXRoIHRoZSBsYXRlc3QgdGltZXIgZXZlbnQgcGx1cyB0aGUgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Mud2l0aExhdGVzdEZyb20odGltZXIpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lTGF0ZXN0fVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBvdGhlciBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbWJpbmUgd2l0aCB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBNb3JlIHRoYW4gb25lIGlucHV0IE9ic2VydmFibGVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9qZWN0XSBQcm9qZWN0aW9uIGZ1bmN0aW9uIGZvciBjb21iaW5pbmcgdmFsdWVzXG4gKiB0b2dldGhlci4gUmVjZWl2ZXMgYWxsIHZhbHVlcyBpbiBvcmRlciBvZiB0aGUgT2JzZXJ2YWJsZXMgcGFzc2VkLCB3aGVyZSB0aGVcbiAqIGZpcnN0IHBhcmFtZXRlciBpcyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiAoZS5nLlxuICogYGEud2l0aExhdGVzdEZyb20oYiwgYywgKGExLCBiMSwgYzEpID0+IGExICsgYjEgKyBjMSlgKS4gSWYgdGhpcyBpcyBub3RcbiAqIHBhc3NlZCwgYXJyYXlzIHdpbGwgYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIHByb2plY3RlZCB2YWx1ZXMgZnJvbSB0aGUgbW9zdCByZWNlbnRcbiAqIHZhbHVlcyBmcm9tIGVhY2ggaW5wdXQgT2JzZXJ2YWJsZSwgb3IgYW4gYXJyYXkgb2YgdGhlIG1vc3QgcmVjZW50IHZhbHVlcyBmcm9tXG4gKiBlYWNoIGlucHV0IE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHdpdGhMYXRlc3RGcm9tXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbSgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBwcm9qZWN0O1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJvamVjdCA9IGFyZ3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9ic2VydmFibGVzID0gYXJncztcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yKG9ic2VydmFibGVzLCBwcm9qZWN0KSk7XG4gICAgfTtcbn1cbmV4cG9ydHMud2l0aExhdGVzdEZyb20gPSB3aXRoTGF0ZXN0RnJvbTtcbnZhciBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yKG9ic2VydmFibGVzLCBwcm9qZWN0KSB7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXMgPSBvYnNlcnZhYmxlcztcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICB9XG4gICAgV2l0aExhdGVzdEZyb21PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9ic2VydmFibGVzLCB0aGlzLnByb2plY3QpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgb2JzZXJ2YWJsZXMsIHByb2plY3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gb2JzZXJ2YWJsZXM7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMudG9SZXNwb25kID0gW107XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZhYmxlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudG9SZXNwb25kLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBvYnNlcnZhYmxlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZSwgaSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnZhbHVlc1tvdXRlckluZGV4XSA9IGlubmVyVmFsdWU7XG4gICAgICAgIHZhciB0b1Jlc3BvbmQgPSB0aGlzLnRvUmVzcG9uZDtcbiAgICAgICAgaWYgKHRvUmVzcG9uZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSB0b1Jlc3BvbmQuaW5kZXhPZihvdXRlckluZGV4KTtcbiAgICAgICAgICAgIGlmIChmb3VuZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0b1Jlc3BvbmQuc3BsaWNlKGZvdW5kLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH07XG4gICAgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy50b1Jlc3BvbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFt2YWx1ZV0uY29uY2F0KHRoaXMudmFsdWVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2plY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cnlQcm9qZWN0KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXIucHJvdG90eXBlLl90cnlQcm9qZWN0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpdGhMYXRlc3RGcm9tLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL29wZXJhdG9ycy93aXRoTGF0ZXN0RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMjYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB6aXBfMSA9IHJlcXVpcmUoJy4vemlwJyk7XG5mdW5jdGlvbiB6aXBBbGwocHJvamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgemlwXzEuWmlwT3BlcmF0b3IocHJvamVjdCkpOyB9O1xufVxuZXhwb3J0cy56aXBBbGwgPSB6aXBBbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD16aXBBbGwuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3JzL3ppcEFsbC5qc1xuLy8gbW9kdWxlIGlkID0gMjYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIEEgdW5pdCBvZiB3b3JrIHRvIGJlIGV4ZWN1dGVkIGluIGEge0BsaW5rIFNjaGVkdWxlcn0uIEFuIGFjdGlvbiBpcyB0eXBpY2FsbHlcbiAqIGNyZWF0ZWQgZnJvbSB3aXRoaW4gYSBTY2hlZHVsZXIgYW5kIGFuIFJ4SlMgdXNlciBkb2VzIG5vdCBuZWVkIHRvIGNvbmNlcm5cbiAqIHRoZW1zZWx2ZXMgYWJvdXQgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBhbiBBY3Rpb24uXG4gKlxuICogYGBgdHNcbiAqIGNsYXNzIEFjdGlvbjxUPiBleHRlbmRzIFN1YnNjcmlwdGlvbiB7XG4gKiAgIG5ldyAoc2NoZWR1bGVyOiBTY2hlZHVsZXIsIHdvcms6IChzdGF0ZT86IFQpID0+IHZvaWQpO1xuICogICBzY2hlZHVsZShzdGF0ZT86IFQsIGRlbGF5OiBudW1iZXIgPSAwKTogU3Vic2NyaXB0aW9uO1xuICogfVxuICogYGBgXG4gKlxuICogQGNsYXNzIEFjdGlvbjxUPlxuICovXG52YXIgQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyB0aGlzIGFjdGlvbiBvbiBpdHMgcGFyZW50IFNjaGVkdWxlciBmb3IgZXhlY3V0aW9uLiBNYXkgYmUgcGFzc2VkXG4gICAgICogc29tZSBjb250ZXh0IG9iamVjdCwgYHN0YXRlYC4gTWF5IGhhcHBlbiBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUsXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBgZGVsYXlgIHBhcmFtZXRlciwgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7VH0gW3N0YXRlXSBTb21lIGNvbnRleHR1YWwgZGF0YSB0aGF0IHRoZSBgd29ya2AgZnVuY3Rpb24gdXNlcyB3aGVuXG4gICAgICogY2FsbGVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheV0gVGltZSB0byB3YWl0IGJlZm9yZSBleGVjdXRpbmcgdGhlIHdvcmssIHdoZXJlIHRoZVxuICAgICAqIHRpbWUgdW5pdCBpcyBpbXBsaWNpdCBhbmQgZGVmaW5lZCBieSB0aGUgU2NoZWR1bGVyLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgQWN0aW9uLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEFjdGlvbjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLkFjdGlvbiA9IEFjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjdGlvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9zY2hlZHVsZXIvQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQXN5bmNBY3Rpb25fMSA9IHJlcXVpcmUoJy4vQXN5bmNBY3Rpb24nKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgUXVldWVBY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhRdWV1ZUFjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBRdWV1ZUFjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc2NoZWR1bGVyLCB3b3JrKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMud29yayA9IHdvcms7XG4gICAgfVxuICAgIFF1ZXVlQWN0aW9uLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnNjaGVkdWxlLmNhbGwodGhpcywgc3RhdGUsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIuZmx1c2godGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUXVldWVBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIHJldHVybiAoZGVsYXkgPiAwIHx8IHRoaXMuY2xvc2VkKSA/XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmV4ZWN1dGUuY2FsbCh0aGlzLCBzdGF0ZSwgZGVsYXkpIDpcbiAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGUoc3RhdGUsIGRlbGF5KTtcbiAgICB9O1xuICAgIFF1ZXVlQWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0QXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgLy8gSWYgZGVsYXkgZXhpc3RzIGFuZCBpcyBncmVhdGVyIHRoYW4gMCwgb3IgaWYgdGhlIGRlbGF5IGlzIG51bGwgKHRoZVxuICAgICAgICAvLyBhY3Rpb24gd2Fzbid0IHJlc2NoZWR1bGVkKSBidXQgd2FzIG9yaWdpbmFsbHkgc2NoZWR1bGVkIGFzIGFuIGFzeW5jXG4gICAgICAgIC8vIGFjdGlvbiwgdGhlbiByZWN5Y2xlIGFzIGFuIGFzeW5jIGFjdGlvbi5cbiAgICAgICAgaWYgKChkZWxheSAhPT0gbnVsbCAmJiBkZWxheSA+IDApIHx8IChkZWxheSA9PT0gbnVsbCAmJiB0aGlzLmRlbGF5ID4gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkLmNhbGwodGhpcywgc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSBmbHVzaCB0aGUgc2NoZWR1bGVyIHN0YXJ0aW5nIHdpdGggdGhpcyBhY3Rpb24uXG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuZmx1c2godGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gUXVldWVBY3Rpb247XG59KEFzeW5jQWN0aW9uXzEuQXN5bmNBY3Rpb24pKTtcbmV4cG9ydHMuUXVldWVBY3Rpb24gPSBRdWV1ZUFjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1ZXVlQWN0aW9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3NjaGVkdWxlci9RdWV1ZUFjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEFzeW5jU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuL0FzeW5jU2NoZWR1bGVyJyk7XG52YXIgUXVldWVTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhRdWV1ZVNjaGVkdWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBRdWV1ZVNjaGVkdWxlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBRdWV1ZVNjaGVkdWxlcjtcbn0oQXN5bmNTY2hlZHVsZXJfMS5Bc3luY1NjaGVkdWxlcikpO1xuZXhwb3J0cy5RdWV1ZVNjaGVkdWxlciA9IFF1ZXVlU2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVldWVTY2hlZHVsZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvc2NoZWR1bGVyL1F1ZXVlU2NoZWR1bGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFF1ZXVlQWN0aW9uXzEgPSByZXF1aXJlKCcuL1F1ZXVlQWN0aW9uJyk7XG52YXIgUXVldWVTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4vUXVldWVTY2hlZHVsZXInKTtcbi8qKlxuICpcbiAqIFF1ZXVlIFNjaGVkdWxlclxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5QdXQgZXZlcnkgbmV4dCB0YXNrIG9uIGEgcXVldWUsIGluc3RlYWQgb2YgZXhlY3V0aW5nIGl0IGltbWVkaWF0ZWx5PC9zcGFuPlxuICpcbiAqIGBxdWV1ZWAgc2NoZWR1bGVyLCB3aGVuIHVzZWQgd2l0aCBkZWxheSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgYXN5bmN9IHNjaGVkdWxlci5cbiAqXG4gKiBXaGVuIHVzZWQgd2l0aG91dCBkZWxheSwgaXQgc2NoZWR1bGVzIGdpdmVuIHRhc2sgc3luY2hyb25vdXNseSAtIGV4ZWN1dGVzIGl0IHJpZ2h0IHdoZW5cbiAqIGl0IGlzIHNjaGVkdWxlZC4gSG93ZXZlciB3aGVuIGNhbGxlZCByZWN1cnNpdmVseSwgdGhhdCBpcyB3aGVuIGluc2lkZSB0aGUgc2NoZWR1bGVkIHRhc2ssXG4gKiBhbm90aGVyIHRhc2sgaXMgc2NoZWR1bGVkIHdpdGggcXVldWUgc2NoZWR1bGVyLCBpbnN0ZWFkIG9mIGV4ZWN1dGluZyBpbW1lZGlhdGVseSBhcyB3ZWxsLFxuICogdGhhdCB0YXNrIHdpbGwgYmUgcHV0IG9uIGEgcXVldWUgYW5kIHdhaXQgZm9yIGN1cnJlbnQgb25lIHRvIGZpbmlzaC5cbiAqXG4gKiBUaGlzIG1lYW5zIHRoYXQgd2hlbiB5b3UgZXhlY3V0ZSB0YXNrIHdpdGggYHF1ZXVlYCBzY2hlZHVsZXIsIHlvdSBhcmUgc3VyZSBpdCB3aWxsIGVuZFxuICogYmVmb3JlIGFueSBvdGhlciB0YXNrIHNjaGVkdWxlZCB3aXRoIHRoYXQgc2NoZWR1bGVyIHdpbGwgc3RhcnQuXG4gKlxuICogQGV4YW1wbGVzIDxjYXB0aW9uPlNjaGVkdWxlIHJlY3Vyc2l2ZWx5IGZpcnN0LCB0aGVuIGRvIHNvbWV0aGluZzwvY2FwdGlvbj5cbiAqXG4gKiBSeC5TY2hlZHVsZXIucXVldWUuc2NoZWR1bGUoKCkgPT4ge1xuICogICBSeC5TY2hlZHVsZXIucXVldWUuc2NoZWR1bGUoKCkgPT4gY29uc29sZS5sb2coJ3NlY29uZCcpKTsgLy8gd2lsbCBub3QgaGFwcGVuIG5vdywgYnV0IHdpbGwgYmUgcHV0IG9uIGEgcXVldWVcbiAqXG4gKiAgIGNvbnNvbGUubG9nKCdmaXJzdCcpO1xuICogfSk7XG4gKlxuICogLy8gTG9nczpcbiAqIC8vIFwiZmlyc3RcIlxuICogLy8gXCJzZWNvbmRcIlxuICpcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5SZXNjaGVkdWxlIGl0c2VsZiByZWN1cnNpdmVseTwvY2FwdGlvbj5cbiAqXG4gKiBSeC5TY2hlZHVsZXIucXVldWUuc2NoZWR1bGUoZnVuY3Rpb24oc3RhdGUpIHtcbiAqICAgaWYgKHN0YXRlICE9PSAwKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2JlZm9yZScsIHN0YXRlKTtcbiAqICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlIC0gMSk7IC8vIGB0aGlzYCByZWZlcmVuY2VzIGN1cnJlbnRseSBleGVjdXRpbmcgQWN0aW9uLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggd2UgcmVzY2hlZHVsZSB3aXRoIG5ldyBzdGF0ZVxuICogICAgIGNvbnNvbGUubG9nKCdhZnRlcicsIHN0YXRlKTtcbiAqICAgfVxuICogfSwgMCwgMyk7XG4gKlxuICogLy8gSW4gc2NoZWR1bGVyIHRoYXQgcnVucyByZWN1cnNpdmVseSwgeW91IHdvdWxkIGV4cGVjdDpcbiAqIC8vIFwiYmVmb3JlXCIsIDNcbiAqIC8vIFwiYmVmb3JlXCIsIDJcbiAqIC8vIFwiYmVmb3JlXCIsIDFcbiAqIC8vIFwiYWZ0ZXJcIiwgMVxuICogLy8gXCJhZnRlclwiLCAyXG4gKiAvLyBcImFmdGVyXCIsIDNcbiAqXG4gKiAvLyBCdXQgd2l0aCBxdWV1ZSBpdCBsb2dzOlxuICogLy8gXCJiZWZvcmVcIiwgM1xuICogLy8gXCJhZnRlclwiLCAzXG4gKiAvLyBcImJlZm9yZVwiLCAyXG4gKiAvLyBcImFmdGVyXCIsIDJcbiAqIC8vIFwiYmVmb3JlXCIsIDFcbiAqIC8vIFwiYWZ0ZXJcIiwgMVxuICpcbiAqXG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIHF1ZXVlXG4gKiBAb3duZXIgU2NoZWR1bGVyXG4gKi9cbmV4cG9ydHMucXVldWUgPSBuZXcgUXVldWVTY2hlZHVsZXJfMS5RdWV1ZVNjaGVkdWxlcihRdWV1ZUFjdGlvbl8xLlF1ZXVlQWN0aW9uKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXVlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3NjaGVkdWxlci9xdWV1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBGYXN0TWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGYXN0TWFwKCkge1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHt9O1xuICAgIH1cbiAgICBGYXN0TWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRoaXMudmFsdWVzW2tleV0gPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEZhc3RNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBGYXN0TWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1trZXldO1xuICAgIH07XG4gICAgRmFzdE1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYiwgdGhpc0FyZykge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB2YWx1ZXNba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNiLmNhbGwodGhpc0FyZywgdmFsdWVzW2tleV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZhc3RNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHt9O1xuICAgIH07XG4gICAgcmV0dXJuIEZhc3RNYXA7XG59KCkpO1xuZXhwb3J0cy5GYXN0TWFwID0gRmFzdE1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZhc3RNYXAuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9GYXN0TWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4vcm9vdCcpO1xudmFyIE1hcFBvbHlmaWxsXzEgPSByZXF1aXJlKCcuL01hcFBvbHlmaWxsJyk7XG5leHBvcnRzLk1hcCA9IHJvb3RfMS5yb290Lk1hcCB8fCAoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFwUG9seWZpbGxfMS5NYXBQb2x5ZmlsbDsgfSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hcC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy91dGlsL01hcC5qc1xuLy8gbW9kdWxlIGlkID0gMjY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBNYXBQb2x5ZmlsbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwUG9seWZpbGwoKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLl9rZXlzID0gW107XG4gICAgfVxuICAgIE1hcFBvbHlmaWxsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIHJldHVybiBpID09PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMuX3ZhbHVlc1tpXTtcbiAgICB9O1xuICAgIE1hcFBvbHlmaWxsLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkpO1xuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1hcFBvbHlmaWxsLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHRoaXMuX2tleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLnNpemUtLTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBNYXBQb2x5ZmlsbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2tleXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfTtcbiAgICBNYXBQb2x5ZmlsbC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYiwgdGhpc0FyZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHRoaXMuX3ZhbHVlc1tpXSwgdGhpcy5fa2V5c1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNYXBQb2x5ZmlsbDtcbn0oKSk7XG5leHBvcnRzLk1hcFBvbHlmaWxsID0gTWFwUG9seWZpbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBQb2x5ZmlsbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy91dGlsL01hcFBvbHlmaWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4vcm9vdCcpO1xuZnVuY3Rpb24gbWluaW1hbFNldEltcGwoKSB7XG4gICAgLy8gVEhJUyBJUyBOT1QgYSBmdWxsIGltcGwgb2YgU2V0LCB0aGlzIGlzIGp1c3QgdGhlIG1pbmltdW1cbiAgICAvLyBiaXRzIG9mIGZ1bmN0aW9uYWxpdHkgd2UgbmVlZCBmb3IgdGhpcyBsaWJyYXJ5LlxuICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNaW5pbWFsU2V0KCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgTWluaW1hbFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTWluaW1hbFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1pbmltYWxTZXQucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTWluaW1hbFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE1pbmltYWxTZXQ7XG4gICAgfSgpKTtcbn1cbmV4cG9ydHMubWluaW1hbFNldEltcGwgPSBtaW5pbWFsU2V0SW1wbDtcbmV4cG9ydHMuU2V0ID0gcm9vdF8xLnJvb3QuU2V0IHx8IG1pbmltYWxTZXRJbXBsKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9TZXQuanNcbi8vIG1vZHVsZSBpZCA9IDI3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gZHVldGltZSBlbGFwc2VzLlxuICpcbiAqIEBzZWUge0BsaW5rIHRpbWVvdXR9XG4gKlxuICogQGNsYXNzIFRpbWVvdXRFcnJvclxuICovXG52YXIgVGltZW91dEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZW91dEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVvdXRFcnJvcigpIHtcbiAgICAgICAgdmFyIGVyciA9IF9zdXBlci5jYWxsKHRoaXMsICdUaW1lb3V0IGhhcyBvY2N1cnJlZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIFRpbWVvdXRFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGltZW91dEVycm9yLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvVGltZW91dEVycm9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gbm90KHByZWQsIHRoaXNBcmcpIHtcbiAgICBmdW5jdGlvbiBub3RQcmVkKCkge1xuICAgICAgICByZXR1cm4gIShub3RQcmVkLnByZWQuYXBwbHkobm90UHJlZC50aGlzQXJnLCBhcmd1bWVudHMpKTtcbiAgICB9XG4gICAgbm90UHJlZC5wcmVkID0gcHJlZDtcbiAgICBub3RQcmVkLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgIHJldHVybiBub3RQcmVkO1xufVxuZXhwb3J0cy5ub3QgPSBub3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9ub3QuanNcbi8vIG1vZHVsZSBpZCA9IDI3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXG4gICAgICAgIHZhciByZXN1bHQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2FwcC5jb21wb25lbnQuY3NzXCIpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvYXBwL2FwcC5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSAyNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/P3JlZi0tMy0xIS4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/c291cmNlTWFwIS4vam9icy1jb250YWluZXIuY29tcG9uZW50LnNjc3NcIik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9hcHAvZW5kLXVzZXIvaG9tZS9jb21wb25lbnRzL2pvYnMtY29udGFpbmVyL2pvYnMtY29udGFpbmVyLmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/P3JlZi0tMy0xIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/c291cmNlTWFwIS4vYWN0aW9uLWl0ZW0uY29tcG9uZW50LnNjc3NcIik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvYWN0aW9uLW1lbnUvYWN0aW9uLWl0ZW0vYWN0aW9uLWl0ZW0uY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDI3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXG4gICAgICAgIHZhciByZXN1bHQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz8/cmVmLS0zLTEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9zb3VyY2VNYXAhLi9hY3Rpb24tbWVudS5jb21wb25lbnQuc2Nzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9hY3Rpb24tbWVudS9hY3Rpb24tbWVudS5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMjc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzPz9yZWYtLTMtMSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3NvdXJjZU1hcCEuL2Jsb2cuY29tcG9uZW50LnNjc3NcIik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvdWkvYmxvZy9ibG9nLmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/P3JlZi0tMy0xIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/c291cmNlTWFwIS4vY2FyZC5jb21wb25lbnQuc2Nzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9jYXJkL2NhcmQuY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDI3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXG4gICAgICAgIHZhciByZXN1bHQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz8/cmVmLS0zLTEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9zb3VyY2VNYXAhLi9jYXJvdXNlbC1saXN0LmNvbXBvbmVudC5zY3NzXCIpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2Nhcm91c2VsLWxpc3QvY2Fyb3VzZWwtbGlzdC5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMjgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzPz9yZWYtLTMtMSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3NvdXJjZU1hcCEuL2Ryb3Bkb3duLmNvbXBvbmVudC5zY3NzXCIpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2Ryb3Bkb3duL2Ryb3Bkb3duLmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyODFcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/P3JlZi0tMy0xIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/c291cmNlTWFwIS4vZXhwYW5zaWJsZS1jYXJkLmNvbXBvbmVudC5zY3NzXCIpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL2V4cGFuc2libGUtY2FyZC9leHBhbnNpYmxlLWNhcmQuY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDI4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXG4gICAgICAgIHZhciByZXN1bHQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz8/cmVmLS0zLTEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9zb3VyY2VNYXAhLi9ncm91cC5jb21wb25lbnQuc2Nzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9ncm91cC9ncm91cC5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMjgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzPz9yZWYtLTMtMSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3NvdXJjZU1hcCEuL2pvYi5jb21wb25lbnQuc2Nzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9qb2Ivam9iLmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyODRcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIlxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/P3JlZi0tMy0xIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/c291cmNlTWFwIS4vb3ZlcmxheS5jb21wb25lbnQuc2Nzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS9vdmVybGF5L292ZXJsYXkuY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDI4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiXG4gICAgICAgIHZhciByZXN1bHQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz8/cmVmLS0zLTEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9zb3VyY2VNYXAhLi9wb3BvdmVyLmNvbXBvbmVudC5zY3NzXCIpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3VpL3BvcG92ZXIvcG9wb3Zlci5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMjg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzPz9yZWYtLTMtMSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3NvdXJjZU1hcCEuL3dhaXRlci5jb21wb25lbnQuc2Nzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC91aS93YWl0ZXIvd2FpdGVyLmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyODdcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBnbG9iYWwsIGRlZmluZSwgU3lzdGVtLCBSZWZsZWN0LCBQcm9taXNlICovXHJcbnZhciBfX2V4dGVuZHM7XHJcbnZhciBfX2Fzc2lnbjtcclxudmFyIF9fcmVzdDtcclxudmFyIF9fZGVjb3JhdGU7XHJcbnZhciBfX3BhcmFtO1xyXG52YXIgX19tZXRhZGF0YTtcclxudmFyIF9fYXdhaXRlcjtcclxudmFyIF9fZ2VuZXJhdG9yO1xyXG52YXIgX19leHBvcnRTdGFyO1xyXG52YXIgX192YWx1ZXM7XHJcbnZhciBfX3JlYWQ7XHJcbnZhciBfX3NwcmVhZDtcclxudmFyIF9fYXdhaXQ7XHJcbnZhciBfX2FzeW5jR2VuZXJhdG9yO1xyXG52YXIgX19hc3luY0RlbGVnYXRvcjtcclxudmFyIF9fYXN5bmNWYWx1ZXM7XHJcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgPyB0aGlzIDoge307XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoXCJ0c2xpYlwiLCBbXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAoZXhwb3J0cykgeyBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMpKSk7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKG1vZHVsZS5leHBvcnRzKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFeHBvcnRlcihleHBvcnRzLCBwcmV2aW91cykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQsIHYpIHsgcmV0dXJuIGV4cG9ydHNbaWRdID0gcHJldmlvdXMgPyBwcmV2aW91cyhpZCwgdikgOiB2OyB9O1xyXG4gICAgfVxyXG59KVxyXG4oZnVuY3Rpb24gKGV4cG9ydGVyKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVzdCA9IGZ1bmN0aW9uIChzLCBlKSB7XHJcbiAgICAgICAgdmFyIHQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2RlY29yYXRlID0gZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxuICAgIH07XHJcblxyXG4gICAgX19wYXJhbSA9IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXRlciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2V4cG9ydFN0YXIgPSBmdW5jdGlvbiAobSwgZXhwb3J0cykge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH07XHJcblxyXG4gICAgX192YWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICAgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVhZCA9IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgIH1cclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0RlbGVnYXRvciA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIGksIHA7XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKG9bbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH07IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY1ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdO1xyXG4gICAgICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRlcihcIl9fZXh0ZW5kc1wiLCBfX2V4dGVuZHMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2Fzc2lnblwiLCBfX2Fzc2lnbik7XHJcbiAgICBleHBvcnRlcihcIl9fcmVzdFwiLCBfX3Jlc3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2RlY29yYXRlXCIsIF9fZGVjb3JhdGUpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3BhcmFtXCIsIF9fcGFyYW0pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX21ldGFkYXRhXCIsIF9fbWV0YWRhdGEpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0ZXJcIiwgX19hd2FpdGVyKTtcclxuICAgIGV4cG9ydGVyKFwiX19nZW5lcmF0b3JcIiwgX19nZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2V4cG9ydFN0YXJcIiwgX19leHBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX192YWx1ZXNcIiwgX192YWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3JlYWRcIiwgX19yZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRcIiwgX19zcHJlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0XCIsIF9fYXdhaXQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jR2VuZXJhdG9yXCIsIF9fYXN5bmNHZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jRGVsZWdhdG9yXCIsIF9fYXN5bmNEZWxlZ2F0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jVmFsdWVzXCIsIF9fYXN5bmNWYWx1ZXMpO1xyXG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdHNsaWIvdHNsaWIuanNcbi8vIG1vZHVsZSBpZCA9IDI4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIEludmFsaWRTdGF0ZUVycm9yLCBOZXR3b3JrRXJyb3IsIFByb2dyZXNzRXZlbnQsIFNlY3VyaXR5RXJyb3IsIFN5bnRheEVycm9yLCBYTUxIdHRwUmVxdWVzdCwgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCwgWE1MSHR0cFJlcXVlc3RVcGxvYWQsIGh0dHAsIGh0dHBzLCBvcywgdXJsLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0KCkge1xuICAgICAgdGhpcy5vbmxvYWRzdGFydCA9IG51bGw7XG4gICAgICB0aGlzLm9ucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgdGhpcy5vbmFib3J0ID0gbnVsbDtcbiAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICB0aGlzLm9ubG9hZCA9IG51bGw7XG4gICAgICB0aGlzLm9udGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLm9ubG9hZGVuZCA9IG51bGw7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB9XG5cbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbmxvYWRzdGFydCA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbnByb2dyZXNzID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlLm9uYWJvcnQgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldC5wcm90b3R5cGUub25lcnJvciA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbmxvYWQgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldC5wcm90b3R5cGUub250aW1lb3V0ID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlLm9ubG9hZGVuZCA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGJhc2U7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIChiYXNlID0gdGhpcy5fbGlzdGVuZXJzKVtldmVudFR5cGVdIHx8IChiYXNlW2V2ZW50VHlwZV0gPSBbXSk7XG4gICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgaW5kZXg7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSkge1xuICAgICAgICBpbmRleCA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgZXZlbnRUeXBlLCBqLCBsZW4sIGxpc3RlbmVyLCBsaXN0ZW5lcnM7XG4gICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZXZlbnQudGFyZ2V0ID0gdGhpcztcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50LnR5cGU7XG4gICAgICBpZiAobGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0pIHtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbal07XG4gICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsaXN0ZW5lciA9IHRoaXNbXCJvblwiICsgZXZlbnRUeXBlXSkge1xuICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0O1xuXG4gIH0pKCk7XG5cbiAgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcblxuICBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5cbiAgb3MgPSByZXF1aXJlKCdvcycpO1xuXG4gIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG4gIFhNTEh0dHBSZXF1ZXN0ID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MSHR0cFJlcXVlc3QsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgWE1MSHR0cFJlcXVlc3QuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9hbm9ueW1vdXMgPSBvcHRpb25zICYmIG9wdGlvbnMuYW5vbjtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFhNTEh0dHBSZXF1ZXN0LlVOU0VOVDtcbiAgICAgIHRoaXMucmVzcG9uc2UgPSBudWxsO1xuICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSAnJztcbiAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gJyc7XG4gICAgICB0aGlzLnJlc3BvbnNlVVJMID0gJyc7XG4gICAgICB0aGlzLnN0YXR1cyA9IDA7XG4gICAgICB0aGlzLnN0YXR1c1RleHQgPSAnJztcbiAgICAgIHRoaXMudGltZW91dCA9IDA7XG4gICAgICB0aGlzLnVwbG9hZCA9IG5ldyBYTUxIdHRwUmVxdWVzdFVwbG9hZCh0aGlzKTtcbiAgICAgIHRoaXMuX21ldGhvZCA9IG51bGw7XG4gICAgICB0aGlzLl91cmwgPSBudWxsO1xuICAgICAgdGhpcy5fc3luYyA9IGZhbHNlO1xuICAgICAgdGhpcy5faGVhZGVycyA9IG51bGw7XG4gICAgICB0aGlzLl9sb3dlcmVkSGVhZGVycyA9IG51bGw7XG4gICAgICB0aGlzLl9taW1lT3ZlcnJpZGUgPSBudWxsO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgICB0aGlzLl9yZXNwb25zZSA9IG51bGw7XG4gICAgICB0aGlzLl9yZXNwb25zZVBhcnRzID0gbnVsbDtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlSGVhZGVycyA9IG51bGw7XG4gICAgICB0aGlzLl9hYm9ydGluZyA9IG51bGw7XG4gICAgICB0aGlzLl9lcnJvciA9IG51bGw7XG4gICAgICB0aGlzLl9sb2FkZWRCeXRlcyA9IDA7XG4gICAgICB0aGlzLl90b3RhbEJ5dGVzID0gMDtcbiAgICAgIHRoaXMuX2xlbmd0aENvbXB1dGFibGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5yZWFkeVN0YXRlID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5yZXNwb25zZSA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUucmVzcG9uc2VUZXh0ID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5yZXNwb25zZVR5cGUgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnN0YXR1cyA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUudGltZW91dCA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUudXBsb2FkID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIGFzeW5jLCB1c2VyLCBwYXNzd29yZCkge1xuICAgICAgdmFyIHhoclVybDtcbiAgICAgIG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKG1ldGhvZCBpbiB0aGlzLl9yZXN0cmljdGVkTWV0aG9kcykge1xuICAgICAgICB0aHJvdyBuZXcgU2VjdXJpdHlFcnJvcihcIkhUVFAgbWV0aG9kIFwiICsgbWV0aG9kICsgXCIgaXMgbm90IGFsbG93ZWQgaW4gWEhSXCIpO1xuICAgICAgfVxuICAgICAgeGhyVXJsID0gdGhpcy5fcGFyc2VVcmwodXJsKTtcbiAgICAgIGlmIChhc3luYyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGFzeW5jID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgIGNhc2UgWE1MSHR0cFJlcXVlc3QuVU5TRU5UOlxuICAgICAgICBjYXNlIFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRDpcbiAgICAgICAgY2FzZSBYTUxIdHRwUmVxdWVzdC5ET05FOlxuICAgICAgICAgIG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRDpcbiAgICAgICAgY2FzZSBYTUxIdHRwUmVxdWVzdC5MT0FESU5HOlxuICAgICAgICAgIG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9tZXRob2QgPSBtZXRob2Q7XG4gICAgICB0aGlzLl91cmwgPSB4aHJVcmw7XG4gICAgICB0aGlzLl9zeW5jID0gIWFzeW5jO1xuICAgICAgdGhpcy5faGVhZGVycyA9IHt9O1xuICAgICAgdGhpcy5fbG93ZXJlZEhlYWRlcnMgPSB7fTtcbiAgICAgIHRoaXMuX21pbWVPdmVycmlkZSA9IG51bGw7XG4gICAgICB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlID0gbnVsbDtcbiAgICAgIHRoaXMuc3RhdHVzID0gMDtcbiAgICAgIHRoaXMuc3RhdHVzVGV4dCA9ICcnO1xuICAgICAgdGhpcy5fcmVzcG9uc2VQYXJ0cyA9IFtdO1xuICAgICAgdGhpcy5fcmVzcG9uc2VIZWFkZXJzID0gbnVsbDtcbiAgICAgIHRoaXMuX2xvYWRlZEJ5dGVzID0gMDtcbiAgICAgIHRoaXMuX3RvdGFsQnl0ZXMgPSAwO1xuICAgICAgdGhpcy5fbGVuZ3RoQ29tcHV0YWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnNldFJlcXVlc3RIZWFkZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGxvd2VyZWROYW1lO1xuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuT1BFTkVEKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3RhdGVFcnJvcihcIlhIUiByZWFkeVN0YXRlIG11c3QgYmUgT1BFTkVEXCIpO1xuICAgICAgfVxuICAgICAgbG93ZXJlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodGhpcy5fcmVzdHJpY3RlZEhlYWRlcnNbbG93ZXJlZE5hbWVdIHx8IC9ec2VjXFwtLy50ZXN0KGxvd2VyZWROYW1lKSB8fCAvXnByb3h5LS8udGVzdChsb3dlcmVkTmFtZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiUmVmdXNlZCB0byBzZXQgdW5zYWZlIGhlYWRlciBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpO1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgaWYgKGxvd2VyZWROYW1lIGluIHRoaXMuX2xvd2VyZWRIZWFkZXJzKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLl9sb3dlcmVkSGVhZGVyc1tsb3dlcmVkTmFtZV07XG4gICAgICAgIHRoaXMuX2hlYWRlcnNbbmFtZV0gPSB0aGlzLl9oZWFkZXJzW25hbWVdICsgJywgJyArIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbG93ZXJlZEhlYWRlcnNbbG93ZXJlZE5hbWVdID0gbmFtZTtcbiAgICAgICAgdGhpcy5faGVhZGVyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5PUEVORUQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdGF0ZUVycm9yKFwiWEhSIHJlYWR5U3RhdGUgbXVzdCBiZSBPUEVORURcIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcmVxdWVzdCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0YXRlRXJyb3IoXCJzZW5kKCkgYWxyZWFkeSBjYWxsZWRcIik7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHRoaXMuX3VybC5wcm90b2NvbCkge1xuICAgICAgICBjYXNlICdmaWxlOic6XG4gICAgICAgICAgdGhpcy5fc2VuZEZpbGUoZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2h0dHA6JzpcbiAgICAgICAgY2FzZSAnaHR0cHM6JzpcbiAgICAgICAgICB0aGlzLl9zZW5kSHR0cChkYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKFwiVW5zdXBwb3J0ZWQgcHJvdG9jb2wgXCIgKyB0aGlzLl91cmwucHJvdG9jb2wpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX3JlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgdGhpcy5fc2V0RXJyb3IoKTtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2Fib3J0Jyk7XG4gICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdsb2FkZW5kJyk7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgbG93ZXJlZE5hbWU7XG4gICAgICBpZiAoIXRoaXMuX3Jlc3BvbnNlSGVhZGVycykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGxvd2VyZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyZWROYW1lIGluIHRoaXMuX3Jlc3BvbnNlSGVhZGVycykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2VIZWFkZXJzW2xvd2VyZWROYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZXMsIG5hbWUsIHZhbHVlO1xuICAgICAgaWYgKCF0aGlzLl9yZXNwb25zZUhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgbGluZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWYsIHJlc3VsdHM7XG4gICAgICAgIHJlZiA9IHRoaXMuX3Jlc3BvbnNlSGVhZGVycztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgdmFsdWUgPSByZWZbbmFtZV07XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG5hbWUgKyBcIjogXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXHJcXG5cIik7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5vdmVycmlkZU1pbWVUeXBlID0gZnVuY3Rpb24obmV3TWltZVR5cGUpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkxPQURJTkcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3RhdGVFcnJvcihcIm92ZXJyaWRlTWltZVR5cGUoKSBub3QgYWxsb3dlZCBpbiBMT0FESU5HIG9yIERPTkVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLl9taW1lT3ZlcnJpZGUgPSBuZXdNaW1lVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLm5vZGVqc1NldCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBiYXNlVXJsLCBwYXJzZWRVcmw7XG4gICAgICBpZiAoJ2h0dHBBZ2VudCcgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLm5vZGVqc0h0dHBBZ2VudCA9IG9wdGlvbnMuaHR0cEFnZW50O1xuICAgICAgfVxuICAgICAgaWYgKCdodHRwc0FnZW50JyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubm9kZWpzSHR0cHNBZ2VudCA9IG9wdGlvbnMuaHR0cHNBZ2VudDtcbiAgICAgIH1cbiAgICAgIGlmICgnYmFzZVVybCcgaW4gb3B0aW9ucykge1xuICAgICAgICBiYXNlVXJsID0gb3B0aW9ucy5iYXNlVXJsO1xuICAgICAgICBpZiAoYmFzZVVybCAhPT0gbnVsbCkge1xuICAgICAgICAgIHBhcnNlZFVybCA9IHVybC5wYXJzZShiYXNlVXJsLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKCFwYXJzZWRVcmwucHJvdG9jb2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcImJhc2VVcmwgbXVzdCBiZSBhbiBhYnNvbHV0ZSBVUkxcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZWpzQmFzZVVybCA9IGJhc2VVcmw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5ub2RlanNTZXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUubm9kZWpzU2V0KG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLlVOU0VOVCA9IDA7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5VTlNFTlQgPSAwO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLk9QRU5FRCA9IDE7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5PUEVORUQgPSAxO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLkhFQURFUlNfUkVDRUlWRUQgPSAyO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRCA9IDI7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuTE9BRElORyA9IDM7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5MT0FESU5HID0gMztcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5ET05FID0gNDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LkRPTkUgPSA0O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLm5vZGVqc0h0dHBBZ2VudCA9IGh0dHAuZ2xvYmFsQWdlbnQ7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUubm9kZWpzSHR0cHNBZ2VudCA9IGh0dHBzLmdsb2JhbEFnZW50O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLm5vZGVqc0Jhc2VVcmwgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9yZXN0cmljdGVkTWV0aG9kcyA9IHtcbiAgICAgIENPTk5FQ1Q6IHRydWUsXG4gICAgICBUUkFDRTogdHJ1ZSxcbiAgICAgIFRSQUNLOiB0cnVlXG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fcmVzdHJpY3RlZEhlYWRlcnMgPSB7XG4gICAgICAnYWNjZXB0LWNoYXJzZXQnOiB0cnVlLFxuICAgICAgJ2FjY2VwdC1lbmNvZGluZyc6IHRydWUsXG4gICAgICAnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1oZWFkZXJzJzogdHJ1ZSxcbiAgICAgICdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZCc6IHRydWUsXG4gICAgICBjb25uZWN0aW9uOiB0cnVlLFxuICAgICAgJ2NvbnRlbnQtbGVuZ3RoJzogdHJ1ZSxcbiAgICAgIGNvb2tpZTogdHJ1ZSxcbiAgICAgIGNvb2tpZTI6IHRydWUsXG4gICAgICBkYXRlOiB0cnVlLFxuICAgICAgZG50OiB0cnVlLFxuICAgICAgZXhwZWN0OiB0cnVlLFxuICAgICAgaG9zdDogdHJ1ZSxcbiAgICAgICdrZWVwLWFsaXZlJzogdHJ1ZSxcbiAgICAgIG9yaWdpbjogdHJ1ZSxcbiAgICAgIHJlZmVyZXI6IHRydWUsXG4gICAgICB0ZTogdHJ1ZSxcbiAgICAgIHRyYWlsZXI6IHRydWUsXG4gICAgICAndHJhbnNmZXItZW5jb2RpbmcnOiB0cnVlLFxuICAgICAgdXBncmFkZTogdHJ1ZSxcbiAgICAgICd1c2VyLWFnZW50JzogdHJ1ZSxcbiAgICAgIHZpYTogdHJ1ZVxuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3ByaXZhdGVIZWFkZXJzID0ge1xuICAgICAgJ3NldC1jb29raWUnOiB0cnVlLFxuICAgICAgJ3NldC1jb29raWUyJzogdHJ1ZVxuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3VzZXJBZ2VudCA9IChcIk1vemlsbGEvNS4wIChcIiArIChvcy50eXBlKCkpICsgXCIgXCIgKyAob3MuYXJjaCgpKSArIFwiKSBcIikgKyAoXCJub2RlLmpzL1wiICsgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICsgXCIgdjgvXCIgKyBwcm9jZXNzLnZlcnNpb25zLnY4KTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fc2V0UmVhZHlTdGF0ZSA9IGZ1bmN0aW9uKG5ld1JlYWR5U3RhdGUpIHtcbiAgICAgIHZhciBldmVudDtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IG5ld1JlYWR5U3RhdGU7XG4gICAgICBldmVudCA9IG5ldyBQcm9ncmVzc0V2ZW50KCdyZWFkeXN0YXRlY2hhbmdlJyk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9zZW5kRmlsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX3VybC5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoJ1RoZSBmaWxlIHByb3RvY29sIG9ubHkgc3VwcG9ydHMgR0VUJyk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm90b2NvbCBmaWxlOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fc2VuZEh0dHAgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBpZiAodGhpcy5fc3luYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW5jaHJvbm91cyBYSFIgcHJvY2Vzc2luZyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAoKGRhdGEgIT0gbnVsbCkgJiYgKHRoaXMuX21ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5fbWV0aG9kID09PSAnSEVBRCcpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkRpc2NhcmRpbmcgZW50aXR5IGJvZHkgZm9yIFwiICsgdGhpcy5fbWV0aG9kICsgXCIgcmVxdWVzdHNcIik7XG4gICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSB8fCAoZGF0YSA9ICcnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBsb2FkLl9zZXREYXRhKGRhdGEpO1xuICAgICAgdGhpcy5fZmluYWxpemVIZWFkZXJzKCk7XG4gICAgICB0aGlzLl9zZW5kSHh4cFJlcXVlc3QoKTtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fc2VuZEh4eHBSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWdlbnQsIGh4eHAsIHJlcXVlc3Q7XG4gICAgICBpZiAodGhpcy5fdXJsLnByb3RvY29sID09PSAnaHR0cDonKSB7XG4gICAgICAgIGh4eHAgPSBodHRwO1xuICAgICAgICBhZ2VudCA9IHRoaXMubm9kZWpzSHR0cEFnZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHh4cCA9IGh0dHBzO1xuICAgICAgICBhZ2VudCA9IHRoaXMubm9kZWpzSHR0cHNBZ2VudDtcbiAgICAgIH1cbiAgICAgIHJlcXVlc3QgPSBoeHhwLnJlcXVlc3Qoe1xuICAgICAgICBob3N0bmFtZTogdGhpcy5fdXJsLmhvc3RuYW1lLFxuICAgICAgICBwb3J0OiB0aGlzLl91cmwucG9ydCxcbiAgICAgICAgcGF0aDogdGhpcy5fdXJsLnBhdGgsXG4gICAgICAgIGF1dGg6IHRoaXMuX3VybC5hdXRoLFxuICAgICAgICBtZXRob2Q6IHRoaXMuX21ldGhvZCxcbiAgICAgICAgaGVhZGVyczogdGhpcy5faGVhZGVycyxcbiAgICAgICAgYWdlbnQ6IGFnZW50XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICByZXF1ZXN0LnNldFRpbWVvdXQodGhpcy50aW1lb3V0LCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX29uSHR0cFRpbWVvdXQocmVxdWVzdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgfVxuICAgICAgcmVxdWVzdC5vbigncmVzcG9uc2UnLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9vbkh0dHBSZXNwb25zZShyZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICByZXF1ZXN0Lm9uKCdlcnJvcicsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX29uSHR0cFJlcXVlc3RFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICB0aGlzLnVwbG9hZC5fc3RhcnRVcGxvYWQocmVxdWVzdCk7XG4gICAgICBpZiAodGhpcy5fcmVxdWVzdCA9PT0gcmVxdWVzdCkge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdsb2Fkc3RhcnQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fZmluYWxpemVIZWFkZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9oZWFkZXJzWydDb25uZWN0aW9uJ10gPSAna2VlcC1hbGl2ZSc7XG4gICAgICB0aGlzLl9oZWFkZXJzWydIb3N0J10gPSB0aGlzLl91cmwuaG9zdDtcbiAgICAgIGlmICh0aGlzLl9hbm9ueW1vdXMpIHtcbiAgICAgICAgdGhpcy5faGVhZGVyc1snUmVmZXJlciddID0gJ2Fib3V0OmJsYW5rJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hlYWRlcnNbJ1VzZXItQWdlbnQnXSA9IHRoaXMuX3VzZXJBZ2VudDtcbiAgICAgIHRoaXMudXBsb2FkLl9maW5hbGl6ZUhlYWRlcnModGhpcy5faGVhZGVycywgdGhpcy5fbG93ZXJlZEhlYWRlcnMpO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9vbkh0dHBSZXNwb25zZSA9IGZ1bmN0aW9uKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgICB2YXIgbGVuZ3RoU3RyaW5nO1xuICAgICAgaWYgKHRoaXMuX3JlcXVlc3QgIT09IHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChyZXNwb25zZS5zdGF0dXNDb2RlKSB7XG4gICAgICAgIGNhc2UgMzAxOlxuICAgICAgICBjYXNlIDMwMjpcbiAgICAgICAgY2FzZSAzMDM6XG4gICAgICAgIGNhc2UgMzA3OlxuICAgICAgICBjYXNlIDMwODpcbiAgICAgICAgICB0aGlzLl91cmwgPSB0aGlzLl9wYXJzZVVybChyZXNwb25zZS5oZWFkZXJzWydsb2NhdGlvbiddKTtcbiAgICAgICAgICB0aGlzLl9tZXRob2QgPSAnR0VUJztcbiAgICAgICAgICBpZiAoJ2NvbnRlbnQtdHlwZScgaW4gdGhpcy5fbG93ZXJlZEhlYWRlcnMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkZXJzW3RoaXMuX2xvd2VyZWRIZWFkZXJzWydjb250ZW50LXR5cGUnXV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbG93ZXJlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ0NvbnRlbnQtVHlwZScgaW4gdGhpcy5faGVhZGVycykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyc1snQ29udGVudC1MZW5ndGgnXTtcbiAgICAgICAgICB0aGlzLnVwbG9hZC5fcmVzZXQoKTtcbiAgICAgICAgICB0aGlzLl9maW5hbGl6ZUhlYWRlcnMoKTtcbiAgICAgICAgICB0aGlzLl9zZW5kSHh4cFJlcXVlc3QoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgdGhpcy5fcmVzcG9uc2Uub24oJ2RhdGEnLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX29uSHR0cFJlc3BvbnNlRGF0YShyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICB0aGlzLl9yZXNwb25zZS5vbignZW5kJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX29uSHR0cFJlc3BvbnNlRW5kKHJlc3BvbnNlKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlLm9uKCdjbG9zZScsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9vbkh0dHBSZXNwb25zZUNsb3NlKHJlc3BvbnNlKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIHRoaXMucmVzcG9uc2VVUkwgPSB0aGlzLl91cmwuaHJlZi5zcGxpdCgnIycpWzBdO1xuICAgICAgdGhpcy5zdGF0dXMgPSB0aGlzLl9yZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gaHR0cC5TVEFUVVNfQ09ERVNbdGhpcy5zdGF0dXNdO1xuICAgICAgdGhpcy5fcGFyc2VSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICAgICAgaWYgKGxlbmd0aFN0cmluZyA9IHRoaXMuX3Jlc3BvbnNlSGVhZGVyc1snY29udGVudC1sZW5ndGgnXSkge1xuICAgICAgICB0aGlzLl90b3RhbEJ5dGVzID0gcGFyc2VJbnQobGVuZ3RoU3RyaW5nKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoQ29tcHV0YWJsZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9sZW5ndGhDb21wdXRhYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc2V0UmVhZHlTdGF0ZShYTUxIdHRwUmVxdWVzdC5IRUFERVJTX1JFQ0VJVkVEKTtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9vbkh0dHBSZXNwb25zZURhdGEgPSBmdW5jdGlvbihyZXNwb25zZSwgZGF0YSkge1xuICAgICAgaWYgKHRoaXMuX3Jlc3BvbnNlICE9PSByZXNwb25zZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXNwb25zZVBhcnRzLnB1c2goZGF0YSk7XG4gICAgICB0aGlzLl9sb2FkZWRCeXRlcyArPSBkYXRhLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0LkxPQURJTkcpIHtcbiAgICAgICAgdGhpcy5fc2V0UmVhZHlTdGF0ZShYTUxIdHRwUmVxdWVzdC5MT0FESU5HKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdwcm9ncmVzcycpO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX29uSHR0cFJlc3BvbnNlRW5kID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIGlmICh0aGlzLl9yZXNwb25zZSAhPT0gcmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGFyc2VSZXNwb25zZSgpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgICB0aGlzLl9yZXNwb25zZSA9IG51bGw7XG4gICAgICB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0LkRPTkUpO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnbG9hZCcpO1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2xvYWRlbmQnKTtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9vbkh0dHBSZXNwb25zZUNsb3NlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHZhciByZXF1ZXN0O1xuICAgICAgaWYgKHRoaXMuX3Jlc3BvbnNlICE9PSByZXNwb25zZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXF1ZXN0ID0gdGhpcy5fcmVxdWVzdDtcbiAgICAgIHRoaXMuX3NldEVycm9yKCk7XG4gICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0LkRPTkUpO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnZXJyb3InKTtcbiAgICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdsb2FkZW5kJyk7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fb25IdHRwVGltZW91dCA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9PSByZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldEVycm9yKCk7XG4gICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0LkRPTkUpO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygndGltZW91dCcpO1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2xvYWRlbmQnKTtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9vbkh0dHBSZXF1ZXN0RXJyb3IgPSBmdW5jdGlvbihyZXF1ZXN0LCBlcnJvcikge1xuICAgICAgaWYgKHRoaXMuX3JlcXVlc3QgIT09IHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0RXJyb3IoKTtcbiAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgIHRoaXMuX3NldFJlYWR5U3RhdGUoWE1MSHR0cFJlcXVlc3QuRE9ORSk7XG4gICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdlcnJvcicpO1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2xvYWRlbmQnKTtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9kaXNwYXRjaFByb2dyZXNzID0gZnVuY3Rpb24oZXZlbnRUeXBlKSB7XG4gICAgICB2YXIgZXZlbnQ7XG4gICAgICBldmVudCA9IG5ldyBQcm9ncmVzc0V2ZW50KGV2ZW50VHlwZSk7XG4gICAgICBldmVudC5sZW5ndGhDb21wdXRhYmxlID0gdGhpcy5fbGVuZ3RoQ29tcHV0YWJsZTtcbiAgICAgIGV2ZW50LmxvYWRlZCA9IHRoaXMuX2xvYWRlZEJ5dGVzO1xuICAgICAgZXZlbnQudG90YWwgPSB0aGlzLl90b3RhbEJ5dGVzO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fc2V0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgICAgdGhpcy5fcmVzcG9uc2UgPSBudWxsO1xuICAgICAgdGhpcy5fcmVzcG9uc2VIZWFkZXJzID0gbnVsbDtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlUGFydHMgPSBudWxsO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9wYXJzZVVybCA9IGZ1bmN0aW9uKHVybFN0cmluZykge1xuICAgICAgdmFyIGFic29sdXRlVXJsU3RyaW5nLCBpbmRleCwgcGFzc3dvcmQsIHVzZXIsIHhoclVybDtcbiAgICAgIGlmICh0aGlzLm5vZGVqc0Jhc2VVcmwgPT09IG51bGwpIHtcbiAgICAgICAgYWJzb2x1dGVVcmxTdHJpbmcgPSB1cmxTdHJpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhYnNvbHV0ZVVybFN0cmluZyA9IHVybC5yZXNvbHZlKHRoaXMubm9kZWpzQmFzZVVybCwgdXJsU3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHhoclVybCA9IHVybC5wYXJzZShhYnNvbHV0ZVVybFN0cmluZywgZmFsc2UsIHRydWUpO1xuICAgICAgeGhyVXJsLmhhc2ggPSBudWxsO1xuICAgICAgaWYgKHhoclVybC5hdXRoICYmICgodHlwZW9mIHVzZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdXNlciAhPT0gbnVsbCkgfHwgKHR5cGVvZiBwYXNzd29yZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwYXNzd29yZCAhPT0gbnVsbCkpKSB7XG4gICAgICAgIGluZGV4ID0geGhyVXJsLmF1dGguaW5kZXhPZignOicpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICB1c2VyID0geGhyVXJsLmF1dGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdXNlcikge1xuICAgICAgICAgICAgdXNlciA9IHhoclVybC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXBhc3N3b3JkKSB7XG4gICAgICAgICAgICBwYXNzd29yZCA9IHhoclVybC5zdWJzdHJpbmcoaW5kZXggKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1c2VyIHx8IHBhc3N3b3JkKSB7XG4gICAgICAgIHhoclVybC5hdXRoID0gdXNlciArIFwiOlwiICsgcGFzc3dvcmQ7XG4gICAgICB9XG4gICAgICByZXR1cm4geGhyVXJsO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3BhcnNlUmVzcG9uc2VIZWFkZXJzID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHZhciBsb3dlcmVkTmFtZSwgbmFtZSwgcmVmLCB2YWx1ZTtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlSGVhZGVycyA9IHt9O1xuICAgICAgcmVmID0gcmVzcG9uc2UuaGVhZGVycztcbiAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcbiAgICAgICAgdmFsdWUgPSByZWZbbmFtZV07XG4gICAgICAgIGxvd2VyZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZUhlYWRlcnNbbG93ZXJlZE5hbWVdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21pbWVPdmVycmlkZSAhPT0gbnVsbCAmJiBsb3dlcmVkTmFtZSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX21pbWVPdmVycmlkZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNwb25zZUhlYWRlcnNbbG93ZXJlZE5hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbWltZU92ZXJyaWRlICE9PSBudWxsICYmICEoJ2NvbnRlbnQtdHlwZScgaW4gdGhpcy5fcmVzcG9uc2VIZWFkZXJzKSkge1xuICAgICAgICB0aGlzLl9yZXNwb25zZUhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gdGhpcy5fbWltZU92ZXJyaWRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJyYXlCdWZmZXIsIGJ1ZmZlciwgaSwgaiwganNvbkVycm9yLCByZWYsIHZpZXc7XG4gICAgICBpZiAoQnVmZmVyLmNvbmNhdCkge1xuICAgICAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KHRoaXMuX3Jlc3BvbnNlUGFydHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyID0gdGhpcy5fY29uY2F0QnVmZmVycyh0aGlzLl9yZXNwb25zZVBhcnRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlc3BvbnNlUGFydHMgPSBudWxsO1xuICAgICAgc3dpdGNoICh0aGlzLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICB0aGlzLl9wYXJzZVRleHRSZXNwb25zZShidWZmZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IG51bGw7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBKU09OLnBhcnNlKGJ1ZmZlci50b1N0cmluZygndXRmLTgnKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgICAgICAgICBqc29uRXJyb3IgPSBlcnJvcjE7XG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2J1ZmZlcic6XG4gICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBudWxsO1xuICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBidWZmZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FycmF5YnVmZmVyJzpcbiAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IG51bGw7XG4gICAgICAgICAgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gYnVmZmVyLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICB2aWV3W2ldID0gYnVmZmVyW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gYXJyYXlCdWZmZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5fcGFyc2VUZXh0UmVzcG9uc2UoYnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fcGFyc2VUZXh0UmVzcG9uc2UgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIHZhciBlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBidWZmZXIudG9TdHJpbmcodGhpcy5fcGFyc2VSZXNwb25zZUVuY29kaW5nKCkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgICAgIGUgPSBlcnJvcjE7XG4gICAgICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gYnVmZmVyLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlVGV4dDtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fcGFyc2VSZXNwb25zZUVuY29kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29udGVudFR5cGUsIGVuY29kaW5nLCBtYXRjaDtcbiAgICAgIGVuY29kaW5nID0gbnVsbDtcbiAgICAgIGlmIChjb250ZW50VHlwZSA9IHRoaXMuX3Jlc3BvbnNlSGVhZGVyc1snY29udGVudC10eXBlJ10pIHtcbiAgICAgICAgaWYgKG1hdGNoID0gL1xcO1xccypjaGFyc2V0XFw9KC4qKSQvLmV4ZWMoY29udGVudFR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3V0Zi04JztcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9jb25jYXRCdWZmZXJzID0gZnVuY3Rpb24oYnVmZmVycykge1xuICAgICAgdmFyIGJ1ZmZlciwgaiwgaywgbGVuLCBsZW4xLCBsZW5ndGgsIHRhcmdldDtcbiAgICAgIGlmIChidWZmZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcbiAgICAgIH1cbiAgICAgIGlmIChidWZmZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYnVmZmVyc1swXTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGogPSAwLCBsZW4gPSBidWZmZXJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlcnNbal07XG4gICAgICAgIGxlbmd0aCArPSBidWZmZXIubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGFyZ2V0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIGZvciAoayA9IDAsIGxlbjEgPSBidWZmZXJzLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICBidWZmZXIgPSBidWZmZXJzW2tdO1xuICAgICAgICBidWZmZXIuY29weSh0YXJnZXQsIGxlbmd0aCk7XG4gICAgICAgIGxlbmd0aCArPSBidWZmZXIubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTEh0dHBSZXF1ZXN0O1xuXG4gIH0pKFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MSHR0cFJlcXVlc3Q7XG5cbiAgWE1MSHR0cFJlcXVlc3QuWE1MSHR0cFJlcXVlc3QgPSBYTUxIdHRwUmVxdWVzdDtcblxuICBTZWN1cml0eUVycm9yID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU2VjdXJpdHlFcnJvciwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBTZWN1cml0eUVycm9yKCkge1xuICAgICAgU2VjdXJpdHlFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU2VjdXJpdHlFcnJvcjtcblxuICB9KShFcnJvcik7XG5cbiAgWE1MSHR0cFJlcXVlc3QuU2VjdXJpdHlFcnJvciA9IFNlY3VyaXR5RXJyb3I7XG5cbiAgSW52YWxpZFN0YXRlRXJyb3IgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChJbnZhbGlkU3RhdGVFcnJvciwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBJbnZhbGlkU3RhdGVFcnJvcigpIHtcbiAgICAgIEludmFsaWRTdGF0ZUVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBJbnZhbGlkU3RhdGVFcnJvcjtcblxuICB9KShFcnJvcik7XG5cbiAgSW52YWxpZFN0YXRlRXJyb3IgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChJbnZhbGlkU3RhdGVFcnJvciwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBJbnZhbGlkU3RhdGVFcnJvcigpIHtcbiAgICAgIHJldHVybiBJbnZhbGlkU3RhdGVFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gSW52YWxpZFN0YXRlRXJyb3I7XG5cbiAgfSkoRXJyb3IpO1xuXG4gIFhNTEh0dHBSZXF1ZXN0LkludmFsaWRTdGF0ZUVycm9yID0gSW52YWxpZFN0YXRlRXJyb3I7XG5cbiAgTmV0d29ya0Vycm9yID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTmV0d29ya0Vycm9yLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIE5ldHdvcmtFcnJvcigpIHtcbiAgICAgIE5ldHdvcmtFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTmV0d29ya0Vycm9yO1xuXG4gIH0pKEVycm9yKTtcblxuICBYTUxIdHRwUmVxdWVzdC5TeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xuXG4gIFN5bnRheEVycm9yID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU3ludGF4RXJyb3IsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gU3ludGF4RXJyb3IoKSB7XG4gICAgICBTeW50YXhFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3ludGF4RXJyb3I7XG5cbiAgfSkoRXJyb3IpO1xuXG4gIFByb2dyZXNzRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUHJvZ3Jlc3NFdmVudCh0eXBlKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMubGVuZ3RoQ29tcHV0YWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5sb2FkZWQgPSAwO1xuICAgICAgdGhpcy50b3RhbCA9IDA7XG4gICAgfVxuXG4gICAgUHJvZ3Jlc3NFdmVudC5wcm90b3R5cGUuYnViYmxlcyA9IGZhbHNlO1xuXG4gICAgUHJvZ3Jlc3NFdmVudC5wcm90b3R5cGUuY2FuY2VsYWJsZSA9IGZhbHNlO1xuXG4gICAgUHJvZ3Jlc3NFdmVudC5wcm90b3R5cGUudGFyZ2V0ID0gbnVsbDtcblxuICAgIFByb2dyZXNzRXZlbnQucHJvdG90eXBlLmxvYWRlZCA9IG51bGw7XG5cbiAgICBQcm9ncmVzc0V2ZW50LnByb3RvdHlwZS5sZW5ndGhDb21wdXRhYmxlID0gbnVsbDtcblxuICAgIFByb2dyZXNzRXZlbnQucHJvdG90eXBlLnRvdGFsID0gbnVsbDtcblxuICAgIHJldHVybiBQcm9ncmVzc0V2ZW50O1xuXG4gIH0pKCk7XG5cbiAgWE1MSHR0cFJlcXVlc3QuUHJvZ3Jlc3NFdmVudCA9IFByb2dyZXNzRXZlbnQ7XG5cbiAgWE1MSHR0cFJlcXVlc3RVcGxvYWQgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxIdHRwUmVxdWVzdFVwbG9hZCwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxIdHRwUmVxdWVzdFVwbG9hZChyZXF1ZXN0KSB7XG4gICAgICBYTUxIdHRwUmVxdWVzdFVwbG9hZC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICB9XG5cbiAgICBYTUxIdHRwUmVxdWVzdFVwbG9hZC5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jb250ZW50VHlwZSA9IG51bGw7XG4gICAgICB0aGlzLl9ib2R5ID0gbnVsbDtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0VXBsb2FkLnByb3RvdHlwZS5fc2V0RGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBib2R5LCBpLCBqLCBrLCBvZmZzZXQsIHJlZiwgcmVmMSwgdmlldztcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHRoaXMuX2NvbnRlbnRUeXBlID0gJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYm9keSA9IG5ldyBCdWZmZXIoZGF0YSwgJ3V0ZjgnKTtcbiAgICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIHRoaXMuX2JvZHkgPSBkYXRhO1xuICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgYm9keSA9IG5ldyBCdWZmZXIoZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gZGF0YS5ieXRlTGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICBib2R5W2ldID0gdmlld1tpXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ib2R5ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5idWZmZXIgJiYgZGF0YS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBib2R5ID0gbmV3IEJ1ZmZlcihkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICBvZmZzZXQgPSBkYXRhLmJ5dGVPZmZzZXQ7XG4gICAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlcik7XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYxID0gZGF0YS5ieXRlTGVuZ3RoOyAwIDw9IHJlZjEgPyBrIDwgcmVmMSA6IGsgPiByZWYxOyBpID0gMCA8PSByZWYxID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgYm9keVtpXSA9IHZpZXdbaSArIG9mZnNldF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYm9keSA9IGJvZHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzZW5kKCkgZGF0YSBcIiArIGRhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3RVcGxvYWQucHJvdG90eXBlLl9maW5hbGl6ZUhlYWRlcnMgPSBmdW5jdGlvbihoZWFkZXJzLCBsb3dlcmVkSGVhZGVycykge1xuICAgICAgaWYgKHRoaXMuX2NvbnRlbnRUeXBlKSB7XG4gICAgICAgIGlmICghKCdjb250ZW50LXR5cGUnIGluIGxvd2VyZWRIZWFkZXJzKSkge1xuICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdGhpcy5fY29udGVudFR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9ib2R5KSB7XG4gICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSB0aGlzLl9ib2R5Lmxlbmd0aC50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3RVcGxvYWQucHJvdG90eXBlLl9zdGFydFVwbG9hZCA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAgIGlmICh0aGlzLl9ib2R5KSB7XG4gICAgICAgIHJlcXVlc3Qud3JpdGUodGhpcy5fYm9keSk7XG4gICAgICB9XG4gICAgICByZXF1ZXN0LmVuZCgpO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTEh0dHBSZXF1ZXN0VXBsb2FkO1xuXG4gIH0pKFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQpO1xuXG4gIFhNTEh0dHBSZXF1ZXN0LlhNTEh0dHBSZXF1ZXN0VXBsb2FkID0gWE1MSHR0cFJlcXVlc3RVcGxvYWQ7XG5cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34veGhyMi9saWIveGhyMi5qc1xuLy8gbW9kdWxlIGlkID0gMjg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSgxMik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL21lcmdlQWxsLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMjkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSgxNCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvc3ltYm9sL2l0ZXJhdG9yLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMjkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSgxNyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9FbXB0eUVycm9yLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMjkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSgyMSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL2J1bmRsZXMvY29tcGlsZXIudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMjkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSgyNyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9TY2FsYXJPYnNlcnZhYmxlLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMjk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSgyOCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDI5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoMzApO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9yZWZDb3VudC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDI5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoMzEpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAyOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDYwKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9TdWJqZWN0U3Vic2NyaXB0aW9uLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMjk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg2NCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9Gcm9tT2JzZXJ2YWJsZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDI5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoNjcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvZnJvbS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDMwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoNzApO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2NhdGNoLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMzAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg3Mik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvY29uY2F0TWFwLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMzAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg3OCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvbWVyZ2VNYXAuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAzMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDgwKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9zaGFyZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDMwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoODEpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9jYXRjaEVycm9yLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMzA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg4NCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL2RlZmF1bHRJZkVtcHR5LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMzA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg4NSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL2V2ZXJ5LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMzA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg4Nyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL2ZpcnN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMzA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg4OCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL2xhc3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAzMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDkzKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvc2Nhbi5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDMxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoOTQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9zaGFyZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDMxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoOTUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy90YWtlTGFzdC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDMxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoOTgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaWRlbnRpdHkuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAzMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDk5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL25vb3AuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAzMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJodHRwXCJcbi8vIG1vZHVsZSBpZCA9IDMxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDEwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJodHRwc1wiXG4vLyBtb2R1bGUgaWQgPSAzMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm9zXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwib3NcIlxuLy8gbW9kdWxlIGlkID0gMzE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTAiXSwic291cmNlUm9vdCI6IiJ9